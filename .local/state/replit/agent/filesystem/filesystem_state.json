{"file_contents":{"src/except.cpp":{"content":"/* except.cpp --\n\n   This file is part of the Resize executable compressor.\n\n   Copyright (C) 2025 WHO-AM-I-404\n   Based on UPX - Ultimate Packer for eXecutables\n   Copyright (C) 1996-2025 Markus Franz Xaver Johannes Oberhumer\n   Copyright (C) 1996-2025 Laszlo Molnar\n   All Rights Reserved.\n\n   Resize and the UCL library are free software; you can redistribute them\n   and/or modify them under the terms of the GNU General Public License as\n   published by the Free Software Foundation; either version 2 of\n   the License, or (at your option) any later version.\n\n   This program is distributed in the hope that it will be useful,\n   but WITHOUT ANY WARRANTY; without even the implied warranty of\n   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n   GNU General Public License for more details.\n\n   You should have received a copy of the GNU General Public License\n   along with this program; see the file COPYING.\n   If not, write to the Free Software Foundation, Inc.,\n   59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.\n\n   WHO-AM-I-404 <who-am-i-404@proton.me>\n   Based on original work by:\n   Markus F.X.J. Oberhumer <markus@oberhumer.com>\n   Laszlo Molnar <ezerotven+github@gmail.com>\n */\n\n#include \"conf.h\"\n\n/*************************************************************************\n//\n**************************************************************************/\n\n/*static*/ Throwable::Stats Throwable::stats;\n\nThrowable::Throwable(const char *m, int e, bool w) noexcept : super(),\n                                                              msg(nullptr),\n                                                              err(e),\n                                                              is_warning(w) {\n    if (m != nullptr) {\n        msg = strdup(m);\n        assert_noexcept(msg != nullptr);\n    }\n    NO_fprintf(stderr, \"construct exception: %zu %zu %s\\n\", size_t(stats.counter_current),\n               size_t(stats.counter_total), (const char *) msg);\n    stats.counter_current += 1;\n    stats.counter_total += 1;\n}\n\nThrowable::Throwable(const Throwable &other) noexcept : super(other),\n                                                        msg(nullptr),\n                                                        err(other.err),\n                                                        is_warning(other.is_warning) {\n    if (other.msg != nullptr) {\n        msg = strdup(other.msg);\n        assert_noexcept(msg != nullptr);\n    }\n    NO_fprintf(stderr, \"copy construct exception: %zu %zu %s\\n\", size_t(stats.counter_current),\n               size_t(stats.counter_total), (const char *) msg);\n    stats.counter_current += 1;\n    stats.counter_total += 1;\n}\n\nThrowable::~Throwable() noexcept {\n    stats.counter_current -= 1;\n    NO_fprintf(stderr, \"destruct exception: %zu %zu %s\\n\", size_t(stats.counter_current),\n               size_t(stats.counter_total), (const char *) msg);\n    upx::owner_free(msg);\n}\n\n/*************************************************************************\n// compression\n**************************************************************************/\n\nvoid throwCantPack(const char *msg) {\n    // UGLY, but makes things easier\n    if (opt->cmd == CMD_NONE)\n        throw CantPackException(msg);\n    else if (opt->cmd == CMD_COMPRESS)\n        throw CantPackException(msg);\n    else if (opt->cmd == CMD_FILEINFO)\n        throw CantPackException(msg);\n    else\n        throw CantUnpackException(msg);\n}\n\nvoid throwCantPackExact() { throwCantPack(\"option '--exact' does not work with this file\"); }\n\nvoid throwFilterException() { throwCantPack(\"filter problem\"); }\n\nvoid throwUnknownExecutableFormat(const char *msg, bool warn) {\n    throw UnknownExecutableFormatException(msg, warn);\n}\n\nvoid throwNotCompressible(const char *msg) { throw NotCompressibleException(msg); }\n\nvoid throwAlreadyPacked(const char *msg) { throw AlreadyPackedException(msg); }\n\nvoid throwAlreadyPackedByUPX(const char *msg) {\n    if (msg == nullptr)\n        msg = \"already packed by UPX\";\n    throwAlreadyPacked(msg);\n}\n\n/*************************************************************************\n// decompression\n**************************************************************************/\n\nvoid throwCantUnpack(const char *msg) {\n    // UGLY, but makes things easier\n    throwCantPack(msg);\n}\n\nvoid throwNotPacked(const char *msg) {\n    if (msg == nullptr)\n        msg = \"not packed by UPX\";\n    throw NotPackedException(msg);\n}\n\nvoid throwChecksumError() { throw Exception(\"checksum error\"); }\n\nvoid throwCompressedDataViolation() { throw Exception(\"compressed data violation\"); }\n\n/*************************************************************************\n// other\n**************************************************************************/\n\nvoid throwInternalError(const char *msg) { throw InternalError(msg); }\n\nvoid throwBadLoader() { throwInternalError(\"bad loader\"); }\n\nvoid throwOutOfMemoryException(const char *msg) {\n    if (msg == nullptr)\n        msg = \"out of memory\";\n    throw OutOfMemoryException(msg);\n}\n\nvoid throwIOException(const char *msg, int e) { throw IOException(msg, e); }\n\nvoid throwEOFException(const char *msg, int e) {\n    if (msg == nullptr && e == 0)\n        msg = \"premature end of file\";\n    throw EOFException(msg, e);\n}\n\n/*************************************************************************\n// varargs overloads\n**************************************************************************/\n\ntemplate <>\nvoid throwCantPack(const char *format, ...) {\n    char msg[1024];\n    va_list ap;\n    va_start(ap, format);\n    upx_safe_vsnprintf_noexcept(msg, sizeof(msg), format, ap);\n    va_end(ap);\n    throwCantPack(msg);\n}\n\ntemplate <>\nvoid throwCantUnpack(const char *format, ...) {\n    char msg[1024];\n    va_list ap;\n    va_start(ap, format);\n    upx_safe_vsnprintf_noexcept(msg, sizeof(msg), format, ap);\n    va_end(ap);\n    throwCantUnpack(msg);\n}\n\ntemplate <>\nvoid throwInternalError(const char *format, ...) {\n    char msg[1024];\n    va_list ap;\n    va_start(ap, format);\n    upx_safe_vsnprintf_noexcept(msg, sizeof(msg), format, ap);\n    va_end(ap);\n    throwInternalError(msg);\n}\n\n/*************************************************************************\n// util\n**************************************************************************/\n\nvoid assertFailed(const char *expr, const char *file, int line, const char *func) noexcept {\n    fflush(stdout);\n    fprintf(stderr, \"Assertion failed: %s (%s: %s: %d)\\n\", expr, file, func, line);\n    std::terminate();\n}\n\nvoid throwAssertFailed(const char *expr, const char *file, int line, const char *func) {\n    if (opt->debug.debug_level >= 1) {\n        throwCantPack(\"corrupted file; details: %s (%s: %s: %d)\", expr, file, func, line);\n    } else {\n        throwCantPack(\"corrupted file; try '--debug' for more details\");\n    }\n}\n\nconst char *prettyExceptionName(const char *n) noexcept {\n    if (n == nullptr)\n        return \"(null)\";\n    while (*n) {\n        if (*n >= '0' && *n <= '9') // Linux ABI\n            n++;\n        else if (*n == ' ')\n            n++;\n        else if (strncmp(n, \"class \", 6) == 0) // Visual C++ (MSVC)\n            n += 6;\n        else\n            break;\n    }\n    return n;\n}\n\n/* vim:set ts=4 sw=4 et: */\n","size_bytes":7250},"src/file.cpp":{"content":"/* file.cpp --\n\n   This file is part of the Resize executable compressor.\n\n   Copyright (C) 2025 WHO-AM-I-404\n   Based on UPX - Ultimate Packer for eXecutables\n   Copyright (C) 1996-2025 Markus Franz Xaver Johannes Oberhumer\n   Copyright (C) 1996-2025 Laszlo Molnar\n   All Rights Reserved.\n\n   Resize and the UCL library are free software; you can redistribute them\n   and/or modify them under the terms of the GNU General Public License as\n   published by the Free Software Foundation; either version 2 of\n   the License, or (at your option) any later version.\n\n   This program is distributed in the hope that it will be useful,\n   but WITHOUT ANY WARRANTY; without even the implied warranty of\n   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n   GNU General Public License for more details.\n\n   You should have received a copy of the GNU General Public License\n   along with this program; see the file COPYING.\n   If not, write to the Free Software Foundation, Inc.,\n   59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.\n\n   WHO-AM-I-404 <who-am-i-404@proton.me>\n   Based on original work by:\n   Markus F.X.J. Oberhumer <markus@oberhumer.com>\n   Laszlo Molnar <ezerotven+github@gmail.com>\n */\n\n#include \"conf.h\"\n#include \"file.h\"\n\n/*************************************************************************\n// static file-related util functions; will throw on error\n**************************************************************************/\n\n/*static*/ void FileBase::chmod(const char *name, int mode) {\n    assert(name != nullptr && name[0] != 0);\n#if HAVE_CHMOD\n    if (::chmod(name, mode) != 0)\n        throwIOException(name, errno);\n#else\n    UNUSED(name);\n    UNUSED(mode);\n    // no error\n#endif\n}\n\n/*static*/ void FileBase::rename(const char *old_, const char *new_) {\n#if (ACC_OS_DOS32) && defined(__DJGPP__)\n    if (::_rename(old_, new_) != 0)\n#else\n    if (::rename(old_, new_) != 0)\n#endif\n        throwIOException(\"rename error\", errno);\n}\n\n/*static*/ bool FileBase::unlink_noexcept(const char *name) noexcept {\n    assert_noexcept(name != nullptr && name[0] != 0);\n    bool success = ::unlink(name) == 0;\n#if HAVE_CHMOD\n    if (!success)\n        success = (::chmod(name, 0666) == 0 && ::unlink(name) == 0);\n#endif\n    return success;\n}\n\n/*static*/ void FileBase::unlink(const char *name) {\n    if (!unlink_noexcept(name))\n        throwIOException(name, errno);\n}\n\n/*************************************************************************\n// FileBase\n**************************************************************************/\n\nFileBase::~FileBase() may_throw {\n#if 0 && defined(__GNUC__) // debug\n    if (isOpen())\n        fprintf(stderr, \"%s: %s\\n\", _name, __PRETTY_FUNCTION__);\n#endif\n    if (std::uncaught_exceptions() == 0)\n        closex(); // may_throw\n    else\n        close_noexcept(); // currently in exception unwinding, use noexcept variant\n}\n\nbool FileBase::do_sopen() {\n    if (_shflags < 0)\n        _fd = ::open(_name, _flags, _mode);\n    else {\n#if (ACC_OS_DOS32) && defined(__DJGPP__)\n        _fd = ::open(_name, _flags | _shflags, _mode);\n#elif (ACC_ARCH_M68K && ACC_OS_TOS && ACC_CC_GNUC) && defined(__MINT__)\n        _fd = ::open(_name, _flags | (_shflags & O_SHMODE), _mode);\n#elif defined(SH_DENYRW)\n        _fd = ::sopen(_name, _flags, _shflags, _mode);\n#else\n        throwInternalError(\"bad usage of do_sopen()\");\n#endif\n    }\n    if (_fd < 0)\n        return false;\n    st.st_size = 0;\n    if (::fstat(_fd, &st) != 0)\n        throwIOException(_name, errno);\n    _length = st.st_size;\n    return true;\n}\n\nbool FileBase::close_noexcept() noexcept {\n    bool ok = true;\n    if (isOpen() && _fd != STDIN_FILENO && _fd != STDOUT_FILENO && _fd != STDERR_FILENO)\n        if (::close(_fd) == -1)\n            ok = false;\n    _fd = -1;\n    _flags = 0;\n    _mode = 0;\n    _name = nullptr;\n    _offset = 0;\n    _length = 0;\n    return ok;\n}\n\nvoid FileBase::closex() may_throw {\n    if (!close_noexcept())\n        throwIOException(\"close failed\", errno);\n}\n\n// Return value of ::seek is the resulting file offset (same as ::tell())\nupx_off_t FileBase::seek(upx_off_t off, int whence) {\n    if (!isOpen())\n        throwIOException(\"bad seek 1\");\n    if (!mem_size_valid_bytes(off >= 0 ? off : -off)) // sanity check\n        throwIOException(\"bad seek\");\n    if (whence == SEEK_SET) {\n        if (off < 0)\n            throwIOException(\"bad seek 2\");\n        off += _offset;\n    } else if (whence == SEEK_END) {\n        if (off > 0)\n            throwIOException(\"bad seek 3\");\n        off += _offset + _length;\n        whence = SEEK_SET;\n    } else if (whence == SEEK_CUR) {\n    } else\n        throwInternalError(\"bad seek: whence\");\n    upx_off_t l = ::lseek(_fd, off, whence);\n    if (l < 0)\n        throwIOException(\"seek error\", errno);\n    return l - _offset;\n}\n\nupx_off_t FileBase::tell() const {\n    if (!isOpen())\n        throwIOException(\"bad tell\");\n    upx_off_t l = ::lseek(_fd, 0, SEEK_CUR);\n    if (l < 0)\n        throwIOException(\"tell error\", errno);\n    return l - _offset;\n}\n\nvoid FileBase::set_extent(upx_off_t offset, upx_off_t length) {\n    _offset = offset;\n    _length = length;\n}\n\nupx_off_t FileBase::st_size() const { return _length; }\n\n/*************************************************************************\n// InputFile\n**************************************************************************/\n\nvoid InputFile::sopen(const char *name, int flags, int shflags) {\n    closex();\n    _name = name;\n    _flags = flags;\n    _shflags = shflags;\n    _mode = 0;\n    _offset = 0;\n    _length = 0;\n    if (!super::do_sopen()) {\n        if (errno == ENOENT)\n            throw FileNotFoundException(_name, errno);\n        else if (errno == EEXIST)\n            throw FileAlreadyExistsException(_name, errno);\n        else\n            throwIOException(_name, errno);\n    }\n    _length_orig = _length;\n}\n\nint InputFile::read(SPAN_P(void) buf, upx_int64_t blen) {\n    if (!isOpen() || blen < 0)\n        throwIOException(\"bad read\");\n    int len = (int) mem_size(1, blen); // sanity check\n    errno = 0;\n    long l = acc_safe_hread(_fd, raw_bytes(buf, len), len);\n    if (errno)\n        throwIOException(\"read error\", errno);\n    return (int) l;\n}\n\nint InputFile::readx(SPAN_P(void) buf, upx_int64_t blen) {\n    int l = this->read(buf, blen);\n    if (l != blen)\n        throwEOFException();\n    return l;\n}\n\nupx_off_t InputFile::seek(upx_off_t off, int whence) {\n    upx_off_t pos = super::seek(off, whence);\n    if (_length < pos)\n        throwIOException(\"bad seek 4\");\n    return pos;\n}\n\nupx_off_t InputFile::st_size_orig() const { return _length_orig; }\n\nint InputFile::dupFd() may_throw {\n    if (!isOpen())\n        throwIOException(\"bad dup\");\n#if defined(HAVE_DUP) && (HAVE_DUP + 0 == 0)\n    errno = ENOSYS;\n    int r = -1;\n#else\n    int r = ::dup(getFd());\n#endif\n    if (r < 0)\n        throwIOException(\"dup\", errno);\n    return r;\n}\n\n/*************************************************************************\n// OutputFile\n**************************************************************************/\n\nvoid OutputFile::sopen(const char *name, int flags, int shflags, int mode) {\n    closex();\n    _name = name;\n    _flags = flags;\n    _shflags = shflags;\n    _mode = mode;\n    _offset = 0;\n    _length = 0;\n    if (!super::do_sopen()) {\n#if 0\n        // don't throw FileNotFound here -- this is confusing\n        if (errno == ENOENT)\n            throw FileNotFoundException(_name,errno);\n        else\n#endif\n        if (errno == EEXIST)\n            throw FileAlreadyExistsException(_name, errno);\n        else\n            throwIOException(_name, errno);\n    }\n}\n\nbool OutputFile::openStdout(int flags, bool force) {\n    closex();\n    int fd = STDOUT_FILENO;\n    if (!force && acc_isatty(fd))\n        return false;\n    _name = \"<stdout>\";\n    _flags = flags;\n    _shflags = -1;\n    _mode = 0;\n    _offset = 0;\n    _length = 0;\n    if (flags && acc_set_binmode(fd, 1) == -1)\n        throwIOException(_name, errno);\n    _fd = fd;\n    return true;\n}\n\nvoid OutputFile::write(SPAN_0(const void) buf, upx_int64_t blen) {\n    if (!isOpen() || blen < 0)\n        throwIOException(\"bad write\");\n    // allow nullptr if blen == 0\n    if (blen == 0)\n        return;\n    int len = (int) mem_size(1, blen); // sanity check\n    errno = 0;\n#if WITH_XSPAN >= 2\n    NO_fprintf(stderr, \"write %p %zd (%p) %d\\n\", buf.raw_ptr(), buf.raw_size_in_bytes(),\n               buf.raw_base(), len);\n#endif\n    long l = acc_safe_hwrite(_fd, raw_bytes(buf, len), len);\n    if (l != len)\n        throwIOException(\"write error\", errno);\n    bytes_written += len;\n#if TESTING && 0\n    static upx_std_atomic(bool) dumping;\n    if (!dumping) {\n        dumping = true;\n        char fn[64];\n        static int part = 0;\n        snprintf(fn, sizeof(fn), \"upx-dump-%04d.data\", part++);\n        OutputFile::dump(fn, buf, len);\n        dumping = false;\n    }\n#endif\n}\n\nupx_off_t OutputFile::st_size() const {\n    if (opt->to_stdout) {     // might be a pipe ==> .st_size is invalid\n        return bytes_written; // too big if seek()+write() instead of rewrite()\n    }\n    struct stat my_st;\n    my_st.st_size = 0;\n    if (::fstat(_fd, &my_st) != 0)\n        throwIOException(_name, errno);\n    return my_st.st_size;\n}\n\nvoid OutputFile::rewrite(SPAN_P(const void) buf, int len) {\n    assert(!opt->to_stdout);\n    write(buf, len);\n    bytes_written -= len; // restore\n}\n\nupx_off_t OutputFile::seek(upx_off_t off, int whence) {\n    if (!mem_size_valid_bytes(off >= 0 ? off : -off)) // sanity check\n        throwIOException(\"bad seek\");\n    assert(!opt->to_stdout);\n    switch (whence) {\n    case SEEK_SET:\n        if (bytes_written < off)\n            bytes_written = off;\n        _length = bytes_written; // cheap, lazy update; needed?\n        break;\n    case SEEK_END:\n        _length = bytes_written; // necessary\n        break;\n    }\n    return super::seek(off, whence);\n}\n\n// WARNING: fsync() does not exist in some Windows environments.\n// This trick works only on UNIX-like systems.\n// int OutputFile::read(void *buf, int len) {\n//    fsync(_fd);\n//    InputFile infile;\n//    infile.open(this->getName(), O_RDONLY | O_BINARY);\n//    infile.seek(this->tell(), SEEK_SET);\n//    return infile.read(buf, len);\n//}\n\nvoid OutputFile::set_extent(upx_off_t offset, upx_off_t length) {\n    super::set_extent(offset, length);\n    bytes_written = 0;\n    if (0 == offset && 0xffffffffLL == length) { // TODO: check all callers of this method\n        st.st_size = 0;\n        if (::fstat(_fd, &st) != 0)\n            throwIOException(_name, errno);\n        _length = st.st_size - offset;\n    }\n}\n\nupx_off_t OutputFile::unset_extent() {\n    upx_off_t l = ::lseek(_fd, 0, SEEK_END);\n    if (l < 0)\n        throwIOException(\"lseek error\", errno);\n    _offset = 0;\n    _length = l;\n    bytes_written = _length;\n    return _length;\n}\n\n/*static*/ void OutputFile::dump(const char *name, SPAN_P(const void) buf, int len, int flags) {\n    if (flags < 0)\n        flags = O_CREAT | O_TRUNC;\n    flags |= O_WRONLY | O_BINARY;\n    OutputFile f;\n    f.open(name, flags, 0600);\n    f.write(raw_bytes(buf, len), len);\n    f.closex();\n}\n\n/*************************************************************************\n//\n**************************************************************************/\n\nTEST_CASE(\"file\") {\n    InputFile fi;\n    CHECK(!fi.isOpen());\n    CHECK(fi.getFd() == -1);\n    CHECK(fi.st_size() == 0);\n    OutputFile fo;\n    CHECK(!fo.isOpen());\n    CHECK(fo.getFd() == -1);\n    CHECK(fo.getBytesWritten() == 0);\n}\n\n/* vim:set ts=4 sw=4 et: */\n","size_bytes":11552},"src/filter.cpp":{"content":"/* filter.cpp --\n\n   This file is part of the Resize executable compressor.\n\n   Copyright (C) 2025 WHO-AM-I-404\n   Based on UPX - Ultimate Packer for eXecutables\n   Copyright (C) 1996-2025 Markus Franz Xaver Johannes Oberhumer\n   Copyright (C) 1996-2025 Laszlo Molnar\n   All Rights Reserved.\n\n   Resize and the UCL library are free software; you can redistribute them\n   and/or modify them under the terms of the GNU General Public License as\n   published by the Free Software Foundation; either version 2 of\n   the License, or (at your option) any later version.\n\n   This program is distributed in the hope that it will be useful,\n   but WITHOUT ANY WARRANTY; without even the implied warranty of\n   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n   GNU General Public License for more details.\n\n   You should have received a copy of the GNU General Public License\n   along with this program; see the file COPYING.\n   If not, write to the Free Software Foundation, Inc.,\n   59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.\n\n   WHO-AM-I-404 <who-am-i-404@proton.me>\n   Based on original work by:\n   Markus F.X.J. Oberhumer <markus@oberhumer.com>\n   Laszlo Molnar <ezerotven+github@gmail.com>\n */\n\n#include \"conf.h\"\n#include \"filter.h\"\n#include \"file.h\"\n\n/*************************************************************************\n// util\n**************************************************************************/\n\nstatic void initFilter(Filter *f, byte *buf, unsigned buf_len) noexcept {\n    f->buf = buf;\n    f->buf_len = buf_len;\n    // clear output parameters\n    f->calls = f->wrongcalls = f->noncalls = f->firstcall = f->lastcall = 0;\n}\n\n/*************************************************************************\n// get a FilterEntry\n**************************************************************************/\n\n/*static*/ const FilterImpl::FilterEntry *FilterImpl::getFilter(int id) {\n    static upx_uint8_t filter_map[256];\n    static upx_std_once_flag init_done;\n\n    upx_std_call_once(init_done, []() noexcept {\n        // init the filter_map[] (using a lambda function)\n        assert_noexcept(n_filters <= 254); // as 0xff means \"empty slot\"\n        memset(filter_map, 0xff, sizeof(filter_map));\n        for (int i = 0; i < n_filters; i++) {\n            int filter_id = filters[i].id;\n            assert_noexcept(filter_id >= 0 && filter_id <= 255);\n            assert_noexcept(filter_map[filter_id] == 0xff);\n            filter_map[filter_id] = (upx_uint8_t) i;\n        }\n    });\n\n    if (id < 0 || id > 255)\n        return nullptr;\n    unsigned index = filter_map[id];\n    if (index == 0xff) // empty slot\n        return nullptr;\n    assert_noexcept(filters[index].id == id);\n    return &filters[index];\n}\n\n/*static*/ bool Filter::isValidFilter(int filter_id) {\n    const FilterImpl::FilterEntry *const fe = FilterImpl::getFilter(filter_id);\n    return fe != nullptr;\n}\n\n/*static*/ bool Filter::isValidFilter(int filter_id, const int *allowed_filters) {\n    if (!isValidFilter(filter_id))\n        return false;\n    if (filter_id == 0)\n        return true;\n    if (allowed_filters == nullptr)\n        return false;\n    while (*allowed_filters != FT_END)\n        if (*allowed_filters++ == filter_id)\n            return true;\n    return false;\n}\n\n/*************************************************************************\n// high level API\n**************************************************************************/\n\nFilter::Filter(int level) noexcept : clevel(level) { init(); }\n\nvoid Filter::init(int id_, unsigned addvalue_) noexcept {\n    this->id = id_;\n    initFilter(this, nullptr, 0);\n    // clear input parameters\n    this->addvalue = addvalue_;\n    this->preferred_ctos = nullptr;\n    // clear input/output parameters\n    this->cto = 0;\n    this->n_mru = 0;\n}\n\nbool Filter::filter(SPAN_0(byte) xbuf, unsigned buf_len_) {\n    byte *const buf_ = raw_bytes(xbuf, buf_len_);\n    initFilter(this, buf_, buf_len_);\n\n    const FilterImpl::FilterEntry *const fe = FilterImpl::getFilter(id);\n    if (fe == nullptr)\n        throwInternalError(\"filter-1\");\n    if (fe->id == 0)\n        return true;\n    if (buf_len < fe->min_buf_len)\n        return false;\n    if (fe->max_buf_len && buf_len > fe->max_buf_len)\n        return false;\n    if (!fe->do_filter)\n        throwInternalError(\"filter-2\");\n\n    // save checksum\n    this->adler = 0;\n    if (clevel != 1)\n        this->adler = upx_adler32(this->buf, this->buf_len);\n\n    NO_printf(\"filter: %02x %p %d\\n\", this->id, this->buf, this->buf_len);\n    // OutputFile::dump(\"filter.dat\", buf, buf_len);\n    int r = (*fe->do_filter)(this);\n    NO_printf(\"filter: %02x %d\\n\", fe->id, r);\n    if (r > 0)\n        throwFilterException();\n    if (r == 0)\n        return true;\n    return false;\n}\n\nvoid Filter::unfilter(SPAN_0(byte) xbuf, unsigned buf_len_, bool verify_checksum) {\n    byte *const buf_ = raw_bytes(xbuf, buf_len_);\n    initFilter(this, buf_, buf_len_);\n\n    const FilterImpl::FilterEntry *const fe = FilterImpl::getFilter(id);\n    if (fe == nullptr)\n        throwInternalError(\"unfilter-1\");\n    if (fe->id == 0)\n        return;\n    if (buf_len < fe->min_buf_len)\n        return;\n    if (fe->max_buf_len && buf_len > fe->max_buf_len)\n        return;\n    if (!fe->do_unfilter)\n        throwInternalError(\"unfilter-2\");\n\n    NO_printf(\"unfilter: %02x %p %d\\n\", this->id, this->buf, this->buf_len);\n    int r = (*fe->do_unfilter)(this);\n    NO_printf(\"unfilter: %02x %d\\n\", fe->id, r);\n    if (r != 0)\n        throwInternalError(\"unfilter-3\");\n    // OutputFile::dump(\"unfilter.dat\", buf, buf_len);\n\n    // verify checksum\n    if (verify_checksum && clevel != 1) {\n        if (this->adler != upx_adler32(this->buf, this->buf_len))\n            throwInternalError(\"unfilter-4\");\n    }\n}\n\nvoid Filter::verifyUnfilter() {\n    // Note:\n    //   This verify is just because of complete paranoia that there\n    //   could be a hidden bug in the filter implementation, and\n    //   it should not be necessary at all.\n    //   Maybe we will remove it at some future point.\n    //\n    // See also:\n    //   Packer::verifyOverlappingDecompression()\n\n    NO_printf(\"verifyUnfilter: %02x %p %d\\n\", this->id, this->buf, this->buf_len);\n    if (clevel != 1)\n        unfilter(this->buf, this->buf_len, true);\n}\n\nbool Filter::scan(SPAN_0(const byte) xbuf, unsigned buf_len_) {\n    const byte *const buf_ = raw_bytes(xbuf, buf_len_);\n    // Note: must use const_cast here. This is fine as the scan\n    //   implementations (fe->do_scan) actually don't change the buffer.\n    byte *const b = const_cast<byte *>(buf_);\n    initFilter(this, b, buf_len_);\n\n    const FilterImpl::FilterEntry *const fe = FilterImpl::getFilter(id);\n    if (fe == nullptr)\n        throwInternalError(\"scan-1\");\n    if (fe->id == 0)\n        return true;\n    if (buf_len < fe->min_buf_len)\n        return false;\n    if (fe->max_buf_len && buf_len > fe->max_buf_len)\n        return false;\n    if (!fe->do_scan)\n        throwInternalError(\"scan-2\");\n\n    NO_printf(\"filter: %02x %p %d\\n\", this->id, this->buf, this->buf_len);\n    int r = (*fe->do_scan)(this);\n    NO_printf(\"filter: %02x %d\\n\", fe->id, r);\n    if (r > 0)\n        throwFilterException();\n    if (r == 0)\n        return true;\n    return false;\n}\n\n/* vim:set ts=4 sw=4 et: */\n","size_bytes":7279},"src/help.cpp":{"content":"/* help.cpp --\n\n   This file is part of the Resize executable compressor.\n\n   Copyright (C) 2025 WHO-AM-I-404\n   Based on UPX - Ultimate Packer for eXecutables\n   Copyright (C) 1996-2025 Markus Franz Xaver Johannes Oberhumer\n   Copyright (C) 1996-2025 Laszlo Molnar\n   All Rights Reserved.\n\n   Resize and the UCL library are free software; you can redistribute them\n   and/or modify them under the terms of the GNU General Public License as\n   published by the Free Software Foundation; either version 2 of\n   the License, or (at your option) any later version.\n\n   This program is distributed in the hope that it will be useful,\n   but WITHOUT ANY WARRANTY; without even the implied warranty of\n   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n   GNU General Public License for more details.\n\n   You should have received a copy of the GNU General Public License\n   along with this program; see the file COPYING.\n   If not, write to the Free Software Foundation, Inc.,\n   59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.\n\n   WHO-AM-I-404 <who-am-i-404@proton.me>\n   Based on original work by:\n   Markus F.X.J. Oberhumer <markus@oberhumer.com>\n   Laszlo Molnar <ezerotven+github@gmail.com>\n */\n\n#if defined(_WIN32_WINNT)\nstatic constexpr long long initial_win32_winnt = _WIN32_WINNT + 0LL;\n#else\nstatic constexpr long long initial_win32_winnt = 0;\n#endif\n#define WANT_WINDOWS_LEAN_H 1 // _WIN32_WINNT\n#include \"conf.h\"\n#include \"compress/compress.h\" // upx_ucl_version_string()\n// for list_all_packers():\n#include \"filter.h\" // Filter::isValidFilter\n#include \"packer.h\"\n#include \"packmast.h\" // PackMaster::visitAllPackers\n\n/*************************************************************************\n// header\n**************************************************************************/\n\n// also see UPX_CONFIG_DISABLE_GITREV in CMakeLists.txt\n#if defined(UPX_VERSION_GITREV)\nconst char gitrev[] = UPX_VERSION_GITREV;\n#else\nconst char gitrev[1] = {0};\n#endif\n\nvoid show_header(void) {\n    FILE *f = con_term;\n    int fg;\n\n    static bool header_done;\n    if (header_done)\n        return;\n    header_done = true;\n\n    fg = con_fg(f, FG_GREEN);\n    // clang-format off\n    con_fprintf(f,\n                \"                       Ultimate Packer for eXecutables\\n\"\n                \"                          Copyright (C) 1996 - \" UPX_VERSION_YEAR \"\\n\"\n#if defined(UPX_VERSION_GITREV)\n                \"UPX git-%6.6s%c\"\n#else\n                \"UPX %-11s\"\n#endif\n                \" Markus Oberhumer, Laszlo Molnar & John Reiser  %14s\\n\\n\",\n#if defined(UPX_VERSION_GITREV)\n                gitrev,\n                (sizeof(gitrev)-1 > 6 && gitrev[sizeof(gitrev)-2] == '+') ? '+' : ' ',\n#else\n                UPX_VERSION_STRING,\n#endif\n                UPX_VERSION_DATE);\n    // clang-format on\n    fg = con_fg(f, fg);\n    UNUSED(fg);\n}\n\n/*************************************************************************\n// usage\n**************************************************************************/\n\nvoid show_usage(void) {\n    FILE *f = con_term;\n\n    con_fprintf(f, \"Usage: %s [-123456789dlthVL] [-qvfk] [-o file] %sfile..\\n\", progname,\n#if (ACC_OS_DOS32) && defined(__DJGPP__)\n                \"[@]\");\n#else\n                \"\");\n#endif\n}\n\n/*************************************************************************\n// list_all_packers()\n**************************************************************************/\n\nnamespace {\nstruct PackerNames final {\n    explicit PackerNames() noexcept = default;\n    ~PackerNames() noexcept = default;\n\n    static constexpr unsigned MAX_NAMES = 64; // arbitrary limit, increase as needed\n    struct Entry {\n        const char *fname;\n        const char *sname;\n        unsigned methods_count;\n        unsigned filters_count;\n        unsigned methods[PackerBase::MAX_METHODS];\n        unsigned filters[PackerBase::MAX_FILTERS];\n    };\n    Entry names_array[MAX_NAMES];\n    Entry *names[MAX_NAMES];\n    unsigned names_count = 0;\n    const Options *o = nullptr;\n\n    void add(const PackerBase *pb) {\n        assert_noexcept(names_count < MAX_NAMES);\n        Entry &e = names_array[names_count];\n        names[names_count++] = &e;\n        e.fname = pb->getFullName(o);\n        e.sname = pb->getName();\n        e.methods_count = e.filters_count = 0;\n        for (const int *m = pb->getCompressionMethods(M_ALL, 10); *m != M_END; m++) {\n            if (*m >= 0) {\n                assert_noexcept(Packer::isValidCompressionMethod(*m));\n                assert_noexcept(e.methods_count < PackerBase::MAX_METHODS);\n                e.methods[e.methods_count++] = *m;\n            }\n        }\n        for (const int *f = pb->getFilters(); f != nullptr && *f != FT_END; f++) {\n            if (*f >= 0) {\n                assert_noexcept(Filter::isValidFilter(*f));\n                assert_noexcept(e.filters_count < PackerBase::MAX_FILTERS);\n                e.filters[e.filters_count++] = *f;\n            }\n        }\n        upx_gnomesort(e.methods, e.methods_count, sizeof(e.methods[0]), ne32_compare);\n        upx_gnomesort(e.filters, e.filters_count, sizeof(e.filters[0]), ne32_compare);\n    }\n    static tribool visit(PackerBase *pb, void *user) {\n        NO_fprintf(stderr, \"visit %s\\n\", pb->getFullName(nullptr));\n        PackerNames *self = (PackerNames *) user;\n        self->add(pb);\n        return false;\n    }\n    static int __acc_cdecl_qsort compare_fname(const void *aa, const void *bb) {\n        const Entry *a = *(const Entry *const *) aa;\n        const Entry *b = *(const Entry *const *) bb;\n        return strcmp(a->fname, b->fname);\n    }\n};\n} // namespace\n\nstatic noinline void list_all_packers(FILE *f, int verbose) {\n    Options o;\n    o.reset();\n    PackerNames pn;\n    pn.o = &o;\n    (void) PackMaster::visitAllPackers(PackerNames::visit, nullptr, &o, &pn);\n    // NOLINTNEXTLINE(bugprone-multi-level-implicit-pointer-conversion)\n    upx_gnomesort(pn.names, pn.names_count, sizeof(pn.names[0]), PackerNames::compare_fname);\n    size_t pos = 0;\n    for (size_t i = 0; i < pn.names_count; i++) {\n        const PackerNames::Entry &e = *pn.names[i];\n        const char *const fn = e.fname;\n        const char *const sn = e.sname;\n        if (verbose >= 3) {\n            con_fprintf(f, \"    %-36s %s\\n\", fn, sn);\n            con_fprintf(f, \"        methods:\");\n            for (size_t j = 0; j < e.methods_count; j++)\n                con_fprintf(f, \" %#x\", e.methods[j]);\n            con_fprintf(f, \"\\n\");\n            con_fprintf(f, \"        filters:\");\n            for (size_t j = 0; j < e.filters_count; j++)\n                con_fprintf(f, \" %#x\", e.filters[j]);\n            con_fprintf(f, \"\\n\");\n        } else if (verbose >= 2) {\n            con_fprintf(f, \"    %-36s %s\\n\", fn, sn);\n        } else {\n            size_t fl = strlen(fn);\n            if (pos == 0) {\n                con_fprintf(f, \"  %s\", fn);\n                pos = 2 + fl;\n            } else if (pos + 1 + fl > 80) {\n                con_fprintf(f, \"\\n  %s\", fn);\n                pos = 2 + fl;\n            } else {\n                con_fprintf(f, \" %s\", fn);\n                pos += 1 + fl;\n            }\n        }\n    }\n    if (verbose < 2 && pn.names_count)\n        con_fprintf(f, \"\\n\");\n}\n\n/*************************************************************************\n// help\n**************************************************************************/\n\nvoid show_help(int verbose) {\n    FILE *f = con_term;\n    int fg;\n\n    show_header();\n    show_usage();\n\n    // clang-format off\n    fg = con_fg(f, FG_YELLOW);\n    con_fprintf(f, \"\\nCommands:\\n\");\n    fg = con_fg(f, fg);\n    con_fprintf(f,\n                \"  -1     compress faster                   -9    compress better\\n\"\n                \"%s\"\n                \"  -d     decompress                        -l    list compressed file\\n\"\n                \"  -t     test compressed file              -V    display version number\\n\"\n                \"%s\"\n                \"  -h     give %s help                    -L    display software license\\n%s\",\n                verbose == 0 ? \"\" : \"  --best compress best (can be slow for big files)\\n\",\n                verbose == 0 ? \"\" : \"  --fileinfo show parameters of already-compressed file\\n\",\n                verbose == 0 ? \"more\" : \"this\",\n                verbose == 0 ? \"\" : \"\\n\");\n\n    fg = con_fg(f, FG_YELLOW);\n    con_fprintf(f, \"Options:\\n\");\n    fg = con_fg(f, fg);\n\n    con_fprintf(f,\n                \"  -q     be quiet                          -v    be verbose\\n\"\n                \"  -oFILE write output to 'FILE'\\n\"\n                \"  -f     force compression of suspicious files\\n\"\n                \"%s%s\"\n                , (verbose == 0) ? \"  -k     keep backup files\\n\" : \"\"\n#if 1\n                , (verbose > 0) ? \"  --no-color, --mono, --color, --no-progress   change look\\n\" : \"\"\n#else\n                , \"\"\n#endif\n                );\n\n    if (verbose > 0)\n    {\n        fg = con_fg(f, FG_YELLOW);\n        con_fprintf(f, \"\\nCompression tuning options:\\n\");\n        fg = con_fg(f, fg);\n        con_fprintf(f,\n                    \"  --lzma              try LZMA [slower but tighter than NRV]\\n\"\n                    \"  --brute             try all available compression methods & filters [slow]\\n\"\n                    \"  --ultra-brute       try even more compression variants [very slow]\\n\"\n                    \"\\n\");\n        fg = con_fg(f, FG_YELLOW);\n        con_fprintf(f, \"Backup options:\\n\");\n        fg = con_fg(f, fg);\n        con_fprintf(f,\n                    \"  -k, --backup        keep backup files\\n\"\n                    \"  --no-backup         no backup files [default]\\n\"\n                    \"\\n\");\n        fg = con_fg(f, FG_YELLOW);\n        con_fprintf(f, \"Overlay options:\\n\");\n        fg = con_fg(f, fg);\n        con_fprintf(f,\n                    \"  --overlay=copy      copy any extra data attached to the file [default]\\n\"\n                    \"  --overlay=strip     strip any extra data attached to the file [DANGEROUS]\\n\"\n                    \"  --overlay=skip      don't compress a file with an overlay\\n\"\n                    \"\\n\");\n        fg = con_fg(f, FG_YELLOW);\n        con_fprintf(f, \"File system options:\\n\");\n        fg = con_fg(f, fg);\n        con_fprintf(f,\n                    \"  --force-overwrite   force overwrite of output files\\n\"\n#if defined(__unix__)\n                    \"  --link              preserve hard links (Unix only) [USE WITH CARE]\\n\"\n                    \"  --no-link           do not preserve hard links but rename files [default]\\n\"\n#endif\n                    \"  --no-mode           do not preserve file mode (aka permissions)\\n\"\n                    \"  --no-owner          do not preserve file ownership\\n\"\n                    \"  --no-time           do not preserve file timestamp\\n\"\n                    \"\\n\");\n        fg = con_fg(f, FG_YELLOW);\n        con_fprintf(f, \"Options for djgpp2/coff:\\n\");\n        fg = con_fg(f, fg);\n        con_fprintf(f,\n                    \"  --coff              produce COFF output [default: EXE]\\n\"\n                    \"\\n\");\n        fg = con_fg(f, FG_YELLOW);\n        con_fprintf(f, \"Options for dos/com:\\n\");\n        fg = con_fg(f, fg);\n        con_fprintf(f,\n                    \"  --8086              make compressed com work on any 8086\\n\"\n                    \"\\n\");\n        fg = con_fg(f, FG_YELLOW);\n        con_fprintf(f, \"Options for dos/exe:\\n\");\n        fg = con_fg(f, fg);\n        con_fprintf(f,\n                    \"  --8086              make compressed exe work on any 8086\\n\"\n                    \"  --no-reloc          put no relocations in to the exe header\\n\"\n                    \"\\n\");\n        fg = con_fg(f, FG_YELLOW);\n        con_fprintf(f, \"Options for dos/sys:\\n\");\n        fg = con_fg(f, fg);\n        con_fprintf(f,\n                    \"  --8086              make compressed sys work on any 8086\\n\"\n                    \"\\n\");\n        fg = con_fg(f, FG_YELLOW);\n        con_fprintf(f, \"Options for ps1/exe:\\n\");\n        fg = con_fg(f, fg);\n        con_fprintf(f,\n                    \"  --8-bit             uses 8 bit size compression [default: 32 bit]\\n\"\n                    \"  --8mib-ram          8 megabyte memory limit [default: 2 MiB]\\n\"\n                    \"  --boot-only         disables client/host transfer compatibility\\n\"\n                    \"  --no-align          don't align to 2048 bytes [enables: --console-run]\\n\"\n                    \"\\n\");\n        fg = con_fg(f, FG_YELLOW);\n        con_fprintf(f, \"Options for watcom/le:\\n\");\n        fg = con_fg(f, fg);\n        con_fprintf(f,\n                    \"  --le                produce LE output [default: EXE]\\n\"\n                    \"\\n\");\n        fg = con_fg(f, FG_YELLOW);\n        con_fprintf(f, \"Options for win32/pe, win64/pe & rtm32/pe:\\n\");\n        fg = con_fg(f, fg);\n        con_fprintf(f,\n                    \"  --compress-exports=0    do not compress the export section\\n\"\n                    \"  --compress-exports=1    compress the export section [default]\\n\"\n                    \"  --compress-icons=0      do not compress any icons\\n\"\n                    \"  --compress-icons=1      compress all but the first icon\\n\"\n                    \"  --compress-icons=2      compress all but the first icon directory [default]\\n\"\n                    \"  --compress-icons=3      compress all icons\\n\"\n                    \"  --compress-resources=0  do not compress any resources at all\\n\"\n                    \"  --keep-resource=list    do not compress resources specified by list\\n\"\n                    \"  --strip-relocs=0        do not strip relocations\\n\"\n                    \"  --strip-relocs=1        strip relocations [default]\\n\"\n                    \"\\n\");\n        fg = con_fg(f, FG_YELLOW);\n        con_fprintf(f, \"Options for linux/elf:\\n\");\n        fg = con_fg(f, fg);\n        con_fprintf(f,\n                    \"  --preserve-build-id     copy .gnu.note.build-id to compressed output\\n\"\n                    \"  --catch-sigsegv         debug errors in hardware or de-compressor\\n\"\n                    \"\\n\");\n    }\n    // clang-format on\n\n    con_fprintf(f, \"file..   executables to (de)compress\\n\");\n\n    if (verbose > 0) {\n        fg = con_fg(f, FG_YELLOW);\n        con_fprintf(f, \"\\nThis version supports:\\n\");\n        fg = con_fg(f, fg);\n        list_all_packers(f, verbose);\n    } else {\n        con_fprintf(f, \"\\nType '%s --help' for more detailed help.\\n\", progname);\n    }\n\n    con_fprintf(f, \"\\nUPX comes with ABSOLUTELY NO WARRANTY; \"\n                   \"for details visit https://upx.github.io\\n\");\n\n#if DEBUG || TESTING\n    fg = con_fg(f, FG_RED);\n    con_fprintf(f, \"\\nWARNING: this version is compiled with\"\n#if DEBUG\n                   \" -DDEBUG\"\n#endif\n#if TESTING\n                   \" -DTESTING\"\n#endif\n                   \"\\n\");\n    fg = con_fg(f, fg);\n#endif\n\n    UNUSED(fg);\n}\n\n/*************************************************************************\n// license\n**************************************************************************/\n\nvoid show_license(void) {\n    FILE *f = con_term;\n\n    show_header();\n\n    // clang-format off\n    con_fprintf(f,\n        \"   This program may be used freely, and you are welcome to\\n\"\n        \"   redistribute it under certain conditions.\\n\"\n        \"\\n\"\n        \"   This program is distributed in the hope that it will be useful,\\n\"\n        \"   but WITHOUT ANY WARRANTY; without even the implied warranty of\\n\"\n        \"   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\\n\"\n        \"   UPX License Agreements for more details.\\n\"\n        \"\\n\"\n        \"   You should have received a copy of the UPX License Agreements\\n\"\n        \"   along with this program; see the files COPYING and LICENSE.\\n\"\n        \"   If not, visit one of the following pages:\\n\"\n        \"\\n\"\n    );\n    int fg = con_fg(f, FG_CYAN);\n    con_fprintf(f,\n        \"        https://upx.github.io\\n\"\n        \"        https://www.oberhumer.com/opensource/upx/\\n\"\n    );\n    (void) con_fg(f, FG_ORANGE);\n    con_fprintf(f,\n        \"\\n\"\n        \"   WHO-AM-I-404 <who-am-i-404@proton.me>\\n\"\n        \"   Based on original work by:\n   Markus F.X.J. Oberhumer <markus@oberhumer.com>\n   Laszlo Molnar <ezerotven+github@gmail.com>\\n\"\n    );\n    // clang-format on\n    fg = con_fg(f, fg);\n    UNUSED(fg);\n}\n\n/*************************************************************************\n// version\n**************************************************************************/\n\nvoid show_version(bool one_line) {\n    FILE *f = stdout;\n    const char *v;\n\n#if defined(UPX_VERSION_GIT_DESCRIBE)\n    fprintf(f, \"upx %s\\n\", UPX_VERSION_GIT_DESCRIBE);\n#elif defined(UPX_VERSION_GITREV)\n    fprintf(f, \"upx %s\\n\", UPX_VERSION_STRING \"-git-\" UPX_VERSION_GITREV);\n#else\n    fprintf(f, \"upx %s\\n\", UPX_VERSION_STRING);\n#endif\n    if (one_line)\n        return;\n\n#if (WITH_NRV)\n    v = upx_nrv_version_string();\n    if (v != nullptr && v[0])\n        fprintf(f, \"NRV data compression library %s\\n\", v);\n#endif\n#if (WITH_UCL)\n    v = upx_ucl_version_string();\n    if (v != nullptr && v[0])\n        fprintf(f, \"UCL data compression library %s\\n\", v);\n#endif\n#if (WITH_ZLIB)\n    v = upx_zlib_version_string();\n    if (v != nullptr && v[0])\n        fprintf(f, \"zlib data compression library %s\\n\", v);\n#endif\n#if (WITH_LZMA)\n    v = upx_lzma_version_string();\n    if (v != nullptr && v[0])\n        fprintf(f, \"LZMA SDK version %s\\n\", v);\n#endif\n#if (WITH_ZSTD)\n    v = upx_zstd_version_string();\n    if (v != nullptr && v[0])\n        fprintf(f, \"zstd data compression library %s\\n\", v);\n#endif\n#if (WITH_BZIP2)\n    v = upx_bzip2_version_string();\n    if (v != nullptr && v[0])\n        fprintf(f, \"bzip2 data compression library %s\\n\", v);\n#endif\n#if !defined(DOCTEST_CONFIG_DISABLE)\n    fprintf(f, \"doctest C++ testing framework version %s\\n\", DOCTEST_VERSION_STR);\n#endif\n    // clang-format off\n   Copyright (C) 2025 WHO-AM-I-404\n   Based on UPX - Ultimate Packer for eXecutables\n    fprintf(f, \"Copyright (C) 1996-2025 Markus Franz Xaver Johannes Oberhumer\\n\");\n    fprintf(f, \"Copyright (C) 1996-2025 Laszlo Molnar\\n\");\n    fprintf(f, \"Copyright (C) 2000-2025 John F. Reiser\\n\");\n#if (WITH_ZLIB)\n    // see vendor/zlib/LICENSE\n    fprintf(f, \"Copyright (C) 1995\" \"-2024 Jean-loup Gailly and Mark Adler\\n\");\n#endif\n#if (WITH_LZMA)\n    // see vendor/lzma-sdk\n    fprintf(f, \"Copyright (C) 1999\" \"-2006 Igor Pavlov\\n\");\n#endif\n#if (WITH_ZSTD)\n    // see vendor/zstd/LICENSE; main author is Yann Collet\n    fprintf(f, \"Copyright (C) 2015\" \"-2024 Meta Platforms, Inc. and affiliates\\n\");\n#endif\n#if (WITH_BZIP2)\n    // see vendor/bzip2/bzlib.h\n    fprintf(f, \"Copyright (C) 1996\" \"-2010 Julian Seward\\n\");\n#endif\n#if !defined(DOCTEST_CONFIG_DISABLE)\n    // see vendor/doctest/LICENSE.txt\n    fprintf(f, \"Copyright (C) 2016\" \"-2023 Viktor Kirilov\\n\");\n#endif\n    // clang-format on\n    fprintf(f, \"UPX comes with ABSOLUTELY NO WARRANTY; for details type '%s -L'.\\n\", progname);\n}\n\n/*************************************************************************\n// sysinfo\n// undocumented and subject to change\n**************************************************************************/\n\nvoid show_sysinfo(const char *options_var) {\n    FILE *f = con_term;\n\n    show_header();\n\n    if (opt->verbose >= 1) {\n        con_fprintf(f, \"UPX version: \");\n        fflush(f);\n        show_version(true);\n        con_fprintf(f, \"UPX version internal: 0x%06x %s\\n\", UPX_VERSION_HEX, UPX_VERSION_STRING);\n    }\n    fflush(stdout);\n\n    // Compilation Flags\n    {\n        size_t cf_count = 0;\n        auto cf_print = [f, &cf_count](const char *name, const char *fmt, upx_int64_t v,\n                                       int need_verbose = 2) noexcept {\n            if (opt->verbose < need_verbose)\n                return;\n            if (cf_count++ == 0)\n                con_fprintf(f, \"\\nCompilation flags:\\n\");\n            con_fprintf(f, \"  %s = \", name);\n            con_fprintf(f, fmt, v);\n            con_fprintf(f, \"\\n\");\n        };\n\n        // language\n        cf_print(\"__cplusplus\", \"%lld\", __cplusplus + 0, 3);\n#if defined(_MSVC_LANG)\n        cf_print(\"_MSVC_LANG\", \"%lld\", _MSVC_LANG + 0, 3);\n#endif\n#if defined(upx_is_constant_evaluated)\n        cf_print(\"upx_is_constant_evaluated\", \"%lld\", 1, 3);\n#endif\n\n        // compiler\n#if defined(ACC_CC_CLANG)\n        cf_print(\"ACC_CC_CLANG\", \"0x%06llx\", ACC_CC_CLANG + 0, 3);\n#endif\n#if defined(ACC_CC_GNUC)\n        cf_print(\"ACC_CC_GNUC\", \"0x%06llx\", ACC_CC_GNUC + 0, 3);\n#endif\n#if defined(ACC_CC_MSC)\n        cf_print(\"ACC_CC_MSC\", \"%lld\", ACC_CC_MSC + 0, 3);\n#endif\n#if defined(__clang__)\n        cf_print(\"__clang__\", \"%lld\", __clang__ + 0);\n#endif\n#if defined(__clang_major__)\n        cf_print(\"__clang_major__\", \"%lld\", __clang_major__ + 0);\n#endif\n#if defined(__clang_minor__)\n        cf_print(\"__clang_minor__\", \"%lld\", __clang_minor__ + 0, 3);\n#endif\n#if defined(__clang_patchlevel__)\n        cf_print(\"__clang_patchlevel__\", \"%lld\", __clang_patchlevel__ + 0, 3);\n#endif\n#if defined(__GNUC__)\n        cf_print(\"__GNUC__\", \"%lld\", __GNUC__ + 0);\n#endif\n#if defined(__GNUC_MINOR__)\n        cf_print(\"__GNUC_MINOR__\", \"%lld\", __GNUC_MINOR__ + 0, 3);\n#endif\n#if defined(__GNUC_PATCHLEVEL__)\n        cf_print(\"__GNUC_PATCHLEVEL__\", \"%lld\", __GNUC_PATCHLEVEL__ + 0, 3);\n#endif\n#if defined(_MSC_VER)\n        cf_print(\"_MSC_VER\", \"%lld\", _MSC_VER + 0);\n#endif\n#if defined(_MSC_FULL_VER)\n        cf_print(\"_MSC_FULL_VER\", \"%lld\", _MSC_FULL_VER + 0);\n#endif\n\n        // architecture\n#if defined(__CHERI__)\n        cf_print(\"__CHERI__\", \"%lld\", __CHERI__ + 0, 3);\n#endif\n#if defined(__CHERI_PURE_CAPABILITY__)\n        cf_print(\"__CHERI_PURE_CAPABILITY__\", \"%lld\", __CHERI_PURE_CAPABILITY__ + 0, 3);\n#endif\n#if defined(__mips_hard_float)\n        cf_print(\"__mips_hard_float\", \"%lld\", __mips_hard_float + 0);\n#endif\n#if defined(__mips_soft_float)\n        cf_print(\"__mips_soft_float\", \"%lld\", __mips_soft_float + 0);\n#endif\n#if defined(__wasm__)\n        cf_print(\"__wasm__\", \"%lld\", __wasm__ + 0);\n#endif\n#if defined(__wasm32__)\n        cf_print(\"__wasm32__\", \"%lld\", __wasm32__ + 0);\n#endif\n#if defined(__wasm64__)\n        cf_print(\"__wasm64__\", \"%lld\", __wasm64__ + 0);\n#endif\n\n        // OS and libc\n#if defined(WINVER)\n        cf_print(\"WINVER\", \"0x%04llx\", WINVER + 0);\n#endif\n#if defined(_WIN32_WINNT)\n        cf_print(\"_WIN32_WINNT\", \"0x%04llx\", _WIN32_WINNT + 0);\n        if (initial_win32_winnt != 0 && initial_win32_winnt != _WIN32_WINNT + 0)\n            cf_print(\"INITIAL_WIN32_WINNT\", \"0x%04llx\", initial_win32_winnt);\n#endif\n#if defined(__MSVCRT_VERSION__)\n        cf_print(\"__MSVCRT_VERSION__\", \"0x%04llx\", __MSVCRT_VERSION__ + 0);\n#endif\n#if defined(__MINGW64_VERSION_MAJOR)\n        cf_print(\"__MINGW64_VERSION_MAJOR\", \"%lld\", __MINGW64_VERSION_MAJOR + 0);\n#endif\n#if defined(__USE_MINGW_ANSI_STDIO)\n        cf_print(\"__USE_MINGW_ANSI_STDIO\", \"%lld\", __USE_MINGW_ANSI_STDIO + 0, 3);\n#endif\n#if defined(__ELF__)\n        cf_print(\"__ELF__\", \"%lld\", __ELF__ + 0, 3);\n#endif\n#if defined(__GLIBC__)\n        cf_print(\"__GLIBC__\", \"%lld\", __GLIBC__ + 0);\n#endif\n#if defined(__GLIBC_MINOR__)\n        cf_print(\"__GLIBC_MINOR__\", \"%lld\", __GLIBC_MINOR__ + 0);\n#endif\n#if defined(__wasi__)\n        cf_print(\"__wasi__\", \"%lld\", __wasi__ + 0);\n#endif\n\n        // misc compilation options\n#if defined(__PIC__)\n        cf_print(\"__PIC__\", \"%lld\", __PIC__ + 0, 3);\n#elif defined(__pic__)\n        cf_print(\"__pic__\", \"%lld\", __pic__ + 0, 3);\n#endif\n#if defined(__PIE__)\n        cf_print(\"__PIE__\", \"%lld\", __PIE__ + 0, 3);\n#elif defined(__pie__)\n        cf_print(\"__pie__\", \"%lld\", __pie__ + 0, 3);\n#endif\n#if defined(__SIZEOF_INT128__)\n        cf_print(\"__SIZEOF_INT128__\", \"%lld\", __SIZEOF_INT128__ + 0, 3);\n#endif\n#if defined(__SIZEOF_LONG_LONG__) && (__SIZEOF_LONG_LONG__ + 0 > 8)\n        cf_print(\"__SIZEOF_LONG_LONG__\", \"%lld\", __SIZEOF_LONG_LONG__ + 0, 3);\n#endif\n#if defined(__SIZEOF_POINTER__) && (__SIZEOF_POINTER__ + 0 > 8)\n        cf_print(\"__SIZEOF_POINTER__\", \"%lld\", __SIZEOF_POINTER__ + 0, 3);\n#endif\n#if defined(UPX_CONFIG_DISABLE_WSTRICT)\n        cf_print(\"UPX_CONFIG_DISABLE_WSTRICT\", \"%lld\", UPX_CONFIG_DISABLE_WSTRICT + 0, 3);\n#endif\n#if defined(UPX_CONFIG_DISABLE_WERROR)\n        cf_print(\"UPX_CONFIG_DISABLE_WERROR\", \"%lld\", UPX_CONFIG_DISABLE_WERROR + 0, 3);\n#endif\n#if defined(WITH_THREADS)\n        cf_print(\"WITH_THREADS\", \"%lld\", WITH_THREADS + 0);\n#endif\n\n        UNUSED(cf_count);\n        UNUSED(cf_print);\n        UNUSED(initial_win32_winnt);\n    }\n\n    // run-time settings\n#if defined(HAVE_LOCALTIME) && defined(HAVE_GMTIME)\n    {\n        auto tm2str = [](char *s, size_t size, const struct tm *tmp) noexcept {\n            snprintf(s, size, \"%04d-%02d-%02d %02d:%02d:%02d\", (int) tmp->tm_year + 1900,\n                     (int) tmp->tm_mon + 1, (int) tmp->tm_mday, (int) tmp->tm_hour,\n                     (int) tmp->tm_min, (int) tmp->tm_sec);\n        };\n\n        char s[40];\n        const time_t t = time(nullptr);\n        tm2str(s, sizeof(s), localtime(&t));\n        con_fprintf(f, \"\\n\");\n        con_fprintf(f, \"Local time is:  %s\\n\", s);\n        tm2str(s, sizeof(s), gmtime(&t));\n        con_fprintf(f, \"UTC time is:    %s\\n\", s);\n    }\n#endif\n\n    // environment\n    if (options_var && options_var[0]) {\n        const char *e = upx_getenv(options_var);\n        con_fprintf(f, \"\\n\");\n        if (e && e[0])\n            con_fprintf(f, \"Contents of environment variable %s: '%s'\\n\\n\", options_var, e);\n        else if (e)\n            con_fprintf(f, \"Environment variable '%s' is set but empty.\\n\\n\", options_var);\n        else\n            con_fprintf(f, \"Environment variable '%s' is not set.\\n\\n\", options_var);\n    }\n}\n\n/* vim:set ts=4 sw=4 et: */\n","size_bytes":25609},"src/lefile.cpp":{"content":"/* lefile.cpp --\n\n   This file is part of the Resize executable compressor.\n\n   Copyright (C) 2025 WHO-AM-I-404\n   Based on UPX - Ultimate Packer for eXecutables\n   Copyright (C) 1996-2025 Markus Franz Xaver Johannes Oberhumer\n   Copyright (C) 1996-2025 Laszlo Molnar\n   All Rights Reserved.\n\n   Resize and the UCL library are free software; you can redistribute them\n   and/or modify them under the terms of the GNU General Public License as\n   published by the Free Software Foundation; either version 2 of\n   the License, or (at your option) any later version.\n\n   This program is distributed in the hope that it will be useful,\n   but WITHOUT ANY WARRANTY; without even the implied warranty of\n   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n   GNU General Public License for more details.\n\n   You should have received a copy of the GNU General Public License\n   along with this program; see the file COPYING.\n   If not, write to the Free Software Foundation, Inc.,\n   59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.\n\n   WHO-AM-I-404 <who-am-i-404@proton.me>\n   Based on original work by:\n   Markus F.X.J. Oberhumer <markus@oberhumer.com>\n   Laszlo Molnar <ezerotven+github@gmail.com>\n */\n\n#include \"conf.h\"\n#include \"file.h\"\n#include \"lefile.h\"\n\nLeFile::LeFile(InputFile *f) noexcept : fif(f) {\n    COMPILE_TIME_ASSERT(sizeof(le_header_t) == 196)\n    COMPILE_TIME_ASSERT(sizeof(le_object_table_entry_t) == 24)\n    COMPILE_TIME_ASSERT(sizeof(le_pagemap_entry_t) == 4)\n    mem_clear(&ih);\n    mem_clear(&oh);\n}\n\nLeFile::~LeFile() noexcept {\n    delete[] iobject_table;\n    delete[] oobject_table;\n    delete[] ifpage_table;\n    delete[] ofpage_table;\n    delete[] ipm_entries;\n    delete[] opm_entries;\n    delete[] ires_names;\n    delete[] ores_names;\n    delete[] ifixups;\n    delete[] ofixups;\n    delete[] inonres_names;\n    delete[] ononres_names;\n    delete[] ientries;\n    delete[] oentries;\n}\n\n#define objects ih.object_table_entries\n#define pages   ih.memory_pages\n#define mps     ih.memory_page_size\n\nvoid LeFile::readObjectTable() {\n    soobject_table = objects;\n    iobject_table = New(le_object_table_entry_t, soobject_table);\n    fif->seek(le_offset + ih.object_table_offset, SEEK_SET);\n    fif->readx(iobject_table, sizeof(*iobject_table) * objects);\n}\n\nvoid LeFile::writeObjectTable() {\n    if (fof && oobject_table)\n        fof->write(oobject_table, sizeof(*iobject_table) * soobject_table);\n}\n\nvoid LeFile::readPageMap() {\n    sopm_entries = pages;\n    ipm_entries = New(le_pagemap_entry_t, sopm_entries);\n    fif->seek(le_offset + ih.object_pagemap_offset, SEEK_SET);\n    fif->readx(ipm_entries, sizeof(*ipm_entries) * pages);\n\n    for (unsigned ic = 0; ic < pages; ic++)\n        if ((ipm_entries[ic].type & 0xC0) != 0 && (ipm_entries[ic].type & 0xC0) != 0xC0)\n            throwCantPack(\"unexpected value in page map table\");\n}\n\nvoid LeFile::writePageMap() {\n    if (fof && opm_entries)\n        fof->write(opm_entries, sizeof(*ipm_entries) * sopm_entries);\n}\n\nvoid LeFile::readResidentNames() {\n    sores_names = ih.entry_table_offset - ih.resident_names_offset;\n    ires_names = New(byte, sores_names);\n    fif->seek(le_offset + ih.resident_names_offset, SEEK_SET);\n    fif->readx(ires_names, sores_names);\n}\n\nvoid LeFile::writeResidentNames() {\n    if (fof && ores_names)\n        fof->write(ores_names, sores_names);\n}\n\nvoid LeFile::readEntryTable() {\n    soentries = ih.fixup_page_table_offset - ih.entry_table_offset;\n    fif->seek(le_offset + ih.entry_table_offset, SEEK_SET);\n    ientries = New(byte, soentries);\n    fif->readx(ientries, soentries);\n}\n\nvoid LeFile::writeEntryTable() {\n    if (fof && oentries)\n        fof->write(oentries, soentries);\n}\n\nvoid LeFile::readFixupPageTable() {\n    sofpage_table = 1 + pages;\n    ifpage_table = New(unsigned, sofpage_table);\n    fif->seek(le_offset + ih.fixup_page_table_offset, SEEK_SET);\n    fif->readx(ifpage_table, 4 * sofpage_table);\n}\n\nvoid LeFile::writeFixupPageTable() {\n    if (fof && ofpage_table)\n        fof->write(ofpage_table, 4 * sofpage_table);\n}\n\nvoid LeFile::readFixups() {\n    sofixups = get_le32(ifpage_table + pages) - get_le32(ifpage_table);\n    ifixups = New(byte, sofixups);\n    fif->seek(le_offset + ih.fixup_record_table_offset, SEEK_SET);\n    fif->readx(ifixups, sofixups);\n}\n\nvoid LeFile::writeFixups() {\n    if (fof && ofixups)\n        fof->write(ofixups, sofixups);\n}\n\nunsigned LeFile::getImageSize() const {\n    unsigned n = 0;\n    if (ih.memory_pages > 0) {\n        n = (ih.memory_pages - 1) * ih.memory_page_size;\n        n += ih.bytes_on_last_page;\n    }\n    return n;\n}\n\nvoid LeFile::readImage() {\n    soimage = mem_size(mps, pages); // assert size\n    if (!soimage)                   // late detection, but protect against .alloc(0)\n        throwCantPack(\"no soimage\");\n    mb_iimage.alloc(soimage);\n    mb_iimage.clear();\n    iimage = mb_iimage; // => now a SPAN_S\n\n    unsigned ic, jc;\n    for (ic = jc = 0; ic < pages; ic++) {\n        if ((ipm_entries[ic].type & 0xC0) == 0) {\n            fif->seek(ih.data_pages_offset + exe_offset +\n                          (ipm_entries[ic].m * 0x100 + ipm_entries[ic].l - 1) * mps,\n                      SEEK_SET);\n            unsigned bytes = ic != pages - 1 ? mps : ih.bytes_on_last_page;\n            fif->readx(iimage + jc, bytes);\n        }\n        jc += mps;\n    }\n}\n\nvoid LeFile::writeImage() {\n    if (fof && oimage != nullptr)\n        fof->write(oimage, soimage);\n}\n\nvoid LeFile::readNonResidentNames() {\n    if (ih.non_resident_name_table_length) {\n        sononres_names = ih.non_resident_name_table_length;\n        inonres_names = New(byte, sononres_names);\n        fif->seek(exe_offset + ih.non_resident_name_table_offset, SEEK_SET);\n        fif->readx(inonres_names, sononres_names);\n    }\n}\n\nvoid LeFile::writeNonResidentNames() {\n    if (fof && ononres_names)\n        fof->write(ononres_names, sononres_names);\n}\n\nbool LeFile::readFileHeader() {\n#define H(x) get_le16(header + (2 * (x)))\n    byte header[0x40];\n    le_offset = exe_offset = 0;\n    int ic;\n\n    for (ic = 0; ic < 20; ic++) {\n        fif->seek(le_offset, SEEK_SET);\n        fif->readx(header, sizeof(header));\n\n        if (memcmp(header, \"MZ\", 2) == 0) // normal dos exe\n        {\n            exe_offset = le_offset;\n            if (H(0x18 / 2) >= 0x40 && memcmp(header + 0x19, \"TIPPACH\", 7)) // new format exe\n                le_offset += H(0x3c / 2) + H(0x3e / 2) * 65536;\n            else {\n                le_offset += H(2) * 512 + H(1);\n                if (H(1))\n                    le_offset -= 512;\n                else if (H(2) == 0)\n                    return false;\n            }\n        } else if (memcmp(header, \"BW\", 2) == 0) // used in dos4gw.exe\n            le_offset += H(2) * 512 + H(1);\n        else if (memcmp(header, \"LE\", 2) == 0)\n            break; // success\n        else if (memcmp(header, \"PMW1\", 4) == 0)\n            throwCantPack(\"already packed with PMWLITE\");\n        else\n            return false;\n    }\n    if (ic == 20)\n        return false;\n    fif->seek(le_offset, SEEK_SET);\n    fif->readx(&ih, sizeof(ih));\n    if (mps < 512 || mps > 2097152 || (mps & (mps - 1)) != 0)\n        throwCantPack(\"LE file header invalid page size %u\", (unsigned) mps);\n    if (ih.bytes_on_last_page > mps || pages == 0)\n        throwCantPack(\"bad LE file header\");\n    if (!mem_size_valid(mps, pages) || exe_offset > le_offset)\n        throwCantPack(\"bad LE file header\");\n    return true;\n#undef H\n}\n\nvoid LeFile::writeFile(OutputFile *f, bool le) {\n    fof = f;\n    memcpy(&oh, &ih,\n           (charptr) &oh.memory_pages - (charptr) &oh); // copy some members of the orig. header\n    oh.memory_page_size = mps;\n    oh.object_table_offset = sizeof(oh);\n    oh.object_table_entries = soobject_table;\n    oh.object_pagemap_offset = oh.object_table_offset + soobject_table * sizeof(*iobject_table);\n    oh.resident_names_offset = oh.object_pagemap_offset + sopm_entries * sizeof(*ipm_entries);\n    oh.entry_table_offset = oh.resident_names_offset + sores_names;\n    oh.fixup_page_table_offset = oh.entry_table_offset + soentries;\n    oh.fixup_record_table_offset = oh.fixup_page_table_offset + sofpage_table * 4;\n    oh.imported_modules_name_table_offset = oh.fixup_record_table_offset + sofixups - FIXUP_EXTRA;\n    oh.imported_procedures_name_table_offset = oh.imported_modules_name_table_offset;\n    oh.data_pages_offset =\n        oh.fixup_record_table_offset + sofixups + (le ? 0 : le_offset - exe_offset);\n    if (ih.non_resident_name_table_length) {\n        oh.non_resident_name_table_offset = oh.data_pages_offset + soimage;\n        oh.non_resident_name_table_length = sononres_names;\n    }\n    oh.fixup_size = sofixups + 4 * sofpage_table;\n    oh.loader_size = oh.fixup_size + oh.fixup_page_table_offset - sizeof(oh);\n\n    fof->write(&oh, sizeof(oh));\n    writeObjectTable();\n    writePageMap();\n    writeResidentNames();\n    writeEntryTable();\n    writeFixupPageTable();\n    writeFixups();\n    writeImage();\n    writeNonResidentNames();\n}\n\nvoid LeFile::countFixups(unsigned *counts) const {\n    const unsigned o = objects;\n    memset(counts, 0, mem_size(sizeof(unsigned), o + 2));\n    // counts[0..objects-1] - # of 32-bit offset relocations in for that objects\n    // counts[objects]      - # of selector fixups\n    // counts[objects+1]    - # of self-relative fixups\n\n    const byte *fix = ifixups;\n    const unsigned sfixups = get_le32(ifpage_table + pages);\n    unsigned ll;\n\n    while (ptr_udiff_bytes(fix, ifixups) < sfixups) {\n        if ((fix[1] & ~0x10) != 0)\n            throwCantPack(\"unsupported fixup record\");\n        switch (*fix) {\n        case 2: // selector fixup\n            counts[o] += 9;\n            fix += 5;\n            break;\n        case 0x12: // alias selector\n            throwCantPack(\"16-bit selector alias fixup not yet supported\");\n        case 5: // 16-bit offset\n            fix += (fix[1] & 0x10) ? 9 : 7;\n            break;\n        case 6: // 16:32 pointer\n            counts[o] += 9;\n            // fall through\n        case 7: // 32-bit offset\n            counts[fix[4] - 1] += 4;\n            fix += (fix[1] & 0x10) ? 9 : 7;\n            break;\n        case 0x27: // 32-bit offset list\n            ll = fix[2];\n            counts[fix[3] - 1] += ll * 4;\n            fix += (fix[1] & 0x10) ? 6 : 4;\n            fix += ll * 2;\n            break;\n        case 8: // 32-bit self relative fixup\n            counts[o + 1] += 4;\n            fix += (fix[1] & 0x10) ? 9 : 7;\n            break;\n        default:\n            throwCantPack(\"unsupported fixup record\");\n        }\n    }\n    counts[o]++;        // extra space for 'ret'\n    counts[o + 1] += 4; // extra space for 0xFFFFFFFF\n}\n\n/* vim:set ts=4 sw=4 et: */\n","size_bytes":10719},"src/linker.cpp":{"content":"/* linker.cpp --\n\n   This file is part of the Resize executable compressor.\n\n   Copyright (C) 2025 WHO-AM-I-404\n   Based on UPX - Ultimate Packer for eXecutables\n   Copyright (C) 1996-2025 Markus Franz Xaver Johannes Oberhumer\n   Copyright (C) 1996-2025 Laszlo Molnar\n   All Rights Reserved.\n\n   Resize and the UCL library are free software; you can redistribute them\n   and/or modify them under the terms of the GNU General Public License as\n   published by the Free Software Foundation; either version 2 of\n   the License, or (at your option) any later version.\n\n   This program is distributed in the hope that it will be useful,\n   but WITHOUT ANY WARRANTY; without even the implied warranty of\n   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n   GNU General Public License for more details.\n\n   You should have received a copy of the GNU General Public License\n   along with this program; see the file COPYING.\n   If not, write to the Free Software Foundation, Inc.,\n   59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.\n\n   WHO-AM-I-404 <who-am-i-404@proton.me>\n   Based on original work by:\n   Markus F.X.J. Oberhumer <markus@oberhumer.com>\n   Laszlo Molnar <ezerotven+github@gmail.com>\n */\n\n#include \"conf.h\"\n#include \"linker.h\"\n\nstatic unsigned hex(uchar c) { return (c & 0xf) + (c > '9' ? 9 : 0); }\n\nstatic bool grow_capacity(unsigned size, unsigned *capacity) {\n    if (size < *capacity)\n        return false;\n    if (*capacity == 0)\n        *capacity = 16;\n    while (size >= *capacity)\n        *capacity *= 2;\n    return true;\n}\n\ntemplate <class T>\nstatic T **realloc_array(T **array, size_t capacity) may_throw {\n    assert_noexcept(capacity > 0);\n    // NOLINTNEXTLINE(bugprone-multi-level-implicit-pointer-conversion)\n    void *p = realloc(array, mem_size(sizeof(T *), capacity));\n    assert_noexcept(p != nullptr);\n    return static_cast<T **>(p);\n}\n\ntemplate <class T>\nstatic void free_array(T **array, size_t count) noexcept {\n    for (size_t i = 0; i < count; i++) {\n        T *item = upx::atomic_exchange(&array[i], (T *) nullptr);\n        delete item;\n    }\n    ::free(array); // NOLINT(bugprone-multi-level-implicit-pointer-conversion)\n}\n\n/*************************************************************************\n// Section\n**************************************************************************/\n\nElfLinker::Section::Section(const char *n, const void *i, unsigned s, unsigned a)\n    : name(nullptr), output(nullptr), size(s), offset(0), p2align(a), next(nullptr) {\n    name = strdup(n);\n    assert_noexcept(name != nullptr);\n    input = ::malloc(s + 1);\n    assert_noexcept(input != nullptr);\n    if (s != 0) {\n        assert_noexcept(i != nullptr);\n        memcpy(input, i, s);\n    }\n    ((char *) input)[s] = 0;\n}\n\nElfLinker::Section::~Section() noexcept {\n    ::free(name);\n    ::free(input);\n}\n\n/*************************************************************************\n// Symbol\n**************************************************************************/\n\nElfLinker::Symbol::Symbol(const char *n, Section *s, upx_uint64_t o)\n    : name(nullptr), section(s), offset(o) {\n    name = strdup(n);\n    assert_noexcept(name != nullptr);\n    assert_noexcept(section != nullptr);\n}\n\nElfLinker::Symbol::~Symbol() noexcept { ::free(name); }\n\n/*************************************************************************\n// Relocation\n**************************************************************************/\n\nElfLinker::Relocation::Relocation(const Section *s, unsigned o, const char *t, const Symbol *v,\n                                  upx_uint64_t a)\n    : section(s), offset(o), type(t), value(v), add(a) {\n    assert_noexcept(section != nullptr);\n}\n\n/*************************************************************************\n// ElfLinker\n**************************************************************************/\n\nElfLinker::ElfLinker(const N_BELE_RTP::AbstractPolicy *b) noexcept : bele(b) {}\n\nElfLinker::~ElfLinker() noexcept {\n    delete[] input;\n    delete[] output;\n    free_array(sections, nsections);\n    free_array(symbols, nsymbols);\n    free_array(relocations, nrelocations);\n}\n\nvoid ElfLinker::init(const void *pdata_v, int plen, unsigned pxtra) {\n    const byte *pdata = (const byte *) pdata_v;\n    if (plen >= 16 && memcmp(pdata, \"UPX#\", 4) == 0) {\n        // decompress pre-compressed stub-loader\n        int method;\n        unsigned u_len, c_len;\n        if (pdata[4]) {\n            method = pdata[4];\n            u_len = get_le16(pdata + 5);\n            c_len = get_le16(pdata + 7);\n            pdata += 9;\n            assert(9 + c_len == (unsigned) plen);\n        } else {\n            method = pdata[5];\n            u_len = get_le32(pdata + 6);\n            c_len = get_le32(pdata + 10);\n            pdata += 14;\n            assert(14 + c_len == (unsigned) plen);\n        }\n        assert((unsigned) plen < u_len);\n        inputlen = u_len;\n        input = New(byte, inputlen + 1);\n        unsigned new_len = u_len;\n        int r = upx_decompress(pdata, c_len, input, &new_len, method, nullptr);\n        if (r == UPX_E_OUT_OF_MEMORY)\n            throwOutOfMemoryException();\n        if (r != UPX_E_OK || new_len != u_len)\n            throwBadLoader();\n    } else {\n        inputlen = plen;\n        input = New(byte, inputlen + 1);\n        if (inputlen)\n            memcpy(input, pdata, inputlen);\n    }\n    input[inputlen] = 0; // NUL terminate\n\n    output_capacity = (inputlen ? (inputlen + pxtra) : 0x4000);\n    assert(output_capacity < (1 << 16)); // LE16 l_info.l_size\n    output = New(byte, output_capacity);\n    outputlen = 0;\n    NO_printf(\"\\nElfLinker::init %d @%p\\n\", output_capacity, output);\n\n    // FIXME: bad compare when either symbols or relocs are absent\n    if ((int) strlen(\"Sections:\\n\"\n                     \"SYMBOL TABLE:\\n\"\n                     \"RELOCATION RECORDS FOR \") < inputlen) {\n        char const *const eof = (char const *) &input[inputlen];\n        int pos = find(input, inputlen, \"Sections:\\n\", 10);\n        assert(pos != -1);\n        char *const psections = (char *) input + pos;\n\n        char *const psymbols = strstr(psections, \"SYMBOL TABLE:\\n\");\n        // assert(psymbols != nullptr);\n\n        char *const prelocs = strstr((psymbols ? psymbols : psections), \"RELOCATION RECORDS FOR \");\n        // assert(prelocs != nullptr);\n\n        preprocessSections(psections, (psymbols ? psymbols : (prelocs ? prelocs : eof)));\n        if (psymbols)\n            preprocessSymbols(psymbols, (prelocs ? prelocs : eof));\n        if (prelocs)\n            preprocessRelocations(prelocs, eof);\n        addLoader(\"*UND*\");\n    }\n}\n\nvoid ElfLinker::preprocessSections(char *start, char const *end) {\n    assert_noexcept(nsections == 0);\n    char *nextl;\n    for (; start < end; start = 1 + nextl) {\n        nextl = strchr(start, '\\n');\n        assert(nextl != nullptr);\n        *nextl = '\\0'; // a record is a line\n\n        unsigned offset, size, align;\n        char name[1024];\n\n        if (sscanf(start, \"%*d %1023s %x %*x %*x %x 2**%d\", name, &size, &offset, &align) == 4) {\n            char *n = strstr(start, name);\n            n[strlen(name)] = 0;\n            addSection(n, input + offset, size, align);\n            NO_printf(\"section %s preprocessed\\n\", n);\n        }\n    }\n    addSection(\"*ABS*\", nullptr, 0, 0);\n    addSection(\"*UND*\", nullptr, 0, 0);\n}\n\nvoid ElfLinker::preprocessSymbols(char *start, char const *end) {\n    assert_noexcept(nsymbols == 0);\n    char *nextl;\n    for (; start < end; start = 1 + nextl) {\n        nextl = strchr(start, '\\n');\n        assert(nextl != nullptr);\n        *nextl = '\\0'; // a record is a line\n\n        unsigned value, offset;\n        char section[1024];\n        char symbol[1024];\n\n        if (sscanf(start, \"%x g *ABS* %x %1023s\", &value, &offset, symbol) == 3) {\n            char *s = strstr(start, symbol);\n            s[strlen(symbol)] = 0;\n            addSymbol(s, \"*ABS*\", value);\n            assert(offset == 0);\n        }\n#if 0\n        else if (sscanf(start, \"%x%*8c %1023s %*x %1023s\", &offset, section, symbol) == 3)\n#else\n        // work around broken scanf() implementations\n        // https://bugs.winehq.org/show_bug.cgi?id=10401 (fixed in Wine 0.9.58)\n        else if (sscanf(start, \"%x%*c%*c%*c%*c%*c%*c%*c%*c %1023s %*x %1023s\", &offset, section,\n                        symbol) == 3)\n#endif\n        {\n            char *s = strstr(start, symbol);\n            s[strlen(symbol)] = 0;\n            if (strcmp(section, \"*UND*\") == 0)\n                offset = 0xdeaddead;\n            assert(strcmp(section, \"*ABS*\") != 0);\n            addSymbol(s, section, offset);\n        }\n    }\n}\n\nvoid ElfLinker::preprocessRelocations(char *start, char const *end) {\n    assert_noexcept(nrelocations == 0);\n    Section *section = nullptr;\n    char *nextl;\n    for (; start < end; start = 1 + nextl) {\n        nextl = strchr(start, '\\n');\n        assert(nextl != nullptr);\n        *nextl = '\\0'; // a record is a line\n\n        {\n            char sect[1024];\n            if (sscanf(start, \"RELOCATION RECORDS FOR [%[^]]\", sect) == 1)\n                section = findSection(sect);\n        }\n\n        unsigned offset;\n        char type[100];\n        char symbol[1024];\n\n        if (sscanf(start, \"%x %99s %1023s\", &offset, type, symbol) == 3) {\n            char *t = strstr(start, type);\n            t[strlen(type)] = 0;\n\n            upx_uint64_t add = 0;\n            char *p = strstr(symbol, \"+0x\");\n            if (p == nullptr)\n                p = strstr(symbol, \"-0x\");\n            if (p) {\n                char sign = *p;\n                *p = 0; // terminate the symbol name\n                p += 3;\n                assert(strlen(p) == 8 || strlen(p) == 16);\n#if (ACC_CC_MSC && (_MSC_VER < 1800))\n                unsigned a = 0, b = 0;\n                if (sscanf(p, \"%08x%08x\", &a, &b) == 2)\n                    add = ((upx_uint64_t) a << 32) | b;\n                else\n                    add = a;\n#else\n                char *endptr = nullptr;\n                add = strtoull(p, &endptr, 16);\n                assert(endptr && *endptr == '\\0');\n#endif\n                if (sign == '-')\n                    add = 0 - add;\n            }\n\n            if (section) {\n                addRelocation(section->name, offset, t, symbol, add);\n                NO_printf(\"relocation %s %s %x %llu preprocessed\\n\", section->name, symbol, offset,\n                          (unsigned long long) add);\n            }\n        }\n    }\n}\n\nElfLinker::Section *ElfLinker::findSection(const char *name, bool fatal) const {\n    for (unsigned ic = 0; ic < nsections; ic++)\n        if (strcmp(sections[ic]->name, name) == 0)\n            return sections[ic];\n    if (fatal)\n        throwInternalError(\"unknown section %s\\n\", name);\n    return nullptr;\n}\n\nElfLinker::Symbol *ElfLinker::findSymbol(const char *name, bool fatal) const {\n    for (unsigned ic = 0; ic < nsymbols; ic++)\n        if (strcmp(symbols[ic]->name, name) == 0)\n            return symbols[ic];\n    if (fatal)\n        throwInternalError(\"unknown symbol %s\\n\", name);\n    return nullptr;\n}\n\nElfLinker::Section *ElfLinker::addSection(const char *sname, const void *sdata, int slen,\n                                          unsigned p2align) {\n    NO_printf(\"addSection: %s len=%d align=%d\\n\", sname, slen, p2align);\n    if (!sdata && (!strcmp(\"ABS*\", sname) || !strcmp(\"UND*\", sname)))\n        return nullptr;\n    assert(sname && sname[0]);\n    assert(sname[strlen(sname) - 1] != ':');\n    assert(findSection(sname, false) == nullptr);\n    if (grow_capacity(nsections, &nsections_capacity))\n        sections = realloc_array(sections, nsections_capacity);\n    Section *sec = new Section(sname, sdata, slen, p2align);\n    sec->sort_id = nsections;\n    sections[nsections++] = sec;\n    return sec;\n}\n\nElfLinker::Symbol *ElfLinker::addSymbol(const char *name, const char *section,\n                                        upx_uint64_t offset) {\n    NO_printf(\"addSymbol: %s %s 0x%llx\\n\", name, section, offset);\n    assert(name && name[0]);\n    assert(name[strlen(name) - 1] != ':');\n    assert(findSymbol(name, false) == nullptr);\n    if (grow_capacity(nsymbols, &nsymbols_capacity))\n        symbols = realloc_array(symbols, nsymbols_capacity);\n    Symbol *sym = new Symbol(name, findSection(section), offset);\n    symbols[nsymbols++] = sym;\n    return sym;\n}\n\nElfLinker::Relocation *ElfLinker::addRelocation(const char *section, unsigned off, const char *type,\n                                                const char *symbol, upx_uint64_t add) {\n    if (grow_capacity(nrelocations, &nrelocations_capacity))\n        relocations = realloc_array(relocations, nrelocations_capacity);\n    Relocation *rel = new Relocation(findSection(section), off, type, findSymbol(symbol), add);\n    relocations[nrelocations++] = rel;\n    return rel;\n}\n\n#if 0\nvoid ElfLinker::setLoaderAlignOffset(int phase) {\n    // assert(phase & 0);\n    NO_printf(\"\\nFIXME: ElfLinker::setLoaderAlignOffset %d\\n\", phase);\n}\n#endif\n\nint ElfLinker::addLoader(const char *sname) {\n    assert(sname != nullptr);\n    if (!sname[0])\n        return outputlen;\n\n    char *begin = strdup(sname);\n    char *end = begin + strlen(begin);\n    for (char *sect = begin; sect < end;) {\n        for (char *tokend = sect; *tokend; tokend++)\n            if (*tokend == ' ' || *tokend == ',') {\n                *tokend = 0;\n                break;\n            }\n\n        if (sect[0] == '+') // alignment\n        {\n            assert(tail);\n            unsigned l = hex(sect[2]) - tail->offset - tail->size;\n            unsigned m = hex(sect[1]);\n            if (m) {\n                l %= hex(sect[1]);\n            }\n            if (l) {\n                if (sect[3] == 'D')\n                    alignData(l);\n                else\n                    alignCode(l);\n                tail->size += l;\n            }\n        } else {\n            Section *section = findSection(sect);\n            if (section->p2align) {\n                assert(tail);\n                assert(tail != section);\n                // .p2align must be < 32\n                const unsigned v = ~0u << section->p2align;\n                if (const unsigned l = ~v & (0u - (unsigned) (tail->offset + tail->size))) {\n                    alignCode(l);\n                    tail->size += l;\n                }\n            }\n            // Section->output is not relocatable, and C++ has no realloc() anyway.\n            assert((section->size + outputlen) <= output_capacity);\n            memcpy(output + outputlen, section->input, section->size);\n            section->output = output + outputlen; // FIXME: INVALIDATED by realloc()\n            NO_printf(\"section added: 0x%04x %3d %s\\n\", outputlen, section->size, section->name);\n            outputlen += section->size;\n\n            if (head) {\n                tail->next = section;\n                section->offset = tail->offset + tail->size;\n            } else\n                head = section;\n            tail = section;\n        }\n        sect += strlen(sect) + 1;\n    }\n    ::free(begin);\n    return outputlen;\n}\n\nvoid ElfLinker::addLoader(const char *s, va_list ap) {\n    while (s != nullptr) {\n        addLoader(s);\n        s = va_arg(ap, const char *);\n    }\n}\n\nvoid ElfLinker::addLoaderVA(const char *s, ...) {\n    va_list ap;\n    va_start(ap, s);\n    addLoader(s, ap);\n    va_end(ap);\n}\n\nint ElfLinker::getSection(const char *sname, int *slen) const {\n    const Section *section = findSection(sname);\n    if (slen)\n        *slen = section->size;\n    return (int) (section->output - output);\n}\n\nint ElfLinker::getSectionSize(const char *sname) const {\n    const Section *section = findSection(sname);\n    return section->size;\n}\n\nbyte *ElfLinker::getLoader(int *llen) const {\n    if (llen)\n        *llen = outputlen;\n    return output;\n}\n\nvoid ElfLinker::relocate() {\n    assert(!reloc_done);\n    reloc_done = true;\n    for (unsigned ic = 0; ic < nrelocations; ic++) {\n        const Relocation *rel = relocations[ic];\n        upx_uint64_t value = 0;\n\n        if (rel->section->output == nullptr)\n            continue;\n        if (strcmp(rel->value->section->name, \"*ABS*\") == 0) {\n            value = rel->value->offset;\n        } else if (strcmp(rel->value->section->name, \"*UND*\") == 0 &&\n                   rel->value->offset == 0xdeaddead)\n            throwInternalError(\"undefined symbol '%s' referenced\\n\", rel->value->name);\n        else if (rel->value->section->output == nullptr)\n            throwInternalError(\"can not apply reloc '%s:%x' without section '%s'\\n\",\n                               rel->section->name, rel->offset, rel->value->section->name);\n        else {\n            value = rel->value->section->offset + rel->value->offset + rel->add;\n        }\n        byte *location = rel->section->output + rel->offset;\n        NO_printf(\"%-28s %-28s %-10s %#16llx %#16llx\\n\", rel->section->name, rel->value->name,\n                  rel->type, (long long) value,\n                  (long long) value - rel->section->offset - rel->offset);\n        NO_printf(\"  %llx %d %llx %d %llx :%d\\n\", (long long) value,\n                  (int) rel->value->section->offset, rel->value->offset, rel->offset,\n                  (long long) rel->add, *location);\n        relocate1(rel, location, value, rel->type);\n    }\n}\n\nvoid ElfLinker::defineSymbol(const char *name, upx_uint64_t value) {\n    Symbol *symbol = findSymbol(name);\n    if (strcmp(symbol->section->name, \"*ABS*\") == 0)\n        throwInternalError(\"defineSymbol: symbol '%s' is *ABS*\\n\", name);\n    else if (strcmp(symbol->section->name, \"*UND*\") == 0) // for undefined symbols\n        symbol->offset = value;\n    else if (strcmp(symbol->section->name, name) == 0) // for sections\n    {\n        for (Section *section = symbol->section; section; section = section->next) {\n            assert(section->offset < value);\n            section->offset = value;\n            value += section->size;\n        }\n    } else\n        throwInternalError(\"defineSymbol: symbol '%s' already defined\\n\", name);\n}\n\n// debugging support\nvoid ElfLinker::dumpSymbol(const Symbol *symbol, unsigned flags, FILE *fp) const {\n    if ((flags & 1) && symbol->section->output == nullptr)\n        return;\n    char d0[16 + 1], d1[16 + 1];\n    upx_safe_snprintf(d0, sizeof(d0), \"%016llx\", (upx_uint64_t) symbol->offset);\n    upx_safe_snprintf(d1, sizeof(d1), \"%016llx\", (upx_uint64_t) symbol->section->offset);\n    fprintf(fp, \"%-28s 0x%-16s | %-28s 0x%-16s\\n\", symbol->name, d0, symbol->section->name, d1);\n}\nvoid ElfLinker::dumpSymbols(unsigned flags, FILE *fp) const {\n    if (fp == nullptr)\n        fp = stdout;\n    if ((flags & 2) == 0) {\n        // default: dump symbols in used section order\n        for (const Section *section = head; section; section = section->next) {\n            char d1[16 + 1];\n            upx_safe_snprintf(d1, sizeof(d1), \"%016llx\", (upx_uint64_t) section->offset);\n            fprintf(fp, \"%-42s%-28s 0x%-16s\\n\", \"\", section->name, d1);\n            for (unsigned ic = 0; ic < nsymbols; ic++) {\n                const Symbol *symbol = symbols[ic];\n                if (symbol->section == section && strcmp(symbol->name, section->name) != 0)\n                    dumpSymbol(symbol, flags, fp);\n            }\n        }\n    } else {\n        // dump all symbols\n        for (unsigned ic = 0; ic < nsymbols; ic++)\n            dumpSymbol(symbols[ic], flags, fp);\n    }\n}\n\nupx_uint64_t ElfLinker::getSymbolOffset(const char *name) const {\n    const Symbol *symbol = findSymbol(name);\n    if (symbol->section->output == nullptr)\n        return 0xdeaddead;\n    return symbol->section->offset + symbol->offset;\n}\n\nvoid ElfLinker::alignWithByte(unsigned len, byte b) {\n    memset(output + outputlen, b, len);\n    outputlen += len;\n}\n\nvoid ElfLinker::relocate1(const Relocation *rel, byte *, upx_uint64_t, const char *) {\n    throwInternalError(\"unknown relocation type '%s\\n'\", rel->type);\n}\n\n/*************************************************************************\n// ElfLinker arch subclasses\n// FIXME: add more displacement overflow checks\n// FIXME: add support for our special \"ignore_reloc_overflow\" section\n**************************************************************************/\n\n#if 0 // FIXME\nstatic void check8(const Relocation *rel, const byte *location, int v, int d) {\n    if (v < -128 || v > 127)\n        throwInternalError(\"value out of range (%d) in reloc %s:%x\\n\", v, rel->section->name,\n                           rel->offset);\n    if (d < -128 || d > 127)\n        throwInternalError(\"displacement target out of range (%d) in reloc %s:%x\\n\", v,\n                           rel->section->name, rel->offset);\n}\n#endif\n\nvoid ElfLinkerAMD64::relocate1(const Relocation *rel, byte *location, upx_uint64_t value,\n                               const char *type) {\n    if (strncmp(type, \"R_X86_64_\", 9))\n        return super::relocate1(rel, location, value, type);\n    type += 9;\n\n    bool range_check = false;\n    if (strncmp(type, \"PC\", 2) == 0) {\n        type += 2;\n        value -= rel->section->offset + rel->offset;\n        range_check = true;\n    } else if (strncmp(type, \"PLT\", 3) == 0) {\n        type += 3;\n        value -= rel->section->offset + rel->offset;\n        range_check = true;\n    }\n\n    if (strcmp(type, \"8\") == 0) {\n        int displ = (upx_int8_t) *location + (int) value;\n        if (range_check && (displ < -128 || displ > 127))\n            throwInternalError(\"target out of range (%d) in reloc %s:%x\\n\", displ,\n                               rel->section->name, rel->offset);\n        *location += value;\n    } else if (strcmp(type, \"16\") == 0)\n        set_le16(location, get_le16(location) + value);\n    else if (strncmp(type, \"32\", 2) == 0) // for \"32\" and \"32S\"\n        set_le32(location, get_le32(location) + value);\n    else if (strcmp(type, \"64\") == 0)\n        set_le64(location, get_le64(location) + value);\n    else\n        super::relocate1(rel, location, value, type);\n}\n\nvoid ElfLinkerArmBE::relocate1(const Relocation *rel, byte *location, upx_uint64_t value,\n                               const char *type) {\n    if (!strcmp(type, \"R_ARM_PC24\") || !strcmp(type, \"R_ARM_CALL\") ||\n        !strcmp(type, \"R_ARM_JUMP24\")) {\n        value -= rel->section->offset + rel->offset;\n        set_be24(1 + location, get_be24(1 + location) + value / 4);\n    } else if (strcmp(type, \"R_ARM_ABS32\") == 0) {\n        set_be32(location, get_be32(location) + value);\n    } else if (strcmp(type, \"R_ARM_THM_CALL\") == 0 || strcmp(type, \"R_ARM_THM_XPC22\") == 0 ||\n               strcmp(type, \"R_ARM_THM_PC22\") == 0) {\n        value -= rel->section->offset + rel->offset;\n        value += ((get_be16(location) & 0x7ff) << 12);\n        value += (get_be16(location + 2) & 0x7ff) << 1;\n\n        set_be16(location, 0xf000 + ((value >> 12) & 0x7ff));\n        set_be16(location + 2, 0xf800 + ((value >> 1) & 0x7ff));\n\n        //(b, 0xF000 + ((v - 1) / 2) * 0x10000);\n        // set_be32(location, get_be32(location) + value / 4);\n    } else if (0 == strcmp(\"R_ARM_ABS8\", type)) {\n        *location += value;\n    } else\n        super::relocate1(rel, location, value, type);\n}\n\nvoid ElfLinkerArmLE::relocate1(const Relocation *rel, byte *location, upx_uint64_t value,\n                               const char *type) {\n    if (!strcmp(type, \"R_ARM_PC24\") || !strcmp(type, \"R_ARM_CALL\") ||\n        !strcmp(type, \"R_ARM_JUMP24\")) {\n        value -= rel->section->offset + rel->offset;\n        set_le24(location, get_le24(location) + value / 4);\n    } else if (strcmp(type, \"R_ARM_ABS32\") == 0) {\n        set_le32(location, get_le32(location) + value);\n    } else if (strcmp(type, \"R_ARM_THM_CALL\") == 0 || strcmp(type, \"R_ARM_THM_XPC22\") == 0 ||\n               strcmp(type, \"R_ARM_THM_PC22\") == 0) {\n        value -= rel->section->offset + rel->offset;\n        value += ((get_le16(location) & 0x7ff) << 12);\n        value += (get_le16(location + 2) & 0x7ff) << 1;\n\n        set_le16(location, 0xf000 + ((value >> 12) & 0x7ff));\n        set_le16(location + 2, 0xf800 + ((value >> 1) & 0x7ff));\n\n        //(b, 0xF000 + ((v - 1) / 2) * 0x10000);\n        // set_le32(location, get_le32(location) + value / 4);\n    } else if (0 == strcmp(\"R_ARM_ABS8\", type)) {\n        *location += value;\n    } else\n        super::relocate1(rel, location, value, type);\n}\n\nvoid ElfLinkerArm64LE::relocate1(const Relocation *rel, byte *location, upx_uint64_t value,\n                                 const char *type) {\n    if (strncmp(type, \"R_AARCH64_\", 10))\n        return super::relocate1(rel, location, value, type);\n    type += 10;\n\n    if (!strncmp(type, \"PREL\", 4)) {\n        value -= rel->section->offset + rel->offset;\n        type += 4;\n\n        if (!strcmp(type, \"16\"))\n            set_le16(location, get_le16(location) + value);\n        else if (!strncmp(type, \"32\", 2)) // for \"32\" and \"32S\"\n            set_le32(location, get_le32(location) + value);\n        else if (!strcmp(type, \"64\"))\n            set_le64(location, get_le64(location) + value);\n    } else if (!strcmp(type, \"ADR_PREL_LO21\")) {\n        value -= rel->section->offset + rel->offset;\n        upx_uint32_t const m19 = ~(~0u << 19);\n        upx_uint32_t w = get_le32(location);\n        set_le32(location, (w & ~((3u << 29) | (m19 << 5))) | ((3u & value) << 29) |\n                               ((m19 & (value >> 2)) << 5));\n    } else if (!strcmp(type, \"ABS32\")) {\n        set_le32(location, get_le32(location) + value);\n    } else if (!strcmp(type, \"ABS64\")) {\n        set_le64(location, get_le64(location) + value);\n    } else if (!strcmp(type, \"CONDBR19\")) {\n        value -= rel->section->offset + rel->offset;\n        upx_uint32_t const m19 = ~(~0u << 19);\n        upx_uint32_t w = get_le32(location);\n        set_le32(location, (w & ~(m19 << 5)) | ((((w >> 5) + (value >> 2)) & m19) << 5));\n    } else if (!strcmp(type, \"CALL26\") || !strcmp(type, \"JUMP26\")) {\n        value -= rel->section->offset + rel->offset;\n        upx_uint32_t const m26 = ~(~0u << 26);\n        upx_uint32_t w = get_le32(location);\n        set_le32(location, (w & ~m26) | (m26 & (value >> 2)));\n    } else\n        super::relocate1(rel, location, value, type);\n}\n\nvoid ElfLinkerM68k::alignCode(unsigned len) {\n    assert((len & 1) == 0);\n    assert((outputlen & 1) == 0);\n    for (unsigned i = 0; i < len; i += 2)\n        set_be16(output + outputlen + i, 0x4e71); // \"nop\"\n    outputlen += len;\n}\n\nvoid ElfLinkerM68k::relocate1(const Relocation *rel, byte *location, upx_uint64_t value,\n                              const char *type) {\n    if (strncmp(type, \"R_68K_\", 6))\n        return super::relocate1(rel, location, value, type);\n    type += 6;\n\n    if (strncmp(type, \"PC\", 2) == 0) {\n        value -= rel->section->offset + rel->offset;\n        type += 2;\n    }\n    if (strcmp(type, \"8\") == 0) {\n        *location += value;\n    } else if (strcmp(type, \"16\") == 0) {\n        set_be16(location, get_be16(location) + value);\n    } else if (strcmp(type, \"32\") == 0) {\n        set_be32(location, get_be32(location) + value);\n    } else\n        super::relocate1(rel, location, value, type);\n}\n\nvoid ElfLinkerMipsBE::relocate1(const Relocation *rel, byte *location, upx_uint64_t value,\n                                const char *type) {\n#define MIPS_HI(a)   (((a) >> 16) + (((a) &0x8000) >> 15))\n#define MIPS_LO(a)   ((a) &0xffff)\n#define MIPS_PC16(a) ((a) >> 2)\n#define MIPS_PC26(a) (((a) &0x0fffffff) >> 2)\n\n    if (strcmp(type, \"R_MIPS_HI16\") == 0)\n        set_be16(2 + location, get_be16(2 + location) + MIPS_HI(value));\n    else if (strcmp(type, \"R_MIPS_LO16\") == 0)\n        set_be16(2 + location, get_be16(2 + location) + MIPS_LO(value));\n    else if (strcmp(type, \"R_MIPS_PC16\") == 0) {\n        value -= rel->section->offset + rel->offset;\n        set_be16(2 + location, get_be16(2 + location) + MIPS_PC16(value));\n    } else if (strcmp(type, \"R_MIPS_26\") == 0)\n        set_be32(location, get_be32(location) + MIPS_PC26(value));\n    else if (strcmp(type, \"R_MIPS_32\") == 0)\n        set_be32(location, get_be32(location) + value);\n    else\n        super::relocate1(rel, location, value, type);\n\n#undef MIPS_HI\n#undef MIPS_LO\n#undef MIPS_PC16\n#undef MIPS_PC26\n}\n\nvoid ElfLinkerMipsLE::relocate1(const Relocation *rel, byte *location, upx_uint64_t value,\n                                const char *type) {\n#define MIPS_HI(a)   (((a) >> 16) + (((a) &0x8000) >> 15))\n#define MIPS_LO(a)   ((a) &0xffff)\n#define MIPS_PC16(a) ((a) >> 2)\n#define MIPS_PC26(a) (((a) &0x0fffffff) >> 2)\n\n    if (strcmp(type, \"R_MIPS_HI16\") == 0)\n        set_le16(location, get_le16(location) + MIPS_HI(value));\n    else if (strcmp(type, \"R_MIPS_LO16\") == 0)\n        set_le16(location, get_le16(location) + MIPS_LO(value));\n    else if (strcmp(type, \"R_MIPS_PC16\") == 0) {\n        value -= rel->section->offset + rel->offset;\n        set_le16(location, get_le16(location) + MIPS_PC16(value));\n    } else if (strcmp(type, \"R_MIPS_26\") == 0)\n        set_le32(location, get_le32(location) + MIPS_PC26(value));\n    else if (strcmp(type, \"R_MIPS_32\") == 0)\n        set_le32(location, get_le32(location) + value);\n    else\n        super::relocate1(rel, location, value, type);\n\n#undef MIPS_HI\n#undef MIPS_LO\n#undef MIPS_PC16\n#undef MIPS_PC26\n}\n\nvoid ElfLinkerPpc32::relocate1(const Relocation *rel, byte *location, upx_uint64_t value,\n                               const char *type) {\n    if (strncmp(type, \"R_PPC_\", 6))\n        return super::relocate1(rel, location, value, type);\n    type += 6;\n\n    if (strcmp(type, \"ADDR32\") == 0) {\n        set_be32(location, get_be32(location) + value);\n        return;\n    }\n\n    if (strncmp(type, \"REL\", 3) == 0) {\n        value -= rel->section->offset + rel->offset;\n        type += 3;\n    }\n\n    // FIXME: more relocs\n\n    // Note that original (*location).displ is ignored.\n    if (strcmp(type, \"24\") == 0) {\n        if (3 & value)\n            throwInternalError(\"unaligned word displacement\");\n        // FIXME: displacement overflow?\n        set_be32(location, (0xfc000003 & get_be32(location)) + (0x03fffffc & value));\n    } else if (strcmp(type, \"14\") == 0) {\n        if (3 & value)\n            throwInternalError(\"unaligned word displacement\");\n        // FIXME: displacement overflow?\n        set_be32(location, (0xffff0003 & get_be32(location)) + (0x0000fffc & value));\n    } else\n        super::relocate1(rel, location, value, type);\n}\n\nvoid ElfLinkerPpc64le::relocate1(const Relocation *rel, byte *location, upx_uint64_t value,\n                                 const char *type) {\n    if (!strcmp(type, \"R_PPC64_ADDR64\")) {\n        set_le64(location, get_le64(location) + value);\n        return;\n    }\n    if (!strcmp(type, \"R_PPC64_ADDR32\")) {\n        set_le32(location, get_le32(location) + value);\n        return;\n    }\n    if (strncmp(type, \"R_PPC64_REL\", 11))\n        return super::relocate1(rel, location, value, type);\n    type += 11;\n\n    bool range_check = false;\n    if (strncmp(type, \"PC\", 2) == 0) {\n        type += 2;\n        range_check = true;\n    }\n\n    /* value will hold relative displacement */\n    value -= rel->section->offset + rel->offset;\n\n    if (strncmp(type, \"14\", 2) == 0) { // for \"14\" and \"14S\"\n        if (3 & value)\n            throwInternalError(\"unaligned word displacement\");\n        // FIXME: displacement overflow?\n        set_le32(location, (0xffff0003 & get_le32(location)) + (0x0000fffc & value));\n    } else if (strncmp(type, \"24\", 2) == 0) { // for \"24\" and \"24S\"\n        if (3 & value)\n            throwInternalError(\"unaligned word displacement\");\n        // FIXME: displacement overflow?\n        set_le32(location, (0xfc000003 & get_le32(location)) + (0x03fffffc & value));\n    } else if (strcmp(type, \"8\") == 0) {\n        int displ = (upx_int8_t) *location + (int) value;\n        if (range_check && (displ < -128 || displ > 127))\n            throwInternalError(\"target out of range (%d) in reloc %s:%x\\n\", displ,\n                               rel->section->name, rel->offset);\n        *location += value;\n    } else if (strcmp(type, \"16\") == 0)\n        set_le16(location, get_le16(location) + value);\n    else if (strncmp(type, \"32\", 2) == 0) // for \"32\" and \"32S\"\n        set_le32(location, get_le32(location) + value);\n    else if (strcmp(type, \"64\") == 0)\n        set_le64(location, get_le64(location) + value);\n    else\n        super::relocate1(rel, location, value, type);\n}\n\nvoid ElfLinkerPpc64::relocate1(const Relocation *rel, byte *location, upx_uint64_t value,\n                               const char *type) {\n    if (!strcmp(type, \"R_PPC64_ADDR32\")) {\n        set_be32(location, get_be32(location) + value);\n        return;\n    }\n    if (!strcmp(type, \"R_PPC64_ADDR64\")) {\n        set_be64(location, get_be64(location) + value);\n        return;\n    }\n    if (strncmp(type, \"R_PPC64_REL\", 11))\n        return super::relocate1(rel, location, value, type);\n    type += 11;\n\n    bool range_check = false;\n    if (strncmp(type, \"PC\", 2) == 0) {\n        type += 2;\n        range_check = true;\n    }\n\n    // We have \"R_PPC64_REL\" or \"R_PPC64_RELPC\" as a prefix.\n    /* value will hold relative displacement */\n    value -= rel->section->offset + rel->offset;\n\n    if (strncmp(type, \"14\", 2) == 0) { // for \"14\" and \"14S\"\n        if (3 & value)\n            throwInternalError(\"unaligned word displacement\");\n        // FIXME: displacement overflow?\n        set_be32(location, (0xffff0003 & get_be32(location)) + (0x0000fffc & value));\n    } else if (strncmp(type, \"24\", 2) == 0) { // for \"24\" and \"24S\"\n        if (3 & value)\n            throwInternalError(\"unaligned word displacement\");\n        // FIXME: displacement overflow?\n        set_be32(location, (0xfc000003 & get_be32(location)) + (0x03fffffc & value));\n    } else if (strcmp(type, \"8\") == 0) {\n        int displ = (upx_int8_t) *location + (int) value;\n        if (range_check && (displ < -128 || displ > 127))\n            throwInternalError(\"target out of range (%d) in reloc %s:%x\\n\", displ,\n                               rel->section->name, rel->offset);\n        *location += value;\n    } else if (strcmp(type, \"16\") == 0)\n        set_be16(location, get_be16(location) + value);\n    else if (strncmp(type, \"32\", 2) == 0) // for \"32\" and \"32S\"\n        set_be32(location, get_be32(location) + value);\n    else if (strcmp(type, \"64\") == 0)\n        set_be64(location, get_be64(location) + value);\n    else\n        super::relocate1(rel, location, value, type);\n}\n\nvoid ElfLinkerX86::relocate1(const Relocation *rel, byte *location, upx_uint64_t value,\n                             const char *type) {\n    if (strncmp(type, \"R_386_\", 6))\n        return super::relocate1(rel, location, value, type);\n    type += 6;\n\n    bool range_check = false;\n    if (strncmp(type, \"PC\", 2) == 0) {\n        value -= rel->section->offset + rel->offset;\n        type += 2;\n        range_check = true;\n    }\n\n    if (strcmp(type, \"8\") == 0) {\n        int displ = (upx_int8_t) *location + (int) value;\n        if (range_check && (displ < -128 || displ > 127))\n            throwInternalError(\"target out of range (%d,%d,%llu) in reloc %s:%x\\n\", displ,\n                               *location, value, rel->section->name, rel->offset);\n        *location += value;\n    } else if (strcmp(type, \"16\") == 0)\n        set_le16(location, get_le16(location) + value);\n    else if (strcmp(type, \"32\") == 0)\n        set_le32(location, get_le32(location) + value);\n    else\n        super::relocate1(rel, location, value, type);\n}\n\n/* vim:set ts=4 sw=4 et: */\n","size_bytes":35389},"src/main.cpp":{"content":"/* main.cpp -- main entry\n\n   This file is part of the Resize executable compressor.\n\n   Copyright (C) 2025 WHO-AM-I-404\n   Based on UPX - Ultimate Packer for eXecutables\n   Copyright (C) 2025 WHO-AM-I-404\n   Based on UPX - Ultimate Packer for eXecutables\n   Copyright (C) 1996-2025 Markus Franz Xaver Johannes Oberhumer\n   Copyright (C) 1996-2025 Laszlo Molnar\n   All Rights Reserved.\n\n   Resize and the UCL library are free software; you can redistribute them\n   and/or modify them under the terms of the GNU General Public License as\n   published by the Free Software Foundation; either version 2 of\n   the License, or (at your option) any later version.\n\n   This program is distributed in the hope that it will be useful,\n   but WITHOUT ANY WARRANTY; without even the implied warranty of\n   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n   GNU General Public License for more details.\n\n   You should have received a copy of the GNU General Public License\n   along with this program; see the file COPYING.\n   If not, write to the Free Software Foundation, Inc.,\n   59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.\n\n   WHO-AM-I-404 <who-am-i-404@proton.me>\n   Based on original work by:\n   Markus F.X.J. Oberhumer <markus@oberhumer.com>\n   Laszlo Molnar <ezerotven+github@gmail.com>\n */\n\n// main entry, mostly boring stuff; see work.cpp for actual action\n\n#include \"conf.h\"\n#include \"packer.h\"            // Packer::isValidCompressionMethod()\n#include \"p_elf.h\"             // ELFOSABI_xxx\n#include \"compress/compress.h\" // upx_ucl_init()\n\n/*************************************************************************\n// options\n**************************************************************************/\n\n#ifndef OPTIONS_VAR\n// historical note: \"UPX_OPTIONS\" would be a better name, but back in the old\n// days environment variables used to be short; and we cannot change that now\n// because of backward compatibility issues\n#define OPTIONS_VAR \"RESIZE\"\n#endif\n\nstatic const char *argv0 = \"\";\nconst char *progname = \"resize\";\n\nstatic acc_getopt_t mfx_getopt;\n#define mfx_optarg mfx_getopt.optarg\n#define mfx_optind mfx_getopt.optind\n#define mfx_option acc_getopt_longopt_t\nstatic void handle_opterr(acc_getopt_p g, const char *f, void *v) {\n    struct A {\n        va_list ap;\n    };\n    struct A *a = (struct A *) v;\n    fprintf(stderr, \"%s: \", g->progname);\n    vfprintf(stderr, f, a->ap);\n    fprintf(stderr, \"\\n\");\n}\n\n/*************************************************************************\n// exit handlers\n**************************************************************************/\n\nstatic int exit_code = EXIT_OK;\n\n#if (WITH_GUI)\nstatic noinline void do_exit(void) { throw exit_code; }\n#else\n#if defined(__GNUC__)\nstatic void do_exit(void) __attribute__((__noreturn__));\n#endif\nstatic void do_exit(void) {\n    static bool in_exit = false;\n\n    if (in_exit)\n        exit(exit_code);\n    in_exit = true;\n\n    fflush(con_term);\n    fflush(stderr);\n    exit(exit_code);\n}\n#endif\n\n#define EXIT_FATAL 3\n\nstatic bool set_eec(int ec, int *eec) {\n    if (ec == EXIT_FATAL) {\n        *eec = EXIT_ERROR;\n        return true;\n    }\n    if (ec < 0 || ec == EXIT_ERROR) {\n        *eec = EXIT_ERROR;\n    } else if (ec == EXIT_WARN) {\n        if (!opt->ignorewarn)\n            if (*eec == EXIT_OK)\n                *eec = ec;\n    } else if (ec == EXIT_OK) {\n        /* do nothing */\n    } else {\n        assert(0);\n    }\n    return false;\n}\n\nbool main_set_exit_code(int ec) { return set_eec(ec, &exit_code); }\n\nstatic noinline void e_exit(int ec) {\n    if (opt->debug.getopt_throw_instead_of_exit)\n        throw ec;\n    (void) main_set_exit_code(ec);\n    do_exit();\n}\n\nstatic noinline void e_usage(void) {\n    if (opt->debug.getopt_throw_instead_of_exit)\n        throw EXIT_USAGE;\n    show_usage();\n    e_exit(EXIT_USAGE);\n}\n\nstatic void e_method(int m, int l) {\n    fflush(con_term);\n    fprintf(stderr, \"%s: illegal method option -- %d/%d\\n\", argv0, m, l);\n    e_usage();\n}\n\nstatic void e_optarg(const char *n) {\n    fflush(con_term);\n    fprintf(stderr, \"%s: invalid argument in option '%s'\\n\", argv0, n);\n    e_exit(EXIT_USAGE);\n}\n\nstatic void e_optval(const char *n) {\n    fflush(con_term);\n    fprintf(stderr, \"%s: invalid value for option '%s'\\n\", argv0, n);\n    e_exit(EXIT_USAGE);\n}\n\n#if defined(OPTIONS_VAR)\nstatic void e_envopt(const char *n) {\n    fflush(con_term);\n    if (n)\n        fprintf(stderr, \"%s: invalid string '%s' in environment variable '%s'\\n\", argv0, n,\n                OPTIONS_VAR);\n    else\n        fprintf(stderr, \"%s: illegal option in environment variable '%s'\\n\", argv0, OPTIONS_VAR);\n    e_exit(EXIT_USAGE);\n}\n#endif /* defined(OPTIONS_VAR) */\n\n/*************************************************************************\n// check options\n**************************************************************************/\n\nstatic void check_not_both(bool e1, bool e2, const char *c1, const char *c2) {\n    if (e1 && e2) {\n        fprintf(stderr, \"%s: cannot use both '%s' and '%s'\\n\", argv0, c1, c2);\n        e_usage();\n    }\n}\n\nstatic void check_and_update_options(int i, int argc) {\n    assert(i <= argc);\n\n    if (opt->cmd != CMD_COMPRESS) {\n        // invalidate compression options\n        opt->method = 0;\n        opt->level = 0;\n        opt->exact = 0;\n        opt->small = 0;\n        opt->crp.reset();\n    }\n\n    // set default overlay action\n    if (!(opt->cmd == CMD_COMPRESS || opt->cmd == CMD_DECOMPRESS))\n        opt->overlay = opt->COPY_OVERLAY;\n    else if (opt->overlay < 0)\n        opt->overlay = opt->COPY_OVERLAY;\n\n    check_not_both(opt->exact, opt->overlay == opt->STRIP_OVERLAY, \"--exact\", \"--overlay=strip\");\n\n    // set default backup option\n    if (opt->backup < 0)\n        opt->backup = 0;\n    if (!(opt->cmd == CMD_COMPRESS || opt->cmd == CMD_DECOMPRESS))\n        opt->backup = 1;\n\n    check_not_both(opt->to_stdout, opt->output_name != nullptr, \"--stdout\", \"-o\");\n    if (opt->to_stdout && opt->cmd == CMD_COMPRESS) {\n        fprintf(stderr, \"%s: cannot use '--stdout' when compressing\\n\", argv0);\n        e_usage();\n    }\n    if (opt->to_stdout || opt->output_name) {\n        if (i + 1 != argc) {\n            fprintf(stderr, \"%s: need exactly one argument when using '%s'\\n\", argv0,\n                    opt->to_stdout ? \"--stdout\" : \"-o\");\n            e_usage();\n        }\n    }\n    check_not_both(opt->force_overwrite, opt->preserve_link, \"--force-overwrite\", \"--link\");\n    check_not_both(opt->to_stdout, opt->preserve_link, \"--stdout\", \"--link\");\n\n#if defined(__unix__)\n    static_assert(HAVE_LSTAT);\n#else\n    // preserve_link is currently silently ignored on non-Unix platforms\n    // (we may revisit this decision later if there is some actual use-case)\n    opt->preserve_link = false;\n#endif\n}\n\n/*************************************************************************\n// misc\n**************************************************************************/\n\nstatic void e_help(void) {\n    show_help(0);\n    e_exit(EXIT_USAGE);\n}\n\nstatic void set_term(FILE *f) {\n    if (f != nullptr)\n        con_term = f;\n    else\n        con_term = acc_isatty(STDIN_FILENO) ? stderr : stdout;\n}\n\nstatic void set_cmd(int cmd) {\n    if (cmd > opt->cmd)\n        opt->cmd = cmd;\n}\n\nstatic bool set_method(int m, int l) {\n    if (m > 0) {\n        if (!Packer::isValidCompressionMethod(m))\n            return false;\n        // something like \"--brute --lzma\" should not disable \"--brute\"\n        if (!opt->all_methods)\n            opt->method = m;\n    }\n    if (l > 0)\n        opt->level = l;\n    set_cmd(CMD_COMPRESS);\n    return true;\n}\n\nstatic void set_output_name(const char *n, bool allow_m) {\n#if 1\n    if (opt->output_name) {\n        fprintf(stderr, \"%s: option '-o' more than once given\\n\", argv0);\n        e_usage();\n    }\n#endif\n    if (!n || !n[0] || (!allow_m && n[0] == '-')) {\n        fprintf(stderr, \"%s: missing output name\\n\", argv0);\n        e_usage();\n    }\n    if (strlen(n) >= ACC_FN_PATH_MAX - 4) {\n        fprintf(stderr, \"%s: output name too long\\n\", argv0);\n        e_usage();\n    }\n    opt->output_name = n;\n}\n\n/*************************************************************************\n// get options\n**************************************************************************/\n\nstatic char *prepare_shortopts(char *buf, const char *n, const struct mfx_option *longopts) {\n    char *o = buf;\n\n    for (; n && *n; n++)\n        if (*n != ' ')\n            *o++ = *n;\n    *o = 0;\n    for (; longopts && longopts->name; longopts++) {\n        int v = longopts->val;\n#if !defined(NDEBUG)\n        assert(longopts->name[0] != '\\0');\n        assert(longopts->name[0] != '-');\n        if (longopts->has_arg & 0x20)\n            assert((longopts->has_arg & 0xf) == 1);\n#endif\n#if 0\n        static char vopts[1024];\n        if (v > 0 && v < 1024)\n        {\n            if (vopts[v] && strchr(buf,v) == nullptr)\n                printf(\"warning: duplicate option %d ('%c')!\\n\", v, v & 127);\n            vopts[v] = 1;\n        }\n#endif\n        if (v > 0 && v < 256 && strchr(buf, v) == nullptr) {\n            *o++ = (char) v;\n            if ((longopts->has_arg & 0xf) >= 1)\n                *o++ = ':';\n            if ((longopts->has_arg & 0xf) >= 2)\n                *o++ = ':';\n            *o = 0;\n        }\n        if (longopts->has_arg & 0x20)\n            assert((longopts->has_arg & 0xf) == 1);\n    }\n    return buf;\n}\n\ntemplate <class T>\nstatic int getoptvar(T *var, const T min_value, const T max_value, const char *arg_fatal) {\n    const char *p = mfx_optarg;\n    char *endptr = nullptr;\n    int r = 0;\n    long long n;\n    T v;\n\n    if (!p || !p[0]) {\n        r = -1;\n        goto error;\n    }\n    // avoid interpretation as octal value\n    while (p[0] == '0' && isdigit(p[1]))\n        p++;\n    n = strtoll(p, &endptr, 0);\n    if (*endptr != '\\0') {\n        r = -2;\n        goto error;\n    }\n    v = (T) n;\n    if ((long long) v != n || v < min_value || v > max_value) {\n        r = -3;\n        goto error;\n    }\n    *var = v;\n    goto done;\nerror:\n    if (arg_fatal != nullptr)\n        e_optval(arg_fatal);\ndone:\n    return r;\n}\n\ntemplate <class T, T default_value, T min_value, T max_value>\nstatic int getoptvar(upx::OptVar<T, default_value, min_value, max_value> *var,\n                     const char *arg_fatal) {\n    T v = default_value;\n    int r = getoptvar(&v, min_value, max_value, arg_fatal);\n    if (r == 0)\n        *var = v;\n    return r;\n}\n\nstatic int do_option(int optc, const char *arg) {\n    int i = 0;\n\n    switch (optc) {\n#if 0\n    // FIXME: to_stdout doesn't work because of console code mess\n    //case 'c':\n    case 517:\n        opt->to_stdout = true;\n        break;\n#endif\n    case 'd':\n        set_cmd(CMD_DECOMPRESS);\n        break;\n    case 'D':\n        opt->debug.debug_level++;\n        break;\n    case 'f':\n        opt->force++;\n        break;\n    case 529:\n        opt->force_overwrite = true;\n        break;\n    case 909:\n        set_cmd(CMD_FILEINFO);\n        break;\n    case 910:\n        set_cmd(CMD_SYSINFO);\n        break;\n    case 'h':\n    case 'H':\n    case '?':\n        set_cmd(CMD_HELP);\n        break;\n    case 'h' + 256:\n    case 996:\n    case 997:\n#if 1\n        if (!acc_isatty(STDOUT_FILENO)) {\n            /* according to GNU standards */\n            set_term(stdout);\n            opt->console = CON_FILE;\n        }\n#endif\n        show_help(optc == 996 ? 1 : (optc == 997 ? 3 : 2));\n        e_exit(EXIT_OK);\n        break;\n    case 'i':\n        opt->info_mode++;\n        break;\n    case 'l':\n        set_cmd(CMD_LIST);\n        break;\n    case 'L':\n        set_cmd(CMD_LICENSE);\n        break;\n    case 'o':\n        set_output_name(mfx_optarg, 1);\n        break;\n    case 'q':\n        opt->verbose = (opt->verbose > 1 ? 1 : opt->verbose - 1);\n        break;\n    case 't':\n        set_cmd(CMD_TEST);\n        break;\n    case 'v':\n        opt->verbose = (opt->verbose < 3 ? 3 : opt->verbose + 1);\n        break;\n    case 'V':\n        set_cmd(CMD_VERSION);\n        break;\n    case 'V' + 256:\n    case 998:\n        /* according to GNU standards */\n        set_term(stdout);\n        opt->console = CON_FILE;\n        show_version(optc == 998 ? true : false);\n        e_exit(EXIT_OK);\n        break;\n\n    // method\n    case 702:\n        opt->method_nrv2b_seen = true;\n        if (!set_method(M_NRV2B_LE32, -1))\n            e_method(M_NRV2B_LE32, opt->level);\n        break;\n    case 704:\n        opt->method_nrv2d_seen = true;\n        if (!set_method(M_NRV2D_LE32, -1))\n            e_method(M_NRV2D_LE32, opt->level);\n        break;\n    case 705:\n        opt->method_nrv2e_seen = true;\n        if (!set_method(M_NRV2E_LE32, -1))\n            e_method(M_NRV2E_LE32, opt->level);\n        break;\n    case 721:\n        opt->method_lzma_seen = true;\n        opt->all_methods_use_lzma = 1;\n        if (!set_method(M_LZMA, -1))\n            e_method(M_LZMA, opt->level);\n        break;\n    case 722:\n        opt->method_lzma_seen = false;\n        opt->all_methods_use_lzma = -1; // explicitly disabled\n        if (M_IS_LZMA(opt->method))\n            opt->method = -1;\n        break;\n    case 723:\n        opt->prefer_ucl = false;\n        break;\n    case 724:\n        opt->prefer_ucl = true;\n        break;\n\n    // compression level\n    case '1':\n    case '2':\n    case '3':\n    case '4':\n    case '5':\n    case '6':\n    case '7':\n    case '8':\n    case '9':\n        if (!set_method(-1, optc - '0'))\n            e_method(opt->method, optc);\n        break;\n\n    case 902: // --ultra-brute\n        opt->ultra_brute = true;\n        /* fallthrough */\n    case 901: // --brute, much like --all-methods --all-filters --best\n        opt->all_methods = true;\n        if (opt->all_methods_use_lzma != -1)\n            opt->all_methods_use_lzma = 1;\n        opt->method = -1;\n        opt->all_filters = true;\n        opt->filter = -1;\n        opt->crp.crp_ucl.m_size = 999999;\n        /* fallthrough */\n    case 900: // --best\n        if (!set_method(-1, 10))\n            e_method(opt->method, 10);\n        break;\n\n    // debug\n    case 542:\n        if (!mfx_optarg || strlen(mfx_optarg) != 4)\n            e_optarg(arg);\n        memcpy(opt->debug.fake_stub_version, mfx_optarg, 4);\n        break;\n    case 543:\n        if (!mfx_optarg || strlen(mfx_optarg) != 4)\n            e_optarg(arg);\n        memcpy(opt->debug.fake_stub_year, mfx_optarg, 4);\n        break;\n    case 544:\n        if (!mfx_optarg || !mfx_optarg[0])\n            e_optarg(arg);\n        opt->debug.dump_stub_loader = mfx_optarg;\n        break;\n    case 545:\n        opt->debug.disable_random_id = true;\n        break;\n    case 546:\n        opt->debug.use_random_method = true;\n        break;\n    case 547:\n        opt->debug.use_random_filter = true;\n        break;\n\n    // misc\n    case 512:\n        opt->console = CON_FILE;\n        break;\n    case 513:\n        opt->console = CON_ANSI_MONO;\n        break;\n    case 514:\n        opt->console = CON_ANSI_COLOR;\n        break;\n    case 516:\n        opt->no_progress = true;\n        break;\n    case 519:\n        opt->no_env = true;\n        break;\n    case 530:\n        // NOTE: only use \"preserve_link\" if you really need it, e.g. it can fail\n        //   with ETXTBSY and other unexpected errors; renaming files is much safer\n        opt->preserve_link = true;\n        break;\n    case 531:\n        opt->preserve_link = false;\n        break;\n    case 526:\n        opt->preserve_mode = false;\n        break;\n    case 527:\n        opt->preserve_ownership = false;\n        break;\n    case 528:\n        opt->preserve_timestamp = false;\n        break;\n    // compression settings\n    case 520: // --small\n        if (opt->small < 0)\n            opt->small = 0;\n        opt->small++;\n        break;\n    case 521: // --filter=\n        getoptvar(&opt->filter, 0, 255, arg);\n        opt->all_filters = false;\n        break;\n    case 522: // --no-filter\n        opt->filter = 0;\n        opt->all_filters = false;\n        opt->no_filter = true;\n        break;\n    case 523: // --all-filters, also see --brute above\n        opt->all_filters = true;\n        opt->filter = -1;\n        break;\n    case 524: // --all-methods, also see --brute above\n        opt->all_methods = true;\n        if (opt->all_methods_use_lzma != -1)\n            opt->all_methods_use_lzma = 1;\n        opt->method = -1;\n        break;\n    case 525: // --exact\n        opt->exact = true;\n        break;\n    // CRP - Compression Runtime Parameters (undocumented and subject to change)\n    case 801:\n        getoptvar(&opt->crp.crp_ucl.c_flags, 0, 3, arg);\n        break;\n    case 802:\n        getoptvar(&opt->crp.crp_ucl.s_level, 0, 2, arg);\n        break;\n    case 803:\n        getoptvar(&opt->crp.crp_ucl.h_level, 0, 1, arg);\n        break;\n    case 804:\n        getoptvar(&opt->crp.crp_ucl.p_level, 0, 7, arg);\n        break;\n    case 805:\n        getoptvar(&opt->crp.crp_ucl.max_offset, 256u, ~0u, arg);\n        break;\n    case 806:\n        getoptvar(&opt->crp.crp_ucl.max_match, 16u, ~0u, arg);\n        break;\n    case 807:\n        getoptvar(&opt->crp.crp_ucl.m_size, 10000u, 999999u, arg);\n        break;\n    case 811:\n        getoptvar(&opt->crp.crp_lzma.pos_bits, arg);\n        break;\n    case 812:\n        getoptvar(&opt->crp.crp_lzma.lit_pos_bits, arg);\n        break;\n    case 813:\n        getoptvar(&opt->crp.crp_lzma.lit_context_bits, arg);\n        break;\n    case 814:\n        getoptvar(&opt->crp.crp_lzma.dict_size, arg);\n        break;\n    case 816:\n        getoptvar(&opt->crp.crp_lzma.num_fast_bytes, arg);\n        break;\n    case 821:\n        getoptvar(&opt->crp.crp_zlib.mem_level, arg);\n        break;\n    case 822:\n        getoptvar(&opt->crp.crp_zlib.window_bits, arg);\n        break;\n    case 823:\n        getoptvar(&opt->crp.crp_zlib.strategy, arg);\n        break;\n    // backup\n    case 'k':\n        opt->backup = 1;\n        break;\n    case 541:\n        if (opt->backup != 1) // do not override '--backup'\n            opt->backup = 0;\n        break;\n    // overlay\n    case 551:\n        if (mfx_optarg && strcmp(mfx_optarg, \"skip\") == 0)\n            opt->overlay = opt->SKIP_OVERLAY;\n        else if (mfx_optarg && strcmp(mfx_optarg, \"copy\") == 0)\n            opt->overlay = opt->COPY_OVERLAY;\n        else if (mfx_optarg && strcmp(mfx_optarg, \"strip\") == 0)\n            opt->overlay = opt->STRIP_OVERLAY;\n        else\n            e_optarg(arg);\n        break;\n    case 552:\n        opt->overlay = opt->SKIP_OVERLAY;\n        break;\n    case 553:\n        opt->overlay = opt->COPY_OVERLAY;\n        break;\n    case 554:\n        opt->overlay = opt->STRIP_OVERLAY;\n        break;\n    // CPU\n    case 560:\n        if (mfx_optarg && strcmp(mfx_optarg, \"8086\") == 0)\n            opt->cpu_x86 = opt->CPU_8086;\n        else if (mfx_optarg && strcmp(mfx_optarg, \"386\") == 0)\n            opt->cpu_x86 = opt->CPU_386;\n        else if (mfx_optarg && strcmp(mfx_optarg, \"486\") == 0)\n            opt->cpu_x86 = opt->CPU_486;\n        else\n            e_optarg(arg);\n        break;\n    case 561:\n        opt->cpu_x86 = opt->CPU_8086;\n        break;\n    case 563:\n        opt->cpu_x86 = opt->CPU_386;\n        break;\n    case 564:\n        opt->cpu_x86 = opt->CPU_486;\n        break;\n\n    // atari/tos\n    case 650:\n        opt->atari_tos.split_segments = true;\n        break;\n    // darwin/macho\n    case 690:\n        opt->darwin_macho.force_macos = true;\n        break;\n    // dos/exe\n    case 600:\n        opt->dos_exe.force_stub = true;\n        break;\n    case 601:\n        opt->dos_exe.no_reloc = true;\n        break;\n    // djgpp2/coff\n    case 610:\n        opt->djgpp2_coff.coff = true;\n        break;\n    // o_unix\n    case 660:\n        getoptvar(&opt->o_unix.blocksize, 8192u, ~0u, arg);\n        break;\n    case 661:\n        opt->o_unix.force_execve = true;\n        break;\n    case 663:\n        opt->o_unix.is_ptinterp = true;\n        break;\n    case 664:\n        opt->o_unix.use_ptinterp = true;\n        break;\n    case 665:\n        opt->o_unix.make_ptinterp = true;\n        break;\n    case 666: // Linux\n        opt->o_unix.osabi0 = Elf32_Ehdr::ELFOSABI_LINUX;\n        break;\n    case 667: // FreeBSD\n        opt->o_unix.osabi0 = Elf32_Ehdr::ELFOSABI_FREEBSD;\n        break;\n    case 668: // NetBSD\n        opt->o_unix.osabi0 = Elf32_Ehdr::ELFOSABI_NETBSD;\n        break;\n    case 669: // OpenBSD\n        opt->o_unix.osabi0 = Elf32_Ehdr::ELFOSABI_OPENBSD;\n        break;\n    case 674:\n        opt->o_unix.unmap_all_pages = true; // val ?\n        break;\n    case 675:\n        opt->o_unix.preserve_build_id = true;\n        break;\n    case 676:\n        opt->o_unix.android_shlib = true;\n        break;\n    case 677:\n        opt->o_unix.force_pie = true;\n        break;\n    case 678:\n        opt->o_unix.android_old = true;\n        break;\n    case 679:\n        opt->o_unix.catch_sigsegv = true;\n        break;\n    // ps1/exe\n    case 670:\n        opt->ps1_exe.boot_only = true;\n        break;\n    case 671:\n        opt->ps1_exe.no_align = true;\n        opt->ps1_exe.boot_only = false;\n        break;\n    case 672:\n        opt->ps1_exe.do_8bit = true;\n        break;\n    case 673:\n        opt->ps1_exe.do_8mib = false;\n        break;\n    // watcom/le\n    case 620:\n        opt->watcom_le.le = true;\n        break;\n    // win32/pe\n    case 630:\n        opt->win32_pe.compress_exports = 1;\n        if (mfx_optarg && mfx_optarg[0])\n            getoptvar(&opt->win32_pe.compress_exports, 0, 1, arg);\n        // printf(\"compress_exports: %d\\n\", opt->win32_pe.compress_exports);\n        break;\n    case 631:\n        opt->win32_pe.compress_icons = 1;\n        if (mfx_optarg && mfx_optarg[0])\n            getoptvar(&opt->win32_pe.compress_icons, 0, 3, arg);\n        // printf(\"compress_icons: %d\\n\", opt->win32_pe.compress_icons);\n        break;\n    case 632:\n        opt->win32_pe.compress_resources = 1;\n        if (mfx_optarg && mfx_optarg[0]) {\n            int value = 0;\n            getoptvar(&value, 0, 1, arg);\n            opt->win32_pe.compress_resources = bool(value);\n        }\n        // printf(\"compress_resources: %d\\n\", opt->win32_pe.compress_resources);\n        break;\n    case 633:\n        // opt->win32_pe.strip_loadconf - OBSOLETE - IGNORED\n        break;\n    case 634:\n        opt->win32_pe.strip_relocs = 1;\n        if (mfx_optarg && mfx_optarg[0])\n            getoptvar(&opt->win32_pe.strip_relocs, 0, 1, arg);\n        // printf(\"strip_relocs: %d\\n\", opt->win32_pe.strip_relocs);\n        break;\n    case 635:\n        if (!mfx_optarg || !mfx_optarg[0])\n            e_optarg(arg);\n        opt->win32_pe.keep_resource = mfx_optarg;\n        break;\n\n#if !defined(DOCTEST_CONFIG_DISABLE)\n    case 999: // [doctest] --dt-XXX option; ignored here, see upx_doctest_check()\n        break;\n#endif\n\n    case '\\0':\n        return -1;\n    case ':':\n        return -2;\n    default:\n        fprintf(stderr, \"%s: internal error in getopt (%d)\\n\", argv0, optc);\n        return -3;\n    }\n\n    UNUSED(i);\n    return 0;\n}\n\nint main_get_options(int argc, char **argv) {\n    constexpr int *N = nullptr;\n\n    static const struct mfx_option longopts[] = {\n        // commands\n        {\"best\", 0x10, N, 900},        // compress best\n        {\"brute\", 0x10, N, 901},       // compress best, brute force\n        {\"ultra-brute\", 0x10, N, 902}, // compress best, ultra-brute force\n        {\"decompress\", 0, N, 'd'},     // decompress\n        {\"fast\", 0x10, N, '1'},        // compress faster\n        {\"fileinfo\", 0x10, N, 909},    // display info about file\n        {\"file-info\", 0x10, N, 909},   // display info about file\n        {\"help\", 0, N, 'h' + 256},     // give help\n        {\"license\", 0, N, 'L'},        // display software license\n        {\"list\", 0, N, 'l'},           // list compressed exe\n        {\"sysinfo\", 0x90, N, 910},     // display system info // undocumented and subject to change\n        {\"sys-info\", 0x90, N, 910},    // display system info // undocumented and subject to change\n        {\"test\", 0, N, 't'},           // test compressed file integrity\n        {\"uncompress\", 0, N, 'd'},     // decompress\n        {\"version\", 0, N, 'V' + 256},  // display version number\n\n        // options\n        {\"force\", 0, N, 'f'},              // force overwrite of output files\n        {\"force-compress\", 0, N, 'f'},     //   and compression of suspicious files\n        {\"force-overwrite\", 0x90, N, 529}, // force overwrite of output files\n        {\"info\", 0, N, 'i'},               // info mode\n        {\"link\", 0x90, N, 530},            // preserve hard link\n        {\"no-env\", 0x10, N, 519},          // no environment var\n        {\"no-link\", 0x90, N, 531},         // do not preserve hard link [default]\n        {\"no-mode\", 0x10, N, 526},         // do not preserve mode (permissions)\n        {\"no-owner\", 0x10, N, 527},        // do not preserve ownership\n        {\"no-progress\", 0, N, 516},        // no progress bar\n        {\"no-time\", 0x10, N, 528},         // do not preserve timestamp\n        {\"output\", 0x21, N, 'o'},\n        {\"quiet\", 0, N, 'q'},  // quiet mode\n        {\"silent\", 0, N, 'q'}, // quiet mode\n#if 0\n        // FIXME: to_stdout doesn't work because of console code mess\n        {\"stdout\",           0x10, N, 517},     // write output on standard output\n        {\"to-stdout\",        0x10, N, 517},     // write output on standard output\n#endif\n        {\"verbose\", 0, N, 'v'}, // verbose mode\n\n        // debug options\n        {\"debug\", 0x10, N, 'D'},\n        {\"dump-stub-loader\", 0x31, N, 544},        // for internal debugging\n        {\"fake-stub-version\", 0x31, N, 542},       // for internal debugging\n        {\"fake-stub-year\", 0x31, N, 543},          // for internal debugging\n        {\"disable-random-id\", 0x90, N, 545},       // for internal debugging\n        {\"debug-use-random-method\", 0x90, N, 546}, // for internal debugging / fuzz testing\n        {\"debug-use-random-filter\", 0x90, N, 547}, // for internal debugging / fuzz testing\n\n        // backup options\n        {\"backup\", 0x10, N, 'k'},\n        {\"keep\", 0x10, N, 'k'},\n        {\"no-backup\", 0x10, N, 541},\n\n        // overlay options\n        {\"overlay\", 0x31, N, 551}, // --overlay=\n        {\"skip-overlay\", 0x10, N, 552},\n        {\"no-overlay\", 0x10, N, 552}, // old name\n        {\"copy-overlay\", 0x10, N, 553},\n        {\"strip-overlay\", 0x10, N, 554},\n\n        // CPU options\n        {\"cpu\", 0x31, N, 560}, // --cpu=\n        {\"8086\", 0x10, N, 561},\n        {\"386\", 0x10, N, 563},\n        {\"486\", 0x10, N, 564},\n\n        // color options\n        {\"no-color\", 0x10, N, 512},\n        {\"mono\", 0x10, N, 513},\n        {\"color\", 0x10, N, 514},\n\n        // compression method\n        {\"nrv2b\", 0x10, N, 702},   // --nrv2b\n        {\"nrv2d\", 0x10, N, 704},   // --nrv2d\n        {\"nrv2e\", 0x10, N, 705},   // --nrv2e\n        {\"lzma\", 0x10, N, 721},    // --lzma\n        {\"no-lzma\", 0x10, N, 722}, // disable all_methods_use_lzma\n        {\"prefer-nrv\", 0x10, N, 723},\n        {\"prefer-ucl\", 0x10, N, 724},\n        // compression settings\n        {\"all-filters\", 0x10, N, 523},\n        {\"all-methods\", 0x10, N, 524},\n        {\"exact\", 0x10, N, 525},  // user requires byte-identical decompression\n        {\"filter\", 0x31, N, 521}, // --filter=\n        {\"no-filter\", 0x10, N, 522},\n        {\"small\", 0x10, N, 520},\n        // CRP - Compression Runtime Parameters (undocumented and subject to change)\n        {\"crp-nrv-cf\", 0x31, N, 801},\n        {\"crp-nrv-sl\", 0x31, N, 802},\n        {\"crp-nrv-hl\", 0x31, N, 803},\n        {\"crp-nrv-pl\", 0x31, N, 804},\n        {\"crp-nrv-mo\", 0x31, N, 805},\n        {\"crp-nrv-mm\", 0x31, N, 806},\n        {\"crp-nrv-ms\", 0x31, N, 807},\n        {\"crp-ucl-cf\", 0x31, N, 801},\n        {\"crp-ucl-sl\", 0x31, N, 802},\n        {\"crp-ucl-hl\", 0x31, N, 803},\n        {\"crp-ucl-pl\", 0x31, N, 804},\n        {\"crp-ucl-mo\", 0x31, N, 805},\n        {\"crp-ucl-mm\", 0x31, N, 806},\n        {\"crp-ucl-ms\", 0x31, N, 807},\n        {\"crp-lzma-pb\", 0x31, N, 811},\n        {\"crp-lzma-lp\", 0x31, N, 812},\n        {\"crp-lzma-lc\", 0x31, N, 813},\n        {\"crp-lzma-ds\", 0x31, N, 814},\n        {\"crp-lzma-fb\", 0x31, N, 816},\n        {\"crp-zlib-ml\", 0x31, N, 821},\n        {\"crp-zlib-wb\", 0x31, N, 822},\n        {\"crp-zlib-st\", 0x31, N, 823},\n\n        // atari/tos\n        {\"split-segments\", 0x90, N, 650},\n        // darwin/macho\n        {\"force-macos\", 0x90, N, 690}, // undocumented temporary option until we do fix macOS 13+\n        // djgpp2/coff\n        {\"coff\", 0x90, N, 610}, // produce COFF output\n        // dos/exe\n        //{\"force-stub\", 0x10, N, 600},\n        {\"no-reloc\", 0x10, N, 601}, // no reloc. record into packer dos/exe\n        // o_unix\n        {\"blocksize\", 0x31, N, 660},     // --blocksize=\n        {\"force-execve\", 0x90, N, 661},  // force linux/386 execve format\n        {\"is_ptinterp\", 0x10, N, 663},   // linux/elf386 PT_INTERP program\n        {\"use_ptinterp\", 0x10, N, 664},  // linux/elf386 PT_INTERP program\n        {\"make_ptinterp\", 0x10, N, 665}, // linux/elf386 PT_INTERP program\n        {\"Linux\", 0x10, N, 666},\n        {\"linux\", 0x10, N, 666},\n        {\"FreeBSD\", 0x10, N, 667},\n        {\"freebsd\", 0x10, N, 667},\n        {\"NetBSD\", 0x10, N, 668},\n        {\"netbsd\", 0x10, N, 668},\n        {\"OpenBSD\", 0x10, N, 669},\n        {\"openbsd\", 0x10, N, 669},\n        {\"unmap-all-pages\", 0x10, N, 674}, // linux /proc/self/exe vanishes\n        {\"preserve-build-id\", 0, N, 675},\n        {\"android-shlib\", 0, N, 676},\n        {\"force-pie\", 0x90, N, 677},\n        {\"android-old\", 0, N, 678},\n        {\"catch-sigsegv\", 0, N, 679},\n        // ps1/exe\n        {\"boot-only\", 0x90, N, 670},\n        {\"no-align\", 0x90, N, 671},\n        {\"8-bit\", 0x90, N, 672},\n        {\"8mib-ram\", 0x90, N, 673},\n        {\"8mb-ram\", 0x90, N, 673},\n        // watcom/le\n        {\"le\", 0x90, N, 620}, // produce LE output\n        // win32/pe\n        {\"compress-exports\", 2, N, 630},\n        {\"compress-icons\", 2, N, 631},\n        {\"compress-resources\", 2, N, 632},\n        {\"strip-loadconf\", 0x12, N, 633}, // OBSOLETE - IGNORED\n        {\"strip-relocs\", 0x12, N, 634},\n        {\"keep-resource\", 0x31, N, 635},\n\n#if !defined(DOCTEST_CONFIG_DISABLE) // accept and ignore some doctest --dt-XXX options\n        // [doctest] Query flags - the program quits after them. Available:\n        {\"dt-c\", 0x10, N, 999},\n        {\"dt-count\", 0x10, N, 999},\n        {\"dt-h\", 0x10, N, 999},\n        {\"dt-help\", 0x10, N, 999},\n        {\"dt-lr\", 0x10, N, 999},\n        {\"dt-list-reporters\", 0x10, N, 999},\n        {\"dt-ltc\", 0x10, N, 999},\n        {\"dt-list-test-cases\", 0x10, N, 999},\n        {\"dt-lts\", 0x10, N, 999},\n        {\"dt-list-test-suites\", 0x10, N, 999},\n        {\"dt-v\", 0x10, N, 999},\n        {\"dt-version\", 0x10, N, 999},\n        // [doctest] Bool options - can be used like flags and true is assumed. Available:\n        {\"dt-d\", 0x12, N, 999},\n        {\"dt-duration\", 0x12, N, 999},\n        {\"dt-e\", 0x12, N, 999},\n        {\"dt-exit\", 0x12, N, 999},\n        {\"dt-m\", 0x12, N, 999},\n        {\"dt-minimal\", 0x12, N, 999},\n        {\"dt-nt\", 0x12, N, 999},\n        {\"dt-no-throw\", 0x12, N, 999},\n        {\"dt-nr\", 0x12, N, 999},\n        {\"dt-no-run\", 0x12, N, 999},\n        {\"dt-s\", 0x12, N, 999},\n        {\"dt-success\", 0x12, N, 999},\n#endif\n\n        {nullptr, 0, nullptr, 0}\n    };\n\n    int optc, longind;\n    char shortopts[256];\n\n    prepare_shortopts(shortopts, \"123456789hH?V\", longopts);\n    acc_getopt_init(&mfx_getopt, 1, argc, argv);\n    mfx_getopt.progname = progname;\n    mfx_getopt.opterr = handle_opterr;\n    while ((optc = acc_getopt(&mfx_getopt, shortopts, longopts, &longind)) >= 0) {\n        if (do_option(optc, argv[mfx_optind - 1]) != 0)\n            e_usage();\n    }\n\n    return mfx_optind;\n}\n\nvoid main_get_envoptions() {\n#if defined(OPTIONS_VAR)\n    constexpr int *N = nullptr;\n\n    /* only some options are allowed in the environment variable */\n\n    static const struct mfx_option longopts[] = {\n        // commands\n        {\"best\", 0x10, N, 900},        // compress best\n        {\"brute\", 0x10, N, 901},       // compress best, brute force\n        {\"ultra-brute\", 0x10, N, 902}, // compress best, ultra-brute force\n        {\"fast\", 0x10, N, '1'},        // compress faster\n\n        // options\n        {\"info\", 0, N, 'i'},        // info mode\n        {\"no-progress\", 0, N, 516}, // no progress bar\n        {\"quiet\", 0, N, 'q'},       // quiet mode\n        {\"silent\", 0, N, 'q'},      // quiet mode\n        {\"verbose\", 0, N, 'v'},     // verbose mode\n\n        // debug options\n        {\"disable-random-id\", 0x90, N, 545}, // for internal debugging\n\n        // backup options\n        {\"backup\", 0x10, N, 'k'},\n        {\"keep\", 0x10, N, 'k'},\n        {\"no-backup\", 0x10, N, 541},\n\n        // overlay options\n        {\"overlay\", 0x31, N, 551}, // --overlay=\n        {\"skip-overlay\", 0x10, N, 552},\n        {\"no-overlay\", 0x10, N, 552}, // old name\n        {\"copy-overlay\", 0x10, N, 553},\n        {\"strip-overlay\", 0x10, N, 554},\n\n        // CPU options\n        {\"cpu\", 0x31, N, 560}, // --cpu=\n        {\"8086\", 0x10, N, 561},\n        {\"386\", 0x10, N, 563},\n        {\"486\", 0x10, N, 564},\n\n        // color options\n        {\"no-color\", 0x10, N, 512},\n        {\"mono\", 0x10, N, 513},\n        {\"color\", 0x10, N, 514},\n\n        // compression settings\n        {\"exact\", 0x10, N, 525}, // user requires byte-identical decompression\n\n        // compression method\n        {\"nrv2b\", 0x10, N, 702},   // --nrv2b\n        {\"nrv2d\", 0x10, N, 704},   // --nrv2d\n        {\"nrv2e\", 0x10, N, 705},   // --nrv2e\n        {\"lzma\", 0x10, N, 721},    // --lzma\n        {\"no-lzma\", 0x10, N, 722}, // disable all_methods_use_lzma\n        {\"prefer-nrv\", 0x10, N, 723},\n        {\"prefer-ucl\", 0x10, N, 724},\n\n        // win32/pe\n        {\"compress-exports\", 2, N, 630},\n        {\"compress-icons\", 2, N, 631},\n        {\"compress-resources\", 2, N, 632},\n        {\"strip-loadconf\", 0x12, N, 633}, // OBSOLETE - IGNORED\n        {\"strip-relocs\", 0x12, N, 634},\n        {\"keep-resource\", 0x31, N, 635},\n\n        {nullptr, 0, nullptr, 0}};\n\n    char *env, *p;\n    const char *var;\n    int i, optc, longind;\n    int targc;\n    const char **targv = nullptr;\n    static const char sep[] = \" \\t\";\n    char shortopts[256];\n\n    var = upx_getenv(OPTIONS_VAR);\n    if (var == nullptr || !var[0])\n        return;\n    env = strdup(var);\n    if (env == nullptr)\n        return;\n\n    /* count arguments */\n    for (p = env, targc = 1;;) {\n        while (*p && strchr(sep, *p))\n            p++;\n        if (*p == '\\0')\n            break;\n        targc++;\n        while (*p && !strchr(sep, *p))\n            p++;\n        if (*p == '\\0')\n            break;\n        p++;\n    }\n\n    /* alloc temp argv */\n    if (targc > 1)\n        targv = (const char **) upx_calloc(targc + 1, sizeof(char *));\n    if (targv == nullptr) {\n        ::free(env);\n        return;\n    }\n\n    /* fill temp argv */\n    targv[0] = argv0;\n    for (p = env, targc = 1;;) {\n        while (*p && strchr(sep, *p))\n            p++;\n        if (*p == '\\0')\n            break;\n        targv[targc++] = p;\n        while (*p && !strchr(sep, *p))\n            p++;\n        if (*p == '\\0')\n            break;\n        *p++ = '\\0';\n    }\n    targv[targc] = nullptr;\n\n    /* check that only options are in temp argv */\n    for (i = 1; i < targc; i++)\n        if (targv[i][0] != '-' || !targv[i][1] || strcmp(targv[i], \"--\") == 0)\n            e_envopt(targv[i]);\n\n    /* handle options */\n    prepare_shortopts(shortopts, \"123456789\", longopts);\n    acc_getopt_init(&mfx_getopt, 1, targc, const_cast<char **>(targv));\n    mfx_getopt.progname = progname;\n    mfx_getopt.opterr = handle_opterr;\n    while ((optc = acc_getopt(&mfx_getopt, shortopts, longopts, &longind)) >= 0) {\n        if (do_option(optc, targv[mfx_optind - 1]) != 0)\n            e_envopt(nullptr);\n    }\n\n    if (mfx_optind < targc)\n        e_envopt(targv[mfx_optind]);\n\n    /* clean up */\n    ::free(targv); // NOLINT(bugprone-multi-level-implicit-pointer-conversion)\n    ::free(env);\n#endif /* defined(OPTIONS_VAR) */\n}\n\nstatic void first_options(int argc, char **argv) {\n    int i;\n    int n = argc;\n\n    for (i = 1; i < n; i++) {\n        if (strcmp(argv[i], \"--\") == 0) {\n            n = i;\n            break;\n        }\n        if (strcmp(argv[i], \"--version\") == 0)\n            do_option('V' + 256, argv[i]);\n        if (strcmp(argv[i], \"--version-short\") == 0)\n            do_option(998, argv[i]);\n    }\n    for (i = 1; i < n; i++) {\n        if (strcmp(argv[i], \"--help\") == 0)\n            do_option('h' + 256, argv[i]);\n        if (strcmp(argv[i], \"--help-short\") == 0) // undocumented and subject to change\n            do_option(996, argv[i]);\n        if (strcmp(argv[i], \"--help-verbose\") == 0) // undocumented and subject to change\n            do_option(997, argv[i]);\n    }\n    for (i = 1; i < n; i++)\n        if (strcmp(argv[i], \"--no-env\") == 0)\n            do_option(519, argv[i]);\n}\n\n/*************************************************************************\n// main entry point\n**************************************************************************/\n\nint upx_main(int argc, char *argv[]) may_throw {\n    int i;\n    static char default_argv0[] = \"upx\";\n    assert(argc >= 1); // sanity check\n    if (!argv[0] || !argv[0][0])\n        argv[0] = default_argv0;\n    argv0 = argv[0];\n\n    upx_compiler_sanity_check();\n    int dt_res = upx_doctest_check(argc, argv);\n    if (dt_res != 0) {\n        if (dt_res == 2)\n            fprintf(stderr, \"%s: doctest requested program exit; Stop.\\n\", argv0);\n        else\n            fprintf(stderr, \"%s: internal error: doctest check failed\\n\", argv0);\n        e_exit(EXIT_INIT);\n    }\n\n    // Allow serial re-use of upx_main() as a subroutine\n    exit_code = EXIT_OK;\n    opt->reset();\n\n#if (ACC_OS_CYGWIN || ACC_OS_DOS16 || ACC_OS_DOS32 || ACC_OS_EMX || ACC_OS_TOS || ACC_OS_WIN16 ||  \\\n     ACC_OS_WIN32 || ACC_OS_WIN64)\n    {\n        char *prog = fn_basename(argv0);\n        char *p;\n        bool allupper = true;\n        for (p = prog; *p; p++)\n            if (islower((uchar) *p))\n                allupper = false;\n        if (allupper)\n            fn_strlwr(prog);\n        if (p - prog > 4) {\n            p -= 4;\n            if (fn_strcmp(p, \".exe\") == 0 || fn_strcmp(p, \".ttp\") == 0)\n                *p = 0;\n        }\n        progname = prog;\n    }\n#else\n    progname = fn_basename(argv0);\n#endif\n    while (progname[0] == '.' && progname[1] == '/' && progname[2])\n        progname += 2;\n\n    set_term(stderr);\n\n#if (WITH_BZIP2)\n    assert(upx_bzip2_init() == 0);\n#endif\n    assert(upx_lzma_init() == 0);\n#if (WITH_NRV)\n    assert(upx_nrv_init() == 0);\n#endif\n    assert(upx_ucl_init() == 0);\n#if (WITH_ZLIB)\n    assert(upx_zlib_init() == 0);\n#endif\n#if (WITH_ZSTD)\n    assert(upx_zstd_init() == 0);\n#endif\n\n    /* get options */\n    first_options(argc, argv);\n    if (!opt->no_env)\n        main_get_envoptions();\n    i = main_get_options(argc, argv);\n    assert(i <= argc);\n\n    set_term(nullptr);\n    switch (opt->cmd) {\n    case CMD_NONE:\n        /* default - compress */\n        set_cmd(CMD_COMPRESS);\n        break;\n    case CMD_COMPRESS:\n        break;\n    case CMD_DECOMPRESS:\n        break;\n    case CMD_TEST:\n        break;\n    case CMD_LIST:\n        break;\n    case CMD_FILEINFO:\n        break;\n    case CMD_SYSINFO:\n        show_sysinfo(OPTIONS_VAR);\n        e_exit(EXIT_OK);\n        break;\n    case CMD_HELP:\n        show_help(2);\n        e_exit(EXIT_OK);\n        break;\n    case CMD_LICENSE:\n        show_license();\n        e_exit(EXIT_OK);\n        break;\n    case CMD_VERSION:\n        show_version();\n        e_exit(EXIT_OK);\n        break;\n    default:\n        assert(false); // should not happen\n        break;\n    }\n\n    /* check options */\n    if (argc == 1)\n        e_help();\n    set_term(stderr);\n    check_and_update_options(i, argc);\n    int num_files = argc - i;\n    if (num_files < 1) {\n        if (opt->verbose >= 2)\n            e_help();\n        else\n            e_usage();\n    }\n\n    /* start work */\n    set_term(stdout);\n    if (do_files(i, argc, argv) != 0) {\n        assert(exit_code != 0);\n        return exit_code;\n    }\n\n    if (gitrev[0]) {\n        // also see UPX_CONFIG_DISABLE_GITREV in CMakeLists.txt\n        bool warn_gitrev = true;\n        if (is_envvar_true(\"UPX_DEBUG_DISABLE_GITREV_WARNING\"))\n            warn_gitrev = false;\n        if (warn_gitrev) {\n            FILE *f = stdout;\n            int fg = con_fg(f, FG_RED);\n            con_fprintf(\n                f, \"\\nWARNING: this is an unstable beta version - use for testing only! Really.\\n\");\n            fg = con_fg(f, fg);\n            UNUSED(fg);\n        }\n    }\n\n    return exit_code;\n}\n\n/*************************************************************************\n// real entry point\n**************************************************************************/\n\n#if !(WITH_GUI)\n\n#if 1 && (ACC_OS_DOS32) && defined(__DJGPP__)\n#include <crt0.h>\nint _crt0_startup_flags = _CRT0_FLAG_UNIX_SBRK;\n#endif\n#if (ACC_ARCH_M68K && ACC_OS_TOS && ACC_CC_GNUC) && defined(__MINT__)\nextern \"C\" {\nextern long _stksize;\nlong _stksize = 256 * 1024L;\n}\n#endif\n#if (ACC_OS_WIN32 || ACC_OS_WIN64) && (defined(__MINGW32__) || defined(__MINGW64__))\nextern \"C\" {\nextern int _dowildcard;\nint _dowildcard = -1;\n}\n#endif\n\nint __acc_cdecl_main main(int argc, char *argv[]) /*noexcept*/ {\n#if 0 && (ACC_OS_DOS32) && defined(__DJGPP__)\n    // LFN=n may cause problems with 2.03's _rename and mkdir under WinME\n    putenv(\"LFN=y\");\n#endif\n#if (ACC_OS_WIN32 || ACC_OS_WIN64) && (ACC_CC_MSC) && defined(_WRITE_ABORT_MSG) &&                 \\\n    defined(_CALL_REPORTFAULT)\n    _set_abort_behavior(_WRITE_ABORT_MSG, _WRITE_ABORT_MSG | _CALL_REPORTFAULT);\n#endif\n    acc_wildargv(&argc, &argv);\n    upx_rand_init();\n\n    // info: main() is implicitly \"noexcept\", so we need a try block\n#if 0\n    int r = upx_main(argc, argv);\n#else\n    int r;\n    try {\n        r = upx_main(argc, argv);\n    } catch (const Throwable &e) {\n        printErr(\"unknown\", e);\n        std::terminate();\n    } catch (...) {\n        std::terminate();\n    }\n#endif\n\n#if 0 && defined(__GLIBC__)\n    // malloc_stats();\n#endif\n    return r;\n}\n\n#endif /* !(WITH_GUI) */\n\n/* vim:set ts=4 sw=4 et: */\n","size_bytes":42033},"src/msg.cpp":{"content":"/* msg.cpp -- info and error messages\n\n   This file is part of the Resize executable compressor.\n\n   Copyright (C) 2025 WHO-AM-I-404\n   Based on UPX - Ultimate Packer for eXecutables\n   Copyright (C) 1996-2025 Markus Franz Xaver Johannes Oberhumer\n   Copyright (C) 1996-2025 Laszlo Molnar\n   All Rights Reserved.\n\n   Resize and the UCL library are free software; you can redistribute them\n   and/or modify them under the terms of the GNU General Public License as\n   published by the Free Software Foundation; either version 2 of\n   the License, or (at your option) any later version.\n\n   This program is distributed in the hope that it will be useful,\n   but WITHOUT ANY WARRANTY; without even the implied warranty of\n   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n   GNU General Public License for more details.\n\n   You should have received a copy of the GNU General Public License\n   along with this program; see the file COPYING.\n   If not, write to the Free Software Foundation, Inc.,\n   59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.\n\n   WHO-AM-I-404 <who-am-i-404@proton.me>\n   Based on original work by:\n   Markus F.X.J. Oberhumer <markus@oberhumer.com>\n   Laszlo Molnar <ezerotven+github@gmail.com>\n */\n\n#include \"util/system_headers.h\"\n#include <typeinfo> // typeid()\n#include \"conf.h\"\n\n/*************************************************************************\n//\n**************************************************************************/\n\nstatic int pr_need_nl = 0;\n\nvoid printSetNl(int need_nl) noexcept { pr_need_nl = need_nl; }\n\nvoid printClearLine(FILE *f) noexcept {\n    static char clear_line_msg[1 + 79 + 1 + 1];\n    if (!clear_line_msg[0]) {\n        char *msg = clear_line_msg;\n        msg[0] = '\\r';\n        memset(msg + 1, ' ', 79);\n        msg[80] = '\\r';\n        msg[81] = 0;\n    }\n\n    fflush(stdout);\n    fflush(stderr);\n    if (f == nullptr)\n        f = stdout;\n    con_fprintf(f, \"%s\", clear_line_msg); // NOLINT(clang-analyzer-unix.Stream)\n    fflush(f);\n    printSetNl(0);\n}\n\nstatic void pr_print(bool c, const char *msg) noexcept {\n    if (c && !opt->to_stdout)\n        con_fprintf(stderr, \"%s\", msg);\n    else\n        fprintf(stderr, \"%s\", msg);\n}\n\nstatic void pr_error(const char *iname, const char *msg, bool is_warning) noexcept {\n    fflush(stdout);\n    fflush(stderr);\n    char buf[1024];\n    buf[0] = 0;\n    if (pr_need_nl == 2)\n        printClearLine(stdout);\n    else if (pr_need_nl) {\n        buf[0] = '\\n';\n        buf[1] = 0;\n        printSetNl(0);\n    }\n\n    // This hack is needed, otherwise error messages may get lost\n    // when the cursor is not yet at the bottom of the screen.\n    // At least I can use some colors then...\n    bool c = acc_isatty(STDERR_FILENO) ? 1 : 0;\n\n    int fg = con_fg(stderr, FG_BRTRED);\n    upx_safe_snprintf(buf + strlen(buf), sizeof(buf) - strlen(buf), \"%s: \", progname);\n    pr_print(c, buf);\n    //(void)con_fg(stderr,FG_RED);\n    upx_safe_snprintf(buf, sizeof(buf), \"%s: \", iname);\n    pr_print(c, buf);\n    //(void)con_fg(stderr,FG_BRTRED);\n    pr_print(c, msg);\n    pr_print(c, \"\\n\");\n    fflush(stdout);\n    fflush(stderr);\n    fg = con_fg(stderr, fg);\n\n    UNUSED(is_warning);\n    UNUSED(fg);\n}\n\nvoid printErr(const char *iname, const Throwable &e) noexcept {\n    char buf[1024];\n    size_t l;\n\n    upx_safe_snprintf(buf, sizeof(buf), \"%s\", prettyExceptionName(typeid(e).name()));\n    l = strlen(buf);\n    if (l < sizeof(buf) && e.getMsg())\n        upx_safe_snprintf(buf + l, sizeof(buf) - l, \": %s\", e.getMsg());\n    l = strlen(buf);\n    if (l < sizeof(buf) && e.getErrno()) {\n        upx_safe_snprintf(buf + l, sizeof(buf) - l, \": %s\", strerror(e.getErrno()));\n#if 1\n        // some compilers (e.g. Borland C++) put a trailing '\\n'\n        // into the strerror() result\n        l = strlen(buf);\n        while (l-- > 0 && (buf[l] == '\\n' || buf[l] == ' '))\n            buf[l] = 0;\n#endif\n    }\n    pr_error(iname, buf, e.isWarning());\n}\n\nvoid printErr(const char *iname, const char *format, ...) noexcept {\n    va_list args;\n    char buf[1024];\n\n    va_start(args, format);\n    upx_safe_vsnprintf(buf, sizeof(buf), format, args);\n    va_end(args);\n\n    pr_error(iname, buf, false);\n}\n\nvoid printWarn(const char *iname, const char *format, ...) noexcept {\n    va_list args;\n    char buf[1024];\n\n    va_start(args, format);\n    upx_safe_vsnprintf(buf, sizeof(buf), format, args);\n    va_end(args);\n\n    pr_error(iname, buf, true);\n}\n\nvoid printUnhandledException(const char *iname, const std::exception *e) noexcept {\n    if (e != nullptr)\n        printErr(iname, \"unhandled exception: %s\\n\", prettyExceptionName(e->what()));\n    else\n        printErr(iname, \"internal error: unhandled exception!\\n\");\n    if (opt->cmd != CMD_COMPRESS) {\n        printErr(iname, \"  this file has possibly been modified/hacked; take care!\\n\");\n    }\n}\n\n/*************************************************************************\n// info\n**************************************************************************/\n\nstatic int info_header = 0;\n\nstatic void info_print(const char *msg) {\n    if (opt->info_mode <= 0)\n        return;\n    FILE *f = opt->to_stdout ? stderr : stdout;\n    if (pr_need_nl) {\n        printClearLine(f);\n        con_fprintf(f, \"%s\\n\", msg);\n    } else if (pr_need_nl)\n        con_fprintf(f, \"\\n%s\\n\", msg);\n    else\n        con_fprintf(f, \"%s\\n\", msg);\n    fflush(f);\n    printSetNl(0);\n}\n\nvoid infoHeader() { info_header = 0; }\n\nvoid infoHeader(const char *format, ...) {\n    if (opt->info_mode <= 0)\n        return;\n    va_list args;\n    char buf[1024];\n    va_start(args, format);\n    upx_safe_vsnprintf(buf, sizeof(buf), format, args);\n    va_end(args);\n    info_print(buf);\n    info_header = 1;\n}\n\nvoid info(const char *format, ...) {\n    if (opt->info_mode <= 0)\n        return;\n    va_list args;\n    char buf[1024];\n    const int n = 4 * info_header;\n    memset(buf, ' ', n);\n    va_start(args, format);\n    upx_safe_vsnprintf(buf + n, sizeof(buf) - n, format, args);\n    va_end(args);\n    info_print(buf);\n}\n\nvoid infoWarning(const char *format, ...) {\n    if (opt->info_mode <= 0)\n        return;\n    va_list args;\n    char buf[1024];\n    va_start(args, format);\n    upx_safe_vsnprintf(buf, sizeof(buf), format, args);\n    va_end(args);\n    info(\"[WARNING] %s\\n\", buf);\n}\n\nvoid infoWriting(const char *what, upx_int64_t size) {\n    if (opt->info_mode <= 0)\n        return;\n    info(\"Writing %s: %lld bytes\", what, size);\n}\n\n/* vim:set ts=4 sw=4 et: */\n","size_bytes":6478},"src/options.cpp":{"content":"/* options.cpp --\n\n   This file is part of the Resize executable compressor.\n\n   Copyright (C) 2025 WHO-AM-I-404\n   Based on UPX - Ultimate Packer for eXecutables\n   Copyright (C) 1996-2025 Markus Franz Xaver Johannes Oberhumer\n   Copyright (C) 1996-2025 Laszlo Molnar\n   All Rights Reserved.\n\n   Resize and the UCL library are free software; you can redistribute them\n   and/or modify them under the terms of the GNU General Public License as\n   published by the Free Software Foundation; either version 2 of\n   the License, or (at your option) any later version.\n\n   This program is distributed in the hope that it will be useful,\n   but WITHOUT ANY WARRANTY; without even the implied warranty of\n   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n   GNU General Public License for more details.\n\n   You should have received a copy of the GNU General Public License\n   along with this program; see the file COPYING.\n   If not, write to the Free Software Foundation, Inc.,\n   59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.\n\n   WHO-AM-I-404 <who-am-i-404@proton.me>\n   Based on original work by:\n   Markus F.X.J. Oberhumer <markus@oberhumer.com>\n   Laszlo Molnar <ezerotven+github@gmail.com>\n */\n\n#include \"conf.h\"\n\nstatic Options global_options;\n// also see class PackMaster for per-file local options\nOptions *opt = &global_options;\n\n#if WITH_THREADS\nstd::mutex opt_lock_mutex; // for locking \"opt\"\n#endif\n\n/*************************************************************************\n// reset\n**************************************************************************/\n\nvoid Options::reset() noexcept {\n#define opt ERROR_DO_NOT_USE_opt // self-protect against using the wrong variable\n    Options *const o = this;\n    mem_clear(o);\n    o->crp.reset();\n\n    o->cmd = CMD_NONE;\n    o->method = M_NONE;\n    o->level = -1;\n    o->filter = FT_NONE;\n\n    o->backup = -1;\n    o->overlay = -1;\n    o->preserve_mode = true;\n    o->preserve_ownership = true;\n    o->preserve_timestamp = true;\n    o->verbose = 2;\n\n    o->console = CON_FILE;\n#if (ACC_OS_DOS32) && defined(__DJGPP__)\n    o->console = CON_INIT;\n#elif (USE_SCREEN_WIN32)\n    o->console = CON_INIT;\n#elif 1 && defined(__linux__)\n    o->console = CON_INIT;\n#endif\n    // support NO_COLOR, see https://no-color.org/\n    // \"... when present and not an empty string (regardless of its value)\"\n    const char *e = upx_getenv(\"NO_COLOR\");\n    if (e && e[0])\n        o->console = CON_FILE;\n\n    // options for various executable formats\n\n    o->o_unix.osabi0 = 3; // 3 == ELFOSABI_LINUX\n\n    o->win32_pe.compress_exports = 1;\n    o->win32_pe.compress_icons = 2;\n    o->win32_pe.compress_resources = -1;\n    for (size_t i = 0; i < TABLESIZE(o->win32_pe.compress_rt); i++)\n        o->win32_pe.compress_rt[i] = -1;\n    o->win32_pe.compress_rt[24] = false; // 24 == RT_MANIFEST\n    o->win32_pe.strip_relocs = -1;\n    o->win32_pe.keep_resource = \"\";\n#undef opt\n}\n\n/*************************************************************************\n// doctest checks\n**************************************************************************/\n\nTEST_CASE(\"Options::reset\") {\n#define opt ERROR_DO_NOT_USE_opt // self-protect against using the wrong variable\n    COMPILE_TIME_ASSERT(std::is_standard_layout<Options>::value)\n    COMPILE_TIME_ASSERT(std::is_nothrow_default_constructible<Options>::value)\n    COMPILE_TIME_ASSERT(std::is_trivially_copyable<Options>::value)\n\n    Options local_options;\n    Options *const o = &local_options;\n    o->reset();\n    CHECK(o->o_unix.osabi0 == 3);\n    static_assert(TABLESIZE(o->win32_pe.compress_rt) == 25); // 25 == RT_LAST\n    CHECK(o->win32_pe.compress_exports);\n    CHECK(o->win32_pe.compress_icons);\n    CHECK(o->win32_pe.strip_relocs);\n    // issue 728\n    CHECK(o->win32_pe.compress_resources);\n    for (size_t i = 0; i < 24; i++)\n        CHECK(o->win32_pe.compress_rt[i]);\n    CHECK(!o->win32_pe.compress_rt[24]); // 24 == RT_MANIFEST\n#undef opt\n}\n\ntemplate <size_t N>\nstatic inline void test_options(const char *(&a)[N]) {\n    (void) main_get_options((int) (N - 1), ACC_UNCONST_CAST(char **, a));\n}\n\nTEST_CASE(\"getopt\") {\n#if WITH_THREADS\n    std::lock_guard<std::mutex> lock(opt_lock_mutex);\n#endif\n    Options *const saved_opt = opt;\n    Options local_options;\n    opt = &local_options;\n    opt->reset();\n    opt->debug.getopt_throw_instead_of_exit = true;\n    static const char a0[] = \"<argv0>\";\n\n    SUBCASE(\"issue 587\") {\n        const char *a[] = {a0, \"--brute\", \"--lzma\", nullptr};\n        test_options(a);\n        CHECK(opt->all_methods);\n        CHECK(opt->all_methods_use_lzma == 1);\n    }\n    SUBCASE(\"issue 587\") {\n        const char *a[] = {a0, \"--lzma\", \"--brute\", nullptr};\n        test_options(a);\n        CHECK(opt->all_methods);\n        CHECK(opt->all_methods_use_lzma == 1);\n    }\n    SUBCASE(\"issue 587\") {\n        const char *a[] = {a0, \"--brute\", \"--no-lzma\", nullptr};\n        test_options(a);\n        CHECK(opt->all_methods);\n        CHECK(opt->all_methods_use_lzma == -1);\n    }\n    SUBCASE(\"issue 587\") {\n        const char *a[] = {a0, \"--no-lzma\", \"--brute\", nullptr};\n        test_options(a);\n        CHECK(opt->all_methods);\n        CHECK(opt->all_methods_use_lzma == -1);\n    }\n    SUBCASE(\"issue 587\") {\n        const char *a[] = {a0, \"--no-lzma\", \"--lzma\", nullptr};\n        test_options(a);\n        CHECK(!opt->all_methods);\n        CHECK(opt->all_methods_use_lzma == 1);\n        CHECK(opt->method == M_LZMA);\n    }\n    SUBCASE(\"issue 587\") {\n        const char *a[] = {a0, \"--no-lzma\", \"--lzma\", \"--brute\", nullptr};\n        test_options(a);\n        CHECK(opt->all_methods);\n        CHECK(opt->all_methods_use_lzma == 1);\n        CHECK(opt->method == -1);\n    }\n    SUBCASE(\"issue 587\") {\n        const char *a[] = {a0, \"--lzma\", \"--no-lzma\", nullptr};\n        test_options(a);\n        CHECK(!opt->all_methods);\n        CHECK(opt->all_methods_use_lzma == -1);\n        CHECK(opt->method == -1);\n    }\n    SUBCASE(\"issue 587\") {\n        const char *a[] = {a0, \"--lzma\", \"--no-lzma\", \"--brute\", nullptr};\n        test_options(a);\n        CHECK(opt->all_methods);\n        CHECK(opt->all_methods_use_lzma == -1);\n        CHECK(opt->method == -1);\n    }\n\n    opt = saved_opt;\n}\n\n/* vim:set ts=4 sw=4 et: */\n","size_bytes":6237},"src/p_com.cpp":{"content":"/* p_com.cpp -- dos/com executable format\n\n   This file is part of the Resize executable compressor.\n\n   Copyright (C) 2025 WHO-AM-I-404\n   Based on UPX - Ultimate Packer for eXecutables\n   Copyright (C) 1996-2025 Markus Franz Xaver Johannes Oberhumer\n   Copyright (C) 1996-2025 Laszlo Molnar\n   All Rights Reserved.\n\n   Resize and the UCL library are free software; you can redistribute them\n   and/or modify them under the terms of the GNU General Public License as\n   published by the Free Software Foundation; either version 2 of\n   the License, or (at your option) any later version.\n\n   This program is distributed in the hope that it will be useful,\n   but WITHOUT ANY WARRANTY; without even the implied warranty of\n   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n   GNU General Public License for more details.\n\n   You should have received a copy of the GNU General Public License\n   along with this program; see the file COPYING.\n   If not, write to the Free Software Foundation, Inc.,\n   59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.\n\n   WHO-AM-I-404 <who-am-i-404@proton.me>\n   Based on original work by:\n   Markus F.X.J. Oberhumer <markus@oberhumer.com>\n   Laszlo Molnar <ezerotven+github@gmail.com>\n */\n\n#include \"conf.h\"\n#include \"file.h\"\n#include \"filter.h\"\n#include \"packer.h\"\n#include \"p_com.h\"\n#include \"linker.h\"\n\nstatic const CLANG_FORMAT_DUMMY_STATEMENT\n#include \"stub/i086-dos16.com.h\"\n\n/*************************************************************************\n//\n**************************************************************************/\n\nLinker *PackCom::newLinker() const { return new ElfLinkerX86(); }\n\nconst int *PackCom::getCompressionMethods(int method, int level) const {\n    static const int m_nrv2b[] = {M_NRV2B_LE16, M_END};\n    UNUSED(method);\n    UNUSED(level);\n    return m_nrv2b;\n}\n\nconst int *PackCom::getFilters() const {\n    // see class FilterImpl\n    static const int filters[] = {0x06, 0x03, 0x04, 0x01, 0x05, 0x02, FT_END};\n    return filters;\n}\n\n/*************************************************************************\n//\n**************************************************************************/\n\ntribool PackCom::canPack() {\n    byte buf[128];\n\n    fi->readx(buf, sizeof(buf));\n    if (memcmp(buf, \"MZ\", 2) == 0 || memcmp(buf, \"ZM\", 2) == 0) // .exe\n        return false;\n    if (memcmp(buf, \"\\xff\\xff\\xff\\xff\", 4) == 0) // .sys\n        return false;\n    if (!fn_has_ext(fi->getName(), \"com\")) // query file name\n        return false;\n    checkAlreadyPacked(buf, sizeof(buf));\n    if (file_size < 1024)\n        throwCantPack(\"file is too small for dos/com\");\n    if (file_size > 0xFF00)\n        throwCantPack(\"file is too large for dos/com\");\n    return true;\n}\n\n/*************************************************************************\n//\n**************************************************************************/\n\nvoid PackCom::addFilter16(int filter_id) {\n    assert(filter_id > 0);\n    assert(isValidFilter(filter_id));\n\n    if (filter_id % 3 == 0) {\n        // clang-format off\n        addLoader(\"CALLTR16\",\n                  filter_id < 4 ? \"CT16SUB0\" : \"\",\n                  filter_id < 4 ? \"\" : (opt->cpu_x86 == opt->CPU_8086 ? \"CT16I086\" : \"CT16I286,CT16SUB0\"),\n                  \"CALLTRI2\",\n                  getFormat() == UPX_F_DOS_COM ? \"CORETURN\" : \"\");\n        // clang-format on\n    } else {\n        // clang-format off\n        addLoader(filter_id % 3 == 1 ? \"CT16E800\" : \"CT16E900\",\n                 \"CALLTRI5\",\n                 getFormat() == UPX_F_DOS_COM ? \"CT16JEND\" : \"CT16JUL2\",\n                 filter_id < 4 ? \"CT16SUB1\" : \"\",\n                 filter_id < 4 ? \"\" : (opt->cpu_x86 == opt->CPU_8086 ? \"CT16I087\" : \"CT16I287,CT16SUB1\"),\n                 \"CALLTRI6\");\n        // clang-format on\n    }\n}\n\nvoid PackCom::buildLoader(const Filter *ft) {\n    initLoader(stub_i086_dos16_com, sizeof(stub_i086_dos16_com));\n    // clang-format off\n    addLoader(\"COMMAIN1\",\n              ph.first_offset_found == 1 ? \"COMSBBBP\" : \"\",\n              \"COMPSHDI\",\n              ft->id ? \"COMCALLT\" : \"\",\n              \"COMMAIN2,UPX1HEAD,COMCUTPO,NRV2B160\",\n              ft->id ? \"NRVDDONE\" : \"NRVDRETU\",\n              \"NRVDECO1\",\n              ph.max_offset_found <= 0xd00 ? \"NRVLED00\" : \"NRVGTD00\",\n              \"NRVDECO2\");\n    // clang-format on\n    if (ft->id) {\n        assert(ft->calls > 0);\n        addFilter16(ft->id);\n    }\n}\n\nvoid PackCom::patchLoader(OutputFile *fo, byte *loader, int lsize, unsigned calls) {\n    const int e_len = getLoaderSectionStart(\"COMCUTPO\");\n    const int d_len = lsize - e_len;\n    assert(e_len > 0 && e_len < 128);\n    assert(d_len > 0 && d_len < 256);\n\n    const unsigned upper_end = ph.u_len + ph.overlap_overhead + d_len + 0x100;\n    unsigned stacksize = 0x60;\n    if (upper_end + stacksize > 0xfffe)\n        stacksize = 0x56;\n    if (upper_end + stacksize > 0xfffe)\n        throwCantPack(\"file is too large for dos/com\");\n\n    linker->defineSymbol(\"calltrick_calls\", calls);\n    linker->defineSymbol(\"sp_limit\", upper_end + stacksize);\n    linker->defineSymbol(\"bytes_to_copy\", ph.c_len + lsize);\n    linker->defineSymbol(\"copy_source\", ph.c_len + lsize + 0x100);\n    linker->defineSymbol(\"copy_destination\", upper_end);\n    linker->defineSymbol(\"neg_e_len\", 0 - e_len);\n    linker->defineSymbol(\"NRV2B160\", ph.u_len + ph.overlap_overhead);\n\n    relocateLoader();\n    loader = getLoader();\n\n    // some day we could use the relocation stuff for patchPackHeader too..\n    patchPackHeader(loader, e_len);\n    // write loader + compressed file\n    fo->write(loader, e_len);         // entry\n    fo->write(obuf, ph.c_len);        // compressed\n    fo->write(loader + e_len, d_len); // decompressor\n    NO_printf(\"%-13s: entry        : %8u bytes\\n\", getName(), e_len);\n    NO_printf(\"%-13s: compressed   : %8u bytes\\n\", getName(), ph.c_len);\n    NO_printf(\"%-13s: decompressor : %8u bytes\\n\", getName(), d_len);\n}\n\n/*************************************************************************\n//\n**************************************************************************/\n\nvoid PackCom::pack(OutputFile *fo) {\n    // read file\n    ibuf.alloc(file_size);\n    obuf.allocForCompression(file_size);\n    fi->seek(0, SEEK_SET);\n    fi->readx(ibuf, file_size);\n\n    // prepare packheader\n    ph.u_len = file_size;\n    // prepare filter\n    Filter ft(ph.level);\n    ft.addvalue = getCallTrickOffset();\n    // compress\n    const unsigned overlap_range = ph.u_len < 0xFE00 - ft.addvalue ? 32 : 0;\n    compressWithFilters(&ft, overlap_range, NULL_cconf);\n\n    const int lsize = getLoaderSize();\n    MemBuffer loader(lsize);\n    memcpy(loader, getLoader(), lsize);\n\n    const unsigned calls = ft.id % 3 ? ft.lastcall - 2 * ft.calls : ft.calls;\n    patchLoader(fo, loader, lsize, calls);\n\n    // verify\n    verifyOverlappingDecompression();\n\n    // finally check the compression ratio\n    if (!checkFinalCompressionRatio(fo))\n        throwNotCompressible();\n}\n\n/*************************************************************************\n//\n**************************************************************************/\n\ntribool PackCom::canUnpack() {\n    if (!readPackHeader(128)) // read \"ph\"\n        return false;\n    if (file_size_u <= ph.c_len)\n        return false;\n    return true;\n}\n\n/*************************************************************************\n//\n**************************************************************************/\n\nvoid PackCom::unpack(OutputFile *fo) {\n    ibuf.alloc(file_size);\n    obuf.allocForDecompression(ph.u_len);\n\n    // read whole file\n    fi->seek(0, SEEK_SET);\n    fi->readx(ibuf, file_size);\n\n    // get compressed data offset\n    unsigned e_len = ph.buf_offset + ph.getPackHeaderSize();\n    if (file_size_u <= e_len + ph.c_len)\n        throwCantUnpack(\"file damaged\");\n\n    // decompress\n    decompress(ibuf + e_len, obuf);\n\n    // unfilter\n    Filter ft(ph.level);\n    ft.init(ph.filter, getCallTrickOffset());\n    ft.unfilter(obuf, ph.u_len);\n\n    // write decompressed file\n    if (fo)\n        fo->write(obuf, ph.u_len);\n}\n\n/* vim:set ts=4 sw=4 et: */\n","size_bytes":8110},"src/p_djgpp2.cpp":{"content":"/* p_djgpp2.cpp --\n\n   This file is part of the Resize executable compressor.\n\n   Copyright (C) 2025 WHO-AM-I-404\n   Based on UPX - Ultimate Packer for eXecutables\n   Copyright (C) 1996-2025 Markus Franz Xaver Johannes Oberhumer\n   Copyright (C) 1996-2025 Laszlo Molnar\n   All Rights Reserved.\n\n   Resize and the UCL library are free software; you can redistribute them\n   and/or modify them under the terms of the GNU General Public License as\n   published by the Free Software Foundation; either version 2 of\n   the License, or (at your option) any later version.\n\n   This program is distributed in the hope that it will be useful,\n   but WITHOUT ANY WARRANTY; without even the implied warranty of\n   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n   GNU General Public License for more details.\n\n   You should have received a copy of the GNU General Public License\n   along with this program; see the file COPYING.\n   If not, write to the Free Software Foundation, Inc.,\n   59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.\n\n   WHO-AM-I-404 <who-am-i-404@proton.me>\n   Based on original work by:\n   Markus F.X.J. Oberhumer <markus@oberhumer.com>\n   Laszlo Molnar <ezerotven+github@gmail.com>\n */\n\n#include \"conf.h\"\n#include \"file.h\"\n#include \"filter.h\"\n#include \"packer.h\"\n#include \"p_djgpp2.h\"\n#include \"linker.h\"\n\nstatic const CLANG_FORMAT_DUMMY_STATEMENT\n#include \"stub/i386-dos32.djgpp2.h\"\nstatic const CLANG_FORMAT_DUMMY_STATEMENT\n#include \"stub/i386-dos32.djgpp2-stubify.h\"\n\n/*************************************************************************\n//\n**************************************************************************/\n\nPackDjgpp2::PackDjgpp2(InputFile *f) : super(f), coff_offset(0) {\n    bele = &N_BELE_RTP::le_policy;\n    COMPILE_TIME_ASSERT(sizeof(external_scnhdr_t) == 40)\n    COMPILE_TIME_ASSERT(sizeof(coff_header_t) == 0xa8)\n    COMPILE_TIME_ASSERT_ALIGNED1(external_scnhdr_t)\n    COMPILE_TIME_ASSERT_ALIGNED1(coff_header_t)\n    COMPILE_TIME_ASSERT(sizeof(stub_i386_dos32_djgpp2_stubify) == 2048)\n    COMPILE_TIME_ASSERT(STUB_I386_DOS32_DJGPP2_STUBIFY_ADLER32 == 0xbf689ba8)\n    COMPILE_TIME_ASSERT(STUB_I386_DOS32_DJGPP2_STUBIFY_CRC32 == 0x2ae982b2)\n    // printf(\"0x%08x\\n\", upx_adler32(stubify_stub, sizeof(stubify_stub)));\n    // assert(upx_adler32(stubify_stub, sizeof(stubify_stub)) == STUBIFY_STUB_ADLER32);\n}\n\nLinker *PackDjgpp2::newLinker() const { return new ElfLinkerX86; }\n\nconst int *PackDjgpp2::getCompressionMethods(int method, int level) const {\n    return Packer::getDefaultCompressionMethods_le32(method, level);\n}\n\nconst int *PackDjgpp2::getFilters() const {\n    static const int filters[] = {0x26, 0x24,           0x49, 0x46, 0x16, 0x13,  0x14,\n                                  0x11, FT_ULTRA_BRUTE, 0x25, 0x15, 0x12, FT_END};\n    return filters;\n}\n\nunsigned PackDjgpp2::findOverlapOverhead(const byte *buf, const byte *tbuf, unsigned range,\n                                         unsigned upper_limit) const {\n    unsigned o = super::findOverlapOverhead(buf, tbuf, range, upper_limit);\n    o = (o + 0x3ff) & ~0x1ff;\n    return o;\n}\n\nvoid PackDjgpp2::buildLoader(const Filter *ft) {\n    // prepare loader\n    initLoader(stub_i386_dos32_djgpp2, sizeof(stub_i386_dos32_djgpp2));\n    addLoader(\"IDENTSTR,DJ2MAIN1\", ft->id ? \"DJCALLT1\" : \"\",\n              ph.first_offset_found == 1 ? \"DJ2MAIN2\" : \"\",\n              M_IS_LZMA(ph.method) ? \"LZMA_INIT_STACK\" : \"\", getDecompressorSections(),\n              M_IS_LZMA(ph.method) ? \"LZMA_DONE_STACK\" : \"\", \"DJ2BSS00\");\n    if (ft->id) {\n        assert(ft->calls > 0);\n        addLoader(\"DJCALLT2\");\n        addFilter32(ft->id);\n    }\n    addLoader(\"DJRETURN,+40C,UPX1HEAD\");\n}\n\n/*************************************************************************\n// util\n**************************************************************************/\n\nvoid PackDjgpp2::handleStub(OutputFile *fo) {\n    if (fo && !opt->djgpp2_coff.coff) {\n        if (coff_offset > 0) {\n            // copy stub from exe\n            Packer::handleStub(fi, fo, coff_offset);\n        } else {\n            // \"stubify\" stub\n            info(\"Adding stub: %zd bytes\", sizeof(stub_i386_dos32_djgpp2_stubify));\n            fo->write(stub_i386_dos32_djgpp2_stubify, sizeof(stub_i386_dos32_djgpp2_stubify));\n        }\n    }\n}\n\nstatic bool is_dlm(InputFile *fi, unsigned coff_offset) {\n    byte buf[4];\n    unsigned off;\n\n    try {\n        fi->seek(coff_offset, SEEK_SET);\n        fi->readx(buf, 4);\n        off = get_le32(buf);\n        if (off > coff_offset + 4)\n            return false;\n        fi->seek(off, SEEK_SET);\n        fi->readx(buf, 4);\n        if (memcmp(buf, \"DLMF\", 4) == 0)\n            return true;\n    } catch (const IOException &) {\n    }\n    return false;\n}\n\nstatic void handle_allegropak(InputFile *fi, OutputFile *fo) {\n    byte b[8];\n    int pfsize = 0;\n\n    try {\n        fi->seek(-8, SEEK_END);\n        fi->readx(b, 8);\n        if (memcmp(b, \"slh+\", 4) != 0)\n            return;\n        pfsize = get_be32_signed(b + 4);\n        if (pfsize <= 8 || pfsize >= fi->st.st_size)\n            return;\n        fi->seek(-pfsize, SEEK_END);\n    } catch (const IOException &) {\n        return;\n    }\n    MemBuffer buf(0x4000);\n    while (pfsize > 0) {\n        const int len = UPX_MIN(pfsize, (int) buf.getSize());\n        fi->readx(buf, len);\n        fo->write(buf, len);\n        pfsize -= len;\n    }\n}\n\nint PackDjgpp2::readFileHeader() {\n    dos_header_t dos_hdr;\n\n    fi->seek(0, SEEK_SET);\n    fi->readx(&dos_hdr, sizeof(dos_hdr));\n    if (get_le16(&dos_hdr.e_magic) == 0x5a4d) { // MZ exe signature, stubbed?\n        byte magic[8];\n        fi->seek(16 * get_le16(&dos_hdr.e_cparhdr), SEEK_SET);\n        fi->readx(magic, 8);\n        if (memcmp(\"go32stub\", magic, 8) != 0)\n            return 0; // not V2 image\n    }\n    coff_offset = 512 * get_le16(&dos_hdr.e_cp);\n    if (get_le16(&dos_hdr.e_cblp) != 0)\n        coff_offset += get_le16(&dos_hdr.e_cblp) - 512;\n    fi->seek(coff_offset, SEEK_SET);\n    if (fi->read(&coff_hdr, sizeof(coff_hdr)) != sizeof(coff_hdr))\n        throwCantPack(\"skipping djgpp symlink\");\n    if (coff_hdr.f_magic != 0x014c) // I386MAGIC\n        return 0;\n    if ((coff_hdr.f_flags & 2) == 0) // F_EXEC - COFF executable\n        return 0;\n    if (coff_hdr.a_magic != 0413) // ZMAGIC - demand load format\n        return 0;\n    // FIXME: check for Linux etc.\n\n    text = &coff_hdr.sh[0];\n    data = &coff_hdr.sh[1];\n    bss = &coff_hdr.sh[2];\n    return UPX_F_DJGPP2_COFF;\n}\n\n// \"strip\" debug info\nvoid PackDjgpp2::stripDebug() {\n    coff_hdr.f_symptr = 0;\n    coff_hdr.f_nsyms = 0;\n    coff_hdr.f_flags = 0x10f; // 0x100: \"32 bit machine: LSB first\"\n    memset(text->misc, 0, 12);\n}\n\n/*************************************************************************\n//\n**************************************************************************/\n\ntribool PackDjgpp2::canPack() {\n    if (!readFileHeader())\n        return false;\n    if (is_dlm(fi, coff_offset))\n        throwCantPack(\"can't handle DLM\");\n\n    if (opt->force == 0)\n        if (text->size != coff_hdr.a_tsize || data->size != coff_hdr.a_dsize)\n            throwAlreadyPacked();\n\n    // Check for gap in vaddr between text and data, or between data and bss.\n    if (text->vaddr + text->size != data->vaddr || data->vaddr + data->size != bss->vaddr) {\n        // \"Non-standard\" layout of text,data,bss: not contiguous in vaddr.\n        // But should be OK if no overlap.\n\n        // Check for no overlap of text and data:\n        // neither by vaddr, nor by image data\n        if (text->vaddr + text->size <= data->vaddr &&\n            data->scnptr - text->scnptr <= data->vaddr - text->vaddr) {\n            // Examples: Quake1; FreePascal(DOS) install.exe (github-issue45)\n            // Hack: enlarge text image data to eliminate the gap.\n            text->size = coff_hdr.a_tsize = data->scnptr - text->scnptr;\n            // But complain if this causes overlap in vaddr\n            if (text->vaddr + text->size > data->vaddr)\n                throwAlreadyPacked();\n        } else\n            throwAlreadyPacked();\n    }\n    // FIXME: check for Linux etc.\n    return true;\n}\n\n/*************************************************************************\n//\n**************************************************************************/\n\nvoid PackDjgpp2::pack(OutputFile *fo) {\n    handleStub(fo);\n\n    // patch coff header #1: \"strip\" debug info\n    stripDebug();\n\n    // read file\n    const unsigned size = text->size + data->size;\n    const unsigned tpos = text->scnptr;\n    const unsigned hdrsize = 20 + 28 + mem_size(sizeof(external_scnhdr_t), coff_hdr.f_nscns);\n    const unsigned usize = size + hdrsize;\n    if (hdrsize < sizeof(coff_hdr) || hdrsize > tpos)\n        throwCantPack(\"coff header error\");\n\n    ibuf.alloc(usize);\n    obuf.allocForCompression(usize);\n\n    fi->seek(coff_offset, SEEK_SET);\n    fi->readx(ibuf, hdrsize); // orig. coff header\n    fi->seek(coff_offset + tpos, SEEK_SET);\n    fi->readx(ibuf + hdrsize, size);\n\n    // prepare packheader\n    ph.u_len = usize;\n    // prepare filter\n    Filter ft(ph.level);\n    ft.buf_len = usize - data->size;\n    ft.addvalue = text->vaddr - hdrsize;\n    // compress\n    upx_compress_config_t cconf;\n    cconf.reset();\n    // limit stack size needed for runtime decompression\n    cconf.conf_lzma.max_num_probs = 1846 + (768 << 4); // ushort: ~28 KiB stack\n    compressWithFilters(&ft, 512, &cconf);\n\n    // patch coff header #2\n    const unsigned lsize = getLoaderSize();\n    assert(lsize % 4 == 0);\n    text->size = lsize;    // new size of .text\n    data->size = ph.c_len; // new size of .data\n\n    unsigned stack = 1024 + ph.overlap_overhead + getDecompressorWrkmemSize();\n    stack = ALIGN_UP(stack, 16u);\n    if (bss->size < stack) // give it a .bss\n        bss->size = stack;\n\n    text->scnptr = sizeof(coff_hdr);\n    data->scnptr = text->scnptr + text->size;\n    data->vaddr = bss->vaddr + ((data->scnptr + data->size) & 0x1ff) - data->size +\n                  ph.overlap_overhead - 0x200;\n    coff_hdr.f_nscns = 3;\n\n    linker->defineSymbol(\"original_entry\", coff_hdr.a_entry);\n    linker->defineSymbol(\"length_of_bss\", ph.overlap_overhead / 4);\n    defineDecompressorSymbols();\n    // Just need no overlap; non-contiguous (gap length > 0)) is OK\n    assert(bss->vaddr >= ((size + 0x1ff) & ~0x1ff) + (text->vaddr & ~0x1ff));\n    linker->defineSymbol(\"stack_for_lzma\", bss->vaddr + bss->size);\n    linker->defineSymbol(\"start_of_uncompressed\", text->vaddr - hdrsize);\n    linker->defineSymbol(\"start_of_compressed\", data->vaddr);\n    defineFilterSymbols(&ft);\n\n    // we should not overwrite our decompressor during unpacking\n    // the original coff header (which is put just before the\n    // beginning of the original .text section)\n    assert(text->vaddr > hdrsize + lsize + sizeof(coff_hdr));\n\n    // patch coff header #3\n    text->vaddr = sizeof(coff_hdr);\n    coff_hdr.a_entry = sizeof(coff_hdr) + getLoaderSection(\"DJ2MAIN1\");\n    bss->vaddr += ph.overlap_overhead;\n    bss->size -= ph.overlap_overhead;\n\n    // because of a feature (bug?) in stub.asm we need some padding\n    memcpy(obuf + data->size, \"UPX\", 3);\n    data->size = ALIGN_UP(data->size, 4u);\n\n    linker->defineSymbol(\"DJ2MAIN1\", coff_hdr.a_entry);\n    relocateLoader();\n\n    // prepare loader\n    MemBuffer loader(lsize);\n    memcpy(loader, getLoader(), lsize);\n    patchPackHeader(loader, lsize);\n\n    // write coff header, loader and compressed file\n    fo->write(&coff_hdr, sizeof(coff_hdr));\n    fo->write(loader, lsize);\n    if (opt->debug.dump_stub_loader)\n        OutputFile::dump(opt->debug.dump_stub_loader, loader, lsize);\n    fo->write(obuf, data->size);\n#if 0\n    printf(\"%-13s: coff hdr   : %8d bytes\\n\", getName(), (int) sizeof(coff_hdr));\n    printf(\"%-13s: loader     : %8d bytes\\n\", getName(), (int) lsize);\n    printf(\"%-13s: compressed : %8d bytes\\n\", getName(), (int) data->size);\n#endif\n\n    // verify\n    verifyOverlappingDecompression();\n\n    // handle overlay\n    // FIXME: only Allegro pakfiles are supported\n    handle_allegropak(fi, fo);\n\n    // finally check the compression ratio\n    if (!checkFinalCompressionRatio(fo))\n        throwNotCompressible();\n}\n\n/*************************************************************************\n//\n**************************************************************************/\n\ntribool PackDjgpp2::canUnpack() {\n    if (!readFileHeader())\n        return false;\n    if (is_dlm(fi, coff_offset))\n        throwCantUnpack(\"can't handle DLM\");\n    fi->seek(coff_offset, SEEK_SET);\n    return readPackHeader(4096) ? 1 : -1;\n}\n\n/*************************************************************************\n//\n**************************************************************************/\n\nvoid PackDjgpp2::unpack(OutputFile *fo) {\n    handleStub(fo);\n\n    ibuf.alloc(ph.c_len);\n    obuf.allocForDecompression(ph.u_len);\n\n    fi->seek(coff_offset + ph.buf_offset + ph.getPackHeaderSize(), SEEK_SET);\n    fi->readx(ibuf, ph.c_len);\n\n    // decompress\n    decompress(ibuf, obuf);\n\n    coff_header_t *const chdr = (coff_header_t *) raw_bytes(obuf, sizeof(coff_header_t));\n    text = &chdr->sh[0];\n    data = &chdr->sh[1];\n    bss = &chdr->sh[2];\n\n    const unsigned hdrsize = 20 + 28 + mem_size(sizeof(external_scnhdr_t), chdr->f_nscns);\n    if (hdrsize < sizeof(coff_hdr) || hdrsize > text->scnptr || hdrsize > ph.u_len)\n        throwCantUnpack(\"coff header error\");\n\n    unsigned addvalue;\n    if (ph.version >= 14)\n        addvalue = text->vaddr - hdrsize;\n    else\n        addvalue = text->vaddr & ~0x1ff; // for old versions\n\n    // unfilter\n    if (ph.filter) {\n        Filter ft(ph.level);\n        ft.init(ph.filter, addvalue);\n        ft.cto = (byte) ph.filter_cto;\n        if (ph.version < 11) {\n            byte ctobuf[4];\n            fi->readx(ctobuf, 4);\n            ft.cto = (byte) (get_le32(ctobuf) >> 24);\n        }\n        ft.unfilter(obuf, ph.u_len - data->size);\n    }\n\n    if (ph.version < 14) {\n        // fixup for the aligning bug in strip 2.8+\n        text->scnptr &= 0x1ff;\n        data->scnptr = text->scnptr + text->size;\n        // write decompressed file\n        if (fo)\n            fo->write(obuf, ph.u_len);\n    } else {\n        // write the header\n        // some padding might be required between the end\n        // of the header and the start of the .text section\n\n        const unsigned padding = text->scnptr - hdrsize;\n        ibuf.clear(0, padding);\n\n        if (fo) {\n            fo->write(obuf, hdrsize);\n            fo->write(ibuf, padding);\n            fo->write(obuf + hdrsize, ph.u_len - hdrsize);\n        }\n    }\n\n    if (fo)\n        handle_allegropak(fi, fo);\n}\n\n/* vim:set ts=4 sw=4 et: */\n","size_bytes":14686},"src/p_exe.cpp":{"content":"/* p_exe.cpp -- dos/exe executable format\n\n   This file is part of the Resize executable compressor.\n\n   Copyright (C) 2025 WHO-AM-I-404\n   Based on UPX - Ultimate Packer for eXecutables\n   Copyright (C) 1996-2025 Markus Franz Xaver Johannes Oberhumer\n   Copyright (C) 1996-2025 Laszlo Molnar\n   All Rights Reserved.\n\n   Resize and the UCL library are free software; you can redistribute them\n   and/or modify them under the terms of the GNU General Public License as\n   published by the Free Software Foundation; either version 2 of\n   the License, or (at your option) any later version.\n\n   This program is distributed in the hope that it will be useful,\n   but WITHOUT ANY WARRANTY; without even the implied warranty of\n   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n   GNU General Public License for more details.\n\n   You should have received a copy of the GNU General Public License\n   along with this program; see the file COPYING.\n   If not, write to the Free Software Foundation, Inc.,\n   59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.\n\n   WHO-AM-I-404 <who-am-i-404@proton.me>\n   Based on original work by:\n   Markus F.X.J. Oberhumer <markus@oberhumer.com>\n   Laszlo Molnar <ezerotven+github@gmail.com>\n */\n\n#include \"conf.h\"\n#include \"file.h\"\n#include \"filter.h\"\n#include \"packer.h\"\n#include \"p_exe.h\"\n#include \"linker.h\"\n\nstatic const CLANG_FORMAT_DUMMY_STATEMENT\n#include \"stub/i086-dos16.exe.h\"\n\n#define MAXMATCH     0x2000\n#define MAXRELOCSIZE (0x8000 - MAXMATCH)\n\n#define DI_LIMIT 0xff00 // see the assembly why\n\n/*************************************************************************\n//\n**************************************************************************/\n\nPackExe::PackExe(InputFile *f) : super(f) {\n    bele = &N_BELE_RTP::le_policy;\n    COMPILE_TIME_ASSERT(sizeof(exe_header_t) == 32)\n    COMPILE_TIME_ASSERT_ALIGNED1(exe_header_t)\n}\n\nLinker *PackExe::newLinker() const { return new ElfLinkerX86(); }\n\nconst int *PackExe::getCompressionMethods(int method, int level) const {\n    bool small = ih_imagesize <= 256 * 1024;\n    // disable lzma for \"--brute\" unless explicitly given \"--lzma\"\n    // (note that class PackMaster creates per-file local options)\n    if (opt->all_methods_use_lzma == 1 && !opt->method_lzma_seen)\n        opt->all_methods_use_lzma = 0;\n    return Packer::getDefaultCompressionMethods_8(method, level, small);\n}\n\nconst int *PackExe::getFilters() const { return nullptr; }\n\nint PackExe::fillExeHeader(struct exe_header_t *eh) const {\n#define oh (*eh)\n    // fill new exe header\n    int flag = 0;\n    if (!opt->dos_exe.no_reloc && !M_IS_LZMA(ph.method))\n        flag |= USEJUMP;\n    if (ih.relocs == 0)\n        flag |= NORELOC;\n\n    mem_clear(&oh);\n    oh.ident = 'M' + 'Z' * 256;\n    oh.headsize16 = 2;\n\n    unsigned minsp = 0x200;\n    if (M_IS_LZMA(ph.method))\n        minsp = stack_for_lzma;\n    minsp = ALIGN_UP(minsp, 16u);\n    assert(minsp < 0xff00);\n    if (oh.sp > minsp)\n        minsp = oh.sp;\n    if (minsp < 0xff00 - 2)\n        minsp = ALIGN_UP(minsp, 2u);\n    oh.sp = minsp;\n\n    unsigned destpara = (ph.u_len + ph.overlap_overhead - ph.c_len + 31) / 16;\n    oh.ss = ph.c_len / 16 + destpara;\n    if (ih.ss * 16 + ih.sp < 0x100000 && ih.ss > oh.ss && ih.sp > 0x200)\n        oh.ss = ih.ss;\n    if (oh.ss * 16 + 0x50 < ih.ss * 16 + ih.sp && oh.ss * 16 + 0x200 > ih.ss * 16 + ih.sp)\n        oh.ss += 0x20;\n\n    if (oh.ss != ih.ss)\n        flag |= SS;\n    if (oh.sp != ih.sp || M_IS_LZMA(ph.method))\n        flag |= SP;\n    return flag;\n#undef oh\n}\n\nvoid PackExe::addLoaderEpilogue(int flag) {\n    addLoader(\"EXEMAIN5\");\n    if (relocsize)\n        addLoader(ph.u_len <= DI_LIMIT || (ph.u_len & 0x7fff) >= relocsize ? \"EXENOADJ\"\n                                                                           : \"EXEADJUS\",\n                  \"EXERELO1\", has_9a ? \"EXEREL9A\" : \"\", \"EXERELO2\",\n                  ih_exesize > 0xFE00 ? \"EXEREBIG\" : \"\", \"EXERELO3\");\n    addLoader(\"EXEMAIN8\", device_driver ? \"DEVICEEND\" : \"\", (flag & SS) ? \"EXESTACK\" : \"\",\n              (flag & SP) ? \"EXESTASP\" : \"\", (flag & USEJUMP) ? \"EXEJUMPF\" : \"\");\n    if (!(flag & USEJUMP))\n        addLoader(ih.cs ? \"EXERCSPO\" : \"\", \"EXERETIP\");\n\n    linker->defineSymbol(\"original_cs\", ih.cs);\n    linker->defineSymbol(\"original_ip\", ih.ip);\n    linker->defineSymbol(\"original_sp\", ih.sp);\n    linker->defineSymbol(\"original_ss\", ih.ss);\n    linker->defineSymbol(\n        \"reloc_size\",\n        (ph.u_len <= DI_LIMIT || (ph.u_len & 0x7fff) >= relocsize ? 0 : MAXRELOCSIZE) - relocsize);\n}\n\nvoid PackExe::buildLoader(const Filter *) {\n    // get flag\n    exe_header_t dummy_oh;\n    int flag = fillExeHeader(&dummy_oh);\n\n    initLoader(stub_i086_dos16_exe, sizeof(stub_i086_dos16_exe));\n\n    if (M_IS_LZMA(ph.method)) {\n        addLoader(\"LZMA_DEC00\", opt->small ? \"LZMA_DEC10\" : \"LZMA_DEC20\", \"LZMA_DEC30\",\n                  use_clear_dirty_stack ? \"LZMA_DEC31\" : \"\", \"LZMA_DEC32\",\n                  ph.u_len > 0xffff ? \"LZMA_DEC33\" : \"\");\n\n        addLoaderEpilogue(flag);\n        defineDecompressorSymbols();\n        const unsigned lsize0 = getLoaderSize();\n\n        // Lzma decompression code starts at ss:0x10, and its size is\n        // lsize bytes. It also needs getDecompressorWrkmemSize() bytes\n        // during uncompression. It also uses some stack, so 0x100\n        // more bytes are allocated\n        stack_for_lzma = 0x10 + lsize0 + getDecompressorWrkmemSize() + 0x100;\n        stack_for_lzma = ALIGN_UP(stack_for_lzma, 16u);\n\n        unsigned clear_dirty_stack_low = 0x10 + lsize0;\n        clear_dirty_stack_low = ALIGN_UP(clear_dirty_stack_low, 2u);\n        if (use_clear_dirty_stack)\n            linker->defineSymbol(\"clear_dirty_stack_low\", clear_dirty_stack_low);\n\n        relocateLoader();\n        const unsigned lsize = getLoaderSize();\n        assert(lsize0 == lsize);\n        MemBuffer loader(lsize);\n        memcpy(loader, getLoader(), lsize);\n\n        MemBuffer compressed_lzma;\n        compressed_lzma.allocForCompression(lsize);\n        unsigned c_len_lzma = MemBuffer::getSizeForCompression(lsize);\n        int r = upx_compress(loader, lsize, compressed_lzma, &c_len_lzma, nullptr, M_NRV2B_LE16, 9,\n                             nullptr, nullptr);\n        assert(r == UPX_E_OK);\n        assert(c_len_lzma < lsize);\n\n        info(\"lzma+relocator code compressed: %u -> %u\", lsize, c_len_lzma);\n        // reinit the loader\n        initLoader(stub_i086_dos16_exe, sizeof(stub_i086_dos16_exe));\n        // prepare loader\n        if (device_driver)\n            addLoader(\"DEVICEENTRY,LZMADEVICE,DEVICEENTRY2\");\n\n        linker->addSection(\"COMPRESSED_LZMA\", compressed_lzma, c_len_lzma, 0);\n        addLoader(\"LZMAENTRY,NRV2B160,NRVDDONE,NRVDECO1,NRVGTD00,NRVDECO2\");\n\n    } else if (device_driver)\n        addLoader(\"DEVICEENTRY,DEVICEENTRY2\");\n\n    addLoader(\"EXEENTRY\", M_IS_LZMA(ph.method) && device_driver ? \"LONGSUB\" : \"SHORTSUB\",\n              \"JNCDOCOPY\", relocsize ? \"EXERELPU\" : \"\", \"EXEMAIN4\",\n              M_IS_LZMA(ph.method) ? \"\" : \"EXEMAIN4B\", \"EXEMAIN4C\",\n              M_IS_LZMA(ph.method) ? \"COMPRESSED_LZMA_START,COMPRESSED_LZMA\" : \"\",\n              \"+G5DXXXX,UPX1HEAD,EXECUTPO\");\n    if (ph.method == M_NRV2B_8)\n        addLoader(\"NRV2B16S\", // decompressor\n                  ph.u_len > DI_LIMIT ? \"N2B64K01\" : \"\", \"NRV2BEX1\",\n                  opt->cpu_x86 == opt->CPU_8086 ? \"N2BX8601\" : \"N2B28601\", \"NRV2BEX2\",\n                  opt->cpu_x86 == opt->CPU_8086 ? \"N2BX8602\" : \"N2B28602\", \"NRV2BEX3\",\n                  ph.c_len > 0xffff ? \"N2B64K02\" : \"\", \"NRV2BEX9\");\n    else if (ph.method == M_NRV2D_8)\n        addLoader(\"NRV2D16S\", ph.u_len > DI_LIMIT ? \"N2D64K01\" : \"\", \"NRV2DEX1\",\n                  opt->cpu_x86 == opt->CPU_8086 ? \"N2DX8601\" : \"N2D28601\", \"NRV2DEX2\",\n                  opt->cpu_x86 == opt->CPU_8086 ? \"N2DX8602\" : \"N2D28602\", \"NRV2DEX3\",\n                  ph.c_len > 0xffff ? \"N2D64K02\" : \"\", \"NRV2DEX9\");\n    else if (ph.method == M_NRV2E_8)\n        addLoader(\"NRV2E16S\", ph.u_len > DI_LIMIT ? \"N2E64K01\" : \"\", \"NRV2EEX1\",\n                  opt->cpu_x86 == opt->CPU_8086 ? \"N2EX8601\" : \"N2E28601\", \"NRV2EEX2\",\n                  opt->cpu_x86 == opt->CPU_8086 ? \"N2EX8602\" : \"N2E28602\", \"NRV2EEX3\",\n                  ph.c_len > 0xffff ? \"N2E64K02\" : \"\", \"NRV2EEX9\");\n    else if M_IS_LZMA (ph.method)\n        return;\n    else\n        throwInternalError(\"unknown compression method\");\n\n    addLoaderEpilogue(flag);\n}\n\n/*************************************************************************\n//\n**************************************************************************/\n\nint PackExe::readFileHeader() {\n    ih_exesize = ih_imagesize = ih_overlay = 0;\n    fi->readx(&ih, sizeof(ih));\n    if (ih.ident != 'M' + 'Z' * 256 && ih.ident != 'Z' + 'M' * 256)\n        return 0;\n    ih_exesize = ih.m512 + ih.p512 * 512 - (ih.m512 ? 512 : 0);\n    if (ih_exesize == 0)\n        ih_exesize = file_size;\n    ih_imagesize = ih_exesize - ih.headsize16 * 16;\n    ih_overlay = file_size - ih_exesize;\n    if (file_size_u < sizeof(ih) || ((ih.m512 | ih.p512) && ih.m512 + ih.p512 * 512u < sizeof(ih)))\n        throwCantPack(\"illegal exe header\");\n    if (ih_exesize > file_size_u || ih_imagesize < 4 || ih_imagesize > ih_exesize)\n        throwCantPack(\"exe header corrupted\");\n    NO_printf(\"dos/exe header: %d %d %d\\n\", ih_exesize, ih_imagesize, ih_overlay);\n    return UPX_F_DOS_EXE;\n}\n\ntribool PackExe::canPack() {\n    if (fn_has_ext(fi->getName(), \"sys\")) // dos/sys\n        return false;\n    if (!readFileHeader())\n        return false;\n    if (file_size < 1024 || ih_imagesize < 512)\n        throwCantPack(\"file is too small for dos/exe\");\n    fi->seek(0x3c, SEEK_SET);\n    LE32 offs;\n    fi->readx(&offs, sizeof(offs));\n    if (ih.relocoffs >= 0x40 && offs) {\n        if (opt->dos_exe.force_stub)\n            opt->overlay = opt->COPY_OVERLAY;\n        else\n            throwCantPack(\"dos/exe: can't pack new-exe\");\n    }\n    return true;\n}\n\n/*************************************************************************\n//\n**************************************************************************/\n\nstatic unsigned optimize_relocs(SPAN_S(byte) image, const unsigned image_size,\n                                SPAN_S(const byte) relocs, const unsigned relocnum,\n                                SPAN_S(byte) crel, bool *has_9a) {\n#if WITH_XSPAN >= 2\n    ptr_check_no_overlap(image.data(image_size), image_size, relocs.data(), relocs.size_bytes(),\n                         crel.data(), crel.size_bytes());\n#endif\n    if (opt->exact)\n        throwCantPackExact();\n\n    SPAN_S_VAR(byte, const crel_start, crel);\n    unsigned seg_high = 0;\n#if 0\n    unsigned seg_low = 0xffffffff;\n    unsigned off_low = 0xffffffff;\n    unsigned off_high = 0;\n    unsigned linear_low = 0xffffffff;\n    unsigned linear_high = 0;\n#endif\n\n    // pass 1 - find 0x9a bounds in image\n    for (unsigned i = 0; i < relocnum; i++) {\n        unsigned addr = get_le32(relocs + 4 * i);\n        if (addr >= image_size - 1)\n            throwCantPack(\"unexpected relocation 1\");\n        if (addr >= 3 && image[addr - 3] == 0x9a) {\n            unsigned seg = get_le16(image + addr);\n            if (seg > seg_high)\n                seg_high = seg;\n#if 0\n            if (seg < seg_low)\n                seg_low = seg;\n            unsigned off = get_le16(image + addr - 2);\n            if (off < off_low)\n                off_low = off;\n            if (off > off_high)\n                off_high = off;\n            unsigned l = (seg << 4) + off;\n            if (l < linear_low)\n                linear_low = l;\n            if (l > linear_high)\n                linear_high = l;\n#endif\n        }\n    }\n    // printf(\"%d %d\\n\", seg_low, seg_high);\n    // printf(\"%d %d\\n\", off_low, off_high);\n    // printf(\"%d %d\\n\", linear_low, linear_high);\n\n    // pass 2 - reloc\n\n    crel += 4; // to be filled in later\n\n    unsigned ones = 0;\n    unsigned es = 0;\n    for (unsigned i = 0; i < relocnum;) {\n        unsigned addr = get_le32(relocs + 4 * i);\n        unsigned di = addr & 0x0f;\n        set_le16(crel + 0, di);\n        set_le16(crel + 2, (addr >> 4) - es);\n        crel += 4;\n        es = addr >> 4;\n\n        for (++i; i < relocnum; i++) {\n            unsigned t;\n            addr = get_le32(relocs + 4 * i);\n            NO_printf(\"%x\\n\", es * 16 + di);\n            if ((addr - es * 16 > 0xfffe) || (i == relocnum - 1 && addr - es * 16 > 0xff00)) {\n                // segment change\n                t = 1 + (0xffff - di) / 254;\n                memset(crel, 1, t);\n                crel += t;\n                ones += t - 1; // -1 is used to help the assembly stuff\n                break;\n            }\n            unsigned offs = addr - es * 16;\n            if (offs >= 3 && image[es * 16 + offs - 3] == 0x9a && offs > di + 3) {\n                for (t = di; t < offs - 3; t++)\n                    if (image[es * 16 + t] == 0x9a && get_le16(image + es * 16 + t + 3) <= seg_high)\n                        break;\n                if (t == offs - 3) {\n                    // code 0: search for 0x9a\n                    *crel++ = 0;\n                    di = offs;\n                    *has_9a = true;\n                    continue;\n                }\n            }\n            t = offs - di;\n            if ((int) t < 2)\n                throwCantPack(\"unexpected relocation 2\");\n            while (t >= 256) {\n                // code 1: add 254, don't reloc\n                *crel++ = 1;\n                t -= 254;\n                ones++;\n            }\n            *crel++ = (byte) t;\n            di = offs;\n        }\n    }\n    *crel++ = 1;\n    ones++;\n    set_le16(crel_start, ones);\n    set_le16(crel_start + 2, seg_high);\n\n    // OutputFile::dump(\"x.rel\", crel_start, ptr_udiff_bytes(crel, crel_start));\n    return ptr_udiff_bytes(crel, crel_start);\n}\n\n/*************************************************************************\n//\n**************************************************************************/\n\nvoid PackExe::pack(OutputFile *fo) {\n    unsigned ic;\n\n    const unsigned relocnum = ih.relocs;\n    if (relocnum > MAXRELOCSIZE) // early check\n        throwCantPack(\"too many relocations\");\n    checkOverlay(ih_overlay);\n\n    // read image\n    // image + space for optimized relocs + safety/alignments\n    ibuf.alloc(ih_imagesize + 4 * relocnum + 1024);\n    fi->seek(ih.headsize16 * 16, SEEK_SET);\n    fi->readx(ibuf, ih_imagesize);\n\n    checkAlreadyPacked(ibuf, UPX_MIN(ih_imagesize, 127u));\n\n    device_driver = get_le32(ibuf) == 0xffffffffu;\n\n    // relocations\n    relocsize = 0;\n    has_9a = false;\n    if (relocnum) {\n        MemBuffer mb_relocs(4 * relocnum);\n        SPAN_S_VAR(byte, relocs, mb_relocs);\n        fi->seek(ih.relocoffs, SEEK_SET);\n        fi->readx(relocs, 4 * relocnum);\n\n        // dos/exe runs in real-mode, so convert to linear addresses\n        for (ic = 0; ic < relocnum; ic++) {\n            unsigned jc = get_le32(relocs + 4 * ic);\n            set_le32(relocs + 4 * ic, ((jc >> 16) * 16 + (jc & 0xffff)) & 0xfffff);\n        }\n        upx_qsort(raw_bytes(relocs, 4 * relocnum), relocnum, 4, le32_compare);\n\n        SPAN_S_VAR(byte, image, ibuf + 0, ih_imagesize);\n        SPAN_S_VAR(byte, crel, ibuf + ih_imagesize, ibuf);\n        relocsize = optimize_relocs(image, ih_imagesize, relocs, relocnum, crel, &has_9a);\n        set_le16(crel + relocsize, relocsize + 2);\n        relocsize += 2;\n        assert(relocsize >= 11);\n        if (relocsize > MAXRELOCSIZE) // optimize_relocs did not help\n            throwCantPack(\"too many relocations\");\n#if TESTING && 0\n        unsigned rout_len = MemBuffer::getSizeForCompression(relocsize);\n        MemBuffer rout(rout_len);\n        ucl_nrv2b_99_compress(raw_bytes(crel, relocsize), relocsize, rout, &rout_len, nullptr, 9,\n                              nullptr, nullptr);\n        printf(\"dos/exe reloc compress: %d -> %d\\n\", relocsize, rout_len);\n#endif\n    }\n\n    // prepare packheader\n    ph.u_len = ih_imagesize + relocsize;\n    obuf.allocForCompression(ph.u_len);\n    // prepare filter\n    Filter ft(ph.level);\n    // compress (max_match = 8192)\n    upx_compress_config_t cconf;\n    cconf.reset();\n    cconf.conf_ucl.max_match = MAXMATCH;\n    cconf.conf_lzma.max_num_probs = 1846 + (768 << 4); // ushort: ~28 KiB stack\n    compressWithFilters(&ft, 32, &cconf);\n\n    if (M_IS_NRV2B(ph.method) || M_IS_NRV2D(ph.method) || M_IS_NRV2E(ph.method))\n        if (ph.max_run_found + ph.max_match_found > 0x8000)\n            throwCantPack(\"decompressor limit exceeded, send a bugreport\");\n\n#if TESTING\n    if (opt->debug.debug_level) {\n        printf(\"image+relocs %d -> %d\\n\", ih_imagesize + relocsize, ph.c_len);\n        printf(\"offsets: %d - %d\\nmatches: %d - %d\\nruns: %d - %d\\n\", 0 /*ph.min_offset_found*/,\n               ph.max_offset_found, 0 /*ph.min_match_found*/, ph.max_match_found,\n               0 /*ph.min_run_found*/, ph.max_run_found);\n    }\n#endif\n\n    int flag = fillExeHeader(&oh);\n\n    const unsigned lsize = getLoaderSize();\n    MemBuffer loader(lsize);\n    memcpy(loader, getLoader(), lsize);\n    // OutputFile::dump(\"xxloader.dat\", loader, lsize);\n\n    // patch loader\n    const unsigned packedsize = ph.c_len;\n    const unsigned e_len = getLoaderSectionStart(\"EXECUTPO\");\n    const unsigned d_len = lsize - e_len;\n    assert((e_len & 15) == 0);\n\n    const unsigned copysize = (1 + packedsize + d_len) & ~1;\n    const unsigned firstcopy = copysize % 0x10000 ? copysize % 0x10000 : 0x10000;\n\n    // set oh.min & oh.max\n    ic = ih.min * 16 + ih_imagesize;\n    if (ic < oh.ss * 16u + oh.sp)\n        ic = oh.ss * 16u + oh.sp;\n    oh.min = (ic - (packedsize + lsize)) / 16;\n    ic = oh.min + (ih.max - ih.min);\n    oh.max = ic < 0xffff && ih.max != 0xffff ? ic : 0xffff;\n\n    // set extra info\n    byte extra_info[9];\n    unsigned eisize = 0;\n    if (oh.ss != ih.ss) {\n        set_le16(extra_info + eisize, ih.ss);\n        eisize += 2;\n        assert((flag & SS) != 0); // set in fillExeHeader()\n    }\n    if (oh.sp != ih.sp) {\n        set_le16(extra_info + eisize, ih.sp);\n        eisize += 2;\n        assert((flag & SP) != 0); // set in fillExeHeader()\n    }\n    if (ih.min != oh.min) {\n        set_le16(extra_info + eisize, ih.min);\n        eisize += 2;\n        flag |= MINMEM;\n    }\n    if (ih.max != oh.max) {\n        set_le16(extra_info + eisize, ih.max);\n        eisize += 2;\n        flag |= MAXMEM;\n    }\n    extra_info[eisize++] = (byte) flag;\n\n    if (M_IS_NRV2B(ph.method) || M_IS_NRV2D(ph.method) || M_IS_NRV2E(ph.method))\n        linker->defineSymbol(\"bx_magic\", 0x7FFF + 0x10 * ((packedsize & 15) + 1));\n\n    unsigned decompressor_entry = 1 + (packedsize & 15);\n    if (M_IS_LZMA(ph.method))\n        decompressor_entry = 0x10;\n    linker->defineSymbol(\"decompressor_entry\", decompressor_entry);\n\n    // patch loader\n    if (flag & USEJUMP) {\n        // I use a relocation entry to set the original cs\n        unsigned n = getLoaderSectionStart(\"EXEJUMPF\") + 1;\n        n += packedsize + 2;\n        oh.relocs = 1;\n        oh.firstreloc = (n & 0xf) + ((n >> 4) << 16);\n    } else {\n        oh.relocs = 0;\n        oh.firstreloc = ih.cs * 0x10000 + ih.ip;\n    }\n\n    oh.relocoffs = offsetof(exe_header_t, firstreloc);\n\n    linker->defineSymbol(\"destination_segment\", oh.ss - ph.c_len / 16 - e_len / 16);\n    linker->defineSymbol(\"source_segment\", e_len / 16 + (copysize - firstcopy) / 16);\n    linker->defineSymbol(\"copy_offset\", firstcopy - 2);\n    linker->defineSymbol(\"words_to_copy\", firstcopy / 2);\n\n    linker->defineSymbol(\"exe_stack_sp\", oh.sp);\n    linker->defineSymbol(\"exe_stack_ss\", oh.ss);\n    linker->defineSymbol(\"interrupt\", get_le16(ibuf + 8));\n    linker->defineSymbol(\"attribute\", get_le16(ibuf + 4));\n    linker->defineSymbol(\"orig_strategy\", get_le16(ibuf + 6));\n\n    const unsigned outputlen = sizeof(oh) + e_len + packedsize + d_len + eisize;\n    oh.m512 = outputlen & 511;\n    oh.p512 = (outputlen + 511) >> 9;\n\n    const char *exeentry = M_IS_LZMA(ph.method) ? \"LZMAENTRY\" : \"EXEENTRY\";\n    oh.ip = device_driver ? getLoaderSection(exeentry) - 2 : 0;\n\n    defineDecompressorSymbols();\n    relocateLoader();\n    memcpy(loader, getLoader(), lsize);\n    patchPackHeader(loader, e_len);\n\n    NO_fprintf(stderr, \"\\ne_len=%x d_len=%x c_len=%x oo=%x ulen=%x copysize=%x imagesize=%x\", e_len,\n               d_len, packedsize, ph.overlap_overhead, ph.u_len, copysize, ih_imagesize);\n\n    // write header + write loader + compressed file\n#if TESTING\n    if (opt->debug.debug_level)\n        printf(\"\\n%d %d %d %d\\n\", (int) sizeof(oh), e_len, packedsize, d_len);\n#endif\n    fo->write(&oh, sizeof(oh));       // program header\n    fo->write(loader, e_len);         // entry code\n    fo->write(obuf, packedsize);      // compressed data\n    fo->write(loader + e_len, d_len); // decompressor code\n    fo->write(extra_info, eisize);    // extra info for unpacking\n    assert(eisize <= 9);\n    NO_printf(\"%-13s: program hdr  : %8u bytes\\n\", getName(), usizeof(oh));\n    NO_printf(\"%-13s: entry        : %8u bytes\\n\", getName(), e_len);\n    NO_printf(\"%-13s: compressed   : %8u bytes\\n\", getName(), packedsize);\n    NO_printf(\"%-13s: decompressor : %8u bytes\\n\", getName(), d_len);\n    NO_printf(\"%-13s: extra info   : %8u bytes\\n\", getName(), eisize);\n\n    // verify\n    verifyOverlappingDecompression();\n\n    // copy the overlay\n    copyOverlay(fo, ih_overlay, obuf);\n    NO_fprintf(stderr, \"dos/exe %x %x\\n\", relocsize, ph.u_len);\n\n    // finally check the compression ratio\n    if (!checkFinalCompressionRatio(fo))\n        throwNotCompressible();\n}\n\n/*************************************************************************\n//\n**************************************************************************/\n\ntribool PackExe::canUnpack() {\n    if (!readFileHeader())\n        return false;\n    const unsigned off = ih.headsize16 * 16;\n    fi->seek(off, SEEK_SET);\n    bool b = readPackHeader(4096);\n    return b && (off + ph.c_len <= file_size_u);\n}\n\n/*************************************************************************\n//\n**************************************************************************/\n\nvoid PackExe::unpack(OutputFile *fo) {\n    ibuf.alloc(file_size);\n    obuf.allocForDecompression(ph.u_len);\n\n    // read the file\n    fi->seek(ih.headsize16 * 16, SEEK_SET);\n    fi->readx(ibuf, ih_imagesize);\n\n    // get compressed data offset\n    unsigned e_len = ph.buf_offset + ph.getPackHeaderSize();\n    if (ih_imagesize <= e_len + ph.c_len)\n        throwCantUnpack(\"file damaged\");\n\n    checkOverlay(ih_overlay);\n\n    // decompress\n    decompress(ibuf + e_len, obuf);\n\n    unsigned imagesize = ih_imagesize;\n    imagesize -= 1;\n    const byte flag = ibuf[imagesize];\n\n    // relocations\n    unsigned relocnum = 0;\n    SPAN_S_VAR(const byte, relocstart, obuf + ph.u_len, obuf);\n    MemBuffer mb_relocs;\n    SPAN_0_VAR(byte, relocs, nullptr);\n    if (!(flag & NORELOC)) {\n        mb_relocs.alloc(4 * MAXRELOCSIZE);\n        relocs = mb_relocs; // => now a SPAN_S\n\n        relocsize = get_le16(obuf + ph.u_len - 2);\n        ph.u_len -= 2;\n        if (relocsize < 11 || relocsize > MAXRELOCSIZE || relocsize >= imagesize)\n            throwCantUnpack(\"bad relocations\");\n        relocstart -= relocsize;\n\n        // unoptimize_relocs\n        unsigned ones = get_le16(relocstart);\n        const unsigned seg_high = get_le16(relocstart + 2);\n        SPAN_S_VAR(const byte, p, relocstart + 4);\n        unsigned es = 0;\n        while (ones) {\n            unsigned di = get_le16(p);\n            es += get_le16(p + 2);\n            bool dorel = true;\n            for (p += 4; ones && di < 0x10000; p++) {\n                if (dorel) {\n                    set_le16(relocs + (4 * relocnum + 0), di);\n                    set_le16(relocs + (4 * relocnum + 2), es);\n                    NO_printf(\"dos/exe unreloc %4d %6x\\n\", relocnum, es * 16 + di);\n                    relocnum++;\n                }\n                dorel = true;\n                if (*p == 0) {\n                    SPAN_S_VAR(const byte, q, obuf + (es * 16 + di), obuf);\n                    while (!(*q == 0x9a && get_le16(q + 3) <= seg_high))\n                        q++;\n                    di = ptr_udiff_bytes(q, obuf + (es * 16)) + 3;\n                } else if (*p == 1) {\n                    di += 254;\n                    if (di < 0x10000)\n                        ones--;\n                    dorel = false;\n                } else\n                    di += *p;\n            }\n        }\n    }\n\n    // fill new exe header\n    mem_clear(&oh);\n    oh.ident = 'M' + 'Z' * 256;\n\n    if (relocnum) {\n        oh.relocs = relocnum;\n        while (relocnum & 3) // paragraph align\n            set_le32(relocs + (4 * relocnum++), 0);\n    }\n\n    unsigned outputlen = sizeof(oh) + 4 * relocnum + ptr_udiff_bytes(relocstart, obuf);\n    oh.m512 = outputlen & 511;\n    oh.p512 = (outputlen + 511) >> 9;\n    oh.headsize16 = 2 + relocnum / 4;\n\n    oh.max = ih.max;\n    oh.min = ih.min;\n    oh.sp = ih.sp;\n    oh.ss = ih.ss;\n\n    if (flag & MAXMEM) {\n        imagesize -= 2;\n        oh.max = get_le16(ibuf + imagesize);\n    }\n    if (flag & MINMEM) {\n        imagesize -= 2;\n        oh.min = get_le16(ibuf + imagesize);\n    }\n    if (flag & SP) {\n        imagesize -= 2;\n        oh.sp = get_le16(ibuf + imagesize);\n    }\n    if (flag & SS) {\n        imagesize -= 2;\n        oh.ss = get_le16(ibuf + imagesize);\n    }\n\n    unsigned ip = (flag & USEJUMP) ? get_le32(ibuf + imagesize - 4) : (unsigned) ih.firstreloc;\n    oh.ip = ip & 0xffff;\n    oh.cs = ip >> 16;\n\n    oh.relocoffs = sizeof(oh);\n    oh.firstreloc = 0;\n    if (!fo)\n        return;\n\n    // write header + relocations + uncompressed file\n    fo->write(&oh, sizeof(oh));\n    if (relocnum)\n        fo->write(relocs, 4 * relocnum);\n    fo->write(obuf, ptr_udiff_bytes(relocstart, obuf));\n\n    // copy the overlay\n    copyOverlay(fo, ih_overlay, obuf);\n}\n\n/*\n\nmemory layout at decompression time\n===================================\n\nnormal exe\n----------\n\na, at load time\n\n(e - copying code, C - compressed data, d - decompressor+relocator,\n x - not specified, U - uncompressed code+data, R uncompressed relocation)\n\neeCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCdddd\n^ CS:0                                       ^ SS:0\n\nb, after copying\n\nxxxxxxxxxxxxxxxCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCdddd\n^ES:DI=0       ^ DS:SI=0                     ^ CS=SS, IP in range 0..0xf\n\nc, after uncompression\n\nUUUUUUUUUUUUUUUUUUUUUUUUUUUUUUUUUUUUUUUUUUURRdddd\n                                           ^ ES:DI\n\ndevice driver\n-------------\n\nthe file has 2 entry points, CS:0 in device driver mode, and\nCS:exe_as_device_entry in normal mode. the code in section DEVICEENTRY\nsets up the same environment for section EXEENTRY, as it would see in normal\nexecution mode.\n\nlzma uncompression for normal exes\n----------------------------------\n\n(n - nrv2b uncompressor, l - nrv2b compressed lzma + relocator code)\n\na, at load time\n\nnneelllCCCCCCCCCCCCCCCCCCCCCCCCC\n\n^ CS:0                                       ^ SS:0\n\nb, after nrv2b\n\nnneelllCCCCCCCCCCCCCCCCCCCCCCCCC             dddd\n^ CS:0                                       ^ SS:0x10\n\nafter this, normal ee code runs\n\nlzma + device driver\n--------------------\n\n(D - device driver adapter)\n\na, at load time\n\nDDnneelllCCCCCCCCCCCCCCCCCCCCCCCCC\n\n*/\n\n/* vim:set ts=4 sw=4 et: */\n","size_bytes":27239},"src/p_lx_elf.cpp":{"content":"/* p_lx_elf.cpp --\n\n   This file is part of the Resize executable compressor.\n\n   Copyright (C) 2025 WHO-AM-I-404\n   Based on UPX - Ultimate Packer for eXecutables\n   Copyright (C) 1996-2025 Markus Franz Xaver Johannes Oberhumer\n   Copyright (C) 1996-2025 Laszlo Molnar\n   Copyright (C) 2000-2025 John F. Reiser\n   All Rights Reserved.\n\n   Resize and the UCL library are free software; you can redistribute them\n   and/or modify them under the terms of the GNU General Public License as\n   published by the Free Software Foundation; either version 2 of\n   the License, or (at your option) any later version.\n\n   This program is distributed in the hope that it will be useful,\n   but WITHOUT ANY WARRANTY; without even the implied warranty of\n   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n   GNU General Public License for more details.\n\n   You should have received a copy of the GNU General Public License\n   along with this program; see the file COPYING.\n   If not, write to the Free Software Foundation, Inc.,\n   59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.\n\n   WHO-AM-I-404 <who-am-i-404@proton.me>\n   Based on original work by:\n   Markus F.X.J. Oberhumer <markus@oberhumer.com>\n   Laszlo Molnar <ezerotven+github@gmail.com>\n\n   John F. Reiser\n   <jreiser@users.sourceforge.net>\n */\n\n\n#define ALLOW_INT_PLUS_MEMBUFFER 1\n#include \"conf.h\"\n\n#include \"file.h\"\n#include \"filter.h\"\n#include \"linker.h\"\n#include \"packer.h\"\n#include \"p_elf.h\"\n#include \"p_unix.h\"\n#include \"p_lx_exc.h\"\n#include \"p_lx_elf.h\"\n#include \"ui.h\"\n\n// NOLINTBEGIN(clang-analyzer-core.CallAndMessage)\n// NOLINTBEGIN(clang-analyzer-deadcode.DeadStores)\n\n#if defined(__CHERI__) && defined(__CHERI_PURE_CAPABILITY__)\n#  pragma clang diagnostic ignored \"-Wcheri-capability-misuse\" // TODO later\n#  pragma clang diagnostic ignored \"-Wcheri-provenance\" // TODO later\n#endif\n\nusing upx::umin;\n\n#define PT_LOAD Elf32_Phdr::PT_LOAD  /* 64-bit PT_LOAD is the same */\n#define PT_NOTE32   Elf32_Phdr::PT_NOTE\n#define PT_NOTE64   Elf64_Phdr::PT_NOTE\n#define PT_GNU_STACK32  Elf32_Phdr::PT_GNU_STACK\n#define PT_GNU_STACK64  Elf64_Phdr::PT_GNU_STACK\n#define PT_GNU_RELRO32  Elf32_Phdr::PT_GNU_RELRO\n#define PT_GNU_RELRO64  Elf64_Phdr::PT_GNU_RELRO\n\n// also see stub/src/MAX_ELF_HDR.[Sc]\nstatic constexpr unsigned MAX_ELF_HDR_32 = 512;\nstatic constexpr unsigned MAX_ELF_HDR_64 = 1024;\n\n//static unsigned const EF_ARM_HASENTRY = 0x02;\nstatic unsigned const EF_ARM_EABI_VER4 = 0x04000000;\nstatic unsigned const EF_ARM_EABI_VER5 = 0x05000000;\n\n/*static*/ const unsigned char PackLinuxElf::o_shstrtab[] = {  \\\n/*start*/       '\\0',\n/*offset  1*/   '.','n','o','t','e','.','g','n','u','.','b','u','i','l','d','-','i','d','\\0',\n/*offset 20*/   '.','s','h','s','t','r','t','a','b','\\0'\n};\n\nstatic unsigned\nup4(unsigned x)\n{\n    return ~3u & (3+ x);\n}\n\nstatic unsigned\nup8(unsigned x)\n{\n    return ~7u & (7+ x);\n}\n\nstatic off_t\nfpadN(OutputFile *fo, unsigned len)\n{\n    if (len) {\n        MemBuffer pad(len); pad.clear();\n        fo->write(pad, len);\n    }\n    return fo->st_size();\n}\n\nstatic off_t\nfpad4(OutputFile *fo, unsigned pos)\n{\n    (void)pos;  // debug: compare 'pos' with \"shell grep pos /proc/PID/fdinfo/FD\"\n    if (!fo) { // --test, --list\n        return 0;\n    }\n    off_t len = fo->st_size();\n    unsigned d = 3u & (0 - len);\n    if (d) {\n        unsigned zero = 0;\n        fo->write(&zero, d);\n    }\n    return d + len;\n}\n\nstatic off_t\nfpad8(OutputFile *fo, unsigned pos)\n{\n    (void)pos;  // debug: compare 'pos' with \"shell grep pos /proc/PID/fdinfo/FD\"\n    if (!fo) { // --test, --list\n        return 0;\n    }\n    off_t len = fo->st_size();\n    unsigned d = 7u & (0 - len);\n    if (d) {\n        upx_uint64_t zero = 0;\n        fo->write(&zero, d);\n    }\n    return d + len;\n}\n\nstatic unsigned\nfunpad4(InputFile *fi)\n{\n    unsigned d = 3u & (0 - fi->tell());\n    if (d)\n        fi->seek(d, SEEK_CUR);\n    return d;\n}\n\nstatic void alloc_file_image(MemBuffer &mb, off_t size)\n{\n    assert(mem_size_valid_bytes(size));\n    if (mb.getVoidPtr() == nullptr) {\n        mb.alloc(size);\n    } else {\n        assert((u32_t)size <= mb.getSize());\n    }\n}\n\nint\nPackLinuxElf32::checkEhdr(Elf32_Ehdr const *ehdr) const\n{\n    const unsigned char * const buf = ehdr->e_ident;\n\n    if (0!=memcmp(buf, \"\\x7f\\x45\\x4c\\x46\", 4)  // \"\\177ELF\"\n    ||  buf[Elf32_Ehdr::EI_CLASS]!=ei_class\n    ||  buf[Elf32_Ehdr::EI_DATA] !=ei_data\n    ) {\n        return -1;\n    }\n    if (!memcmp(buf+8, \"FreeBSD\", 7))                   // branded\n        return 1;\n\n    int const type = get_te16(&ehdr->e_type);\n    if (type != Elf32_Ehdr::ET_EXEC && type != Elf32_Ehdr::ET_DYN)\n        return 2;\n    if (get_te16(&ehdr->e_machine) != (unsigned) e_machine)\n        return 3;\n    if (get_te32(&ehdr->e_version) != Elf32_Ehdr::EV_CURRENT)\n        return 4;\n    if (e_phnum < 1)\n        return 5;\n    if (get_te16(&ehdr->e_phentsize) != sizeof(Elf32_Phdr))\n        return 6;\n\n    if (type == Elf32_Ehdr::ET_EXEC) {\n        // check for Linux kernels\n        unsigned const entry = get_te32(&ehdr->e_entry);\n        if (entry == 0xC0100000)    // uncompressed vmlinux\n            return 1000;\n        if (entry == 0x00001000)    // compressed vmlinux\n            return 1001;\n        if (entry == 0x00100000)    // compressed bvmlinux\n            return 1002;\n    }\n\n    // FIXME: add more checks for kernels\n\n    // FIXME: add special checks for other ELF i386 formats, like\n    //        NetBSD, OpenBSD, Solaris, ....\n\n    // success\n    return 0;\n}\n\nint\nPackLinuxElf64::checkEhdr(Elf64_Ehdr const *ehdr) const\n{\n    const unsigned char * const buf = ehdr->e_ident;\n    unsigned char osabi0 = buf[Elf32_Ehdr::EI_OSABI];\n    if (0==osabi0) {\n        osabi0 = opt->o_unix.osabi0;\n    }\n\n    if (0!=memcmp(buf, \"\\x7f\\x45\\x4c\\x46\", 4)  // \"\\177ELF\"\n    ||  buf[Elf64_Ehdr::EI_CLASS]!=ei_class\n    ||  buf[Elf64_Ehdr::EI_DATA] !=ei_data\n    ||                     osabi0!=ei_osabi\n    ) {\n        return -1;\n    }\n    if (!memcmp(buf+8, \"FreeBSD\", 7))                   // branded\n        return 1;\n\n    int const type = get_te16(&ehdr->e_type);\n    if (type != Elf64_Ehdr::ET_EXEC && type != Elf64_Ehdr::ET_DYN)\n        return 2;\n    if (get_te16(&ehdr->e_machine) != (unsigned) e_machine)\n        return 3;\n    if (get_te32(&ehdr->e_version) != Elf64_Ehdr::EV_CURRENT)\n        return 4;\n    if (e_phnum < 1)\n        return 5;\n    if (get_te16(&ehdr->e_phentsize) != sizeof(Elf64_Phdr))\n        return 6;\n\n    if (type == Elf64_Ehdr::ET_EXEC) {\n        // check for Linux kernels\n        upx_uint64_t const entry = get_te64(&ehdr->e_entry);\n        if (entry == 0xC0100000)    // uncompressed vmlinux\n            return 1000;\n        if (entry == 0x00001000)    // compressed vmlinux\n            return 1001;\n        if (entry == 0x00100000)    // compressed bvmlinux\n            return 1002;\n    }\n\n    // FIXME: add more checks for kernels\n\n    // FIXME: add special checks for other ELF i386 formats, like\n    //        NetBSD, OpenBSD, Solaris, ....\n\n    // success\n    return 0;\n}\n\nPackLinuxElf::PackLinuxElf(InputFile *f)\n    : super(f), e_phnum(0), dynstr(nullptr),\n    sz_phdrs(0), sz_elf_hdrs(0), sz_pack2(0), sz_pack2a(0),\n    lg2_page(12), page_size(1u<<lg2_page), is_pie(0), is_asl(0),\n    xct_off(0), o_binfo(0), so_slide(0), xct_va(0), jni_onload_va(0),\n    user_init_va(0), user_init_off(0),\n    e_machine(0), ei_class(0), ei_data(0), ei_osabi(0), osabi_note(nullptr),\n    shstrtab(nullptr),\n    o_elf_shnum(0)\n{\n    memset(dt_table, 0, sizeof(dt_table));\n    symnum_max = 0;\n    user_init_rp = nullptr;\n}\n\nPackLinuxElf::~PackLinuxElf()\n{\n}\n\nint PackLinuxElf32::is_LOAD(Elf32_Phdr const *phdr) const\n{\n    // (1+ PT_LOPROC) can confuse!\n    return PT_LOAD == get_te32(&phdr->p_type);\n}\n\nint PackLinuxElf64::is_LOAD(Elf64_Phdr const *phdr) const\n{\n    // (1+ PT_LOPROC) can confuse!\n    return PT_LOAD == get_te32(&phdr->p_type);\n}\n\nvoid\nPackLinuxElf32::PackLinuxElf32help1(InputFile *f)\n{\n    e_type  = get_te16(&ehdri.e_type);\n    e_phnum = get_te16(&ehdri.e_phnum);\n    e_shnum = get_te16(&ehdri.e_shnum);\n    unsigned const e_phentsize = get_te16(&ehdri.e_phentsize);\n    if (memcmp((char const *)&ehdri, \"\\x7f\\x45\\x4c\\x46\", 4)  // \"\\177ELF\"\n    || ehdri.e_ident[Elf32_Ehdr::EI_CLASS]!=Elf32_Ehdr::ELFCLASS32\n    || sizeof(Elf32_Phdr) != e_phentsize\n    || (Elf32_Ehdr::ELFDATA2MSB == ehdri.e_ident[Elf32_Ehdr::EI_DATA]\n            && &N_BELE_RTP::be_policy != bele)\n    || (Elf32_Ehdr::ELFDATA2LSB == ehdri.e_ident[Elf32_Ehdr::EI_DATA]\n            && &N_BELE_RTP::le_policy != bele)) {\n        e_phoff = 0;\n        e_shoff = 0;\n        sz_phdrs = 0;\n        return;\n    }\n    if (0==e_phnum) throwCantUnpack(\"0==e_phnum\");\n    e_phoff = get_te32(&ehdri.e_phoff);\n    unsigned const last_Phdr = e_phoff + e_phnum * usizeof(Elf32_Phdr);\n    if (last_Phdr < e_phoff  // wrap-around\n    ||  e_phoff != sizeof(Elf32_Ehdr)  // must be contiguous\n    ||  (unsigned long)file_size < last_Phdr) {\n        throwCantUnpack(\"bad e_phoff %#x\", e_phoff);\n    }\n    e_shoff = get_te32(&ehdri.e_shoff);\n    e_shstrndx = get_te16(&ehdri.e_shstrndx);\n    unsigned const last_Shdr = e_shoff + e_shnum * usizeof(Elf32_Shdr);\n    if (last_Shdr < e_shoff  // wrap-around\n    ||  (e_shnum && e_shoff < last_Phdr)\n    ||  (unsigned long)file_size < last_Shdr) {\n        if (opt->cmd == CMD_COMPRESS) {\n            throwCantUnpack(\"bad e_shoff %#x\", e_shoff);\n        }\n    }\n    sz_phdrs = e_phnum * e_phentsize;\n    sz_elf_hdrs = sz_phdrs + sizeof(Elf32_Ehdr) +\n        n_phdrx * sizeof(Elf32_Phdr);  // phdrx bodies later: ::generateElfHdr\n\n    if (f && Elf32_Ehdr::ET_DYN!=e_type) {\n        unsigned const len = file_size;  // (sz_phdrs + e_phoff) except --preserve-build-id\n        alloc_file_image(file_image, len);\n        f->seek(0, SEEK_SET);\n        f->readx(file_image, len);\n        phdri= (Elf32_Phdr       *)(e_phoff + file_image);  // do not free() !!\n    }\n    if (f && Elf32_Ehdr::ET_DYN==e_type) {\n        // The DT_SYMTAB has no designated length.  Read the whole file.\n        alloc_file_image(file_image, file_size);\n        f->seek(0, SEEK_SET);\n        f->readx(file_image, file_size);\n        phdri= (Elf32_Phdr *)(e_phoff + file_image);  // do not free() !!\n        if (opt->cmd != CMD_COMPRESS || !e_shoff ||  file_size < e_shoff) {\n            shdri = nullptr;\n        }\n        else {  // FIXME: copy from file_image ?\n            fi->seek(e_shoff, SEEK_SET);\n            if (mb_shdr.getSize() != sizeof(Elf32_Shdr) * e_shnum) {\n                mb_shdr.alloc(   sizeof(Elf32_Shdr) * e_shnum);\n            }\n            shdri = (Elf32_Shdr *)mb_shdr.getVoidPtr();\n            fi->readx(shdri, sizeof(Elf32_Shdr) * e_shnum);\n        }\n        sec_dynsym = elf_find_section_type(Elf32_Shdr::SHT_DYNSYM);\n        if (sec_dynsym) {\n            unsigned t = get_te32(&sec_dynsym->sh_link);\n            if (e_shnum <= t)\n                throwCantPack(\"bad dynsym->sh_link\");\n            sec_dynstr = &shdri[t];\n        }\n\n        Elf32_Phdr const *phdr= phdri;\n        for (int j = e_phnum; --j>=0; ++phdr)\n        if (Elf32_Phdr::PT_DYNAMIC==get_te32(&phdr->p_type)) {\n            unsigned offset = check_pt_dynamic(phdr);\n            dynseg= (Elf32_Dyn *)(offset + file_image);\n            invert_pt_dynamic(dynseg,\n                umin(get_te32(&phdr->p_filesz), (unsigned)(file_size_u - offset)));\n        }\n        else if (is_LOAD(phdr)) {\n            check_pt_load(phdr);\n        }\n        // elf_find_dynamic() returns 0 if 0==dynseg.\n        dynstr =          (char const *)elf_find_dynamic(Elf32_Dyn::DT_STRTAB);\n        dynsym = (Elf32_Sym /*const*/ *)elf_find_dynamic(Elf32_Dyn::DT_SYMTAB);\n        gashtab =     (unsigned const *)elf_find_dynamic(Elf32_Dyn::DT_GNU_HASH);\n        hashtab =     (unsigned const *)elf_find_dynamic(Elf32_Dyn::DT_HASH);\n        if (3& ((upx_uintptr_t)dynsym | (upx_uintptr_t)gashtab | (upx_uintptr_t)hashtab)) {\n            throwCantPack(\"unaligned DT_SYMTAB, DT_GNU_HASH, or DT_HASH/n\");\n        }\n        jni_onload_sym = elf_lookup(\"JNI_OnLoad\");\n        if (jni_onload_sym) {\n            jni_onload_va = get_te32(&jni_onload_sym->st_value);\n            jni_onload_va = 0;  // FIXME not understood; need example\n        }\n    }\n}\n\n#define WANT_EHDR_ENUM\n#define WANT_REL_ENUM\n#include \"p_elf_enum.h\"\n#undef WANT_REL_ENUM\n#undef WANT_EHDR_ENUM\n\noff_t PackLinuxElf::pack3(OutputFile *fo, Filter &ft) // return length of output\n{\n    if (!fo) {\n        return 0;\n    }\n    unsigned disp;\n    unsigned len = sz_pack2a;  // after headers and all PT_LOAD\n\n    unsigned const t = (4 & len) ^ ((!!xct_off)<<2);  // 0 or 4\n    if (t) {\n        if (fo) {\n            unsigned const zero = 0;\n            fo->write(&zero, t);\n        }\n        len += t;  // force sz_pack2 (0 mod 8)  [see below]\n    }\n\n    set_te32(&disp, sz_elf_hdrs + usizeof(p_info) + usizeof(l_info) +\n        (!!xct_off & !!is_asl));  // |1 iff android shlib\n    fo->write(&disp, sizeof(disp));  // offset(b_info)\n        // FIXME: If is_shlib then that is useful only for the is_asl bit.\n        // Better info is the word below with (overlay_offset - sizeof(linfo)).\n\n    len += sizeof(disp);\n    set_te32(&disp, len);  // distance back to beginning (detect dynamic reloc)\n    fo->write(&disp, sizeof(disp));\n    len += sizeof(disp);\n\n    if (xct_off) {  // is_shlib\n        upx_uint64_t const firstpc_va = (jni_onload_va\n            ? jni_onload_va\n            : user_init_va);\n        set_te32(&disp, firstpc_va - load_va);\n        fo->write(&disp, sizeof(disp));  // DT_INIT.d_val or DT_INIT_ARRAY[0]\n        len += sizeof(disp);\n\n        set_te32(&disp, xct_off);\n        fo->write(&disp, sizeof(disp));  // offset(lowest_executable_instr)\n        len += sizeof(disp);\n\n        if (is_asl) {\n            xct_off += asl_delta;  // the extra page\n        }\n        set_te32(&disp, overlay_offset - sizeof(linfo));\n        fo->write(&disp, sizeof(disp));  // &{l_info; p_info; b_info}\n        len += sizeof(disp);\n    }\n    total_out += len - sz_pack2a;\n    sz_pack2 = len;  // 0 mod 8  [see above]\n\n    // FIXME: debugging aid: entry to decompressor\n    if (lowmem.getSize()) {\n        Elf32_Ehdr *const ehdr = (Elf32_Ehdr *)&lowmem[0];\n        set_te32(&ehdr->e_entry, sz_pack2);  // hint for decompressor\n    }\n    // end debugging aid\n\n    super::pack3(fo, ft);  // append the decompressor\n    set_te16(&linfo.l_lsize, up4(  // MATCH03: up4\n    get_te16(&linfo.l_lsize) + len - sz_pack2a));\n    total_out = fpad4(fo, total_out);  // MATCH03\n    return total_out;\n}\n\nstatic unsigned\nis_pow2(u64_t x)\n{\n    return !((-1+ x) & x);\n}\n\nElf32_Phdr const *\nPackLinuxElf32::elf_find_Phdr_for_va(upx_uint32_t addr, Elf32_Phdr const *phdr, unsigned phnum)\n{\n    for (unsigned j = 0; j < phnum; ++j, ++phdr) {\n        u32_t align = get_te32(&phdr->p_align);\n        if (is_LOAD(phdr)\n        && is_pow2(align) && !((-1+ align) &\n            (get_te32(&phdr->p_vaddr) ^ get_te32(&phdr->p_offset)))\n        &&  (addr - get_te32(&phdr->p_vaddr)) < get_te32(&phdr->p_filesz)) {\n            return phdr;\n        }\n    }\n    return nullptr;\n}\n\nElf64_Phdr const *\nPackLinuxElf64::elf_find_Phdr_for_va(upx_uint64_t addr, Elf64_Phdr const *phdr, unsigned phnum)\n{\n    for (unsigned j = 0; j < phnum; ++j, ++phdr) {\n        u64_t align = get_te64(&phdr->p_align);\n        if (is_LOAD(phdr)\n        && is_pow2(align) && !((-1+ align) &\n            (get_te64(&phdr->p_vaddr) ^ get_te64(&phdr->p_offset)))\n        &&  (addr - get_te64(&phdr->p_vaddr)) < get_te64(&phdr->p_filesz)) {\n            return phdr;\n        }\n    }\n    return nullptr;\n}\n\nunsigned\nPackLinuxElf32::slide_sh_offset(Elf32_Shdr *shdr)\n{\n    unsigned sh_offset = get_te32(&shdr->sh_offset);\n    unsigned sh_addr   = get_te32(&shdr->sh_addr);\n    if (Elf32_Shdr::SHF_WRITE & get_te32(&shdr->sh_flags)\n      || (sh_offset && !sh_addr))\n    {\n        unsigned newoff = so_slide + sh_offset + (is_asl ? asl_delta : 0);\n        if ((unsigned)this->file_size < newoff) {\n            throwInternalError(\"bad slide %p %#x\", shdr, (unsigned)so_slide);\n        }\n        set_te32(&shdr->sh_offset, newoff);\n        if (sh_addr) // change only if non-zero\n            set_te32(&shdr->sh_addr,\n                so_slide + sh_addr + (is_asl ? asl_delta : 0));\n        return newoff;\n    }\n    return sh_offset;\n}\n\nvoid\nPackLinuxElf32::asl_slide_Shdrs()\n{\n    Elf32_Shdr *shdr = shdro;\n    for (unsigned j = 0; j < e_shnum; ++shdr, ++j) {\n        unsigned sh_offset = get_te32(&shdr->sh_offset);\n        if (xct_off < sh_offset) {\n            slide_sh_offset(shdr);\n        }\n    }\n}\n\nunsigned\nPackLinuxElf64::slide_sh_offset(Elf64_Shdr *shdr)\n{\n    unsigned sh_offset = get_te64(&shdr->sh_offset);\n    unsigned sh_addr   = get_te64(&shdr->sh_addr);\n    if (Elf64_Shdr::SHF_WRITE & get_te64(&shdr->sh_flags)\n      || (sh_offset && !sh_addr))\n    {\n        unsigned newoff = so_slide + sh_offset + (is_asl ? asl_delta : 0);\n        if ((unsigned)this->file_size < newoff) {\n            throwInternalError(\"bad slide %p %#x\", shdr, (unsigned)so_slide);\n        }\n        set_te64(&shdr->sh_offset, newoff);\n        if (sh_addr) // change only if non-zero\n            set_te64(&shdr->sh_addr,\n                so_slide + sh_addr + (is_asl ? asl_delta : 0));\n        return newoff;\n    }\n    return sh_offset;\n}\n\nvoid\nPackLinuxElf64::asl_slide_Shdrs()\n{\n    Elf64_Shdr *shdr = shdro;\n    for (unsigned j = 0; j < e_shnum; ++shdr, ++j) {\n        unsigned sh_offset = get_te64_32(&shdr->sh_offset);\n        if (xct_off < sh_offset) {\n            slide_sh_offset(shdr);\n        }\n    }\n}\n\n// C_BASE covers the convex hull of the PT_LOAD of the uncompressed module.\n// It has (PF_W & .p_flags), and is \".bss\": empty (0==.p_filesz, except a bug\n// in Linux kernel forces 0x1000==.p_filesz) with .p_memsz equal to the brk(0).\n// It is first in order to reserve all // pages, in particular so that if\n// (64K == .p_align) but at runtime (4K == PAGE_SIZE) then the Linux kernel\n// does not put [vdso] and [vvar] into alignment holes that the UPX runtime stub\n// will overwrite.\n//\n// Note that C_TEXT[.p_vaddr, +.p_memsz) is a subset of C_BASE.\n// This requires that the kernel process the ELFxx_Phdr in ascending order,\n// and does not mind the overlap.  The UPX runtime stub will \"re-program\"\n// the memory regions anyway.\nenum { // ordinals in ELFxx_Phdr[] of compressed output\n      C_BASE = 0  // reserve address space\n    , C_TEXT = 1  // compressed data and stub\n    , C_NOTE = 2  // PT_NOTE copied from input\n    , C_GSTK = 3  // PT_GNU_STACK; will be 2 if no PT_NOTE\n};\n\noff_t PackLinuxElf32::pack3(OutputFile *fo, Filter &ft)\n{\n    if (!overlay_offset) {\n        overlay_offset = sizeof(linfo) + (xct_off ? xct_off : sz_elf_hdrs);\n    }\n\n    total_out = super::pack3(fo, ft);  // loader follows compressed PT_LOADs\n    if (fo && xct_off  && !is_asl && Elf32_Dyn::DT_INIT != upx_dt_init) {\n        // Patch user_init_rp.  is_asl has done this already in asl_pack2_Shdrs()\n        // Section .init_array[0] must have R_$(ARCH)_RELATIVE relocation.\n        fo->seek((char *)user_init_rp - (char *)&file_image[0], SEEK_SET);\n        Elf32_Rel rel(*(Elf32_Rel const *)user_init_rp);\n        u32_t r_info = get_te32(&((Elf32_Rel const *)user_init_rp)->r_info);\n        u32_t r_type = (Elf32_Ehdr::EM_386  == e_machine) ? R_386_RELATIVE\n                     : (Elf32_Ehdr::EM_ARM  == e_machine) ? R_ARM_RELATIVE\n                     : (Elf32_Ehdr::EM_PPC  == e_machine) ? R_PPC_RELATIVE\n                     : (Elf32_Ehdr::EM_MIPS == e_machine) ? R_MIPS_32\n                     : 0;\n        set_te32(&rel.r_info, ELF32_R_INFO(ELF32_R_SYM(r_info), r_type));\n        if (is_asl) {\n            u32_t r_offset = get_te32(&((Elf32_Rel const *)user_init_rp)->r_offset);\n            set_te32(&rel.r_offset, asl_delta + r_offset);\n        }\n        fo->rewrite(&rel, sizeof(rel));\n        fo->seek(0, SEEK_END);\n\n        // Value of init_array[0] will be changed later.\n        // See write() of 'cpr_entry' below.\n    }\n    // NOTE: PackLinuxElf::pack3  adjusted xct_off for the extra page\n\n    // Then compressed gaps (including debuginfo.)\n    for (unsigned k = 0; k < e_phnum; ++k) {\n        Extent x;\n        x.size = find_LOAD_gap(phdri, k, e_phnum);\n        if (x.size) {\n            x.offset = get_te32(&phdri[k].p_offset) +\n                       get_te32(&phdri[k].p_filesz);\n            packExtent(x, nullptr, fo);\n        }\n    }\n    // write block end marker (uncompressed size 0)\n    b_info hdr; memset(&hdr, 0, sizeof(hdr));\n    set_le32(&hdr.sz_cpr, UPX_MAGIC_LE32);\n    fo->write(&hdr, sizeof(hdr));\n    total_out = fpad4(fo, total_out);\n\n    if (0==xct_off) { // not shared library\n        set_te32(&elfout.phdr[C_BASE].p_align, 0u - page_mask);\n        elfout.phdr[C_BASE].p_paddr = elfout.phdr[C_BASE].p_vaddr;\n        elfout.phdr[C_BASE].p_offset = 0;\n        unsigned abrk = getbrk(phdri, e_phnum);\n        // vbase handles ET_EXEC.  FIXME: pre-linking?\n        unsigned vbase = get_te32(&elfout.phdr[C_BASE].p_vaddr);\n        set_te32(&elfout.phdr[C_BASE].p_filesz, 0x1000);  // Linux kernel SIGSEGV if (0==.p_filesz)\n        set_te32(&elfout.phdr[C_BASE].p_memsz, abrk - vbase);\n        set_te32(&elfout.phdr[C_BASE].p_flags, Elf32_Phdr::PF_W|Elf32_Phdr::PF_R);\n        set_te32(&elfout.phdr[C_TEXT].p_filesz, sz_pack2 + lsize);\n        set_te32(&elfout.phdr[C_TEXT].p_memsz,  sz_pack2 + lsize);\n        set_te32(&elfout.phdr[C_TEXT].p_vaddr, abrk= (page_mask & (~page_mask + abrk)));\n        elfout.phdr[C_TEXT].p_paddr = elfout.phdr[C_TEXT].p_vaddr;\n        set_te32(&elfout.ehdr.e_entry, abrk + get_te32(&elfout.ehdr.e_entry) - vbase);\n    }\n    if (0!=xct_off) { // shared library\n        unsigned const cpr_entry = load_va + sz_pack2;\n        set_te32(&file_image[user_init_off], cpr_entry);  // set the hook\n\n        if (user_init_rp) { // decompressor needs hint for DT_INIT_ARRAY\n            Elf32_Dyn *dynp = (Elf32_Dyn *)elf_find_dynptr(Elf32_Dyn::DT_NULL);\n            set_te32(&dynp->d_val, (char *)user_init_rp - (char *)&file_image[0]);\n        }\n\n        Elf32_Phdr *const phdr0 = (Elf32_Phdr *)lowmem.subref(\n                \"bad e_phoff\", e_phoff, e_phnum * sizeof(Elf32_Phdr));\n        Elf32_Phdr *phdr = phdr0;\n        upx_off_t off = fo->st_size();  // 64 bits\n        so_slide = 0;\n        for (unsigned j = 0; j < e_phnum; ++j, ++phdr) {\n            // p_vaddr and p_paddr do not change!\n            unsigned const len  = get_te32(&phdr->p_filesz);\n            unsigned const ioff = get_te32(&phdri[j].p_offset);  // without asl_delta\n            unsigned       align= get_te32(&phdr->p_align);\n            unsigned const type = get_te32(&phdr->p_type);\n            if (Elf32_Phdr::PT_INTERP==type) {\n                // Rotate to highest position, so it can be lopped\n                // by decrementing e_phnum.\n                memcpy((unsigned char *)ibuf, phdr, sizeof(*phdr));  // extract\n                memmove(phdr, 1+phdr, (e_phnum - (1+ j))*sizeof(*phdr));  // overlapping\n                memcpy(&phdr[e_phnum - (1+ j)], (unsigned char *)ibuf, sizeof(*phdr));  // to top\n                --phdr; --e_phnum;\n                set_te16(&ehdri.e_phnum, e_phnum);\n                set_te16(&((Elf32_Ehdr *)(unsigned char *)lowmem)->e_phnum, e_phnum);\n                continue;\n            }\n            if (PT_LOAD == type) {\n                if (!ioff) { // first PT_LOAD must contain everything written so far\n                    set_te32(&phdr->p_filesz, sz_pack2 + lsize);  // is this correct?\n                    set_te32(&phdr->p_memsz,  sz_pack2 + lsize);\n                    // so_entry._start is in 1st PT_LOAD, and must be eXecutable\n                    unsigned p_flags = get_te32(&phdr->p_flags);\n                    set_te32(&phdr->p_flags, Elf32_Phdr::PF_X | p_flags);\n                }\n                else if ((xct_off - ioff) < len) { // Change length of compressed PT_LOAD.\n                    set_te32(&phdr->p_filesz, total_out - ioff);  // FIXME  (sz_pack2 + lsize - ioff) ?\n                    set_te32(&phdr->p_memsz,  total_out - ioff);\n                    if (user_init_off < xct_off) { // MIPS puts PT_DYNAMIC here\n                        // Allow for DT_INIT in a new [stolen] slot\n                        unsigned off2 = user_init_off - sizeof(unsigned);\n                        fo->seek(off2, SEEK_SET);\n                        fo->rewrite(&file_image[off2], 2*sizeof(unsigned));\n                    }\n                }\n                else if (xct_off < ioff) { // Slide subsequent PT_LOAD.\n                    if ((1u<<12) < align\n                    &&  (  Elf32_Ehdr::EM_386 == e_machine\n                        || Elf32_Ehdr::EM_ARM == e_machine)  // FIXME: other $ARCH ?\n                    ) {\n                        align = 1u<<12;\n                        set_te32(&phdr->p_align, align);\n                    }\n                    off = fpadN(fo, (-1 + align) & (ioff - off));\n                    if (!so_slide) { // only once\n                        so_slide = off - ((is_asl ? asl_delta : 0) + ioff);\n                        //fprintf(stderr, \"\\nso_slide = %#x\\n\", (unsigned)so_slide);\n                        //asl_slide_Shdrs();\n                    }\n                    set_te32(&phdr->p_offset, off);\n                    fo->seek(off, SEEK_SET);\n                    fo->write(&file_image[ioff], len);\n                    off += len;\n                    total_out = off;\n\n                    if ((user_init_off - ioff) < len) {\n                        fo->seek(user_init_off + so_slide, SEEK_SET);\n                        unsigned word = cpr_entry;\n                        set_te32(&word, cpr_entry);\n                        fo->rewrite(&word, sizeof(word));\n                        fo->seek(0, SEEK_END);\n                    }\n                }\n                continue;  // all done with this PT_LOAD\n            }\n            if (xct_off < ioff) {\n                set_te32(&phdr->p_offset, so_slide + (is_asl ? asl_delta : 0) + ioff);\n            }\n        }  // end each Phdr\n\n        if (sec_arm_attr || is_asl) { // must update Shdr.sh_offset for so_slide\n            Elf32_Shdr *shdr = shdri;\n            for (unsigned j = 0; j < e_shnum; ++shdr, ++j) {\n                unsigned sh_type = get_te32(&shdr->sh_type);\n                if (Elf32_Shdr::SHT_REL == sh_type\n                &&  n_jmp_slot  // FIXME  who sets this?\n                &&  !strcmp(\".rel.plt\", get_te32(&shdr->sh_name) + shstrtab)) {\n                    unsigned va = elf_unsigned_dynamic(Elf32_Dyn::DT_PLTGOT)\n                        - (is_asl ? asl_delta : 0);\n                    // Now use the old Phdrs (phdri)\n                    Elf32_Phdr const *phva;\n                    phva = elf_find_Phdr_for_va(va, phdri, e_phnum);\n                    unsigned old_off = (va - get_te32(&phva->p_vaddr))\n                        + get_te32(&phva->p_offset);\n\n                    // Now use the new Phdrs (phdr0)\n                    va += (is_asl ? asl_delta : 0);\n                    phva = elf_find_Phdr_for_va(va, phdr0, e_phnum);\n                    unsigned new_off = (va - get_te32(&phva->p_vaddr))\n                        + get_te32(&phva->p_offset);\n\n                    if (fo && n_jmp_slot) {\n                        fo->seek(new_off, SEEK_SET);\n                        fo->rewrite(&file_image[old_off], n_jmp_slot * 4);\n                    }\n                }\n                if (j && shdr->sh_addr == 0\n                &&  get_te32(&shdr->sh_offset) < xct_off) {\n                    // Try to be nice by sliding; but still fails if compressed.\n                    // So don't do it unless appending plain text of shstrtab.\n                    unsigned sh_off = get_te32(&shdr->sh_offset);\n                    if (xct_off < sh_off) {\n                        slide_sh_offset(shdr);\n                    }\n                }\n            }\n            // Maybe: append plain text of shstrtab strings?\n            fo->seek(total_out, SEEK_SET);\n            if (xct_off < e_shoff) {\n                set_te32(&((Elf32_Ehdr *)lowmem.getVoidPtr())->e_shoff, total_out);\n                if (fo) {\n                    fo->write(shdri, e_shnum * sizeof(*shdr));\n                    total_out += e_shnum * sizeof(*shdr);\n                }\n            }\n        }\n        else { // output has no Shdr\n            ehdri.e_shnum = 0;\n            ehdri.e_shoff = 0;\n            ehdri.e_shstrndx = 0;\n        }\n    }\n    return total_out;\n}\n\noff_t PackLinuxElf64::pack3(OutputFile *fo, Filter &ft)\n{\n    if (!overlay_offset) {\n        overlay_offset = sizeof(linfo) + (xct_off ? xct_off : sz_elf_hdrs);\n    }\n\n    total_out = super::pack3(fo, ft);  // loader follows compressed PT_LOADs\n    if (fo && xct_off && Elf64_Dyn::DT_INIT != upx_dt_init) { // patch user_init_rp\n        fo->seek((char *)user_init_rp - (char *)&file_image[0], SEEK_SET);\n        Elf64_Rela rela(*(Elf64_Rela const *)user_init_rp);\n        //u64_t r_info = get_te64(&((Elf64_Rela const *)user_init_rp)->r_info);\n        u32_t r_type = (Elf64_Ehdr::EM_AARCH64 == e_machine) ? R_AARCH64_RELATIVE\n                     : (Elf64_Ehdr::EM_X86_64  == e_machine) ? R_X86_64_RELATIVE\n                     : (Elf64_Ehdr::EM_PPC64   == e_machine) ? R_PPC64_RELATIVE\n                     : 0;\n        set_te64(&rela.r_info, ELF64_R_INFO(0 /*ELF64_R_SYM(r_info)*/, r_type));\n        set_te64(&rela.r_addend, sz_pack2);  // entry to decompressor\n        fo->rewrite(&rela, sizeof(rela));\n\n        fo->seek(0, SEEK_END);\n    }\n    // NOTE: PackLinuxElf::pack3  adjusted xct_off for the extra page\n\n    // Then compressed gaps (including debuginfo.)\n    for (unsigned k = 0; k < e_phnum; ++k) {\n        Extent x;\n        x.size = find_LOAD_gap(phdri, k, e_phnum);\n        if (x.size) {\n            x.offset = get_te64(&phdri[k].p_offset) +\n                       get_te64(&phdri[k].p_filesz);\n            packExtent(x, nullptr, fo);\n        }\n    }\n    // write block end marker (uncompressed size 0)\n    b_info hdr; memset(&hdr, 0, sizeof(hdr));\n    set_le32(&hdr.sz_cpr, UPX_MAGIC_LE32);\n    fo->write(&hdr, sizeof(hdr));\n    total_out = fpad4(fo, total_out);\n\n    if (0==xct_off) { // not shared library\n        set_te64(&elfout.phdr[C_BASE].p_align, ((u64_t)0) - page_mask);\n        elfout.phdr[C_BASE].p_paddr = elfout.phdr[C_BASE].p_vaddr;\n        elfout.phdr[C_BASE].p_offset = 0;\n        u64_t abrk = getbrk(phdri, e_phnum);\n        // vbase handles ET_EXEC.  FIXME: pre-linking?\n        u64_t const vbase = get_te64(&elfout.phdr[C_BASE].p_vaddr);\n        set_te64(&elfout.phdr[C_BASE].p_filesz, 0x1000);  // Linux kernel SIGSEGV if (0==.p_filesz)\n        set_te64(&elfout.phdr[C_BASE].p_memsz, abrk - vbase);\n        set_te32(&elfout.phdr[C_BASE].p_flags, Elf64_Phdr::PF_W|Elf64_Phdr::PF_R);\n        set_te64(&elfout.phdr[C_TEXT].p_filesz, sz_pack2 + lsize);\n        set_te64(&elfout.phdr[C_TEXT].p_memsz,  sz_pack2 + lsize);\n        set_te64(&elfout.phdr[C_TEXT].p_vaddr, abrk= (page_mask & (~page_mask + abrk)));\n        elfout.phdr[C_TEXT].p_paddr = elfout.phdr[C_TEXT].p_vaddr;\n        set_te64(&elfout.ehdr.e_entry, abrk + get_te64(&elfout.ehdr.e_entry) - vbase);\n    }\n    if (0!=xct_off) { // shared library\n        u64_t const cpr_entry = load_va + sz_pack2;\n        set_te64(&file_image[user_init_off], cpr_entry);  // set the hook\n\n        if (user_init_rp) { // decompressor needs hint for DT_INIT_ARRAY\n            Elf64_Dyn *dynp = (Elf64_Dyn *)elf_find_dynptr(Elf64_Dyn::DT_NULL);\n            set_te64(&dynp->d_val, (char *)user_init_rp - (char *)&file_image[0]);\n        }\n\n        Elf64_Phdr *const phdr0 = (Elf64_Phdr *)lowmem.subref(\n                \"bad e_phoff\", e_phoff, e_phnum * sizeof(Elf64_Phdr));\n        Elf64_Phdr *phdr = phdr0;\n        upx_off_t off = fo->st_size();  // 64 bits\n        so_slide = 0;\n        for (unsigned j = 0; j < e_phnum; ++j, ++phdr) {\n            // p_vaddr and p_paddr do not change!\n            u64_t const len  = get_te64(&phdr->p_filesz);\n            u64_t const ioff = get_te64(&phdri[j].p_offset);  // without asl_delta\n            u64_t       align= get_te64(&phdr->p_align);\n            unsigned const type = get_te32(&phdr->p_type);\n            if (Elf64_Phdr::PT_INTERP==type) {\n                // Rotate to highest position, so it can be lopped\n                // by decrementing e_phnum.\n                memcpy((unsigned char *)ibuf, phdr, sizeof(*phdr));  // extract\n                memmove(phdr, 1+phdr, (e_phnum - (1+ j))*sizeof(*phdr));  // overlapping\n                memcpy(&phdr[e_phnum - (1+ j)], (unsigned char *)ibuf, sizeof(*phdr));  // to top\n                --phdr; --e_phnum;\n                set_te16(&ehdri.e_phnum, e_phnum);\n                set_te16(&((Elf64_Ehdr *)(unsigned char *)lowmem)->e_phnum, e_phnum);\n                continue;\n            }\n            if (PT_LOAD == type) {\n                if (!ioff) { // first PT_LOAD must contain everything written so far\n                    set_te64(&phdr->p_filesz, sz_pack2 + lsize);  // is this correct?\n                    set_te64(&phdr->p_memsz,  sz_pack2 + lsize);\n                }\n                else if ((xct_off - ioff) < len) { // Change length of compressed PT_LOAD.\n                    set_te64(&phdr->p_filesz, total_out - ioff);  // FIXME  (sz_pack2 + lsize - ioff) ?\n                    set_te64(&phdr->p_memsz,  total_out - ioff);\n                    if (user_init_off < xct_off) { // MIPS puts PT_DYNAMIC here\n                        // Allow for DT_INIT in a new [stolen] slot\n                        unsigned off2 = user_init_off - sizeof(u64_t);\n                        fo->seek(off2, SEEK_SET);\n                        fo->rewrite(&file_image[off2], 2*sizeof(u64_t));\n                    }\n                }\n                else if (xct_off < ioff) { // Slide subsequent PT_LOAD.\n                    if ((1u<<12) < align\n                    &&  Elf64_Ehdr::EM_X86_64 == e_machine  // FIXME: other $ARCH ?\n                    ) {\n                        align = 1u<<12;\n                        set_te64(&phdr->p_align, align);\n                    }\n                    off = fpadN(fo, (-1 + align) & (ioff - off));\n                    if (!so_slide) { // only once\n                        so_slide = off - ((is_asl ? asl_delta : 0) + ioff);\n                        //fprintf(stderr, \"\\nso_slide = %#x\\n\", (unsigned)so_slide);\n                        //asl_slide_Shdrs();\n                    }\n                    set_te64(&phdr->p_offset, off);\n                    fo->seek(off, SEEK_SET);\n                    fo->write(&file_image[ioff], len);\n                    off += len;\n                    total_out = off;\n\n                    if ((user_init_off - ioff) < len) {\n                        fo->seek(user_init_off + so_slide, SEEK_SET);\n                        u64_t word = cpr_entry;\n                        set_te64(&word, cpr_entry);\n                        fo->rewrite(&word, sizeof(word));\n                        fo->seek(0, SEEK_END);\n                    }\n                }\n                continue;  // all done with this PT_LOAD\n            }\n            if (xct_off < ioff) {\n                set_te64(&phdr->p_offset, so_slide + (is_asl ? asl_delta : 0) + ioff);\n            }\n        }  // end each Phdr\n\n        if (sec_arm_attr || is_asl) { // must update Shdr.sh_offset for so_slide\n            // Update {DYNAMIC}.sh_offset by so_slide.\n            Elf64_Shdr *shdr = (Elf64_Shdr *)lowmem.subref(  // FIXME: use shdri ?\n                    \"bad e_shoff\", xct_off - (is_asl ? asl_delta : 0), e_shnum * sizeof(Elf64_Shdr));\n            for (unsigned j = 0; j < e_shnum; ++shdr, ++j) {\n                unsigned sh_type = get_te32(&shdr->sh_type);\n                unsigned sh_flags = get_te64(&shdr->sh_flags);  // all SHF_ are 32-bit anyway\n                unsigned sh_offset = get_te64(&shdr->sh_offset); // already asl_delta\n                if (Elf64_Shdr::SHF_ALLOC & sh_flags\n                &&  Elf64_Shdr::SHF_WRITE & sh_flags\n                &&  xct_off < sh_offset) {\n                    set_te64(&shdr->sh_offset, so_slide + sh_offset);\n                }\n                if (Elf64_Shdr::SHT_RELA == sh_type\n                &&  n_jmp_slot  // FIXME: does this apply to SHT_RELA ?\n                &&  !strcmp(\".rel.plt\", get_te32(&shdr->sh_name) + shstrtab)) {\n                    u64_t va = elf_unsigned_dynamic(Elf64_Dyn::DT_PLTGOT) - (is_asl ? asl_delta : 0);\n                    // Now use the old Phdrs (phdri)\n                    Elf64_Phdr const *phva;\n                    phva = elf_find_Phdr_for_va(va, phdri, e_phnum);\n                    u64_t old_off = (va - get_te64(&phva->p_vaddr))\n                        + get_te64(&phva->p_offset);\n\n                    // Now use the new Phdrs (phdr0)\n                    va += (is_asl ? asl_delta : 0);\n                    phva = elf_find_Phdr_for_va(va, phdr0, e_phnum);\n                    u64_t new_off = (va - get_te64(&phva->p_vaddr))\n                        + get_te64(&phva->p_offset);\n\n                    if (fo && n_jmp_slot) {\n                        fo->seek(new_off, SEEK_SET);\n                        fo->rewrite(&file_image[old_off], n_jmp_slot * 8);\n                    }\n                }\n                if (j && shdr->sh_addr == 0\n                &&  get_te64_32(&shdr->sh_offset) < xct_off) { // UPX_RSIZE_MAX_MEM protects us\n                    // Try to be nice by sliding; but still fails if compressed.\n                    // So don't do it unless appending plain text of shstrtab.\n                    unsigned sh_off = get_te64_32(&shdr->sh_offset);  // UPX_RSIZE_MAX_MEM protects us\n                    if (xct_off < sh_off) {\n                        set_te64(&shdr->sh_offset, sh_off + so_slide);\n                    }\n                }\n            }\n            // Maybe: append plain text of shstrtab strings?\n            fo->seek(total_out, SEEK_SET);\n            if (xct_off < e_shoff) {\n                set_te32(&((Elf32_Ehdr *)lowmem.getVoidPtr())->e_shoff, total_out);\n                if (fo) {\n                    fo->write(shdri, e_shnum * sizeof(*shdr));\n                    total_out += e_shnum * sizeof(*shdr);\n                }\n            }\n        }\n        else { // output has no Shdr\n            ehdri.e_shnum = 0;\n            ehdri.e_shoff = 0;\n            ehdri.e_shstrndx = 0;\n        }\n    }\n    return total_out;\n}\n\nvoid\nPackLinuxElf::addStubEntrySections(Filter const *, unsigned m_decompr)\n{\n    (void)m_decompr;  // FIXME\n    if (hasLoaderSection(\"ELFMAINX\")) {\n        addLoader(\"ELFMAINX\", nullptr);\n    }\n    if (hasLoaderSection(\"ELFMAINXu\")) {\n            // brk() trouble if static\n        addLoader(\"ELFMAINXu\", nullptr);\n    }\n    addLoader(\n        ( M_IS_NRV2E(ph_forced_method(ph.method)) ? \"NRV_HEAD,NRV2E,NRV_TAIL\"\n        : M_IS_NRV2D(ph_forced_method(ph.method)) ? \"NRV_HEAD,NRV2D,NRV_TAIL\"\n        : M_IS_NRV2B(ph_forced_method(ph.method)) ? \"NRV_HEAD,NRV2B,NRV_TAIL\"\n        : M_IS_LZMA(ph_forced_method(ph.method))  ? \"LZMA_ELF00,LZMA_DEC20,LZMA_DEC30\"\n        : nullptr), nullptr);\n    if (hasLoaderSection(\"CFLUSH\"))\n        addLoader(\"CFLUSH\");\n    addLoader(\"ELFMAINY,IDENTSTR\", nullptr);\n    if (hasLoaderSection(\"ELFMAINZe\")) { // ppc64 big-endian only\n        addLoader(\"ELFMAINZe\", nullptr);\n    }\n    addLoader(\"+40,ELFMAINZ\", nullptr);\n    if (hasLoaderSection(\"ANDMAJNZ\")) { // Android trouble with args to DT_INIT\n        if (is_asl) {\n            addLoader(\"ANDMAJNZ\", nullptr);  // constant PAGE_SIZE\n        }\n        else {\n            addLoader(\"ELFMAJNZ\", nullptr);  // PAGE_SIZE from AT_PAGESZ\n        }\n        addLoader(\"ELFMAKNZ\", nullptr);\n    }\n    if (hasLoaderSection(\"ELFMAINZu\")) {\n        addLoader(\"ELFMAINZu\", nullptr);\n    }\n    addLoader(\"FOLDEXEC\", nullptr);\n}\n\n\nvoid PackLinuxElf::defineSymbols(Filter const *)\n{\n    linker->defineSymbol(\"O_BINFO\", o_binfo\n       | ((!!opt->o_unix.is_ptinterp)     << 0)\n       | ((!!opt->o_unix.unmap_all_pages) << 1) );\n}\n\nvoid PackLinuxElf32::defineSymbols(Filter const *ft)\n{\n    PackLinuxElf::defineSymbols(ft);\n}\n\nvoid PackLinuxElf64::defineSymbols(Filter const *ft)\n{\n    PackLinuxElf::defineSymbols(ft);\n}\n\nPackLinuxElf32::PackLinuxElf32(InputFile *f)\n    : super(f), phdri(nullptr), shdri(nullptr),\n    n_phdrx(0), sz_phdrx(0),\n    page_mask(~0u<<lg2_page),\n    dynseg(nullptr), hashtab(nullptr), hashend(nullptr),\n                     gashtab(nullptr), gashend(nullptr), dynsym(nullptr),\n    jni_onload_sym(nullptr),\n    sec_strndx(nullptr), sec_dynsym(nullptr), sec_dynstr(nullptr)\n    , sec_arm_attr(nullptr)\n{\n    memset(&ehdri, 0, sizeof(ehdri));\n    n_jmp_slot = 0;\n    if (f) {\n        f->seek(0, SEEK_SET);\n        f->readx(&ehdri, sizeof(ehdri));\n    }\n}\n\nPackLinuxElf32::~PackLinuxElf32()\n{\n}\n\nvoid PackLinuxElf32::add_phdrx(Elf32_Phdr const *phdr)\n{\n    if (END_PHDRX <= n_phdrx) {\n        throwCantPack(\"too many Phdr %u\", (unsigned)(phdr - phdri));\n    }\n    phdrx[n_phdrx++] = phdr;\n}\n\nPackLinuxElf64::PackLinuxElf64(InputFile *f)\n    : super(f), phdri(nullptr), shdri(nullptr),\n    n_phdrx(0), sz_phdrx(0),\n    page_mask(~0ull<<lg2_page),\n    dynseg(nullptr), hashtab(nullptr), hashend(nullptr),\n                     gashtab(nullptr), gashend(nullptr), dynsym(nullptr),\n    jni_onload_sym(nullptr),\n    sec_strndx(nullptr), sec_dynsym(nullptr), sec_dynstr(nullptr)\n    , sec_arm_attr(nullptr)\n{\n    memset(&ehdri, 0, sizeof(ehdri));\n    n_jmp_slot = 0;\n    if (f) {\n        f->seek(0, SEEK_SET);\n        f->readx(&ehdri, sizeof(ehdri));\n    }\n}\n\nPackLinuxElf64::~PackLinuxElf64()\n{\n}\n\nvoid PackLinuxElf64::add_phdrx(Elf64_Phdr const *phdr)\n{\n    if (END_PHDRX <= n_phdrx) {\n        throwCantPack(\"too many Phdr %u\", (unsigned)(phdr - phdri));\n    }\n    phdrx[n_phdrx++] = phdr;\n}\n\n// FIXME: should be templated with PackLinuxElf32help1\nvoid\nPackLinuxElf64::PackLinuxElf64help1(InputFile *f)\n{\n    e_type  = get_te16(&ehdri.e_type);\n    e_phnum = get_te16(&ehdri.e_phnum);\n    e_shnum = get_te16(&ehdri.e_shnum);\n    unsigned const e_phentsize = get_te16(&ehdri.e_phentsize);\n    if (memcmp((char const *)&ehdri, \"\\x7f\\x45\\x4c\\x46\", 4)  // \"\\177ELF\"\n    || ehdri.e_ident[Elf64_Ehdr::EI_CLASS]!=Elf64_Ehdr::ELFCLASS64\n    || sizeof(Elf64_Phdr) != e_phentsize\n    || (Elf64_Ehdr::ELFDATA2MSB == ehdri.e_ident[Elf64_Ehdr::EI_DATA]\n            && &N_BELE_RTP::be_policy != bele)\n    || (Elf64_Ehdr::ELFDATA2LSB == ehdri.e_ident[Elf64_Ehdr::EI_DATA]\n            && &N_BELE_RTP::le_policy != bele)) {\n        e_phoff = 0;\n        e_shoff = 0;\n        sz_phdrs = 0;\n        return;\n    }\n    if (0==e_phnum) throwCantUnpack(\"0==e_phnum\");\n    e_phoff = get_te64(&ehdri.e_phoff);\n    upx_uint64_t const last_Phdr = e_phoff + e_phnum * sizeof(Elf64_Phdr);\n    if (last_Phdr < e_phoff  // wrap-around\n    ||  e_phoff != sizeof(Elf64_Ehdr)  // must be contiguous\n    ||  (unsigned long)file_size < last_Phdr) {\n        throwCantUnpack(\"bad e_phoff %p\", (void *)e_phoff);\n    }\n    e_shoff = get_te64(&ehdri.e_shoff);\n    upx_uint64_t const last_Shdr = e_shoff + e_shnum * sizeof(Elf64_Shdr);\n    if (last_Shdr < e_shoff  // wrap-around\n    ||  (e_shnum && e_shoff < last_Phdr)\n    ||  (unsigned long)file_size < last_Shdr) {\n        if (opt->cmd == CMD_COMPRESS) {\n            throwCantUnpack(\"bad e_shoff %p\", (void *)e_shoff);\n        }\n    }\n    sz_phdrs = e_phnum * e_phentsize;\n    sz_elf_hdrs = sz_phdrs + sizeof(Elf64_Ehdr) +\n        n_phdrx * sizeof(Elf32_Phdr);  // phdrx bodies later: ::generateElfHdr\n\n    if (f && Elf64_Ehdr::ET_DYN!=e_type) {\n        unsigned const len = file_size;  // (sz_phdrs + e_phoff) except --preserve-build-id\n        alloc_file_image(file_image, len);\n        f->seek(0, SEEK_SET);\n        f->readx(file_image, len);\n        phdri= (Elf64_Phdr       *)(e_phoff + file_image);  // do not free() !!\n    }\n    if (f && Elf64_Ehdr::ET_DYN==e_type) {\n        // The DT_SYMTAB has no designated length.  Read the whole file.\n        alloc_file_image(file_image, file_size);\n        f->seek(0, SEEK_SET);\n        f->readx(file_image, file_size);\n        phdri= (file_size <= (unsigned)e_phoff) ? nullptr : (Elf64_Phdr *)(e_phoff + file_image);  // do not free() !!\n        if (!(opt->cmd == CMD_COMPRESS && e_shoff < (upx_uint64_t)file_size && mb_shdr.getSize() == 0)) {\n            shdri = nullptr;\n        }\n        else if (e_shnum && e_shoff && ehdri.e_shentsize) {\n            fi->seek(e_shoff, SEEK_SET);\n            mb_shdr.alloc(   sizeof(Elf64_Shdr) * e_shnum);\n            shdri = (Elf64_Shdr *)mb_shdr.getVoidPtr();\n            fi->readx(shdri, sizeof(Elf64_Shdr) * e_shnum);\n        }\n        else {\n            shdri = nullptr;\n        }\n        sec_dynsym = elf_find_section_type(Elf64_Shdr::SHT_DYNSYM);\n        if (sec_dynsym) {\n            unsigned t = get_te32(&sec_dynsym->sh_link);\n            if (e_shnum <= t)\n                throwCantPack(\"bad dynsym->sh_link\");\n            sec_dynstr = &shdri[t];\n        }\n\n        Elf64_Phdr const *phdr= phdri;\n        for (int j = e_phnum; --j>=0; ++phdr)\n        if (Elf64_Phdr::PT_DYNAMIC==get_te32(&phdr->p_type)) {\n            upx_uint64_t offset = check_pt_dynamic(phdr);\n            dynseg= (Elf64_Dyn *)(offset + file_image);\n            invert_pt_dynamic(dynseg,\n                umin(get_te64(&phdr->p_filesz), file_size_u - offset));\n        }\n        else if (is_LOAD(phdr)) {\n            check_pt_load(phdr);\n        }\n        // elf_find_dynamic() returns 0 if 0==dynseg.\n        dynstr =          (char const *)elf_find_dynamic(Elf64_Dyn::DT_STRTAB);\n        dynsym = (Elf64_Sym /*const*/ *)elf_find_dynamic(Elf64_Dyn::DT_SYMTAB);\n        gashtab =     (unsigned const *)elf_find_dynamic(Elf64_Dyn::DT_GNU_HASH);\n        hashtab =     (unsigned const *)elf_find_dynamic(Elf64_Dyn::DT_HASH);\n        if (3& ((upx_uintptr_t)dynsym | (upx_uintptr_t)gashtab | (upx_uintptr_t)hashtab)) {\n            throwCantPack(\"unaligned DT_SYMTAB, DT_GNU_HASH, or DT_HASH/n\");\n        }\n        jni_onload_sym = elf_lookup(\"JNI_OnLoad\");\n        if (jni_onload_sym) {\n            jni_onload_va = get_te64(&jni_onload_sym->st_value);\n            jni_onload_va = 0;  // FIXME not understood; need example\n        }\n    }\n}\n\nLinker* PackLinuxElf64amd::newLinker() const\n{\n    return new ElfLinkerAMD64;\n}\n\nLinker* PackLinuxElf64arm::newLinker() const\n{\n    return new ElfLinkerArm64LE;\n}\n\nint const *\nPackLinuxElf::getCompressionMethods(int method, int level) const\n{\n    // No real dependency on LE32.\n    return Packer::getDefaultCompressionMethods_le32(method, level);\n}\n\nint const *\nPackLinuxElf32armLe::getCompressionMethods(int method, int level) const\n{\n    return Packer::getDefaultCompressionMethods_8(method, level);\n}\n\nint const *\nPackLinuxElf32armBe::getCompressionMethods(int method, int level) const\n{\n    return Packer::getDefaultCompressionMethods_8(method, level);\n}\n\nint const *\nPackLinuxElf32ppc::getFilters() const\n{\n    static const int filters[] = {\n        0xd0,\n    FT_END };\n    return filters;\n}\n\nint const *\nPackLinuxElf64ppcle::getFilters() const\n{\n    static const int filters[] = {\n        0xd0,\n    FT_END };\n    return filters;\n}\n\nint const *\nPackLinuxElf64ppc::getFilters() const\n{\n    static const int filters[] = {\n        0xd0,\n    FT_END };\n    return filters;\n}\n\nint const *\nPackLinuxElf64amd::getFilters() const\n{\n    static const int filters[] = {\n        0x49,\n    FT_END };\n    return filters;\n}\n\nint const *\nPackLinuxElf64arm::getFilters() const\n{\n    static const int filters[] = {\n        0x52,\n    FT_END };\n    return filters;\n}\n\nvoid PackLinuxElf32::patchLoader()\n{\n}\n\nvoid PackLinuxElf64::patchLoader()\n{\n}\n\nvoid PackLinuxElf32::ARM_updateLoader(OutputFile * /*fo*/)\n{\n    set_te32(&elfout.ehdr.e_entry, sz_pack2 +\n        linker->getSymbolOffset(\"_start\") +\n        get_te32(&elfout.phdr[C_TEXT].p_vaddr));\n}\n\nvoid PackLinuxElf32armLe::updateLoader(OutputFile *fo)\n{\n    ARM_updateLoader(fo);\n}\n\nvoid PackLinuxElf32armBe::updateLoader(OutputFile *fo)\n{\n    ARM_updateLoader(fo);\n}\n\nvoid PackLinuxElf32mipsel::updateLoader(OutputFile *fo)\n{\n    ARM_updateLoader(fo);  // not ARM specific; (no 32-bit immediates)\n}\n\nvoid PackLinuxElf32mipseb::updateLoader(OutputFile *fo)\n{\n    ARM_updateLoader(fo);  // not ARM specific; (no 32-bit immediates)\n}\n\nvoid PackLinuxElf32::updateLoader(OutputFile * /*fo*/)\n{\n    unsigned start = linker->getSymbolOffset(\"_start\");\n    unsigned vbase = get_te32(&elfout.phdr[C_TEXT].p_vaddr);\n    set_te32(&elfout.ehdr.e_entry, start + sz_pack2 + vbase);\n}\n\nvoid PackLinuxElf64::updateLoader(OutputFile * /*fo*/)\n{\n    if (xct_off) {\n        return;  // FIXME elfout has no values at all\n    }\n    upx_uint64_t const vbase = get_te64(&elfout.phdr[C_TEXT].p_vaddr);\n    unsigned start = linker->getSymbolOffset(\"_start\");\n\n    if (get_te16(&elfout.ehdr.e_machine)==Elf64_Ehdr::EM_PPC64\n    &&  elfout.ehdr.e_ident[Elf64_Ehdr::EI_DATA]==Elf64_Ehdr::ELFDATA2MSB) {\n        unsigned descr = linker->getSymbolOffset(\"entry_descr\");\n\n        // External relocation of PPC64 function descriptor.\n        upx_uint64_t dot_entry = start + sz_pack2 + vbase;\n        upx_byte *p = getLoader();\n\n        set_te64(&p[descr], dot_entry);\n        // Kernel 3.16.0 (2017-09-19) uses start, not descr\n        set_te64(&elfout.ehdr.e_entry, start + sz_pack2 + vbase);\n    }\n    else {\n        set_te64(&elfout.ehdr.e_entry, start + sz_pack2 + vbase);\n    }\n}\n\nPackLinuxElf32ppc::PackLinuxElf32ppc(InputFile *f)\n    : super(f)\n{\n    e_machine = Elf32_Ehdr::EM_PPC;\n    ei_class  = Elf32_Ehdr::ELFCLASS32;\n    ei_data   = Elf32_Ehdr::ELFDATA2MSB;\n    ei_osabi  = Elf32_Ehdr::ELFOSABI_LINUX;\n}\n\nPackLinuxElf32ppc::~PackLinuxElf32ppc()\n{\n}\n\nLinker* PackLinuxElf32ppc::newLinker() const\n{\n    return new ElfLinkerPpc32;\n}\n\nPackLinuxElf64ppcle::PackLinuxElf64ppcle(InputFile *f)\n    : super(f), lg2_page(16), page_size(1u<<lg2_page)\n{\n    e_machine = Elf64_Ehdr::EM_PPC64;\n    ei_class  = Elf64_Ehdr::ELFCLASS64;\n    ei_data   = Elf64_Ehdr::ELFDATA2LSB;\n    ei_osabi  = Elf64_Ehdr::ELFOSABI_LINUX;\n}\n\nPackLinuxElf64ppc::PackLinuxElf64ppc(InputFile *f)\n    : super(f), lg2_page(16), page_size(1u<<lg2_page)\n{\n    e_machine = Elf64_Ehdr::EM_PPC64;\n    ei_class  = Elf64_Ehdr::ELFCLASS64;\n    ei_data   = Elf64_Ehdr::ELFDATA2MSB;\n    ei_osabi  = Elf32_Ehdr::ELFOSABI_LINUX;\n}\n\nPackLinuxElf64ppcle::~PackLinuxElf64ppcle()\n{\n}\n\nPackLinuxElf64ppc::~PackLinuxElf64ppc()\n{\n}\n\nLinker* PackLinuxElf64ppcle::newLinker() const\n{\n    return new ElfLinkerPpc64le;\n}\n\nLinker* PackLinuxElf64ppc::newLinker() const\n{\n    return new ElfLinkerPpc64;\n}\n\nPackLinuxElf64amd::PackLinuxElf64amd(InputFile *f)\n    : super(f)\n{\n    // Why did PackLinuxElf64Le set lg2_page = 16 ?\n    // It causes trouble for check_pt_dynamic() from canPack().\n    lg2_page = 12;  page_size = 1u<<lg2_page;\n    e_machine = Elf64_Ehdr::EM_X86_64;\n    ei_class = Elf64_Ehdr::ELFCLASS64;\n    ei_data = Elf64_Ehdr::ELFDATA2LSB;\n    ei_osabi  = Elf32_Ehdr::ELFOSABI_LINUX;\n}\n\nPackLinuxElf64arm::PackLinuxElf64arm(InputFile *f)\n    : super(f)\n{\n    e_machine = Elf64_Ehdr::EM_AARCH64;\n    ei_class = Elf64_Ehdr::ELFCLASS64;\n    ei_data = Elf64_Ehdr::ELFDATA2LSB;\n    ei_osabi  = Elf32_Ehdr::ELFOSABI_LINUX;\n}\n\nPackLinuxElf64amd::~PackLinuxElf64amd()\n{\n}\n\nPackLinuxElf64arm::~PackLinuxElf64arm()\n{\n}\n\nvoid PackLinuxElf32x86::addStubEntrySections(Filter const *ft, unsigned m_decompr)\n{\n    (void)m_decompr;  // FIXME\n    int const n_mru = ft->n_mru;  // FIXME: belongs to filter? packerf?\n\n// Rely on \"+80CXXXX\" [etc] in getDecompressorSections() packer_c.cpp */\n//    // Here is a quick summary of the format of the output file:\n//    linker->setLoaderAlignOffset(\n//            // Elf32_Ehdr\n//        sizeof(elfout.ehdr) +\n//            // Elf32_Phdr: 1 for exec86, 2 for sh86, 3 for elf86\n//        (get_te16(&elfout.ehdr.e_phentsize) * get_te16(&elfout.ehdr.e_phnum)) +\n//            // checksum UPX! lsize version format\n//        sizeof(l_info) +\n//            // PT_DYNAMIC with DT_NEEDED \"forwarded\" from original file\n//        ((get_te16(&elfout.ehdr.e_phnum)==3)\n//            ? (unsigned) get_te32(&elfout.phdr[C_NOTE].p_memsz)\n//            : 0) +\n//            // p_progid, p_filesize, p_blocksize\n//        sizeof(p_info) +\n//            // compressed data\n//        b_len + ph.c_len );\n\n            // entry to stub\n    addLoader(\"LEXEC000\", nullptr);\n\n    if (ft->id) {\n        { // decompr, unfilter are separate\n            addLoader(\"LXUNF000\", nullptr);\n            addLoader(\"LXUNF002\", nullptr);\n                if (0x80==(ft->id & 0xF0)) {\n                    if (256==n_mru) {\n                        addLoader(\"MRUBYTE0\", nullptr);\n                    }\n                    else if (n_mru) {\n                        addLoader(\"LXMRU005\", nullptr);\n                    }\n                    if (n_mru) {\n                        addLoader(\"LXMRU006\", nullptr);\n                    }\n                    else {\n                        addLoader(\"LXMRU007\", nullptr);\n                    }\n            }\n            else if (0x40==(ft->id & 0xF0)) {\n                addLoader(\"LXUNF008\", nullptr);\n            }\n            addLoader(\"LXUNF010\", nullptr);\n        }\n        if (n_mru) {\n            addLoader(\"LEXEC009\", nullptr);\n        }\n    }\n    addLoader(\"LEXEC010\", nullptr);\n    addLoader(getDecompressorSections(), nullptr);\n    addLoader(\"LEXEC015\", nullptr);\n    if (ft->id) {\n        {  // decompr, unfilter are separate\n            if (0x80!=(ft->id & 0xF0)) {\n                addLoader(\"LXUNF042\", nullptr);\n            }\n        }\n        addFilter32(ft->id);\n        { // decompr, unfilter are separate\n            if (0x80==(ft->id & 0xF0)) {\n                if (0==n_mru) {\n                    addLoader(\"LXMRU058\", nullptr);\n                }\n            }\n            addLoader(\"LXUNF035\", nullptr);\n        }\n    }\n    else {\n        addLoader(\"LEXEC017\", nullptr);\n    }\n\n    addLoader(\"IDENTSTR\", nullptr);\n    addLoader(\"+40,LEXEC020\", nullptr);\n    addLoader(\"FOLDEXEC\", nullptr);\n}\n\nvoid PackLinuxElf32x86::defineSymbols(Filter const *const ft)\n{\n    PackLinuxElf32::defineSymbols(ft);\n\n    if (0x80==(ft->id & 0xF0)) {\n        int const mru = ft->n_mru ? 1+ ft->n_mru : 0;\n        if (mru && mru!=256) {\n            unsigned const is_pwr2 = (0==((mru -1) & mru));\n            linker->defineSymbol(\"NMRU\", mru - is_pwr2);\n        }\n    }\n}\n\nvoid\nPackLinuxElf32::buildLinuxLoader(\n    upx_byte const *const proto,\n    unsigned        const szproto,\n    upx_byte const *const fold,\n    unsigned        const szfold,\n    Filter const *ft\n)\n{\n    MemBuffer mb_cprLoader;\n    unsigned sz_cpr = 0;\n    unsigned sz_unc = 0;\n    unsigned method = 0;\n    upx_byte const *uncLoader = nullptr;\n\n  if (0 < szfold) {\n    if (xct_off // shlib\n      && (  this->e_machine==Elf32_Ehdr::EM_ARM\n         || this->e_machine==Elf32_Ehdr::EM_386)\n    ) {\n        initLoader(fold, szfold);\n// Typical layout of 'sections' in compressed stub code for shared library:\n//   SO_HEAD\n//   ptr_NEXT\n//   EXP_HEAD  NRV getbit(), copy\n//   NRV2B etc: daisy chain of de-compressor for each method used\n//   EXP_TAIL  FIXME: unfilter\n//   SO_TAIL\n//   SO_MAIN  C-language supervision based on PT_LOADs\n        char sec[200]; memset(sec, 0, sizeof(sec));  // debug convenience\n        int len = 0;\n        unsigned m_decompr = methods_used | (1u << (0xFF & ph_forced_method(ph.method)));\n        len += snprintf(sec, sizeof(sec), \"%s\", \"SO_HEAD,ptr_NEXT,EXP_HEAD\");\n\n        // Start of dasiy-chain fall-through.\n        if (((1u<<M_NRV2B_LE32)|(1u<<M_NRV2B_8)|(1u<<M_NRV2B_LE16)) & m_decompr) {\n            len += snprintf(&sec[len], sizeof(sec) - len, \",%s\", \"NRV2B\");\n        }\n        if (((1u<<M_NRV2D_LE32)|(1u<<M_NRV2D_8)|(1u<<M_NRV2D_LE16)) & m_decompr) {\n            len += snprintf(&sec[len], sizeof(sec) - len, \",%s\", \"NRV2D\");\n        }\n        if (((1u<<M_NRV2E_LE32)|(1u<<M_NRV2E_8)|(1u<<M_NRV2E_LE16)) & m_decompr) {\n            len += snprintf(&sec[len], sizeof(sec) - len, \",%s\", \"NRV2E\");\n        }\n        if (((1u<<M_LZMA)) & m_decompr) {\n            len += snprintf(&sec[len], sizeof(sec) - len, \",%s\",\n                \"LZMA_DAISY,LZMA_ELF00,LZMA_DEC20,LZMA_DEC30\");\n        }\n        len += snprintf(&sec[len], sizeof(sec) - len, \",%s\", \"EXP_TAIL\");\n        // End of daisy-chain fall-through.\n\n        // MIPS directly calls memfd_create\n        if (this->e_machine != Elf32_Ehdr::EM_MIPS) {\n            len += snprintf(&sec[len], sizeof(sec) - len, \",%s\",\n                (sec_arm_attr || is_asl)\n                    ? \"HUMF_A,UMF_ANDROID\"\n                    : \"HUMF_L,UMF_LINUX\");\n        }\n        if (hasLoaderSection(\"STRCON\")) {\n            len += snprintf(&sec[len], sizeof(sec) - len, \",%s\", \"STRCON\");\n        }\n        len += snprintf(&sec[len], sizeof(sec) - len, \",%s\", \"SO_TAIL,SO_MAIN\");\n        (void)len;  // Pacify the anal-retentive static analyzer which hates a good idiom.\n        NO_printf(\"\\n%s\\n\", sec);\n        addLoader(sec, nullptr);\n        relocateLoader();\n        {\n            int sz_unc_int;\n            uncLoader = linker->getLoader(&sz_unc_int);\n            sz_unc = sz_unc_int;\n        }\n        method = M_NRV2B_LE32;  // requires unaligned fetch\n        if (this->e_machine==Elf32_Ehdr::EM_ARM)\n            method = M_NRV2B_8;  //only ARM v6 and above has unaligned fetch\n    } // end shlib (folded portion)\n    else if (this->e_machine==Elf32_Ehdr::EM_386\n         ||  this->e_machine==Elf32_Ehdr::EM_ARM\n         ||  this->e_machine==Elf32_Ehdr::EM_PPC\n         ||  this->e_machine==Elf32_Ehdr::EM_MIPS\n         ) { // main program with ELF2 de-compressor (folded portion)\n        initLoader(fold, szfold);\n        char sec[200]; memset(sec, 0, sizeof(sec));  // debug convenience\n        int len = 0;\n        unsigned m_decompr = methods_used | (1u << (0xFF & ph_forced_method(ph.method)));\n        len += snprintf(sec, sizeof(sec), \"%s\", \".text,EXP_HEAD\");\n        if (((1u<<M_NRV2B_LE32)|(1u<<M_NRV2B_8)|(1u<<M_NRV2B_LE16)) & m_decompr) {\n            len += snprintf(&sec[len], sizeof(sec) - len, \",%s\", \"NRV2B\");\n        }\n        if (((1u<<M_NRV2D_LE32)|(1u<<M_NRV2D_8)|(1u<<M_NRV2D_LE16)) & m_decompr) {\n            len += snprintf(&sec[len], sizeof(sec) - len, \",%s\", \"NRV2D\");\n        }\n        if (((1u<<M_NRV2E_LE32)|(1u<<M_NRV2E_8)|(1u<<M_NRV2E_LE16)) & m_decompr) {\n            len += snprintf(&sec[len], sizeof(sec) - len, \",%s\", \"NRV2E\");\n        }\n        if (((1u<<M_LZMA)) & m_decompr) {\n            len += snprintf(&sec[len], sizeof(sec) - len, \",%s\",\n                \"LZMA_DAISY,LZMA_ELF00,LZMA_DEC20,LZMA_DEC30\");\n        }\n        len += snprintf(&sec[len], sizeof(sec) - len, \",%s\", \"EXP_TAIL\");\n\n        // $ARCH-linux.elf-main2.c calls upx_mmap_and_fd, not direct memfd_create\n        len += snprintf(&sec[len], sizeof(sec) - len, \",%s\",\n            (sec_arm_attr || is_asl)\n                ? \"HUMF_A,UMF_ANDROID\"\n                : \"HUMF_L,UMF_LINUX\");\n        if (hasLoaderSection(\"SYSCALLS\")) {\n            len += snprintf(&sec[len], sizeof(sec) - len, \",%s\", \"SYSCALLS\");\n        }\n        (void)len;  // Pacify the anal-retentive static analyzer which hates a good idiom.\n        NO_printf(\"\\n%s\\n\", sec);\n        addLoader(sec, nullptr);\n        relocateLoader();\n        {\n            int sz_unc_int;\n            uncLoader = linker->getLoader(&sz_unc_int);\n            sz_unc = sz_unc_int;\n        }\n        method = M_NRV2B_LE32;  // requires unaligned fetch\n        if (this->e_machine==Elf32_Ehdr::EM_ARM)\n            method = M_NRV2B_8;  //only ARM v6 and above has unaligned fetch\n    }\n    else { // main program with ELF1 de-compressor (folded portion)\n        cprElfHdr1 const *const hf = (cprElfHdr1 const *)fold;\n        unsigned fold_hdrlen = usizeof(hf->ehdr) +\n            get_te16(&hf->ehdr.e_phentsize) * get_te16(&hf->ehdr.e_phnum);\n        if (this->e_machine==Elf32_Ehdr::EM_MIPS) {\n            fold_hdrlen = upx::umax(fold_hdrlen, (unsigned)0x80);\n        }\n        uncLoader = fold_hdrlen + fold;\n        sz_unc = ((szfold < fold_hdrlen) ? 0 : (szfold - fold_hdrlen));\n        method = ph.method;\n    }\n\n    struct b_info h; memset(&h, 0, sizeof(h));\n    h.b_method = method;\n    // _Ehdr and _Phdr are NOT filtered, so Leave h.b_ftid and h.b_cto8 as zero.\n\n    mb_cprLoader.allocForCompression(sizeof(h) + sz_unc);\n    unsigned char *const cprLoader = (unsigned char *)mb_cprLoader;  // less typing\n\n    h.sz_unc = sz_unc;\n    h.sz_cpr = mb_cprLoader.getSize();  // max that upx_compress may use\n    {\n        int r = upx_compress(uncLoader, sz_unc, sizeof(h) + cprLoader, &sz_cpr,\n            nullptr, ph_forced_method(method), 10, nullptr, nullptr );\n        h.sz_cpr = sz_cpr;  // actual length used\n        if (r != UPX_E_OK || h.sz_cpr >= h.sz_unc)\n            throwInternalError(\"loader compression failed\");\n    }\n    set_te32(&h.sz_cpr, h.sz_cpr);\n    set_te32(&h.sz_unc, h.sz_unc);\n    memcpy(cprLoader, &h, sizeof(h)); // cprLoader will become FOLDEXEC\n  }  // end (0 < szfold)\n\n    initLoader(proto, szproto, -1, sz_cpr);\n    NO_printf(\"FOLDEXEC unc=%#x  cpr=%#x\\n\", sz_unc, sz_cpr);\n    linker->addSection(\"FOLDEXEC\", mb_cprLoader, sizeof(b_info) + sz_cpr, 0);\n    if (xct_off  // shlib\n       && (this->e_machine==Elf32_Ehdr::EM_NONE\n          || this->e_machine==Elf32_Ehdr::EM_386\n          || this->e_machine==Elf32_Ehdr::EM_ARM\n          || this->e_machine==Elf32_Ehdr::EM_PPC\n          || this->e_machine==Elf32_Ehdr::EM_MIPS\n          )\n    ) { // shlib with ELF2 de-compressor\n        addLoader(\"ELFMAINX\");\n        addLoader((sec_arm_attr || is_asl)\n            ? \"HUMF_A,UMF_ANDROID\"\n            : \"HUMF_L,UMF_LINUX\");\n        addLoader(\"ELFMAINZ,FOLDEXEC,IDENTSTR\");\n    }\n    else if (this->e_machine==Elf32_Ehdr::EM_NONE\n          || this->e_machine==Elf32_Ehdr::EM_386\n          || this->e_machine==Elf32_Ehdr::EM_ARM\n          || this->e_machine==Elf32_Ehdr::EM_PPC\n          || this->e_machine==Elf32_Ehdr::EM_MIPS\n      ) { // main program with ELF2 de-compressor\n        addLoader(\"ELFMAINX\");\n        if (this->e_machine==Elf32_Ehdr::EM_ARM) { // hardware is more problematic\n            if (opt->o_unix.catch_sigsegv && hasLoaderSection(\"ELFSIGSEGV\"))\n                addLoader(\"ELFSIGSEGV\");\n            addLoader(\"ELFMAINX2\");\n        }\n        // Only if $ARCH-linux.elf-entry.S calls upx_mmap_and_fd instead of memfd_create\n        if (this->e_machine != Elf32_Ehdr::EM_PPC\n        &&  this->e_machine != Elf32_Ehdr::EM_MIPS)\n            addLoader((sec_arm_attr || is_asl)\n                ? \"HUMF_A,UMF_ANDROID\"\n                : \"HUMF_L,UMF_LINUX\");\n        addLoader(\"ELFMAINZ,FOLDEXEC,IDENTSTR\");\n            defineSymbols(ft);\n    }\n    else { // main program with ELF1 de-compressor\n        addStubEntrySections(ft, methods_used | (1u << (0xFF & ph_forced_method(ph.method))) );\n        if (!xct_off) { // main program\n            defineSymbols(ft);\n        }\n    }\n    relocateLoader();\n}\n\nvoid\nPackLinuxElf64::buildLinuxLoader(\n    upx_byte const *const proto,\n    unsigned        const szproto,\n    upx_byte const *const fold,\n    unsigned        const szfold,\n    Filter const *ft\n)\n{\n    MemBuffer mb_cprLoader;\n    unsigned sz_cpr = 0;\n    unsigned sz_unc = 0;\n    unsigned method = 0;\n    upx_byte const *uncLoader = nullptr;\n\n  if (0 < szfold) {\n    if (xct_off // shlib\n      && (  this->e_machine==Elf64_Ehdr::EM_X86_64\n         || this->e_machine==Elf64_Ehdr::EM_AARCH64)\n    ) {\n        initLoader(fold, szfold);\n// Typical layout of 'sections' in compressed stub code for shared library:\n//   SO_HEAD\n//   ptr_NEXT\n//   EXP_HEAD  NRV getbit(), copy\n//   NRV2B etc: daisy chain of de-compressor for each method used\n//   EXP_TAIL  FIXME: unfilter\n//   SO_TAIL\n//   SO_MAIN  C-language supervision based on PT_LOADs\n        char sec[200]; memset(sec, 0, sizeof(sec));  // debug convenience\n        int len = 0;\n        unsigned m_decompr = methods_used | (1u << (0xFF & ph_forced_method(ph.method)));\n        len += snprintf(sec, sizeof(sec), \"%s\", \"SO_HEAD,ptr_NEXT,EXP_HEAD\");\n\n        // Start of dasiy-chain fall-through.\n        if (((1u<<M_NRV2B_LE32)|(1u<<M_NRV2B_8)|(1u<<M_NRV2B_LE16)) & m_decompr) {\n            len += snprintf(&sec[len], sizeof(sec) - len, \",%s\", \"NRV2B\");\n        }\n        if (((1u<<M_NRV2D_LE32)|(1u<<M_NRV2D_8)|(1u<<M_NRV2D_LE16)) & m_decompr) {\n            len += snprintf(&sec[len], sizeof(sec) - len, \",%s\", \"NRV2D\");\n        }\n        if (((1u<<M_NRV2E_LE32)|(1u<<M_NRV2E_8)|(1u<<M_NRV2E_LE16)) & m_decompr) {\n            len += snprintf(&sec[len], sizeof(sec) - len, \",%s\", \"NRV2E\");\n        }\n        if (((1u<<M_LZMA)) & m_decompr) {\n            len += snprintf(&sec[len], sizeof(sec) - len, \",%s\",\n                \"LZMA_DAISY,LZMA_ELF00,LZMA_DEC20,LZMA_DEC30\");\n        }\n        len += snprintf(&sec[len], sizeof(sec) - len, \",%s\", \"EXP_TAIL\");\n        // End of daisy-chain fall-through.\n\n        // Android on EM_AARCH64 has memfd_create(), so UMF_ANDROID not needed.\n        len += snprintf(&sec[len], sizeof(sec) - len, \",%s\", \"HUMF_L,UMF_LINUX\");\n        if (hasLoaderSection(\"STRCON\")) {\n            len += snprintf(&sec[len], sizeof(sec) - len, \",%s\", \"STRCON\");\n        }\n        len += snprintf(&sec[len], sizeof(sec) - len, \",%s\", \"SO_TAIL,SO_MAIN\");\n        (void)len;  // Pacify the anal-retentive static analyzer which hates a good idiom.\n        NO_printf(\"\\n%s\\n\", sec);\n        addLoader(sec, nullptr);\n        relocateLoader();\n        {\n            int sz_unc_int;\n            uncLoader = linker->getLoader(&sz_unc_int);\n            sz_unc = sz_unc_int;\n        }\n        method = M_NRV2B_LE32;  // requires unaligned fetch\n    }\n    else if (this->e_machine==Elf32_Ehdr::EM_NONE\n         ||  this->e_machine==Elf64_Ehdr::EM_X86_64\n         ||  this->e_machine==Elf64_Ehdr::EM_AARCH64\n         ||  this->e_machine==Elf64_Ehdr::EM_PPC64\n         ) { // main program with ELF2 de-compressor (folded portion)\n        initLoader(fold, szfold);\n        char sec[200]; memset(sec, 0, sizeof(sec));  // debug convenience\n        int len = 0;\n        unsigned m_decompr = methods_used | (1u << (0xFF & ph_forced_method(ph.method)));\n        len += snprintf(sec, sizeof(sec), \"%s\", \".text,EXP_HEAD\");\n        if (((1u<<M_NRV2B_LE32)|(1u<<M_NRV2B_8)|(1u<<M_NRV2B_LE16)) & m_decompr) {\n            len += snprintf(&sec[len], sizeof(sec) - len, \",%s\", \"NRV2B\");\n        }\n        if (((1u<<M_NRV2D_LE32)|(1u<<M_NRV2D_8)|(1u<<M_NRV2D_LE16)) & m_decompr) {\n            len += snprintf(&sec[len], sizeof(sec) - len, \",%s\", \"NRV2D\");\n        }\n        if (((1u<<M_NRV2E_LE32)|(1u<<M_NRV2E_8)|(1u<<M_NRV2E_LE16)) & m_decompr) {\n            len += snprintf(&sec[len], sizeof(sec) - len, \",%s\", \"NRV2E\");\n        }\n        if (((1u<<M_LZMA)) & m_decompr) {\n            len += snprintf(&sec[len], sizeof(sec) - len, \",%s\",\n                \"LZMA_DAISY,LZMA_ELF00,LZMA_DEC20,LZMA_DEC30\");\n        }\n        len += snprintf(&sec[len], sizeof(sec) - len, \",%s\", \"EXP_TAIL\");\n        if (hasLoaderSection(\"SYSCALLS\")) {\n            len += snprintf(&sec[len], sizeof(sec) - len, \",%s\", \"SYSCALLS\");\n        }\n        if (hasLoaderSection(\"STRCON\")) {\n            len += snprintf(&sec[len], sizeof(sec) - len, \",%s\", \"STRCON\");\n        }\n        (void)len;\n        NO_printf(\"\\n%s\\n\", sec);\n        addLoader(sec, nullptr);\n        relocateLoader();\n        {\n            int sz_unc_int;\n            uncLoader = linker->getLoader(&sz_unc_int);\n            sz_unc = sz_unc_int;\n        }\n        method = M_NRV2B_LE32;  // requires unaligned fetch\n    }\n    else { // not shlib: main program with ELF1 de-compressor\n        cprElfHdr1 const *hf = (cprElfHdr1 const *)fold;\n        e_type = get_te16(&hf->ehdr.e_type);\n        if (ET_REL == e_type) {\n            initLoader(fold, szfold);\n            addLoader(\".text\", nullptr);\n            relocateLoader();\n            int sz_unc_int(0);\n            uncLoader = linker->getLoader(&sz_unc_int);\n            sz_unc = sz_unc_int;\n        }\n        else if (ET_EXEC == e_type) {\n            hf = (cprElfHdr1 const *)fold;\n            unsigned fold_hdrlen = usizeof(hf->ehdr) +\n                get_te16(&hf->ehdr.e_phentsize) * get_te16(&hf->ehdr.e_phnum);\n            if (this->e_machine==Elf64_Ehdr::EM_X86_64) {\n                fold_hdrlen = get_te64(&hf->ehdr.e_entry);\n            }\n            uncLoader = &fold[fold_hdrlen];\n            sz_unc = ((szfold < fold_hdrlen) ? 0 : (szfold - fold_hdrlen));\n        }\n        method = ph.method;\n    }\n\n    struct b_info h; memset(&h, 0, sizeof(h));\n    h.b_method = method;\n    // _Ehdr and _Phdr are NOT filtered, so Leave h.b_ftid and h.b_cto8 as zero.\n\n    mb_cprLoader.allocForCompression(sizeof(h) + sz_unc);\n    unsigned char *const cprLoader = (unsigned char *)mb_cprLoader;  // less typing\n\n    h.sz_unc = sz_unc;\n    h.sz_cpr = mb_cprLoader.getSize();  // max that upx_compress may use\n    {\n        int r = upx_compress(uncLoader, sz_unc, sizeof(h) + cprLoader, &sz_cpr,\n            nullptr, ph_forced_method(method), 10, nullptr, nullptr );\n        h.sz_cpr = sz_cpr;  // actual length used\n        if (r != UPX_E_OK || h.sz_cpr >= h.sz_unc)\n            throwInternalError(\"loader compression failed\");\n    }\n    set_te32(&h.sz_cpr, h.sz_cpr);\n    set_te32(&h.sz_unc, h.sz_unc);\n    memcpy(cprLoader, &h, sizeof(h)); // cprLoader will become FOLDEXEC\n  }  // end (0 < szfold)\n\n    initLoader(proto, szproto, -1, sz_cpr);\n    NO_printf(\"FOLDEXEC unc=%#x  cpr=%#x\\n\", sz_unc, sz_cpr);\n    linker->addSection(\"FOLDEXEC\", mb_cprLoader, sizeof(b_info) + sz_cpr, 0);\n    if (xct_off\n       && (this->e_machine==Elf64_Ehdr::EM_NONE\n          || this->e_machine==Elf64_Ehdr::EM_X86_64\n          || this->e_machine==Elf64_Ehdr::EM_AARCH64\n          || this->e_machine==Elf64_Ehdr::EM_PPC64\n          )\n    ) {\n        addLoader(\"ELFMAINX,ELFMAINZ,FOLDEXEC,IDENTSTR\");\n    } // shlib\n    else if (this->e_machine==Elf32_Ehdr::EM_NONE\n         ||  this->e_machine==Elf64_Ehdr::EM_X86_64\n         ||  this->e_machine==Elf64_Ehdr::EM_AARCH64\n         ||  this->e_machine==Elf64_Ehdr::EM_PPC64\n        ) { // main program with ELF2 de-compressor\n        addLoader(\"ELFMAINX\");\n        // NYI for PPC64 {\n        if (opt->o_unix.catch_sigsegv && hasLoaderSection(\"ELFSIGSEGV\"))\n            addLoader(\"ELFSIGSEGV\");\n        if (this->e_machine!=Elf64_Ehdr::EM_PPC64)\n            addLoader(\"ELFMAINX2\");\n        // } end NYI for PPC64\n        addLoader(\"ELFMAINZ,FOLDEXEC,IDENTSTR\");\n        if (this->e_machine==Elf64_Ehdr::EM_PPC64\n        &&  ehdri.e_ident[Elf64_Ehdr::EI_DATA]==Elf64_Ehdr::ELFDATA2MSB) {\n            addLoader(\"ELFMAINZe\");\n        }\n        if (!xct_off) { // main program\n            defineSymbols(ft);\n        }\n    }\n    else { // main program with ELF1 de-compressor\n        addStubEntrySections(ft, methods_used | (1u << (0xFF & ph_forced_method(ph.method))) );\n        if (!xct_off) { // main program\n            defineSymbols(ft);\n        }\n    }\n    relocateLoader();\n}\n\nvoid\nPackLinuxElf64amd::defineSymbols(Filter const *ft)\n{\n    PackLinuxElf64::defineSymbols(ft);\n}\n\nstatic const CLANG_FORMAT_DUMMY_STATEMENT\n#include \"stub/i386-linux.elf-entry.h\"\nstatic const CLANG_FORMAT_DUMMY_STATEMENT\n#include \"stub/i386-linux.elf-so_entry.h\"\nstatic const CLANG_FORMAT_DUMMY_STATEMENT\n#include \"stub/i386-linux.elf-fold.h\"\nstatic const CLANG_FORMAT_DUMMY_STATEMENT\n#include \"stub/i386-linux.elf-so_fold.h\"\nstatic const CLANG_FORMAT_DUMMY_STATEMENT\n#include \"stub/i386-linux.shlib-init.h\"\n\nvoid\nPackLinuxElf32x86::buildLoader(const Filter *ft)\n{\n    if (0!=xct_off) {  // shared library\n        buildLinuxLoader(\n            stub_i386_linux_elf_so_entry, sizeof(stub_i386_linux_elf_so_entry),\n            stub_i386_linux_elf_so_fold,  sizeof(stub_i386_linux_elf_so_fold), ft);\n        return;\n    }\n    unsigned char tmp[sizeof(stub_i386_linux_elf_fold)];\n    memcpy(tmp, stub_i386_linux_elf_fold, sizeof(stub_i386_linux_elf_fold));\n    checkPatch(nullptr, 0, 0, 0);  // reset\n    if (opt->o_unix.is_ptinterp) {\n        unsigned j;\n        for (j = 0; j < sizeof(stub_i386_linux_elf_fold)-1; ++j) {\n            if (0x60==tmp[  j]\n            &&  0x47==tmp[1+j] ) {\n                /* put INC EDI before PUSHA: inhibits auxv_up for PT_INTERP */\n                tmp[  j] = 0x47;\n                tmp[1+j] = 0x60;\n                break;\n            }\n        }\n    }\n    buildLinuxLoader(\n        stub_i386_linux_elf_entry, sizeof(stub_i386_linux_elf_entry),\n        tmp,                       sizeof(stub_i386_linux_elf_fold),  ft );\n}\n\nstatic const CLANG_FORMAT_DUMMY_STATEMENT\n#include \"stub/i386-bsd.elf-entry.h\"\nstatic const CLANG_FORMAT_DUMMY_STATEMENT\n#include \"stub/i386-bsd.elf-fold.h\"\n\nvoid\nPackBSDElf32x86::buildLoader(const Filter *ft)\n{\n    unsigned char tmp[sizeof(stub_i386_bsd_elf_fold)];\n    memcpy(tmp, stub_i386_bsd_elf_fold, sizeof(stub_i386_bsd_elf_fold));\n    checkPatch(nullptr, 0, 0, 0);  // reset\n    if (opt->o_unix.is_ptinterp) {\n        unsigned j;\n        for (j = 0; j < sizeof(stub_i386_bsd_elf_fold)-1; ++j) {\n            if (0x60==tmp[  j]\n            &&  0x47==tmp[1+j] ) {\n                /* put INC EDI before PUSHA: inhibits auxv_up for PT_INTERP */\n                tmp[  j] = 0x47;\n                tmp[1+j] = 0x60;\n                break;\n            }\n        }\n    }\n    buildLinuxLoader(\n        stub_i386_bsd_elf_entry, sizeof(stub_i386_bsd_elf_entry),\n        tmp,                     sizeof(stub_i386_bsd_elf_fold), ft);\n}\n\nstatic const CLANG_FORMAT_DUMMY_STATEMENT\n#include \"stub/i386-netbsd.elf-entry.h\"\n\nstatic const CLANG_FORMAT_DUMMY_STATEMENT\n#include \"stub/i386-netbsd.elf-fold.h\"\n\n#define WANT_NHDR_ENUM\n#include \"p_elf_enum.h\"\n#undef WANT_NHDR_ENUM\n\nvoid\nPackNetBSDElf32x86::buildLoader(const Filter *ft)\n{\n    unsigned char tmp[sizeof(stub_i386_netbsd_elf_fold)];\n    memcpy(tmp, stub_i386_netbsd_elf_fold, sizeof(stub_i386_netbsd_elf_fold));\n    checkPatch(nullptr, 0, 0, 0);  // reset\n    if (opt->o_unix.is_ptinterp) {\n        unsigned j;\n        for (j = 0; j < sizeof(stub_i386_netbsd_elf_fold)-1; ++j) {\n            if (0x60==tmp[  j]\n            &&  0x47==tmp[1+j] ) {\n                /* put INC EDI before PUSHA: inhibits auxv_up for PT_INTERP */\n                tmp[  j] = 0x47;\n                tmp[1+j] = 0x60;\n                break;\n            }\n        }\n    }\n    buildLinuxLoader(\n        stub_i386_netbsd_elf_entry, sizeof(stub_i386_netbsd_elf_entry),\n        tmp,                        sizeof(stub_i386_netbsd_elf_fold), ft);\n}\n\nstatic const CLANG_FORMAT_DUMMY_STATEMENT\n#include \"stub/i386-openbsd.elf-fold.h\"\n\nvoid\nPackOpenBSDElf32x86::buildLoader(const Filter *ft)\n{\n    unsigned char tmp[sizeof(stub_i386_openbsd_elf_fold)];\n    memcpy(tmp, stub_i386_openbsd_elf_fold, sizeof(stub_i386_openbsd_elf_fold));\n    checkPatch(nullptr, 0, 0, 0);  // reset\n    if (opt->o_unix.is_ptinterp) {\n        unsigned j;\n        for (j = 0; j < sizeof(stub_i386_openbsd_elf_fold)-1; ++j) {\n            if (0x60==tmp[  j]\n            &&  0x47==tmp[1+j] ) {\n                /* put INC EDI before PUSHA: inhibits auxv_up for PT_INTERP */\n                tmp[  j] = 0x47;\n                tmp[1+j] = 0x60;\n                break;\n            }\n        }\n    }\n    buildLinuxLoader(\n        stub_i386_bsd_elf_entry, sizeof(stub_i386_bsd_elf_entry),\n        tmp,                     sizeof(stub_i386_openbsd_elf_fold), ft);\n}\n\nstatic const CLANG_FORMAT_DUMMY_STATEMENT\n#include \"stub/arm.v5a-linux.elf-entry.h\"\nstatic const CLANG_FORMAT_DUMMY_STATEMENT\n#include \"stub/arm.v5a-linux.elf-so_entry.h\"\nstatic const CLANG_FORMAT_DUMMY_STATEMENT\n#include \"stub/arm.v5a-linux.elf-fold.h\"\nstatic const CLANG_FORMAT_DUMMY_STATEMENT\n#include \"stub/arm.v5a-linux.elf-so_fold.h\"\nstatic const CLANG_FORMAT_DUMMY_STATEMENT\n#include \"stub/arm.v5t-linux.shlib-init.h\"\n\nstatic const CLANG_FORMAT_DUMMY_STATEMENT\n#include \"stub/arm.v4a-linux.elf-entry.h\"\nstatic const CLANG_FORMAT_DUMMY_STATEMENT\n#include \"stub/arm.v4a-linux.elf-so_entry.h\"\nstatic const CLANG_FORMAT_DUMMY_STATEMENT\n#include \"stub/arm.v4a-linux.elf-fold.h\"\nstatic const CLANG_FORMAT_DUMMY_STATEMENT\n#include \"stub/arm.v4a-linux.elf-so_fold.h\"\n#if 0\nstatic const CLANG_FORMAT_DUMMY_STATEMENT\n#include \"stub/arm.v4a-linux.shlib-init.h\"\n#endif\n\nstatic const CLANG_FORMAT_DUMMY_STATEMENT\n#include \"stub/armeb.v4a-linux.elf-entry.h\"\nstatic const CLANG_FORMAT_DUMMY_STATEMENT\n#include \"stub/armeb.v4a-linux.elf-fold.h\"\n\nvoid\nPackLinuxElf32armBe::buildLoader(Filter const *ft)\n{\n    buildLinuxLoader(\n        stub_armeb_v4a_linux_elf_entry, sizeof(stub_armeb_v4a_linux_elf_entry),\n        stub_armeb_v4a_linux_elf_fold,  sizeof(stub_armeb_v4a_linux_elf_fold), ft);\n}\n\nvoid\nPackLinuxElf32armLe::buildLoader(Filter const *ft)\n{\n    if (Elf32_Ehdr::ELFOSABI_LINUX==ei_osabi) {\n        if (0!=xct_off) {  // shared library\n            buildLinuxLoader( // FIXME: 4 vs 5 ?\n                stub_arm_v5a_linux_elf_so_entry, sizeof(stub_arm_v5a_linux_elf_so_entry),\n                stub_arm_v5a_linux_elf_so_fold,  sizeof(stub_arm_v5a_linux_elf_so_fold), ft);\n            return;\n        }\n        buildLinuxLoader(\n            stub_arm_v5a_linux_elf_entry, sizeof(stub_arm_v5a_linux_elf_entry),\n            stub_arm_v5a_linux_elf_fold,  sizeof(stub_arm_v5a_linux_elf_fold), ft);\n    }\n    else {\n        buildLinuxLoader(\n            stub_arm_v4a_linux_elf_entry, sizeof(stub_arm_v4a_linux_elf_entry),\n            stub_arm_v4a_linux_elf_fold,  sizeof(stub_arm_v4a_linux_elf_fold), ft);\n    }\n}\n\nstatic const CLANG_FORMAT_DUMMY_STATEMENT\n#include \"stub/mipsel.r3000-linux.elf-entry.h\"\nstatic const CLANG_FORMAT_DUMMY_STATEMENT\n#include \"stub/mipsel.r3000-linux.elf-fold.h\"\nstatic const CLANG_FORMAT_DUMMY_STATEMENT\n#include \"stub/mipsel.r3000-linux.shlib-init.h\"\n\nvoid\nPackLinuxElf32mipsel::buildLoader(Filter const *ft)\n{\n    if (0!=xct_off) {  // shared library\n        buildLinuxLoader(\n            stub_mipsel_r3000_linux_shlib_init, sizeof(stub_mipsel_r3000_linux_shlib_init),\n            nullptr,                        0,                                 ft );\n        return;\n    }\n    buildLinuxLoader(\n        stub_mipsel_r3000_linux_elf_entry, sizeof(stub_mipsel_r3000_linux_elf_entry),\n        stub_mipsel_r3000_linux_elf_fold,  sizeof(stub_mipsel_r3000_linux_elf_fold), ft);\n}\n\nstatic const CLANG_FORMAT_DUMMY_STATEMENT\n#include \"stub/mips.r3000-linux.elf-entry.h\"\nstatic const CLANG_FORMAT_DUMMY_STATEMENT\n#include \"stub/mips.r3000-linux.elf-fold.h\"\nstatic const CLANG_FORMAT_DUMMY_STATEMENT\n#include \"stub/mips.r3000-linux.shlib-init.h\"\n\nvoid\nPackLinuxElf32mipseb::buildLoader(Filter const *ft)\n{\n    if (0!=xct_off) {  // shared library\n        buildLinuxLoader(\n            stub_mips_r3000_linux_shlib_init, sizeof(stub_mips_r3000_linux_shlib_init),\n            nullptr,                        0,                                 ft );\n        return;\n    }\n    buildLinuxLoader(\n        stub_mips_r3000_linux_elf_entry, sizeof(stub_mips_r3000_linux_elf_entry),\n        stub_mips_r3000_linux_elf_fold,  sizeof(stub_mips_r3000_linux_elf_fold), ft);\n}\n\nstatic const CLANG_FORMAT_DUMMY_STATEMENT\n#include \"stub/powerpc-linux.elf-entry.h\"\nstatic const CLANG_FORMAT_DUMMY_STATEMENT\n#include \"stub/powerpc-linux.elf-fold.h\"\n\nvoid\nPackLinuxElf32ppc::buildLoader(const Filter *ft)\n{\n    buildLinuxLoader(\n        stub_powerpc_linux_elf_entry, sizeof(stub_powerpc_linux_elf_entry),\n        stub_powerpc_linux_elf_fold,  sizeof(stub_powerpc_linux_elf_fold), ft);\n}\n\nstatic const CLANG_FORMAT_DUMMY_STATEMENT\n#include \"stub/powerpc64le-linux.elf-entry.h\"\nstatic const CLANG_FORMAT_DUMMY_STATEMENT\n#include \"stub/powerpc64le-linux.elf-fold.h\"\n\nvoid\nPackLinuxElf64ppcle::buildLoader(const Filter *ft)\n{\n    buildLinuxLoader(\n        stub_powerpc64le_linux_elf_entry, sizeof(stub_powerpc64le_linux_elf_entry),\n        stub_powerpc64le_linux_elf_fold,  sizeof(stub_powerpc64le_linux_elf_fold), ft);\n}\n\nstatic const CLANG_FORMAT_DUMMY_STATEMENT\n#include \"stub/powerpc64-linux.elf-entry.h\"\nstatic const CLANG_FORMAT_DUMMY_STATEMENT\n#include \"stub/powerpc64-linux.elf-fold.h\"\n\nvoid\nPackLinuxElf64ppc::buildLoader(const Filter *ft)\n{\n    buildLinuxLoader(\n        stub_powerpc64_linux_elf_entry, sizeof(stub_powerpc64_linux_elf_entry),\n        stub_powerpc64_linux_elf_fold,  sizeof(stub_powerpc64_linux_elf_fold), ft);\n}\n\nstatic const CLANG_FORMAT_DUMMY_STATEMENT\n#include \"stub/amd64-linux.elf-entry.h\"\nstatic const CLANG_FORMAT_DUMMY_STATEMENT\n#include \"stub/amd64-linux.elf-fold.h\"\nstatic const CLANG_FORMAT_DUMMY_STATEMENT\n#include \"stub/amd64-linux.elf-so_entry.h\"\nstatic const CLANG_FORMAT_DUMMY_STATEMENT\n#include \"stub/amd64-linux.elf-so_fold.h\"\nstatic const CLANG_FORMAT_DUMMY_STATEMENT\n#include \"stub/amd64-linux.shlib-init.h\"\n\nvoid\nPackLinuxElf64amd::buildLoader(const Filter *ft)\n{\n    if (0!=xct_off) {  // shared library\n        buildLinuxLoader(\n            stub_amd64_linux_elf_so_entry, sizeof(stub_amd64_linux_elf_so_entry),\n            stub_amd64_linux_elf_so_fold,  sizeof(stub_amd64_linux_elf_so_fold), ft);\n        return;\n    }\n    buildLinuxLoader(\n        stub_amd64_linux_elf_entry, sizeof(stub_amd64_linux_elf_entry),\n        stub_amd64_linux_elf_fold,  sizeof(stub_amd64_linux_elf_fold), ft);\n}\n\nstatic const CLANG_FORMAT_DUMMY_STATEMENT\n#include \"stub/arm64-linux.elf-entry.h\"\nstatic const CLANG_FORMAT_DUMMY_STATEMENT\n#include \"stub/arm64-linux.elf-so_entry.h\"\nstatic const CLANG_FORMAT_DUMMY_STATEMENT\n#include \"stub/arm64-linux.elf-fold.h\"\nstatic const CLANG_FORMAT_DUMMY_STATEMENT\n#include \"stub/arm64-linux.elf-so_fold.h\"\nstatic const CLANG_FORMAT_DUMMY_STATEMENT\n#include \"stub/arm64-linux.shlib-init.h\"\n\nvoid\nPackLinuxElf64arm::buildLoader(const Filter *ft)\n{\n    if (0!=xct_off) {  // shared library\n        buildLinuxLoader(\n            stub_arm64_linux_elf_so_entry, sizeof(stub_arm64_linux_elf_so_entry),\n            stub_arm64_linux_elf_so_fold,  sizeof(stub_arm64_linux_elf_so_fold), ft);\n        return;\n    }\n    buildLinuxLoader(\n        stub_arm64_linux_elf_entry, sizeof(stub_arm64_linux_elf_entry),\n        stub_arm64_linux_elf_fold,  sizeof(stub_arm64_linux_elf_fold), ft);\n}\n\n    // DT_HASH, DT_GNU_HASH have no explicit length (except in ElfXX_Shdr),\n    // so it is hard to detect when the index of a hash chain is out-of-bounds.\n    // Workaround: Assume no overlap of DT_* tables (and often contiguous.)\n    // Then any given table ends at least as early as when another table begins.\n    // So find the tables, and sort the offsets.\n    // The 32-bit DT_xxxxx keys have the same values as 64-bit DT_xxxxx keys.\nstatic unsigned const dt_keys[] = {\n        Elf64_Dyn::DT_SYMTAB,\n        Elf64_Dyn::DT_VERSYM,  // not small integer\n        Elf64_Dyn::DT_VERNEED,  // not small integer\n        Elf64_Dyn::DT_HASH,\n        Elf64_Dyn::DT_GNU_HASH,  // not small integer\n        Elf64_Dyn::DT_STRTAB,\n        Elf64_Dyn::DT_VERDEF,  // not small integer\n        Elf64_Dyn::DT_REL,\n        Elf64_Dyn::DT_RELA,\n        Elf64_Dyn::DT_FINI_ARRAY,\n        Elf64_Dyn::DT_INIT_ARRAY,\n        Elf64_Dyn::DT_PREINIT_ARRAY,\n        0,\n};\n\nstatic int __acc_cdecl_qsort\nqcmp_unsigned(void const *const aa, void const *const bb)\n{\n    unsigned a = *(unsigned const *)aa;\n    unsigned b = *(unsigned const *)bb;\n    if (a < b) return -1;\n    if (a > b) return  1;\n    return  0;\n}\n\nvoid\nPackLinuxElf32::sort_DT32_offsets(Elf32_Dyn const *const dynp0)\n{\n    mb_dt_offsets.alloc(sizeof(unsigned) * sizeof(dt_keys)/sizeof(dt_keys[0]));\n    mb_dt_offsets.clear();\n    dt_offsets = (unsigned *)mb_dt_offsets.getVoidPtr();\n    unsigned n_off = 0, k;\n    for (unsigned j=0; ((k = dt_keys[j]),  k); ++j) {\n        dt_offsets[n_off] = 0;  // default to \"not found\"\n        u32_t rva = 0;\n        if (k < DT_NUM) { // in range of easy table\n            if (!dt_table[k]) {\n                continue;  // not present in input\n            }\n            rva = get_te32(&dynp0[-1+ dt_table[k]].d_val);\n        }\n        else if (file_image) { // why is this guard necessary?\n            rva = elf_unsigned_dynamic(k);  // zero if not found\n        }\n        if (!rva) {\n            continue;  // not present in input\n        }\n        Elf32_Phdr const *phdr = elf_find_Phdr_for_va(rva, phdri, e_phnum);\n        if (!phdr) {\n            char msg[60]; snprintf(msg, sizeof(msg), \"bad  DT_{%#x} = %#x (no Phdr)\",\n                k, rva);\n            throwCantPack(msg);\n        }\n        dt_offsets[n_off] = (rva - get_te32(&phdr->p_vaddr)) + get_te32(&phdr->p_offset);\n\n        if (file_size <= dt_offsets[n_off]) {\n            char msg[60]; snprintf(msg, sizeof(msg), \"bad DT_{%#x} = %#x (beyond EOF)\",\n                k, dt_offsets[n_off]);\n                throwCantPack(msg);\n        }\n        n_off += !!dt_offsets[n_off];\n    }\n    dt_offsets[n_off++] = file_size;  // sentinel\n    upx_qsort(dt_offsets, n_off, sizeof(dt_offsets[0]), qcmp_unsigned);\n}\n\nunsigned PackLinuxElf32::find_dt_ndx(unsigned rva)\n{\n    unsigned *const dto = (unsigned *)mb_dt_offsets.getVoidPtr();\n    unsigned const dto_size = mb_dt_offsets.getSize() / sizeof(*dto);\n    for (unsigned j = 0; j < dto_size && dto[j]; ++j) { // linear search of short table\n        if (rva == dto[j]) {\n            return j;\n        }\n    }\n    return ~0u;\n}\n\nunsigned PackLinuxElf32::elf_find_table_size(unsigned dt_type, unsigned sh_type)\n{\n    Elf32_Shdr const *sec = elf_find_section_type(sh_type);\n    if (sec) { // Cheat the easy way: use _Shdr.  (No _Shdr anyway for de-compression)\n        return get_te32(&sec->sh_size);\n    }\n    // Honest hard work: use _Phdr\n    unsigned x_rva;\n    if (dt_type < DT_NUM) {\n        unsigned const x_ndx = dt_table[dt_type];\n        if (!x_ndx) { // no such entry\n            return 0;\n        }\n        x_rva = get_te32(&dynseg[-1+ x_ndx].d_val);\n    }\n    else {\n        x_rva = elf_unsigned_dynamic(dt_type);\n    }\n    Elf32_Phdr const *const x_phdr = elf_find_Phdr_for_va(x_rva, phdri, e_phnum);\n    if (!x_phdr)\n        return ~0u;  // corrupted Phdrs?\n    unsigned const           d_off =             x_rva - get_te32(&x_phdr->p_vaddr);\n    unsigned const           y_ndx = find_dt_ndx(d_off + get_te32(&x_phdr->p_offset));\n    if (~0u != y_ndx) {\n        return dt_offsets[1+ y_ndx] - dt_offsets[y_ndx];\n    }\n    return ~0u;\n}\n\nvoid\nPackLinuxElf32::invert_pt_dynamic(Elf32_Dyn const *dynp, u32_t headway)\n{\n    if (dt_table[Elf32_Dyn::DT_NULL]) {\n        return;  // not 1st time; do not change upx_dt_init\n    }\n    Elf32_Dyn const *const dynp0 = dynp;\n    unsigned ndx = 0;\n    unsigned const limit = headway / sizeof(*dynp);\n    if (dynp)\n    for (; ; ++ndx, ++dynp) {\n        if (limit <= ndx) {\n            throwCantPack(\"DT_NULL not found\");\n        }\n        u32_t const d_tag = get_te32(&dynp->d_tag);\n        if (d_tag < DT_NUM) {\n            if (Elf32_Dyn::DT_NEEDED != d_tag\n            &&  dt_table[d_tag]\n            &&    get_te32(&dynp->d_val)\n               != get_te32(&dynp0[-1+ dt_table[d_tag]].d_val)) {\n                throwCantPack(\"duplicate DT_%#x: [%#x] [%#x]\",\n                    (unsigned)d_tag, -1+ dt_table[d_tag], ndx);\n            }\n            dt_table[d_tag] = 1+ ndx;\n        }\n        if (Elf32_Dyn::DT_NULL == d_tag) {\n            break;  // check here so that dt_table[DT_NULL] is set\n        }\n    }\n    sort_DT32_offsets(dynp0);\n\n    upx_dt_init = 0;\n         if (dt_table[Elf32_Dyn::DT_INIT])          upx_dt_init = Elf32_Dyn::DT_INIT;\n    else if (dt_table[Elf32_Dyn::DT_PREINIT_ARRAY]) upx_dt_init = Elf32_Dyn::DT_PREINIT_ARRAY;\n    else if (dt_table[Elf32_Dyn::DT_INIT_ARRAY])    upx_dt_init = Elf32_Dyn::DT_INIT_ARRAY;\n\n    unsigned const z_str = dt_table[Elf32_Dyn::DT_STRSZ];\n    strtab_max = !z_str ? 0 : get_te32(&dynp0[-1+ z_str].d_val);\n    unsigned const z_tab = dt_table[Elf32_Dyn::DT_STRTAB];\n    unsigned const tmp1 = !z_tab ? 0 : get_te32(&dynp0[-1+ z_tab].d_val);\n    if (tmp1 < sz_elf_hdrs) {\n        throwCantPack(\"bad DT_STRTAB %#x\", tmp1);\n    }\n    unsigned const strtab_beg = !z_tab ? 0 : elf_get_offset_from_address(tmp1);\n\n    if (!z_str || !z_tab || !(strtab_max + strtab_beg)\n    || (this->file_size - strtab_beg) < strtab_max  // strtab overlaps EOF\n        // last string in table must have terminating NUL\n    ||  '\\0' != ((char *)file_image.getVoidPtr())[-1+ strtab_max + strtab_beg]\n    ) {\n        throwCantPack(\"bad DT_STRSZ %#x\", strtab_max);\n    }\n\n    { // Find end of DT_SYMTAB\n        unsigned const tmp2 = elf_find_table_size(Elf32_Dyn::DT_SYMTAB,\n            Elf32_Shdr::SHT_DYNSYM);\n        symnum_max = (~0u == tmp2) ? 0 : tmp2 / sizeof(Elf32_Sym);\n    }\n\n    unsigned v_sym = dt_table[Elf32_Dyn::DT_SYMTAB];\n    if (v_sym) {\n        v_sym = elf_get_offset_from_address(get_te32(&dynp0[-1+ v_sym].d_val));\n    }\n    unsigned v_hsh = dt_table[Elf32_Dyn::DT_HASH];\n    if (v_hsh) {\n        v_hsh = elf_get_offset_from_address(get_te32(&dynp0[-1+ v_hsh].d_val));\n    }\n    if (v_hsh && file_image) {\n        hashtab = (unsigned const *)elf_find_dynamic(Elf32_Dyn::DT_HASH);\n        if (!hashtab) {\n            throwCantPack(\"bad DT_HASH %#x\", v_hsh);\n        }\n        // Find end of DT_HASH\n        hashend = (unsigned const *)(void const *)(elf_find_table_size(\n            Elf32_Dyn::DT_HASH, Elf32_Shdr::SHT_HASH) + (char const *)hashtab);\n        if (!hashtab || (char const *)hashend <= (char const *)&hashtab[2]\n        ||  file_image.getSizeInBytes()\n            < (unsigned)((char const *)&hashtab[2] - (char *)&file_image[0]) )\n        {\n            throwCantPack(\"bad DT_HASH %#x\", v_hsh);\n        }\n\n        unsigned const nbucket = get_te32(&hashtab[0]);\n        unsigned const *const buckets = &hashtab[2];\n        unsigned const *const chains = &buckets[nbucket]; (void)chains;\n        if ((unsigned)(file_size - ((char const *)buckets - (char const *)(void const *)file_image))\n                <= sizeof(unsigned)*nbucket ) {\n            throwCantPack(\"bad nbucket %#x\\n\", nbucket);\n        }\n\n        if ((unsigned)(hashend - buckets) < nbucket\n        || !v_sym || (unsigned)file_size <= v_sym\n        || ((v_hsh < v_sym) && (v_sym - v_hsh) < sizeof(*buckets)*(2+ nbucket))\n        ) {\n            throwCantPack(\"bad DT_HASH nbucket=%#x  len=%#x\",\n                nbucket, (v_sym - v_hsh));\n        }\n        unsigned chmax = 0;\n        for (unsigned j= 0; j < nbucket; ++j) {\n            unsigned x = get_te32(&buckets[j]);\n            if (chmax < x) {\n                chmax = x;\n            }\n        }\n        if ((v_hsh < v_sym) && (v_sym - v_hsh) <\n                (sizeof(*buckets)*(2+ nbucket) + sizeof(*chains)*(1+ chmax))) {\n            throwCantPack(\"bad DT_HASH nbucket=%#x  len=%#x\",\n                nbucket, (v_sym - v_hsh));\n        }\n    }\n    unsigned const v_gsh = elf_unsigned_dynamic(Elf32_Dyn::DT_GNU_HASH);\n    if (v_gsh && file_image) {\n        // Not similar to DT_HASH because DT_GNU_HASH is not small (0x6ffffef5).\n        gashtab = (unsigned const *)elf_find_dynamic(Elf32_Dyn::DT_GNU_HASH);\n        gashend = (unsigned const *)(void const *)(elf_find_table_size(\n            Elf32_Dyn::DT_GNU_HASH, Elf32_Shdr::SHT_GNU_HASH) + (char const *)gashtab);\n        if (!gashtab || (char const *)gashend <= (char const *)&gashtab[4]\n        ||  file_image.getSizeInBytes()\n            < (unsigned)((char const *)&gashtab[4] - (char *)&file_image[0]) )\n        {\n            throwCantPack(\"bad DT_GNU_HASH %#x\", v_gsh);\n        }\n\n        unsigned const n_bucket = get_te32(&gashtab[0]);\n        unsigned const symbias  = get_te32(&gashtab[1]);\n        unsigned const n_bitmask = get_te32(&gashtab[2]);\n        unsigned const gnu_shift = get_te32(&gashtab[3]);\n        u32_t const *const bitmask = (u32_t const *)(void const *)&gashtab[4];\n        unsigned     const *const buckets = (unsigned const *)&bitmask[n_bitmask];\n        unsigned     const *const hasharr = &buckets[n_bucket]; (void)hasharr;\n        if (!n_bucket || (1u<<31) <= n_bucket  /* fie on fuzzers */\n        || (unsigned)(gashend - buckets) < n_bucket\n        || (file_size + file_image) <= (void const *)hasharr) {\n            throwCantPack(\"bad n_bucket %#x\\n\", n_bucket);\n        }\n        // It would be better to detect zeroes shifted into low 5 bits of:\n        //    (037 & (hash_32 >> gnu_shift))\n        // but compilers can be stupid.\n        if (31 < gnu_shift) {\n            throwCantPack(\"bad gnu_shift %#x\", gnu_shift);\n        }\n        // unsigned const *const gashend = &hasharr[n_bucket];\n        // minimum, except:\n        // Rust and Android trim unused zeroes from high end of hasharr[]\n        unsigned bmax = 0;\n        for (unsigned j= 0; j < n_bucket; ++j) {\n            unsigned bj = get_te32(&buckets[j]);\n            if (bj) {\n                if (bj < symbias) {\n                    throwCantPack(\"bad DT_GNU_HASH bucket[%d] < symbias{%#x}\\n\",\n                        bj, symbias);\n                }\n                if (bmax < bj) {\n                    bmax = bj;\n                }\n            }\n        }\n        if (1==n_bucket  && 0==buckets[0]\n        &&  1==n_bitmask && 0==bitmask[0]) {\n            // 2021-09-11 Rust on RaspberryPi apparently uses this to minimize space.\n            // But then the DT_GNU_HASH symbol lookup algorithm always fails?\n            // https://github.com/upx/upx/issues/525\n        } else\n        if (bmax) {\n            if ((1+ bmax) < symbias) {\n                throwCantPack(\"bad DT_GNU_HASH (1+ max_bucket)=%#x < symbias=%#x\",\n                    1+ bmax, symbias);\n            }\n            bmax -= symbias;\n        }\n\n        unsigned r = 0;\n        if (!n_bucket || !n_bitmask || !v_sym\n        || (r=1, ((-1+ n_bitmask) & n_bitmask))  // not a power of 2\n        || (r=2, (8*sizeof(u32_t) <= gnu_shift))  // shifted result always == 0\n        || (r=3, (n_bucket>>30))  // fie on fuzzers\n        || (r=4, (n_bitmask>>30))\n        || (r=5, ((file_size/sizeof(unsigned))\n                <= ((sizeof(*bitmask)/sizeof(unsigned))*n_bitmask + 2*n_bucket)))  // FIXME: weak\n        || (r=6, ((v_gsh < v_sym) && (v_sym - v_gsh) < (sizeof(unsigned)*4  // headers\n                + sizeof(*bitmask)*n_bitmask  // bitmask\n                + sizeof(*buckets)*n_bucket  // buckets\n                + sizeof(*hasharr)*(!bmax ? 0 : (1+ bmax))  // hasharr\n            )) )\n        ) {\n            char msg[90]; snprintf(msg, sizeof(msg),\n                \"bad DT_GNU_HASH n_bucket=%#x  n_bitmask=%#x  len=%#lx  r=%d\",\n                n_bucket, n_bitmask, (long unsigned)(v_sym - v_gsh), r);\n            throwCantPack(msg);\n        }\n    }\n    e_shstrndx = get_te16(&ehdri.e_shstrndx);  // who omitted this?\n    if (e_shnum <= e_shstrndx\n    &&  !(0==e_shnum && 0==e_shstrndx) ) {\n        char msg[40]; snprintf(msg, sizeof(msg),\n            \"bad .e_shstrndx %d >= .e_shnum %d\", e_shstrndx, e_shnum);\n        throwCantPack(msg);\n    }\n}\n\nElf32_Phdr const *\nPackLinuxElf32::elf_find_ptype(unsigned type, Elf32_Phdr const *phdr, unsigned phnum)\n{\n    for (unsigned j = 0; j < phnum; ++j, ++phdr) {\n        if (type == get_te32(&phdr->p_type)) {\n            return phdr;\n        }\n    }\n    return nullptr;\n}\n\nElf64_Phdr const *\nPackLinuxElf64::elf_find_ptype(unsigned type, Elf64_Phdr const *phdr, unsigned phnum)\n{\n    for (unsigned j = 0; j < phnum; ++j, ++phdr) {\n        if (type == get_te32(&phdr->p_type)) {\n            return phdr;\n        }\n    }\n    return nullptr;\n}\n\nElf32_Shdr const *PackLinuxElf32::elf_find_section_name(\n    char const *const name\n) const\n{\n    Elf32_Shdr const *shdr = shdri;\n    if (!shdr) {\n        return nullptr;\n    }\n    int j = e_shnum;\n    for (; 0 <=--j; ++shdr) {\n        unsigned const sh_name = get_te32(&shdr->sh_name);\n        if ((u32_t)file_size <= sh_name) {  // FIXME: weak\n            char msg[50]; snprintf(msg, sizeof(msg),\n                \"bad Elf32_Shdr[%d].sh_name %#x\",\n                -1+ e_shnum -j, sh_name);\n            throwCantPack(msg);\n        }\n        if (0==strcmp(name, &shstrtab[sh_name])) {\n            return shdr;\n        }\n    }\n    return nullptr;\n}\n\nElf64_Shdr const *PackLinuxElf64::elf_find_section_name(\n    char const *const name\n) const\n{\n    Elf64_Shdr const *shdr = shdri;\n    if (!shdr) {\n        return nullptr;\n    }\n    int j = e_shnum;\n    for (; 0 <=--j; ++shdr) {\n        unsigned const sh_name = get_te32(&shdr->sh_name);\n        if ((u32_t)file_size <= sh_name) {  // FIXME: weak\n            char msg[50]; snprintf(msg, sizeof(msg),\n                \"bad Elf64_Shdr[%d].sh_name %#x\",\n                -1+ e_shnum -j, sh_name);\n            throwCantPack(msg);\n        }\n        if (0==strcmp(name, &shstrtab[sh_name])) {\n            return shdr;\n        }\n    }\n    return nullptr;\n}\n\nElf32_Shdr *PackLinuxElf32::elf_find_section_type(\n    unsigned const type\n) const\n{\n    Elf32_Shdr *shdr = shdri;\n    if (!shdr) {\n        return nullptr;\n    }\n    int j = e_shnum;\n    for (; 0 <=--j; ++shdr) {\n        if (type==get_te32(&shdr->sh_type)) {\n            return shdr;\n        }\n    }\n    return nullptr;\n}\n\nElf64_Shdr *PackLinuxElf64::elf_find_section_type(\n    unsigned const type\n) const\n{\n    Elf64_Shdr *shdr = shdri;\n    if (!shdr) {\n        return nullptr;\n    }\n    int j = e_shnum;\n    for (; 0 <=--j; ++shdr) {\n        if (type==get_te32(&shdr->sh_type)) {\n            return shdr;\n        }\n    }\n    return nullptr;\n}\n\nchar const *PackLinuxElf64::get_str_name(unsigned st_name, unsigned symnum) const\n{\n    if (strtab_max <= st_name) {\n        char msg[70]; snprintf(msg, sizeof(msg),\n            \"bad .st_name %#x in DT_SYMTAB[%d]\", st_name, symnum);\n        throwCantPack(msg);\n    }\n    return &dynstr[st_name];\n}\n\nchar const *PackLinuxElf64::get_dynsym_name(unsigned symnum, unsigned relnum) const\n{\n    if (symnum_max <= symnum) {\n        (void)relnum;\n        return nullptr;\n    }\n    return get_str_name(get_te32(&dynsym[symnum].st_name), symnum);\n}\n\nbool PackLinuxElf64::calls_crt1(Elf64_Rela const *rela, int sz)\n{\n    if (!dynsym || !dynstr || !rela) {\n        return false;\n    }\n    for (unsigned relnum= 0; 0 < sz; (sz -= sizeof(Elf64_Rela)), ++rela, ++relnum) {\n        unsigned const symnum = get_te64(&rela->r_info) >> 32;\n        char const *const symnam = get_dynsym_name(symnum, relnum);\n        if (0==strcmp(symnam, \"__libc_start_main\")  // glibc\n        ||  0==strcmp(symnam, \"__libc_init\")  // Android\n        ||  0==strcmp(symnam, \"__uClibc_main\")\n        ||  0==strcmp(symnam, \"__uClibc_start_main\"))\n            return true;\n    }\n    return false;\n}\n\nchar const *PackLinuxElf32::get_str_name(unsigned st_name, unsigned symnum) const\n{\n    if (strtab_max <= st_name) {\n        char msg[70]; snprintf(msg, sizeof(msg),\n            \"bad .st_name %#x in DT_SYMTAB[%d]\\n\", st_name, symnum);\n        throwCantPack(msg);\n    }\n    return &dynstr[st_name];\n}\n\nchar const *PackLinuxElf32::get_dynsym_name(unsigned symnum, unsigned relnum) const\n{\n    if (symnum_max <= symnum) {\n        (void)relnum;\n        return nullptr;\n    }\n    return get_str_name(get_te32(&dynsym[symnum].st_name), symnum);\n}\n\nbool PackLinuxElf32::calls_crt1(Elf32_Rel const *rel, int sz)\n{\n    if (!dynsym || !dynstr || !rel) {\n        return false;\n    }\n    for (unsigned relnum= 0; 0 < sz; (sz -= sizeof(Elf32_Rel)), ++rel, ++relnum) {\n        unsigned const symnum = get_te32(&rel->r_info) >> 8;\n        char const *const symnam = get_dynsym_name(symnum, relnum);\n        if (0==strcmp(symnam, \"__libc_start_main\")  // glibc\n        ||  0==strcmp(symnam, \"__libc_init\")  // Android\n        ||  0==strcmp(symnam, \"__uClibc_main\")\n        ||  0==strcmp(symnam, \"__uClibc_start_main\"))\n            return true;\n    }\n    return false;\n}\n\ntribool PackLinuxElf32::canUnpack() // bool, except -1: format known, but not packed\n{\n    if (checkEhdr(&ehdri)) {\n        return false;\n    }\n    if (get_te16(&ehdri.e_phnum) < 2) {\n        throwCantUnpack(\"e_phnum must be >= 2\");\n    }\n    if (Elf32_Ehdr::ET_DYN==get_te16(&ehdri.e_type)) {\n        PackLinuxElf32help1(fi);\n    }\n    if (super::canUnpack()) {\n        return true;\n    }\n    return false;\n}\n\nbool  // false [often throwCantPack]: some defect;  true: good so far\nPackLinuxElf32::canPackOSABI(Elf32_Ehdr const *ehdr)\n{\n    unsigned char osabi0 = ehdr->e_ident[Elf32_Ehdr::EI_OSABI];\n    // The first PT_LOAD must cover the beginning of the file (0==p_offset).\n    Elf32_Phdr const *phdr = phdri;\n    note_size = 0;\n    for (unsigned j=0; j < e_phnum; ++phdr, ++j) {\n        if (j > ((MAX_ELF_HDR_32 - sizeof(Elf32_Ehdr)) / sizeof(Elf32_Phdr))) {\n            throwCantPack(\"too many ElfXX_Phdr; try '--force-execve'\");\n            return false;\n        }\n        unsigned const p_type = get_te32(&phdr->p_type);\n        unsigned const p_offset = get_te32(&phdr->p_offset);\n        if (1!=exetype && PT_LOAD == p_type) { // 1st PT_LOAD\n            exetype = 1;\n            load_va = get_te32(&phdr->p_vaddr);  // class data member\n\n            // Cast on next line is to avoid a compiler bug (incorrect complaint) in\n            // Microsoft (R) C/C++ Optimizing Compiler Version 19.00.24215.1 for x64\n            // error C4319: '~': zero extending 'unsigned int' to 'upx_uint64_t' of greater size\n            unsigned const off = ~page_mask & (unsigned)load_va;\n\n            if (off && off == p_offset) { // specific hint\n                throwCantPack(\"Go-language PT_LOAD: try hemfix.c, or try '--force-execve'\");\n                // Fixing it inside upx fails because packExtent() reads original file.\n                return false;\n            }\n            if (0 != p_offset) { // 1st PT_LOAD must cover Ehdr and Phdr\n                throwCantPack(\"first PT_LOAD.p_offset != 0; try '--force-execve'\");\n                return false;\n            }\n            hatch_off = ~3u & (3+ get_te32(&phdr->p_memsz));\n        }\n        if (EM_MIPS == e_machine\n        &&  (Elf32_Phdr::PT_MIPS_ABIFLAGS == p_type\n          || Elf32_Phdr::PT_MIPS_REGINFO  == p_type)\n        ) {\n            add_phdrx(phdr);  // PT_MIPS_*\n            unsigned mask = -1+ get_te32(&phdr->p_align);\n            sz_phdrx = ~mask & (mask + sz_phdrx);\n            sz_phdrx += get_te32(&phdr->p_memsz);\n\n        }\n        if (PT_NOTE32 == p_type) {\n            if (osabi_note && Elf32_Ehdr::ELFOSABI_NONE==osabi0) { // Still seems to be generic.\n                struct {\n                    struct Elf32_Nhdr nhdr;\n                    char name[8];\n                    unsigned body;\n                } note;\n                memset(&note, 0, sizeof(note));\n                fi->seek(p_offset, SEEK_SET);\n                fi->readx(&note, sizeof(note));\n                fi->seek(0, SEEK_SET);\n                if (4==get_te32(&note.nhdr.descsz)\n                &&  1==get_te32(&note.nhdr.type)\n                // &&  0==note.end\n                &&  (1+ strlen(osabi_note))==get_te32(&note.nhdr.namesz)\n                &&  0==strcmp(osabi_note, (char const *)&note.name[0])\n                ) {\n                    osabi0 = ei_osabi;  // Specified by PT_NOTE.\n                }\n            }\n        }\n    }\n    if (Elf32_Ehdr::ELFOSABI_NONE ==osabi0\n    ||  Elf32_Ehdr::ELFOSABI_LINUX==osabi0) { // No EI_OSBAI, no PT_NOTE.\n        unsigned const arm_eabi = 0xff000000u & get_te32(&ehdr->e_flags);\n        if (Elf32_Ehdr::EM_ARM==e_machine\n        &&   (EF_ARM_EABI_VER5==arm_eabi\n          ||  EF_ARM_EABI_VER4==arm_eabi ) ) {\n            // armel-eabi armeb-eabi ARM Linux EABI version 4 is a mess.\n            ei_osabi = osabi0 = Elf32_Ehdr::ELFOSABI_LINUX;\n        }\n        else {\n            osabi0 = opt->o_unix.osabi0;  // Possibly specified by command-line.\n        }\n    }\n    if (osabi0!=ei_osabi) {\n        return false;\n    }\n    return true;  // good so far\n}\n\n#define WANT_SHDR_ENUM\n#include \"p_elf_enum.h\"\n#undef  WANT_SHDR_ENUM\n\nupx_uint64_t PackLinuxElf32::canPack_Shdr(Elf32_Phdr const *pload_x0)\n{\n    Elf32_Shdr const *shdr_xva = nullptr;\n    Elf32_Shdr const *shdr = shdri;\n  for (int j= e_shnum; --j>=0; ++shdr) {\n    unsigned const sh_type = get_te32(&shdr->sh_type);\n    if (!shdr_xva && Elf32_Shdr::SHF_EXECINSTR & get_te32(&shdr->sh_flags)) {\n        shdr_xva = shdr;\n        xct_va = get_te32(&shdr_xva->sh_addr);\n    }\n    // Hook the first slot of DT_PREINIT_ARRAY or DT_INIT_ARRAY.\n    if (!user_init_rp && (\n        (     Elf32_Dyn::DT_PREINIT_ARRAY==upx_dt_init\n        &&  Elf32_Shdr::SHT_PREINIT_ARRAY==sh_type)\n    ||  (     Elf32_Dyn::DT_INIT_ARRAY   ==upx_dt_init\n        &&  Elf32_Shdr::SHT_INIT_ARRAY   ==sh_type) )) {\n        unsigned user_init_ava = get_te32(&shdr->sh_addr);\n        user_init_off = get_te32(&shdr->sh_offset);\n        if ((u32_t)file_size <= user_init_off) {\n            char msg[70]; snprintf(msg, sizeof(msg),\n                \"bad Elf32_Shdr[%d].sh_offset %#x\",\n                -1+ e_shnum - j, user_init_off);\n            throwCantPack(msg);\n        }\n        // Check that &file_image[user_init_off] has\n        // *_RELATIVE or *_ABS* relocation, and fetch user_init_va.\n        // If Elf32_Rela then the actual value is in Rela.r_addend.\n        int z_rel = dt_table[Elf32_Dyn::DT_REL];\n        int z_rsz = dt_table[Elf32_Dyn::DT_RELSZ];\n        if (z_rel && z_rsz) {\n            unsigned rel_off = get_te32(&dynseg[-1+ z_rel].d_val);\n            if ((unsigned)file_size <= rel_off) {\n                char msg[70]; snprintf(msg, sizeof(msg),\n                     \"bad Elf32_Dynamic[DT_REL] %#x\\n\",\n                     rel_off);\n                throwCantPack(msg);\n            }\n            Elf32_Rel *rp = (Elf32_Rel *)&file_image[rel_off];\n            unsigned relsz   = get_te32(&dynseg[-1+ z_rsz].d_val);\n            if ((unsigned)file_size <= relsz) {\n                char msg[70]; snprintf(msg, sizeof(msg),\n                     \"bad Elf32_Dynamic[DT_RELSZ] %#x\\n\",\n                     relsz);\n                throwCantPack(msg);\n            }\n            Elf32_Rel *last = (Elf32_Rel *)(relsz + (char *)rp);\n            for (; rp < last; ++rp) {\n                unsigned r_va = get_te32(&rp->r_offset);\n                if (r_va == user_init_ava) { // found the Elf32_Rel\n                    user_init_rp = rp;\n                    unsigned r_info = get_te32(&rp->r_info);\n                    unsigned r_type = ELF32_R_TYPE(r_info);\n                    set_te32(&dynsym[0].st_name, r_va);  // for decompressor\n                    set_te32(&dynsym[0].st_value, r_info);\n                    if (Elf32_Ehdr::EM_ARM == e_machine) {\n                        if (R_ARM_RELATIVE == r_type) {\n                            user_init_va = get_te32(&file_image[user_init_off]);\n                        }\n                        else if (R_ARM_ABS32 == r_type) {\n                            unsigned symj = ELF32_R_SYM(r_info);\n                            user_init_va = get_te32(&dynsym[symj].st_value);\n                            set_te32(&rp->r_info, ELF32_R_INFO(0, R_ARM_RELATIVE));\n                            // pack3() will set &file_image[user_init_off]\n                        }\n                        else {\n                            goto bad;\n                        }\n                    }\n                    else if (Elf32_Ehdr::EM_386 == e_machine) {\n                        if (R_386_RELATIVE == r_type) {\n                            user_init_va = get_te32(&file_image[user_init_off]);\n                        }\n                        else if (R_386_32 == r_type) {\n                            unsigned symj = ELF32_R_SYM(r_info);\n                            user_init_va = get_te32(&dynsym[symj].st_value);\n                            set_te32(&rp->r_info, ELF32_R_INFO(0, R_386_RELATIVE));\n                            // pack3() will set &file_image[user_init_off]\n                        }\n                        else {\n                            goto bad;\n                        }\n                    }\n                    else {\nbad:\n                        char msg[50]; snprintf(msg, sizeof(msg),\n                            \"bad relocation %#x DT_INIT_ARRAY[0]\",\n                            r_info);\n                        throwCantPack(msg);\n                    }\n                    break;\n                }\n            }\n        }\n        unsigned const p_filesz = get_te32(&pload_x0->p_filesz);\n        if (!((user_init_va - xct_va) < p_filesz)) {\n            // Not in executable portion of first executable PT_LOAD.\n            if (0==user_init_va && is_asl) {\n                // Android allows (0 ==> skip) ?\n                upx_dt_init = 0;  // force steal of 'extra' DT_NULL\n                // XXX: FIXME: depends on SHT_DYNAMIC coming later\n            }\n            else {\n                char msg[70]; snprintf(msg, sizeof(msg),\n                    \"bad init address %#x in Elf32_Shdr[%d].%#x\\n\",\n                    (unsigned)user_init_va, -1+ e_shnum - j, user_init_off);\n                throwCantPack(msg);\n            }\n        }\n    }\n    // By default /usr/bin/ld leaves 4 extra DT_NULL to support pre-linking.\n    // Take one as a last resort.\n    if ((Elf32_Dyn::DT_INIT==upx_dt_init || !upx_dt_init)\n    &&  Elf32_Shdr::SHT_DYNAMIC == sh_type) {\n        unsigned sh_offset = get_te32(&shdr->sh_offset);\n        unsigned sh_size = get_te32(&shdr->sh_size);\n        if ((unsigned)file_size < sh_size\n        ||  (unsigned)file_size < sh_offset\n        || ((unsigned)file_size - sh_offset) < sh_size) {\n            throwCantPack(\"bad SHT_DYNAMIC\");\n        }\n        unsigned const n = get_te32(&shdr->sh_size) / sizeof(Elf32_Dyn);\n        Elf32_Dyn *dynp = (Elf32_Dyn *)&file_image[get_te32(&shdr->sh_offset)];\n        for (; Elf32_Dyn::DT_NULL != dynp->d_tag; ++dynp) {\n            if (upx_dt_init == get_te32(&dynp->d_tag)) {\n                break;  // re-found DT_INIT\n            }\n        }\n        if ((1+ dynp) < (n+ dynseg)) { // not the terminator, so take it\n            user_init_va = get_te32(&dynp->d_val);  // 0 if (0==upx_dt_init)\n            set_te32(&dynp->d_tag, upx_dt_init = Elf32_Dyn::DT_INIT);\n            user_init_off = (char const *)&dynp->d_val - (char const *)&file_image[0];\n        }\n    }\n  }\n    return xct_va;\n}\n\nupx_uint64_t PackLinuxElf64::canPack_Shdr(Elf64_Phdr const *pload_x0)\n{\n    Elf64_Shdr const *shdr_xva = nullptr;\n    Elf64_Shdr const *shdr = shdri;\n  for (int j= e_shnum; --j>=0; ++shdr) {\n    unsigned const sh_type = get_te32(&shdr->sh_type);\n    if (!shdr_xva && Elf64_Shdr::SHF_EXECINSTR & get_te64(&shdr->sh_flags)) {\n        shdr_xva = shdr;\n        xct_va = get_te64_32(&shdr_xva->sh_addr);\n    }\n    // Hook the first slot of DT_PREINIT_ARRAY or DT_INIT_ARRAY.\n    if (!user_init_rp && (\n           (     Elf64_Dyn::DT_PREINIT_ARRAY==upx_dt_init\n           &&  Elf64_Shdr::SHT_PREINIT_ARRAY==sh_type)\n        || (     Elf64_Dyn::DT_INIT_ARRAY   ==upx_dt_init\n           &&  Elf64_Shdr::SHT_INIT_ARRAY   ==sh_type) )) {\n        unsigned user_init_ava = get_te64(&shdr->sh_addr);\n        user_init_off = get_te64(&shdr->sh_offset);\n        if ((u64_t)file_size <= user_init_off) {\n            char msg[70]; snprintf(msg, sizeof(msg),\n                \"bad Elf64_Shdr[%d].sh_offset %#x\",\n                -1+ e_shnum - j, user_init_off);\n            throwCantPack(msg);\n        }\n        // Check that &file_image[user_init_off] has\n        // *_RELATIVE or *_ABS* relocation, and fetch user_init_va.\n        // If Elf_Rela then the actual value is in Rela.r_addend.\n        int z_rel = dt_table[Elf64_Dyn::DT_RELA];\n        int z_rsz = dt_table[Elf64_Dyn::DT_RELASZ];\n        if (z_rel && z_rsz) {\n            upx_uint64_t rel_off = get_te64(&dynseg[-1+ z_rel].d_val);\n            if ((u64_t)file_size <= rel_off) {\n                char msg[70]; snprintf(msg, sizeof(msg),\n                     \"bad Elf64_Dynamic[DT_RELA] %#llx\\n\",\n                     rel_off);\n                throwCantPack(msg);\n            }\n            Elf64_Rela *rp = (Elf64_Rela *)&file_image[rel_off];\n            upx_uint64_t relsz   = get_te64(&dynseg[-1+ z_rsz].d_val);\n            if ((u64_t)file_size <= relsz) {\n                char msg[70]; snprintf(msg, sizeof(msg),\n                     \"bad Elf64_Dynamic[DT_RELASZ] %#llx\\n\",\n                     relsz);\n                throwCantPack(msg);\n            }\n            Elf64_Rela *last = (Elf64_Rela *)(relsz + (char *)rp);\n            for (; rp < last; ++rp) {\n                upx_uint64_t r_va = get_te64(&rp->r_offset);\n                if (r_va == user_init_ava) { // found the Elf64_Rela\n                    user_init_rp = rp;\n                    upx_uint64_t r_info = get_te64(&rp->r_info);\n                    unsigned r_type = ELF64_R_TYPE(r_info);\n                    set_te32(&dynsym[0].st_name, r_va);  // for decompressor\n                    set_te64(&dynsym[0].st_value, r_info);\n                    set_te64(&dynsym[0].st_size, get_te64(&rp->r_addend));\n                    if (Elf64_Ehdr::EM_AARCH64 == e_machine) {\n                        if (R_AARCH64_RELATIVE == r_type) {\n                            user_init_va = get_te64(&rp->r_addend);\n                        }\n                        else if (R_AARCH64_ABS64 == r_type) {\n                            user_init_va = get_te64(&dynsym[ELF64_R_SYM(r_info)].st_value);\n                        }\n                        else {\n                            char msg[50]; snprintf(msg, sizeof(msg),\n                                \"bad relocation %#llx DT_INIT_ARRAY[0]\",\n                                r_info);\n                            throwCantPack(msg);\n                        }\n                    }\n                    else if (Elf64_Ehdr::EM_X86_64 == e_machine) {\n                        if (R_X86_64_RELATIVE == r_type) {\n                            user_init_va = get_te64(&rp->r_addend);\n                        }\n                        else if (R_X86_64_64 == r_type) {\n                            user_init_va = get_te64(&dynsym[ELF64_R_SYM(r_info)].st_value);\n                        }\n                        else {\n                            char msg[50]; snprintf(msg, sizeof(msg),\n                                \"bad relocation %#llx DT_INIT_ARRAY[0]\",\n                                r_info);\n                            throwCantPack(msg);\n                        }\n                    }\n                    break;\n                }\n            }\n        }\n        unsigned const p_filesz = get_te64(&pload_x0->p_filesz);\n        if (!((user_init_va - xct_va) < p_filesz)) {\n            // Not in executable portion of first executable PT_LOAD.\n            if (0==user_init_va && is_asl) {\n                // Android allows (0 ==> skip) ?\n                upx_dt_init = 0;  // force steal of 'extra' DT_NULL\n                // XXX: FIXME: depends on SHT_DYNAMIC coming later\n            }\n            else {\n                char msg[70]; snprintf(msg, sizeof(msg),\n                    \"bad init address %#x in Elf64_Shdr[%d].%#x\\n\",\n                    (unsigned)user_init_va, -1+ e_shnum - j, user_init_off);\n                throwCantPack(msg);\n            }\n        }\n    }\n    // By default /usr/bin/ld leaves 4 extra DT_NULL to support pre-linking.\n    // Take one as a last resort.\n    if ((Elf64_Dyn::DT_INIT==upx_dt_init || !upx_dt_init)\n    &&  Elf64_Shdr::SHT_DYNAMIC == sh_type) {\n        upx_uint64_t sh_offset = get_te64(&shdr->sh_offset);\n        upx_uint64_t sh_size = get_te64(&shdr->sh_size);\n        if ((upx_uint64_t)file_size < sh_size\n        ||  (upx_uint64_t)file_size < sh_offset\n        || ((upx_uint64_t)file_size - sh_offset) < sh_size) {\n            throwCantPack(\"bad SHT_DYNAMIC\");\n        }\n        unsigned const n = sh_size / sizeof(Elf64_Dyn);\n        Elf64_Dyn *dynp = (Elf64_Dyn *)&file_image[sh_offset];\n        for (; Elf64_Dyn::DT_NULL != dynp->d_tag; ++dynp) {\n            if (upx_dt_init == get_te64(&dynp->d_tag)) {\n                break;  // re-found DT_INIT\n            }\n        }\n        if ((1+ dynp) < (n+ dynseg)) { // not the terminator, so take it\n            user_init_va = get_te64(&dynp->d_val);  // 0 if (0==upx_dt_init)\n            set_te64(&dynp->d_tag, upx_dt_init = Elf64_Dyn::DT_INIT);\n            user_init_off = (char const *)&dynp->d_val - (char const *)&file_image[0];\n        }\n    }\n  }\n    return xct_va;\n}\n\ntribool PackLinuxElf32::canPack()\n{\n    union {\n        unsigned char buf[MAX_ELF_HDR_32];\n        //struct { Elf32_Ehdr ehdr; Elf32_Phdr phdr; } e;\n    } u;\n    COMPILE_TIME_ASSERT(sizeof(u.buf) <= (2*512))\n\n// My earlier design with \"extra\" Shdrs in output at xct_off\n// DOES NOT WORK because code for EM_ARM has embedded relocations\n// that are not made visible, such as:\n//    ----- glibc-2.31/sysdeps/arm/crti.S\n//            .type call_weak_fn, %function\n//    call_weak_fn:\n//            ldr r3, .LGOT\n//            ldr r2, .LGOT+4\n//    .LPIC:\n//            add r3, pc, r3\n//            ldr r2, [r3, r2]\n//            cmp r2, #0\n//            bxeq lr\n//            b PREINIT_FUNCTION\n//            .p2align 2\n//    .LGOT:\n//            .word _GLOBAL_OFFSET_TABLE_-(.LPIC+8)  // unseen reloc!\n//            .word PREINIT_FUNCTION(GOT)\n//    -----\n// So, PackUnix::PackUnix() disables (but silently accepts) --android-shlib,\n// and see if appending ARM_ATTRIBUTES Shdr is good enough.\n\n    fi->seek(0, SEEK_SET);\n    fi->readx(u.buf, sizeof(u.buf));\n    fi->seek(0, SEEK_SET);\n    Elf32_Ehdr const *const ehdr = (Elf32_Ehdr *) u.buf;\n\n    // now check the ELF header\n    if (checkEhdr(ehdr) != 0)\n        return false;\n\n    // additional requirements for linux/elf386\n    if (get_te16(&ehdr->e_ehsize) != sizeof(*ehdr)) {\n        throwCantPack(\"invalid Ehdr e_ehsize; try '--force-execve'\");\n        return false;\n    }\n    if (e_phoff != sizeof(*ehdr)) {// Phdrs not contiguous with Ehdr\n        throwCantPack(\"non-contiguous Ehdr/Phdr; try '--force-execve'\");\n        return false;\n    }\n\n    if (!canPackOSABI((Elf32_Ehdr *)u.buf)) {\n        return false;\n    }\n    upx_uint32_t max_LOADsz = 0, max_offset = 0;\n    Elf32_Phdr *phdr = phdri;\n    for (unsigned j=0; j < e_phnum; ++phdr, ++j) {\n        if (j > ((MAX_ELF_HDR_32 - sizeof(Elf32_Ehdr)) / sizeof(Elf32_Phdr))) {\n            throwCantPack(\"too many ElfXX_Phdr; try '--force-execve'\");\n            return false;\n        }\n        if (is_LOAD(phdr)) {\n            // The first PT_LOAD must cover the beginning of the file (0==p_offset).\n            upx_uint32_t const p_offset = get_te32(&phdr->p_offset);\n            if (1!= exetype) {\n                exetype = 1;\n                load_va = get_te32(&phdr->p_vaddr);  // class data member\n                upx_uint32_t const off = ~page_mask & (upx_uint32_t)load_va;\n                if (off && off == p_offset) { // specific hint\n                    throwCantPack(\"Go-language PT_LOAD: try hemfix.c, or try '--force-execve'\");\n                    // Fixing it inside upx fails because packExtent() reads original file.\n                    return false;\n                }\n                if (0 != p_offset) { // 1st PT_LOAD must cover Ehdr and Phdr\n                    throwCantPack(\"first PT_LOAD.p_offset != 0; try '--force-execve'\");\n                    return false;\n                }\n                // FIXME: bad for shlib!\n                hatch_off = ~3ul & (3+ get_te32(&phdr->p_memsz));\n            }\n            max_LOADsz = UPX_MAX(max_LOADsz, UPX_MIN(0x200000u, get_te32(&phdr->p_align)));\n            unsigned filesz = get_te32(&phdr->p_filesz);\n            max_LOADsz = UPX_MAX(max_LOADsz, filesz);\n            max_offset = UPX_MAX(max_offset, filesz + p_offset);\n        }\n    }\n    if (canUnpack()) {\n        throwAlreadyPacked();\n    }\n    // Heuristic for lopped trailing PackHeader (packed and \"hacked\"!)\n    if (3 == e_phnum  // not shlib: PT_LOAD.C_BASE, PT_LOAD.C_TEXT, PT_GNU_STACK\n    && UPX_MAGIC_LE32 == get_le32(&((l_info *)&phdri[e_phnum])->l_magic)) {\n        throwAlreadyPacked();\n    }\n    // We want to compress position-independent executable (gcc -pie)\n    // main programs, but compressing a shared library must be avoided\n    // because the result is no longer usable.  In theory, there is no way\n    // to tell them apart: both are just ET_DYN.  Also in theory,\n    // neither the presence nor the absence of any particular symbol name\n    // can be used to tell them apart; there are counterexamples.\n    // However, we will use the following heuristic suggested by\n    // Peter S. Mazinger <ps.m@gmx.net> September 2005:\n    // If a ET_DYN has __libc_start_main as a global undefined symbol,\n    // then the file is a position-independent executable main program\n    // (that depends on libc.so.6) and is eligible to be compressed.\n    // Otherwise (no __libc_start_main as global undefined): skip it.\n    // Also allow  __uClibc_main  and  __uClibc_start_main .\n\n    if (Elf32_Ehdr::ET_DYN==get_te16(&ehdr->e_type)) {\n        // The DT_SYMTAB has no designated length.  Read the whole file.\n        alloc_file_image(file_image, file_size);\n        fi->seek(0, SEEK_SET);\n        fi->readx(file_image, file_size);\n        memcpy(&ehdri, ehdr, sizeof(Elf32_Ehdr));\n        phdri= (Elf32_Phdr *)((size_t)e_phoff + file_image);  // do not free() !!\n        shdri= (Elf32_Shdr *)((size_t)e_shoff + file_image);  // do not free() !!\n\n        sec_strndx = nullptr;\n        shstrtab = nullptr;\n        if (e_shnum) {\n            e_shstrndx = get_te16(&ehdr->e_shstrndx);\n            if (e_shstrndx) {\n                if (e_shnum <= e_shstrndx) {\n                    char msg[40]; snprintf(msg, sizeof(msg),\n                        \"bad e_shstrndx %#x >= e_shnum %d\", e_shstrndx, e_shnum);\n                    throwCantPack(msg);\n                }\n                sec_strndx = &shdri[e_shstrndx];\n                unsigned const sh_offset = get_te32(&sec_strndx->sh_offset);\n                if ((u32_t)file_size <= sh_offset) {\n                    char msg[50]; snprintf(msg, sizeof(msg),\n                        \"bad .e_shstrndx->sh_offset %#x\", sh_offset);\n                    throwCantPack(msg);\n                }\n                shstrtab = (char const *)(sh_offset + file_image);\n            }\n            sec_dynsym = elf_find_section_type(Elf32_Shdr::SHT_DYNSYM);\n            if (sec_dynsym) {\n                unsigned const sh_link = get_te32(&sec_dynsym->sh_link);\n                if (e_shnum <= sh_link) {\n                    char msg[50]; snprintf(msg, sizeof(msg),\n                        \"bad SHT_DYNSYM.sh_link %#x\", sh_link);\n                }\n                sec_dynstr = &shdri[sh_link];\n            }\n\n            if (sec_strndx) {\n                unsigned const sh_name = get_te32(&sec_strndx->sh_name);\n                if (Elf32_Shdr::SHT_STRTAB != get_te32(&sec_strndx->sh_type)\n                || (u32_t)file_size <= (sizeof(\".shstrtab\")\n                    + sh_name + (shstrtab - (const char *)&file_image[0]))\n                || (sh_name\n                  && 0!=strcmp((char const *)\".shstrtab\", &shstrtab[sh_name]))\n                ) {\n                    throwCantPack(\"bad e_shstrtab\");\n                }\n            }\n        }\n\n        Elf32_Phdr const *pload_x0(nullptr);  // first eXecutable PT_LOAD\n        phdr= phdri;\n        for (int j= e_phnum; --j>=0; ++phdr)\n        if (Elf32_Phdr::PT_DYNAMIC==get_te32(&phdr->p_type)) {\n            unsigned offset = check_pt_dynamic(phdr);\n            dynseg= (Elf32_Dyn *)(offset + file_image);\n            invert_pt_dynamic(dynseg,\n                umin(get_te32(&phdr->p_filesz), (unsigned)(file_size_u - offset)));\n        }\n        else if (is_LOAD(phdr)) {\n            if (!pload_x0\n            &&  Elf32_Phdr::PF_X & get_te32(&phdr->p_flags)\n            ) {\n                pload_x0 = phdr;\n            }\n            check_pt_load(phdr);\n        }\n        if (!pload_x0) {\n            throwCantPack(\"No PT_LOAD has (p_flags & PF_X)\");\n        }\n        // elf_find_dynamic() returns 0 if 0==dynseg.\n        dynstr=          (char const *)elf_find_dynamic(Elf32_Dyn::DT_STRTAB);\n        dynsym= (Elf32_Sym /*const*/ *)elf_find_dynamic(Elf32_Dyn::DT_SYMTAB);\n\n        if (opt->o_unix.force_pie\n        ||      Elf32_Dyn::DF_1_PIE & elf_unsigned_dynamic(Elf32_Dyn::DT_FLAGS_1)\n        ||  calls_crt1((Elf32_Rel const *)elf_find_dynamic(Elf32_Dyn::DT_REL),\n                                 (int)elf_unsigned_dynamic(Elf32_Dyn::DT_RELSZ))\n        ||  calls_crt1((Elf32_Rel const *)elf_find_dynamic(Elf32_Dyn::DT_JMPREL),\n                                 (int)elf_unsigned_dynamic(Elf32_Dyn::DT_PLTRELSZ))) {\n            is_pie = true;  // UNUSED except to ignore is_shlib and xct_off\n            goto proceed;  // calls C library init for main program\n        }\n\n        if (Elf32_Ehdr::EM_ARM==get_te16(&ehdri.e_machine)) {\n            sec_arm_attr = elf_find_section_type(Elf32_Shdr::SHT_ARM_ATTRIBUTES);\n            if (Elf32_Ehdr::ET_DYN == e_type) {\n                // See earlier comment in this function.  is_asl does not work.\n                //is_asl = (!!saved_opt_android_shlib) << 1;  // bit 1; see is_shlib\n                is_asl = 0;\n            }\n        }\n\n        // Heuristic HACK for shared libraries (compare Darwin (MacOS) Dylib.)\n        // If there is an existing DT_INIT, and if everything that the dynamic\n        // linker ld-linux needs to perform relocations before calling DT_INIT\n        // resides below the first SHT_EXECINSTR Section in one PT_LOAD, then\n        // compress from the first executable Section to the end of that PT_LOAD.\n        // We must not alter anything that ld-linux might touch before it calls\n        // the DT_INIT function.\n        //\n        // Obviously this hack requires that the linker script put pieces\n        // into good positions when building the original shared library,\n        // and also requires ld-linux to behave.\n\n        if (/*jni_onload_sym ||*/ elf_find_dynamic(upx_dt_init)) {\n            if (this->e_machine!=Elf32_Ehdr::EM_386\n            &&  this->e_machine!=Elf32_Ehdr::EM_MIPS\n            &&  this->e_machine!=Elf32_Ehdr::EM_ARM)\n                goto abandon;  // need stub: EM_PPC\n            if (elf_has_dynamic(Elf32_Dyn::DT_TEXTREL)) {\n                throwCantPack(\"DT_TEXTREL found; re-compile with -fPIC\");\n                goto abandon;\n            }\n            if (!(Elf32_Dyn::DF_1_PIE & elf_unsigned_dynamic(Elf32_Dyn::DT_FLAGS_1))) {\n                // not explicitly PIE main program\n                if (Elf32_Ehdr::EM_ARM == e_machine  // Android is common\n                &&  0 && !is_asl  // but not explicit\n                ) {\n                    opt->info_mode++;\n                    info(\"note: use --android-shlib if appropriate\");\n                    opt->info_mode--;\n                }\n            }\n            if (Elf32_Ehdr::EM_MIPS == get_te16(&ehdr->e_machine)\n            ||  Elf32_Ehdr::EM_PPC  == get_te16(&ehdr->e_machine)) {\n                throwCantPack(\"This test UPX cannot pack .so for MIPS or PowerPC; coming soon.\");\n            }\n            xct_va = ~(upx_uint64_t)0;\n            if (e_shnum) {\n                xct_va = canPack_Shdr(pload_x0);\n            }\n            else { // no Sections; use heuristics\n                unsigned const strsz  = elf_unsigned_dynamic(Elf32_Dyn::DT_STRSZ);\n                unsigned const strtab = elf_unsigned_dynamic(Elf32_Dyn::DT_STRTAB);\n                unsigned const relsz  = elf_unsigned_dynamic(Elf32_Dyn::DT_RELSZ);\n                unsigned const rel    = elf_unsigned_dynamic(Elf32_Dyn::DT_REL);\n                unsigned const init   = elf_unsigned_dynamic(upx_dt_init);\n                if ((init == (relsz + rel   ) && rel    == (strsz + strtab))\n                ||  (init == (strsz + strtab) && strtab == (relsz + rel   ))\n                ) {\n                    xct_va = init;\n                    user_init_va = init;\n                    user_init_off = elf_get_offset_from_address(init);\n                }\n            }\n            // Rely on 0==elf_unsigned_dynamic(tag) if no such tag.\n            unsigned const va_gash = elf_unsigned_dynamic(Elf32_Dyn::DT_GNU_HASH);\n            unsigned const va_hash = elf_unsigned_dynamic(Elf32_Dyn::DT_HASH);\n            unsigned y = 0;\n            if ((y=1, xct_va < va_gash)  ||  (y=2, (0==va_gash && xct_va < va_hash))\n            ||  (y=3, xct_va < elf_unsigned_dynamic(Elf32_Dyn::DT_STRTAB))\n            ||  (y=4, xct_va < elf_unsigned_dynamic(Elf32_Dyn::DT_SYMTAB))\n            ||  (y=5, xct_va < elf_unsigned_dynamic(Elf32_Dyn::DT_REL))\n            ||  (y=6, xct_va < elf_unsigned_dynamic(Elf32_Dyn::DT_RELA))\n            ||  (y=7, xct_va < elf_unsigned_dynamic(Elf32_Dyn::DT_JMPREL))\n            ||  (y=8, xct_va < elf_unsigned_dynamic(Elf32_Dyn::DT_VERDEF))\n            ||  (y=9, xct_va < elf_unsigned_dynamic(Elf32_Dyn::DT_VERSYM))\n            ||  (y=10, xct_va < elf_unsigned_dynamic(Elf32_Dyn::DT_VERNEED)) ) {\n                static char const *which[] = {\n                    \"unknown\",\n                    \"DT_GNU_HASH\",\n                    \"DT_HASH\",\n                    \"DT_STRTAB\",\n                    \"DT_SYMTAB\",\n                    \"DT_REL\",\n                    \"DT_RELA\",\n                    \"DT_JMPREL\",\n                    \"DT_VERDEF\",\n                    \"DT_VERSYM\",\n                    \"DT_VERNEED\",\n                };\n                char buf[30]; snprintf(buf, sizeof(buf), \"%s above stub\", which[y]);\n                throwCantPack(buf);\n                goto abandon;\n            }\n            xct_off = elf_get_offset_from_address(xct_va);\n            if (opt->debug.debug_level) {\n                fprintf(stderr, \"shlib canPack: xct_va=%#lx  xct_off=%#lx\\n\",\n                    (long)xct_va, (long)xct_off);\n            }\n            goto proceed;  // But proper packing depends on checking xct_va.\n        }\n        else {\n            throwCantPack(\"need DT_INIT; try \\\"void _init(void){}\\\"\");\n        }\nabandon:\n        return false;\nproceed: ;\n    }\n    // XXX Theoretically the following test should be first,\n    // but PackUnix::canPack() wants 0!=exetype ?\n    if (!super::canPack())\n        return false;\n    assert(exetype == 1);\n    exetype = 0;\n\n    // set options\n    // this->blocksize: avoid over-allocating.\n    // (file_size - max_offset): debug info, non-globl symbols, etc.\n    opt->o_unix.blocksize = blocksize = UPX_MAX(max_LOADsz, (unsigned)(file_size - max_offset));\n    return true;\n}\n\ntribool PackLinuxElf64::canUnpack() // bool, except -1: format known, but not packed\n{\n    if (checkEhdr(&ehdri)) {\n        return false;\n    }\n    if (get_te16(&ehdri.e_phnum) < 2) {\n        throwCantUnpack(\"e_phnum must be >= 2\");\n    }\n    if (Elf64_Ehdr::ET_DYN==get_te16(&ehdri.e_type)) {\n        PackLinuxElf64help1(fi);\n    }\n    if (super::canUnpack()) {\n        return true;\n    }\n    return false;\n}\n\ntribool PackLinuxElf64::canPack()\n{\n    union {\n        unsigned char buf[MAX_ELF_HDR_64];\n        //struct { Elf64_Ehdr ehdr; Elf64_Phdr phdr; } e;\n    } u;\n    COMPILE_TIME_ASSERT(sizeof(u) <= (2*1024))\n\n    fi->readx(u.buf, sizeof(u.buf));\n    fi->seek(0, SEEK_SET);\n    Elf64_Ehdr const *const ehdr = (Elf64_Ehdr *) u.buf;\n\n    // now check the ELF header\n    if (checkEhdr(ehdr) != 0)\n        return false;\n\n    // additional requirements for linux/elf386\n    if (get_te16(&ehdr->e_ehsize) != sizeof(*ehdr)) {\n        throwCantPack(\"invalid Ehdr e_ehsize; try '--force-execve'\");\n        return false;\n    }\n    if (e_phoff != sizeof(*ehdr)) {// Phdrs not contiguous with Ehdr\n        throwCantPack(\"non-contiguous Ehdr/Phdr; try '--force-execve'\");\n        return false;\n    }\n\n    upx_uint64_t max_LOADsz = 0, max_offset = 0;\n    Elf64_Phdr const *phdr = phdri;\n    for (unsigned j=0; j < e_phnum; ++phdr, ++j) {\n        if (j > ((MAX_ELF_HDR_64 - sizeof(Elf64_Ehdr)) / sizeof(Elf64_Phdr))) {\n            throwCantPack(\"too many ElfXX_Phdr; try '--force-execve'\");\n            return false;\n        }\n        if (is_LOAD(phdr)) {\n            // The first PT_LOAD must cover the beginning of the file (0==p_offset).\n            upx_uint64_t const p_offset = get_te64(&phdr->p_offset);\n            if (1!= exetype) {\n                exetype = 1;\n                load_va = get_te64(&phdr->p_vaddr);  // class data member\n                upx_uint64_t const off = ~page_mask & load_va;\n                if (off && off == p_offset) { // specific hint\n                    throwCantPack(\"Go-language PT_LOAD: try hemfix.c, or try '--force-execve'\");\n                    // Fixing it inside upx fails because packExtent() reads original file.\n                    return false;\n                }\n                if (0 != p_offset) { // 1st PT_LOAD must cover Ehdr and Phdr\n                    throwCantPack(\"first PT_LOAD.p_offset != 0; try '--force-execve'\");\n                    return false;\n                }\n                // FIXME: bad for shlib!\n                hatch_off = ~3ul & (3+ get_te64(&phdr->p_memsz));\n            }\n            upx_uint64_t align = get_te64(&phdr->p_align);\n            if (0x200000ul < align) align = 0x200000ul;  // UPX_MIN type problem\n            max_LOADsz = UPX_MAX(max_LOADsz, align);\n            upx_uint64_t filesz = get_te64(&phdr->p_filesz);\n            max_LOADsz = UPX_MAX(max_LOADsz, filesz);\n            max_offset = UPX_MAX(max_offset, filesz + p_offset);\n        }\n    }\n    if (canUnpack()) {\n        throwAlreadyPacked();\n    }\n    // Heuristic for lopped trailing PackHeader (packed and \"hacked\"!)\n    if (3 == e_phnum  // not shlib: PT_LOAD.C_BASE, PT_LOAD.C_TEXT, PT_GNU_STACK\n    && UPX_MAGIC_LE32 == get_le32(&((l_info *)&phdri[e_phnum])->l_magic)) {\n        throwAlreadyPacked();\n    }\n    // We want to compress position-independent executable (gcc -pie)\n    // main programs, but compressing a shared library must be avoided\n    // because the result is no longer usable.  In theory, there is no way\n    // to tell them apart: both are just ET_DYN.  Also in theory,\n    // neither the presence nor the absence of any particular symbol name\n    // can be used to tell them apart; there are counterexamples.\n    // However, we will use the following heuristic suggested by\n    // Peter S. Mazinger <ps.m@gmx.net> September 2005:\n    // If a ET_DYN has __libc_start_main as a global undefined symbol,\n    // then the file is a position-independent executable main program\n    // (that depends on libc.so.6) and is eligible to be compressed.\n    // Otherwise (no __libc_start_main as global undefined): skip it.\n    // Also allow  __uClibc_main  and  __uClibc_start_main .\n\n    if (Elf64_Ehdr::ET_DYN==get_te16(&ehdr->e_type)) {\n        // The DT_SYMTAB has no designated length.  Read the whole file.\n        alloc_file_image(file_image, file_size);\n        fi->seek(0, SEEK_SET);\n        fi->readx(file_image, file_size);\n        memcpy(&ehdri, ehdr, sizeof(Elf64_Ehdr));\n        phdri= (Elf64_Phdr *)((size_t)e_phoff + file_image);  // do not free() !!\n        shdri= (Elf64_Shdr *)((size_t)e_shoff + file_image);  // do not free() !!\n\n        sec_strndx = nullptr;\n        shstrtab = nullptr;\n        if (e_shnum) {\n            e_shstrndx = get_te16(&ehdr->e_shstrndx);\n            if (e_shstrndx) {\n                if (e_shnum <= e_shstrndx) {\n                    char msg[40]; snprintf(msg, sizeof(msg),\n                        \"bad e_shstrndx %#x >= e_shnum %d\", e_shstrndx, e_shnum);\n                    throwCantPack(msg);\n                }\n                sec_strndx = &shdri[e_shstrndx];\n                upx_uint64_t sh_offset = get_te64(&sec_strndx->sh_offset);\n                if ((u64_t)file_size <= sh_offset) {\n                    char msg[50]; snprintf(msg, sizeof(msg),\n                        \"bad .e_shstrndx->sh_offset %#lx\", (long unsigned)sh_offset);\n                    throwCantPack(msg);\n                }\n                shstrtab = (char const *)(sh_offset + file_image);\n            }\n            sec_dynsym = elf_find_section_type(Elf64_Shdr::SHT_DYNSYM);\n            if (sec_dynsym) {\n                unsigned const sh_link = get_te32(&sec_dynsym->sh_link);\n                if (e_shnum <= sh_link) {\n                    char msg[50]; snprintf(msg, sizeof(msg),\n                        \"bad SHT_DYNSYM.sh_link %#x\", sh_link);\n                }\n                sec_dynstr = &shdri[sh_link];\n            }\n\n            if (sec_strndx) {\n                unsigned const sh_name = get_te32(&sec_strndx->sh_name);\n                if (Elf64_Shdr::SHT_STRTAB != get_te32(&sec_strndx->sh_type)\n                || (u32_t)file_size <= (sizeof(\".shstrtab\")\n                    + sh_name + (shstrtab - (const char *)&file_image[0]))\n                || (sh_name\n                  && 0!=strcmp((char const *)\".shstrtab\", &shstrtab[sh_name]))\n                ) {\n                    throwCantPack(\"bad e_shstrtab\");\n                }\n            }\n        }\n\n        Elf64_Phdr const *pload_x0(nullptr);  // first eXecutable PT_LOAD\n        phdr= phdri;\n        for (int j= e_phnum; --j>=0; ++phdr)\n        if (Elf64_Phdr::PT_DYNAMIC==get_te32(&phdr->p_type)) {\n            upx_uint64_t offset = check_pt_dynamic(phdr);\n            dynseg= (Elf64_Dyn *)(offset + file_image);\n            invert_pt_dynamic(dynseg,\n                umin(get_te64(&phdr->p_filesz), file_size - offset));\n        }\n        else if (is_LOAD(phdr)) {\n            if (!pload_x0\n            &&  Elf64_Phdr::PF_X & get_te32(&phdr->p_flags)\n            ) {\n                pload_x0 = phdr;\n            }\n            check_pt_load(phdr);\n        }\n        if (!pload_x0) {\n            throwCantPack(\"No PT_LOAD has (p_flags & PF_X)\");\n        }\n        // elf_find_dynamic() returns 0 if 0==dynseg.\n        dynstr=          (char const *)elf_find_dynamic(Elf64_Dyn::DT_STRTAB);\n        dynsym= (Elf64_Sym /*const*/ *)elf_find_dynamic(Elf64_Dyn::DT_SYMTAB);\n\n        if (opt->o_unix.force_pie\n        ||       Elf64_Dyn::DF_1_PIE & elf_unsigned_dynamic(Elf64_Dyn::DT_FLAGS_1)\n        ||  calls_crt1((Elf64_Rela const *)elf_find_dynamic(Elf64_Dyn::DT_RELA),\n                                  (int)elf_unsigned_dynamic(Elf64_Dyn::DT_RELASZ))\n        ||  calls_crt1((Elf64_Rela const *)elf_find_dynamic(Elf64_Dyn::DT_JMPREL),\n                                  (int)elf_unsigned_dynamic(Elf64_Dyn::DT_PLTRELSZ))) {\n            is_pie = true;  // UNUSED except to ignore is_shlib and xct_off\n            goto proceed;  // calls C library init for main program\n        }\n\n        if (Elf64_Ehdr::EM_ARM==get_te16(&ehdri.e_machine)) {\n            sec_arm_attr = elf_find_section_type(Elf64_Shdr::SHT_ARM_ATTRIBUTES);\n            if (Elf64_Ehdr::ET_DYN == e_type) {\n                // See comment in Elf32_Linux::canPack().  is_asl does not work.\n                // 64-bit ARM (aarch64) also has no ARM_ATTRIBUTES.\n                //is_asl = (!!saved_opt_android_shlib) << 1;  // bit 1; see is_shlib\n                is_asl = 0;\n            }\n        }\n\n        // Heuristic HACK for shared libraries (compare Darwin (MacOS) Dylib.)\n        // If there is an existing DT_INIT, and if everything that the dynamic\n        // linker ld-linux needs to perform relocations before calling DT_INIT\n        // resides below the first SHT_EXECINSTR Section in one PT_LOAD, then\n        // compress from the first executable Section to the end of that PT_LOAD.\n        // We must not alter anything that ld-linux might touch before it calls\n        // the DT_INIT function.\n        //\n        // Obviously this hack requires that the linker script put pieces\n        // into good positions when building the original shared library,\n        // and also requires ld-linux to behave.\n\n        if (/*jni_onload_sym ||*/ elf_find_dynamic(upx_dt_init)) {\n            if (elf_has_dynamic(Elf64_Dyn::DT_TEXTREL)) {\n                throwCantPack(\"DT_TEXTREL found; re-compile with -fPIC\");\n                goto abandon;\n            }\n            if (!(Elf64_Dyn::DF_1_PIE & elf_unsigned_dynamic(Elf64_Dyn::DT_FLAGS_1))) {\n                // not explicitly PIE main program\n                if (Elf64_Ehdr::EM_AARCH64 == e_machine  // Android is common\n                &&  !is_asl  // but not explicit\n                ) {\n                    opt->info_mode++;\n                    info(\"note: use --android-shlib if appropriate\");\n                    opt->info_mode--;\n                }\n            }\n            if (Elf64_Ehdr::EM_PPC64 == get_te16(&ehdr->e_machine)) {\n                throwCantPack(\"This test UPX cannot pack .so for PowerPC64; coming soon.\");\n            }\n            xct_va = ~(upx_uint64_t)0;\n            if (e_shnum) {\n                xct_va = canPack_Shdr(pload_x0);\n            }\n            else { // no Sections; use heuristics\n                upx_uint64_t const strsz  = elf_unsigned_dynamic(Elf64_Dyn::DT_STRSZ);\n                upx_uint64_t const strtab = elf_unsigned_dynamic(Elf64_Dyn::DT_STRTAB);\n                upx_uint64_t const relsz  = elf_unsigned_dynamic(Elf64_Dyn::DT_RELSZ);\n                upx_uint64_t const rel    = elf_unsigned_dynamic(Elf64_Dyn::DT_REL);\n                upx_uint64_t const init   = elf_unsigned_dynamic(upx_dt_init);\n                if ((init == (relsz + rel   ) && rel    == (strsz + strtab))\n                ||  (init == (strsz + strtab) && strtab == (relsz + rel   ))\n                ) {\n                    xct_va = init;\n                    user_init_va = init;\n                    user_init_off = elf_get_offset_from_address(init);\n                }\n            }\n            // Rely on 0==elf_unsigned_dynamic(tag) if no such tag.\n            upx_uint64_t const va_gash = elf_unsigned_dynamic(Elf64_Dyn::DT_GNU_HASH);\n            upx_uint64_t const va_hash = elf_unsigned_dynamic(Elf64_Dyn::DT_HASH);\n            unsigned y = 0;\n            if ((y=1, xct_va < va_gash)  ||  (y=2, (0==va_gash && xct_va < va_hash))\n            ||  (y=3, xct_va < elf_unsigned_dynamic(Elf64_Dyn::DT_STRTAB))\n            ||  (y=4, xct_va < elf_unsigned_dynamic(Elf64_Dyn::DT_SYMTAB))\n            ||  (y=5, xct_va < elf_unsigned_dynamic(Elf64_Dyn::DT_REL))\n            ||  (y=6, xct_va < elf_unsigned_dynamic(Elf64_Dyn::DT_RELA))\n            ||  (y=7, xct_va < elf_unsigned_dynamic(Elf64_Dyn::DT_JMPREL))\n            ||  (y=8, xct_va < elf_unsigned_dynamic(Elf64_Dyn::DT_VERDEF))\n            ||  (y=9, xct_va < elf_unsigned_dynamic(Elf64_Dyn::DT_VERSYM))\n            ||  (y=10, xct_va < elf_unsigned_dynamic(Elf64_Dyn::DT_VERNEED)) ) {\n                static char const *which[] = {\n                    \"unknown\",\n                    \"DT_GNU_HASH\",\n                    \"DT_HASH\",\n                    \"DT_STRTAB\",\n                    \"DT_SYMTAB\",\n                    \"DT_REL\",\n                    \"DT_RELA\",\n                    \"DT_JMPREL\",\n                    \"DT_VERDEF\",\n                    \"DT_VERSYM\",\n                    \"DT_VERNEED\",\n                };\n                char buf[30]; snprintf(buf, sizeof(buf), \"%s above stub\", which[y]);\n                throwCantPack(buf);\n                goto abandon;\n            }\n            xct_off = elf_get_offset_from_address(xct_va);\n            if (opt->debug.debug_level) {\n                fprintf(stderr, \"shlib canPack: xct_va=%#lx  xct_off=%#lx\\n\",\n                    (long)xct_va, (long)xct_off);\n            }\n            goto proceed;  // But proper packing depends on checking xct_va.\n        }\n        else {\n            throwCantPack(\"need DT_INIT; try \\\"void _init(void){}\\\"\");\n        }\nabandon:\n        return false;\nproceed: ;\n    }\n    // XXX Theoretically the following test should be first,\n    // but PackUnix::canPack() wants 0!=exetype ?\n    if (!super::canPack())\n        return false;\n    assert(exetype == 1);\n    exetype = 0;\n\n    // set options\n    // this->blocksize: avoid over-allocating.\n    // (file_size - max_offset): debug info, non-globl symbols, etc.\n    opt->o_unix.blocksize = blocksize = UPX_MAX(max_LOADsz, file_size - max_offset);\n    return true;\n}\n\noff_t\nPackLinuxElf32::getbrk(Elf32_Phdr const *phdr, int nph) const\n{\n    off_t brka = 0;\n    for (int j = 0; j < nph; ++phdr, ++j) {\n        if (is_LOAD(phdr)) {\n            off_t b = get_te32(&phdr->p_vaddr) + get_te32(&phdr->p_memsz);\n            if (b > brka)\n                brka = b;\n        }\n    }\n    return brka;\n}\n\noff_t\nPackLinuxElf32::getbase(const Elf32_Phdr *phdr, int nph) const\n{\n    off_t base = ~0u;\n    for (int j = 0; j < nph; ++phdr, ++j) {\n        if (is_LOAD(phdr)) {\n            unsigned const vaddr = get_te32(&phdr->p_vaddr);\n            if (vaddr < (unsigned) base)\n                base = vaddr;\n        }\n    }\n    if (0!=base) {\n        return base;\n    }\n    return 0x12000;\n}\n\noff_t\nPackLinuxElf64::getbrk(const Elf64_Phdr *phdr, int nph) const\n{\n    off_t brka = 0;\n    for (int j = 0; j < nph; ++phdr, ++j) {\n        if (is_LOAD(phdr)) {\n            off_t b = get_te64(&phdr->p_vaddr) + get_te64(&phdr->p_memsz);\n            if (b > brka)\n                brka = b;\n        }\n    }\n    return brka;\n}\n\nstatic unsigned\nis_pow2(unsigned x)\n{\n    return !((-1 + x) & x);\n}\n\nvoid\nPackLinuxElf32::generateElfHdr(\n    OutputFile *fo,\n    void const *proto,\n    unsigned const brka\n)\n{\n    cprElfHdr2 *const h2 = (cprElfHdr2 *)(void *)&elfout;\n    cprElfHdr3 *const h3 = (cprElfHdr3 *)(void *)&elfout;\n    h3->ehdr =         ((cprElfHdr3 const *)proto)->ehdr;\n    e_type = get_te16(&h3->ehdr.e_type);\n    if (!memcmp(\"\\x7f\\x45\\x4c\\x46\", proto, 4) && Elf32_Ehdr::ET_EXEC == e_type\n    &&  2 <= get_te16(&h3->ehdr.e_phnum)) {\n        h3->phdr[C_BASE] = ((cprElfHdr3 const *)proto)->phdr[1];  // .data; .p_align\n        h3->phdr[C_TEXT] = ((cprElfHdr3 const *)proto)->phdr[0];  // .text\n    }\n    else  {\n        memcpy(&h3->ehdr.e_ident[0], \"\\x7f\\x45\\x4c\\x46\", 4);\n        h3->ehdr.e_ident[EI_CLASS] = ei_class;\n        h3->ehdr.e_ident[EI_DATA] = ei_data;\n        h3->ehdr.e_ident[EI_VERSION] = EV_CURRENT;\n        h3->ehdr.e_ident[EI_OSABI] = ei_osabi;\n\n        h3->ehdr.e_ident[EI_ABIVERSION] = ehdri.e_ident[EI_ABIVERSION];  // ei_abiversion ?\n        // Perhaps NT_GNU_ABI_TAG from Shdr .note.ABI-tag  or PT_NOTE ?\n        // But that is much too recent (and un-standardized) for other software.\n\n        set_te32(&h3->ehdr.e_phoff, sizeof(Elf32_Ehdr));\n        set_te16(&h3->ehdr.e_ehsize,sizeof(Elf32_Ehdr));\n        set_te16(&h3->ehdr.e_phentsize, sizeof(Elf32_Phdr));\n        set_te16(&h3->ehdr.e_phnum, 2);\n        set_te16(&h3->ehdr.e_machine, e_machine);\n        set_te16(&h3->ehdr.e_shstrndx, 0);\n        memset(&h3->phdr[C_BASE], 0, sizeof(h3->phdr[C_BASE]));\n        memset(&h3->phdr[C_TEXT], 0, sizeof(h3->phdr[C_TEXT]));\n        memset(&h3->phdr[2     ], 0, sizeof(h3->phdr[2     ]));\n        set_te32(&h3->phdr[C_BASE].p_flags, 0);\n        set_te32(&h3->phdr[C_TEXT].p_flags, Elf32_Phdr::PF_X| Elf32_Phdr::PF_R);\n        if (!memcmp(\"\\x7f\\x45\\x4c\\x46\", proto, 4) && Elf32_Ehdr::ET_REL == e_type) {\n        }\n        else {\n            throwCantPack(\"unknown e_type %#x\", e_type);\n        }\n    }\n    h3->ehdr.e_type = ehdri.e_type;  // ET_EXEC vs ET_DYN (gcc -pie -fPIC)\n    memset(&h3->linfo, 0, sizeof(h3->linfo));\n\n    h3->ehdr.e_ident[Elf32_Ehdr::EI_OSABI] = ei_osabi;\n    if (Elf32_Ehdr::EM_MIPS==e_machine) { // MIPS R3000  FIXME\n        h3->ehdr.e_ident[Elf32_Ehdr::EI_OSABI] = Elf32_Ehdr::ELFOSABI_NONE;\n        h3->ehdr.e_flags = ehdri.e_flags;\n    }\n\n    if (ph.format != getFormat()) {\n        assert(false);  // unknown ph.format, PackLinuxElf32\n    }\n    assert(get_te32(&h2->ehdr.e_phoff)     == sizeof(Elf32_Ehdr));\n    assert(get_te16(&h2->ehdr.e_ehsize)    == sizeof(Elf32_Ehdr));\n    assert(get_te16(&h2->ehdr.e_phentsize) == sizeof(Elf32_Phdr));\n\n    h2->ehdr.e_shoff = 0;\n    set_te16(&h2->ehdr.e_shentsize, sizeof(Elf32_Shdr));  // libbfd-2.41-38.fc40\n    if (o_elf_shnum) {\n        h2->ehdr.e_shnum = o_elf_shnum;\n        h2->ehdr.e_shstrndx = o_elf_shnum - 1;\n    }\n    else {\n        // https://bugzilla.redhat.com/show_bug.cgi?id=2131609\n        // 0==.e_shnum is a special case for libbfd\n        // that requires 0==.e_shentsize in order to force \"no Shdrs\"\n        // But qemu 8.2.9 with libbfd-2.41-38.fc40  says EXEC format error\n        // and uses 0==.e_shoff instead.\n        // h2->ehdr.e_shentsize = 0;\n        h2->ehdr.e_shnum = 0;\n        h2->ehdr.e_shstrndx = 0;\n    }\n\n    unsigned phnum_o = 2 + n_phdrx;  // C_BASE, C_TEXT\n    set_te16(&h2->ehdr.e_phnum, phnum_o);\n\n    // Info for OS kernel to set the brk()\n    if (brka) {\n        // linux-2.6.14 binfmt_elf.c: SIGKILL if (0==.p_memsz) on a page boundary\n        upx_uint32_t lo_va_user = ~0u;  // infinity\n        for (int j= e_phnum; --j>=0; ) {\n            if (is_LOAD(&phdri[j])) {\n                upx_uint32_t const vaddr = get_te32(&phdri[j].p_vaddr);\n                lo_va_user = umin(lo_va_user, vaddr);\n            }\n        }\n        set_te32(                 &h2->phdr[C_BASE].p_vaddr, lo_va_user);\n        h2->phdr[C_BASE].p_paddr = h2->phdr[C_BASE].p_vaddr;\n        h2->phdr[C_TEXT].p_vaddr = h2->phdr[C_BASE].p_vaddr;\n        h2->phdr[C_TEXT].p_paddr = h2->phdr[C_BASE].p_vaddr;\n        set_te32(&h2->phdr[C_BASE].p_type, PT_LOAD);  // be sure\n        set_te32(&h2->phdr[C_TEXT].p_type, PT_LOAD);  // be sure\n        h2->phdr[C_BASE].p_offset = 0;\n        h2->phdr[C_BASE].p_filesz = 0;\n        // .p_memsz = brka;  temporary until sz_pack2\n        set_te32(&h2->phdr[C_BASE].p_memsz, brka - lo_va_user);\n        set_te32(&h2->phdr[C_BASE].p_flags, Elf32_Phdr::PF_R | Elf32_Phdr::PF_W);\n    }\n    set_te32(&h3->phdr[C_BASE].p_align, page_size);\n    set_te32(&h3->phdr[C_TEXT].p_align, page_size);\n    set_te32(&h2->phdr[C_TEXT].p_flags, ~Elf32_Phdr::PF_W & get_te32(&h2->phdr[C_TEXT].p_flags));\n    fo->write(h2, sizeof(Elf32_Ehdr) + 2* sizeof(Elf32_Phdr));  // C_BASE, C_TEXT\n\n    u64_t const zero_pad = 0;\n    unsigned uva0 = get_te32(&h2->phdr[C_TEXT].p_vaddr);\n    unsigned off_o = 0;\n    for (unsigned phase = 0; phase < 2; ++phase) { // 0: Phdrs;  1: bodies\n        off_o = sizeof(Elf32_Ehdr) + phnum_o * sizeof(Elf32_Phdr);\n        for (unsigned j = 0; j < n_phdrx; ++j) {\n            Elf32_Phdr phtmp = *phdrx[j];\n            phtmp.p_vaddr = phtmp.p_paddr = 0;\n            unsigned const off_i = get_te32(&phtmp.p_offset);\n            unsigned const align = get_te32(&phtmp.p_align);\n            unsigned const filesz = get_te32(&phtmp.p_filesz);\n            unsigned pad = 0;\n            if (filesz && align && is_pow2(align)) {\n                unsigned alm1 = -1 + umin(8u, align);\n                pad = alm1 & (0u - off_o);\n                off_o += pad;\n                set_te32(&phtmp.p_vaddr, off_o + uva0); phtmp.p_paddr = phtmp.p_vaddr;\n            }\n            if (0==phase) {\n                set_te32(&phtmp.p_offset, (filesz ? off_o : 0));\n                fo->write(&phtmp, sizeof(phtmp));  // Phdr\n            }\n            if (1==phase) {\n                if (pad) fo->write(&zero_pad, pad);\n                if (filesz) fo->write(&file_image[off_i], filesz);  // body\n            }\n            off_o += filesz;\n        }\n    }\n    off_o = fpad4(fo, off_o);\n    sz_phdrx = off_o - (sizeof(Elf32_Ehdr) + phnum_o * sizeof(Elf32_Phdr));\n    set_te32(&h2->phdr[C_BASE].p_filesz, off_o);\n\n    sz_elf_hdrs = sizeof(Elf32_Ehdr) + phnum_o * sizeof(Elf32_Phdr) + sz_phdrx;\n    overlay_offset = sz_elf_hdrs + sizeof(l_info);\n    o_binfo        = sz_elf_hdrs + sizeof(l_info) + sizeof(p_info);\n\n    l_info linfo2; memset(&linfo2, 0, sizeof(linfo2));\n    fo->write(&linfo2, sizeof(linfo2));\n}\n\nvoid\nPackNetBSDElf32x86::generateElfHdr(\n    OutputFile *fo,\n    void const *proto,\n    unsigned const brka\n)\n{\n    cprElfHdr2 *const h2 = (cprElfHdr2 *)(void *)&elfout;\n    super::generateElfHdr(fo, proto, brka);\n\n    sz_elf_hdrs = sizeof(*h2) - sizeof(linfo);\n    unsigned note_offset = sz_elf_hdrs;\n\n    // Find the NetBSD PT_NOTE and the PaX PT_NOTE.\n    Elf32_Nhdr const *np_NetBSD = nullptr;  unsigned sz_NetBSD = 0;\n    Elf32_Nhdr const *np_PaX    = nullptr;  unsigned sz_PaX    = 0;\n    unsigned char *cp = (unsigned char *)note_body;\n    unsigned j;\n    for (j=0; j < note_size; ) {\n        Elf32_Nhdr const *const np = (Elf32_Nhdr const *)(void *)cp;\n        int k = sizeof(*np) + up4(get_te32(&np->namesz))\n            + up4(get_te32(&np->descsz));\n\n        if (NHDR_NETBSD_TAG == np->type && 7== np->namesz\n        &&  NETBSD_DESCSZ == np->descsz\n        &&  0==strcmp(ELF_NOTE_NETBSD_NAME,\n                /* &np->body */ (char const *)(1+ np))) {\n            np_NetBSD = np;\n            sz_NetBSD = k;\n        }\n        if (NHDR_PAX_TAG == np->type && 4== np->namesz\n        &&  PAX_DESCSZ==np->descsz\n        &&  0==strcmp(ELF_NOTE_PAX_NAME,\n                /* &np->body */ (char const *)(1+ np))) {\n            np_PaX = np;\n            sz_PaX = k;\n        }\n        cp += k;\n        j += k;\n    }\n\n    // Add PT_NOTE for the NetBSD note and PaX note, if any.\n    note_offset += (np_NetBSD ? sizeof(Elf32_Phdr) : 0);\n    note_offset += (np_PaX    ? sizeof(Elf32_Phdr) : 0);\n    Elf32_Phdr *phdr = &elfout.phdr[C_NOTE];\n    if (np_NetBSD) {\n        set_te32(&phdr->p_type, PT_NOTE32);\n        set_te32(&phdr->p_offset, note_offset);\n        set_te32(&phdr->p_vaddr, note_offset);\n        set_te32(&phdr->p_paddr, note_offset);\n        set_te32(&phdr->p_filesz, sz_NetBSD);\n        set_te32(&phdr->p_memsz,  sz_NetBSD);\n        set_te32(&phdr->p_flags, Elf32_Phdr::PF_R);\n        set_te32(&phdr->p_align, 4);\n\n        sz_elf_hdrs += sz_NetBSD + sizeof(*phdr);\n        note_offset += sz_NetBSD;\n        ++phdr;\n    }\n    if (np_PaX) {\n        set_te32(&phdr->p_type, PT_NOTE32);\n        set_te32(&phdr->p_offset, note_offset);\n        set_te32(&phdr->p_vaddr, note_offset);\n        set_te32(&phdr->p_paddr, note_offset);\n        set_te32(&phdr->p_filesz, sz_PaX);\n        set_te32(&phdr->p_memsz,  sz_PaX);\n        set_te32(&phdr->p_flags, Elf32_Phdr::PF_R);\n        set_te32(&phdr->p_align, 4);\n\n        /* &np_PaX->body[4] */\n        const unsigned char *p4 =  &(ACC_CCAST(const unsigned char *, (1+ np_PaX)))[4];\n        unsigned bits = get_te32(p4);\n        bits &= ~PAX_MPROTECT;\n        bits |=  PAX_NOMPROTECT;\n        set_te32(ACC_UNCONST_CAST(unsigned char *, p4), bits);\n\n        sz_elf_hdrs += sz_PaX + sizeof(*phdr);\n        note_offset += sz_PaX;\n        ++phdr;\n    }\n    set_te32(&h2->phdr[C_TEXT].p_filesz, note_offset);\n              h2->phdr[C_TEXT].p_memsz = h2->phdr[C_TEXT].p_filesz;\n\n    if (ph.format==getFormat()) {\n        set_te16(&h2->ehdr.e_phnum, !!sz_NetBSD + !!sz_PaX +\n        get_te16(&h2->ehdr.e_phnum));\n        fo->seek(0, SEEK_SET);\n        fo->rewrite(h2, sizeof(*h2) - sizeof(h2->linfo));\n\n        // The 'if' guards on these two calls to memcpy are required\n        // because the C Standard Committee did not debug the Standard\n        // before publishing.  An empty region (0==size) must nevertheless\n        // have a valid (non-nullptr) pointer.\n        if (sz_NetBSD) memcpy(&((char *)phdr)[0],         np_NetBSD, sz_NetBSD);\n        if (sz_PaX)    memcpy(&((char *)phdr)[sz_NetBSD], np_PaX,    sz_PaX);\n\n        fo->write(&elfout.phdr[C_NOTE],\n            &((char *)phdr)[sz_PaX + sz_NetBSD] - (char *)&elfout.phdr[C_NOTE]);\n\n        l_info foo; memset(&foo, 0, sizeof(foo));\n        fo->rewrite(&foo, sizeof(foo));\n    }\n    else {\n        assert(false);  // unknown ph.format, PackLinuxElf32\n    }\n}\n\nvoid\nPackOpenBSDElf32x86::generateElfHdr(\n    OutputFile *fo,\n    void const *proto,\n    unsigned const brka\n)\n{\n    cprElfHdr3 *const h3 = (cprElfHdr3 *)(void *)&elfout;\n    memcpy(h3, proto, sizeof(*h3));  // reads beyond, but OK\n    h3->ehdr.e_ident[Elf32_Ehdr::EI_OSABI] = ei_osabi;\n    assert(2==get_te16(&h3->ehdr.e_phnum));\n    set_te16(&h3->ehdr.e_phnum, 3);\n\n    assert(get_te32(&h3->ehdr.e_phoff)     == sizeof(Elf32_Ehdr));\n                         h3->ehdr.e_shoff = 0;\n    assert(get_te16(&h3->ehdr.e_ehsize)    == sizeof(Elf32_Ehdr));\n    assert(get_te16(&h3->ehdr.e_phentsize) == sizeof(Elf32_Phdr));\n    set_te16(&h3->ehdr.e_shentsize, sizeof(Elf32_Shdr));  // libbfd-2.41-38.fc40\n    h3->ehdr.e_shnum = 0;\n    h3->ehdr.e_shstrndx = 0;\n\n    struct {\n        Elf32_Nhdr nhdr;\n        char name[8];\n        unsigned body;\n    } elfnote;\n\n    unsigned const note_offset = sizeof(*h3) - sizeof(linfo);\n    sz_elf_hdrs = sizeof(elfnote) + note_offset;\n\n    set_te32(&h3->phdr[C_NOTE].p_type, PT_NOTE32);\n    set_te32(&h3->phdr[C_NOTE].p_offset, note_offset);\n    set_te32(&h3->phdr[C_NOTE].p_vaddr, note_offset);\n    set_te32(&h3->phdr[C_NOTE].p_paddr, note_offset);\n    set_te32(&h3->phdr[C_NOTE].p_filesz, sizeof(elfnote));\n    set_te32(&h3->phdr[C_NOTE].p_memsz,  sizeof(elfnote));\n    set_te32(&h3->phdr[C_NOTE].p_flags, Elf32_Phdr::PF_R);\n    set_te32(&h3->phdr[C_NOTE].p_align, 4);\n\n    // Q: Same as this->note_body[0 .. this->note_size-1] ?\n    set_te32(&elfnote.nhdr.namesz, 8);\n    set_te32(&elfnote.nhdr.descsz, OPENBSD_DESCSZ);\n    set_te32(&elfnote.nhdr.type,   NHDR_OPENBSD_TAG);\n    memcpy(elfnote.name, \"OpenBSD\", sizeof(elfnote.name));\n    elfnote.body = 0;\n\n    set_te32(&h3->phdr[C_TEXT].p_filesz, sz_elf_hdrs);\n              h3->phdr[C_TEXT].p_memsz = h3->phdr[C_TEXT].p_filesz;\n\n    unsigned const brkb = brka | ((0==(~page_mask & brka)) ? 0x20 : 0);\n    set_te32(&h3->phdr[C_BASE].p_type, PT_LOAD);  // be sure\n    set_te32(&h3->phdr[C_BASE].p_offset, ~page_mask & brkb);\n    set_te32(&h3->phdr[C_BASE].p_vaddr, brkb);\n    set_te32(&h3->phdr[C_BASE].p_paddr, brkb);\n    h3->phdr[C_BASE].p_filesz = 0;\n    // Too many kernels have bugs when 0==.p_memsz\n    set_te32(&h3->phdr[C_BASE].p_memsz, 1);\n    set_te32(&h3->phdr[C_BASE].p_flags, Elf32_Phdr::PF_R | Elf32_Phdr::PF_W);\n\n    if (ph.format==getFormat()) {\n        memset(&h3->linfo, 0, sizeof(h3->linfo));\n        fo->write(h3, sizeof(*h3) - sizeof(h3->linfo));\n        fo->write(&elfnote, sizeof(elfnote));\n        fo->write(&h3->linfo, sizeof(h3->linfo));\n    }\n    else {\n        assert(false);  // unknown ph.format, PackLinuxElf32\n    }\n}\n\nvoid\nPackLinuxElf64::generateElfHdr(\n    OutputFile *fo,\n    void const *proto,\n    unsigned const brka\n)\n{\n    cprElfHdr2 *const h2 = (cprElfHdr2 *)(void *)&elfout;\n    cprElfHdr3 *const h3 = (cprElfHdr3 *)(void *)&elfout;\n    h3->ehdr =         ((cprElfHdr3 const *)proto)->ehdr;\n    if (Elf64_Ehdr::ET_REL == get_te16(&h3->ehdr.e_type)) {\n        set_te64(&h3->ehdr.e_phoff, sizeof(Elf64_Ehdr));\n        set_te16(&h3->ehdr.e_ehsize,sizeof(Elf64_Ehdr));\n        set_te16(&h3->ehdr.e_phentsize, sizeof(Elf64_Phdr));\n        set_te16(&h3->ehdr.e_phnum, 2);\n        memset(&h3->phdr[C_BASE], 0, sizeof(h3->phdr[C_BASE]));\n        memset(&h3->phdr[C_TEXT], 0, sizeof(h3->phdr[C_TEXT]));\n        memset(&h3->phdr[2     ], 0, sizeof(h3->phdr[2     ]));\n        set_te32(&h3->phdr[C_BASE].p_flags, 0);\n        set_te32(&h3->phdr[C_TEXT].p_flags, Elf64_Phdr::PF_X| Elf64_Phdr::PF_R);\n    }\n    else {\n        h3->phdr[C_BASE] = ((cprElfHdr3 const *)proto)->phdr[1];  // .data; .p_align\n        h3->phdr[C_TEXT] = ((cprElfHdr3 const *)proto)->phdr[0];  // .text\n    }\n    memset(&h3->linfo, 0, sizeof(h3->linfo));\n\n    h3->ehdr.e_type = ehdri.e_type;  // ET_EXEC vs ET_DYN (gcc -pie -fPIC)\n    h3->ehdr.e_ident[Elf64_Ehdr::EI_OSABI] = ei_osabi;\n    if (Elf64_Ehdr::ELFOSABI_LINUX == ei_osabi  // proper\n    &&  Elf64_Ehdr::ELFOSABI_NONE  == ehdri.e_ident[Elf64_Ehdr::EI_OSABI]  // sloppy\n    ) { // propagate sloppiness so that decompression does not complain\n        h3->ehdr.e_ident[Elf64_Ehdr::EI_OSABI] = ehdri.e_ident[Elf64_Ehdr::EI_OSABI];\n    }\n    if (Elf64_Ehdr::EM_PPC64 == get_te16(&ehdri.e_machine)) {\n        h3->ehdr.e_flags = ehdri.e_flags;  // \"0x1, abiv1\" vs \"0x2, abiv2\"\n    }\n\n    assert(get_te64(&h2->ehdr.e_phoff)     == sizeof(Elf64_Ehdr));\n    assert(get_te16(&h2->ehdr.e_ehsize)    == sizeof(Elf64_Ehdr));\n    assert(get_te16(&h2->ehdr.e_phentsize) == sizeof(Elf64_Phdr));\n\n    h2->ehdr.e_shoff = 0;\n    set_te16(&h2->ehdr.e_shentsize, sizeof(Elf64_Shdr));  // libbfd-2.41-38.fc40\n    if (o_elf_shnum) {\n        h2->ehdr.e_shnum = o_elf_shnum;\n        h2->ehdr.e_shstrndx = o_elf_shnum - 1;\n    }\n    else {\n        // https://bugzilla.redhat.com/show_bug.cgi?id=2131609\n        // 0==.e_shnum is a special case for libbfd\n        // that requires 0==.e_shentsize in order to force \"no Shdrs\"\n        // But qemu 8.2.9 with libbfd-2.41-38.fc40  says EXEC format error\n        // and uses 0==.e_shoff instead.\n        // h2->ehdr.e_shentsize = 0;\n        h2->ehdr.e_shnum = 0;\n        h2->ehdr.e_shstrndx = 0;\n    }\n\n    unsigned const phnum_i = get_te16(&h2->ehdr.e_phnum);\n    unsigned       phnum_o = 2 + n_phdrx;  // C_BASE, C_TEXT\n    set_te16(&h2->ehdr.e_phnum, phnum_o);\n    o_binfo =  sizeof(Elf64_Ehdr) + sizeof(Elf64_Phdr)*phnum_o + sizeof(l_info) + sizeof(p_info);\n    set_te64(&h2->phdr[C_TEXT].p_filesz, sizeof(*h2));  // + identsize;\n              h2->phdr[C_TEXT].p_memsz = h2->phdr[C_TEXT].p_filesz;\n    set_te32(&h2->phdr[C_TEXT].p_type, PT_LOAD);  // be sure\n\n    for (unsigned j=0; j < phnum_i; ++j) {\n        if (is_LOAD(&h3->phdr[j])) {\n            set_te64( &h3->phdr[j].p_align, page_size);\n        }\n    }\n\n    // Info for OS kernel to set the brk()\n    if (brka) {\n        // linux-2.6.14 binfmt_elf.c: SIGKILL if (0==.p_memsz) on a page boundary\n        upx_uint64_t lo_va_user(~(upx_uint64_t)0);  // infinity\n        for (int j= e_phnum; --j>=0; ) {\n            if (is_LOAD(&phdri[j])) {\n                upx_uint64_t const vaddr = get_te64(&phdri[j].p_vaddr);\n                lo_va_user = umin(lo_va_user, vaddr);\n            }\n        }\n        set_te64(                 &h2->phdr[C_BASE].p_vaddr, lo_va_user);\n        h2->phdr[C_BASE].p_paddr = h2->phdr[C_BASE].p_vaddr;\n        h2->phdr[C_TEXT].p_vaddr = h2->phdr[C_BASE].p_vaddr;\n        h2->phdr[C_TEXT].p_paddr = h2->phdr[C_BASE].p_vaddr;\n        set_te32(&h2->phdr[C_BASE].p_type, PT_LOAD);  // be sure\n        h2->phdr[C_BASE].p_offset = 0;\n        h2->phdr[C_BASE].p_filesz = 0;\n        // .p_memsz = brka;  temporary until sz_pack2\n        set_te64(&h2->phdr[C_BASE].p_memsz, brka - lo_va_user);\n        set_te32(&h2->phdr[C_BASE].p_flags, Elf64_Phdr::PF_R | Elf64_Phdr::PF_W);\n    }\n    set_te64(&h3->phdr[C_BASE].p_align, page_size);\n    set_te64(&h3->phdr[C_TEXT].p_align, page_size);\n    set_te32(&h2->phdr[C_TEXT].p_flags, ~Elf64_Phdr::PF_W & get_te32(&h2->phdr[C_TEXT].p_flags));\n    fo->write(h2, sizeof(Elf64_Ehdr) + 2* sizeof(Elf64_Phdr));  // C_BASE, C_TEXT\n\n    u64_t const zero_pad = 0;\n    unsigned uva0 = get_te64(&h2->phdr[C_TEXT].p_vaddr);\n    unsigned off_o = 0;\n    for (unsigned phase = 0; phase < 2; ++phase) { // 0: Phdrs;  1: bodies\n        off_o = sizeof(Elf64_Ehdr) + phnum_o * sizeof(Elf64_Phdr);\n        for (unsigned j = 0; j < n_phdrx; ++j) {\n            Elf64_Phdr phtmp = *phdrx[j];\n            phtmp.p_vaddr = phtmp.p_paddr = 0;\n            u64_t const off_i = get_te64(&phtmp.p_offset);\n            u64_t const align = get_te64(&phtmp.p_align);\n            u64_t const filesz = get_te64(&phtmp.p_filesz);\n            unsigned pad = 0;\n            if (filesz && align && is_pow2(align)) {\n                unsigned alm1 = -1 + umin(8u, (unsigned)align);\n                pad = alm1 & (0u - off_o);\n                off_o += pad;\n                set_te64(&phtmp.p_vaddr, off_o + uva0); phtmp.p_paddr = phtmp.p_vaddr;\n            }\n            if (0==phase) {\n                set_te64(&phtmp.p_offset, (filesz ? off_o : 0));\n                fo->write(&phtmp, sizeof(phtmp));  // Phdr\n            }\n            if (1==phase) {\n                if (pad) fo->write(&zero_pad, pad);\n                if (filesz) fo->write(&file_image[off_i], filesz);  // body\n            }\n            off_o += filesz;\n        }\n    }\n    off_o = fpad4(fo, off_o);\n    sz_phdrx = off_o - (sizeof(Elf64_Ehdr) + phnum_o * sizeof(Elf64_Phdr));\n    set_te64(&h2->phdr[C_BASE].p_filesz, off_o);\n\n    sz_elf_hdrs = sizeof(Elf64_Ehdr) + phnum_o * sizeof(Elf64_Phdr) + sz_phdrx;\n    overlay_offset = sz_elf_hdrs + sizeof(l_info);\n    o_binfo        = sz_elf_hdrs + sizeof(l_info) + sizeof(p_info);\n\n    l_info linfo2; memset(&linfo2, 0, sizeof(linfo2));\n    fo->write(&linfo2, sizeof(linfo2));\n}\n\n// Android shlib has ABS symbols that actually are relative.\nstatic char const abs_symbol_names[][14] = {\n      \"__bss_end__\"\n    ,  \"_bss_end__\"\n    , \"__bss_start\"\n    , \"__bss_start__\"\n    ,  \"_edata\"\n    ,  \"_end\"\n    , \"__end__\"\n    , \"\"\n};\n\nint\nPackLinuxElf32::adjABS(Elf32_Sym *sym, unsigned delta)\n{\n    unsigned st_name = get_te32(&sym->st_name);\n    for (int j = 0; abs_symbol_names[j][0]; ++j) {\n        if (!strcmp(abs_symbol_names[j], get_str_name(st_name, (unsigned)-1))) {\n            sym->st_value += delta;\n            return 1;\n        }\n    }\n    return 0;\n}\n\nint\nPackLinuxElf64::adjABS(Elf64_Sym *sym, unsigned long delta)\n{\n    unsigned st_name = get_te32(&sym->st_name);\n    for (int j = 0; abs_symbol_names[j][0]; ++j) {\n        if (!strcmp(abs_symbol_names[j], get_str_name(st_name, (unsigned)-1))) {\n            sym->st_value += delta;\n            return 1;\n        }\n    }\n    return 0;\n}\n\nvoid PackLinuxElf32::pack1(OutputFile * /*fo*/, Filter &ft)\n{\n    fi->seek(0, SEEK_SET);\n    fi->readx(&ehdri, sizeof(ehdri));\n    assert(e_phoff == sizeof(Elf32_Ehdr));  // checked by canPack()\n    sz_phdrs = e_phnum * get_te16(&ehdri.e_phentsize);\n\n// We compress separate pieces (usually each PT_LOAD, plus the gaps in the file\n// that are not covered by any PT_LOAD), but currently at run time there can be\n// only one decompressor method.\n// Therefore we must plan ahead because Packer::compressWithFilters tries\n// to find the smallest result among the available methods, for one piece only.\n// In the future we may allow more than one decompression method at run time.\n// For now we must choose only one, and force PackUnix::packExtent\n// (==> compressWithFilters) to use it.\n    int nfilters = 0;\n    {\n        int const *fp = getFilters();\n        while (FT_END != *fp++) {\n            ++nfilters;\n        }\n    }\n    {\n        int npieces = 1;  // tail after highest PT_LOAD\n        Elf32_Phdr *phdr = phdri;\n        for (unsigned j=0; j < e_phnum; ++phdr, ++j) {\n            if (is_LOAD(phdr)) {\n                unsigned const  flags = get_te32(&phdr->p_flags);\n                unsigned       offset = get_te32(&phdr->p_offset);\n                if (!xct_off  // not shlib\n                  // new-style shlib: PT_LOAD[0] has symbol table\n                  // which must not be compressed, but also lacks PF_X\n                ||    (Elf32_Phdr::PF_X & flags)\n                  // Read-only, non-first PT_LOAD is _assumed_ to be compressible\n                ||  (!(Elf32_Phdr::PF_W & flags) && 0!=offset))\n                {\n                    ++npieces;  // will attempt compression of this PT_LOAD\n                }\n            }\n        }\n        uip->ui_total_passes += npieces;\n    }\n    int methods[256];\n    unsigned nmethods = prepareMethods(methods, ph.method, getCompressionMethods(M_ALL, ph.level));\n    if (1 < nmethods) { // Many are available, but we must choose only one\n        uip->ui_total_passes += 1;  // the batch for output\n        uip->ui_total_passes *= nmethods * (1+ nfilters);  // finding smallest total\n        PackHeader orig_ph = ph;\n        Filter orig_ft = ft;\n        unsigned max_offset = 0;\n        unsigned sz_best= ~0u;\n        int method_best = 0;\n        for (unsigned k = 0; k < nmethods; ++k) { // FIXME: parallelize; cost: working space\n            unsigned sz_this = 0;\n            Elf32_Phdr *phdr = phdri;\n            for (unsigned j=0; j < e_phnum; ++phdr, ++j) {\n                if (is_LOAD(phdr)) {\n                    unsigned const  flags = get_te32(&phdr->p_flags);\n                    unsigned       offset = get_te32(&phdr->p_offset);\n                    unsigned       filesz = get_te32(&phdr->p_filesz);\n                    max_offset = UPX_MAX(max_offset, filesz + offset);\n                    if (!xct_off  // not shlib\n                      // new-style shlib: PT_LOAD[0] has symbol table\n                      // which must not be compressed, but also lacks PF_X\n                    ||    (Elf32_Phdr::PF_X & flags)\n                      // Read-only, non-first PT_LOAD is _assumed_ to be compressible\n                    ||  (!(Elf32_Phdr::PF_W & flags) && 0!=offset))\n                    {\n                        if (xct_off && 0==offset) { // old-style shlib\n                            offset  = xct_off;\n                            filesz -= xct_off;\n                        }\n                        fi->seek(offset, SEEK_SET);\n                        fi->readx(ibuf, filesz);\n                        ft = orig_ft;\n                        ph = orig_ph;\n                        ph.set_method(ph_force_method(methods[k]), offset);\n                        ph.u_len = filesz;\n                        compressWithFilters(&ft, OVERHEAD, NULL_cconf, 10, true);\n                        sz_this += ph.c_len;\n                    }\n                }\n            }\n            unsigned const sz_tail = file_size - max_offset;  // debuginfo, etc.\n            if (sz_tail) {\n                fi->seek(max_offset, SEEK_SET);\n                fi->readx(ibuf, sz_tail);\n                ft = orig_ft;\n                ph = orig_ph;\n                ph.set_method(ph_force_method(methods[k]));\n                ph.u_len = sz_tail;\n                compressWithFilters(&ft, OVERHEAD, NULL_cconf, 10, true);\n                sz_this += ph.c_len;\n            }\n            // FIXME: loader size also depends on method\n            if (sz_best > sz_this) {\n                sz_best = sz_this;\n                method_best = methods[k];\n            }\n        }\n        ft = orig_ft;\n        ph = orig_ph;\n        ph.set_method(ph_force_method(method_best));\n    }\n\n    Elf32_Phdr *phdr = phdri;\n    for (unsigned j=0; j < e_phnum; ++phdr, ++j) {\n        unsigned const type = get_te32(&phdr->p_type);\n        if (PT_GNU_STACK32 == type || PT_NOTE32 == type) {\n            add_phdrx(phdr);  // PT_GNU_STACK32, PT_NOTE32\n        }\n        if (PT_LOAD == type) {\n            unsigned x = get_te32(&phdr->p_align) >> lg2_page;\n            while (x>>=1) {\n                ++lg2_page;\n            }\n        }\n        if (PT_GNU_RELRO32 == type\n        &&  16 < lg2_page) {\n            // x86* allows 4K, 2M, 1G\n            // arm32 and arm64 both allow 4K, 16K, 64K; Apple Silicon uses 16K\n            // Oracle 5.4.17-2136.314.6.2.el8uek.aarch64 demands 64K\n            // PowerPC and PowerPC64 has 4K, 64K, 1M (?), 16M (?)\n            // MIPS  allows any power of 2 from 4K through 64K\n\n            // If 64K < .p_align then we assume that 4K is also accepted.\n            // .p_align can be like 2M, which is a huge over-estimate.\n            // RELRO ends on a page boundary: usually close to actual page_size\n            unsigned offset = get_te32(&phdr->p_offset);\n            unsigned filesz = get_te32(&phdr->p_filesz);\n            if (!(0xfff & (filesz + offset))) { // a 4KiB boundary\n                unsigned b = 12;\n                while (!(~(~0u << b) & (filesz + offset))) {\n                    ++b;\n                }\n                lg2_page = umin(lg2_page, -1+ b);\n            }\n        }\n    }\n    page_size =  1u  <<lg2_page;\n    page_mask = ~0ull<<lg2_page;\n\n    progid = 0;  // getRandomId();  not useful, so do not clutter\n    sz_elf_hdrs = sizeof(ehdri) + sz_phdrs;\n\n    // only execute if option present\n    if (opt->o_unix.preserve_build_id) {\n        // set this so we can use elf_find_section_name\n        e_shnum = get_te16(&ehdri.e_shnum);\n        if (!shdri) {\n            mb_shdr.alloc(e_shnum * sizeof(Elf32_Shdr));\n            shdri = (Elf32_Shdr *)mb_shdr.getVoidPtr();\n            e_shoff = get_te32(&ehdri.e_shoff);\n            fi->seek(e_shoff, SEEK_SET);\n            fi->readx(shdri, e_shnum * sizeof(Elf32_Shdr));\n        }\n        //set the shstrtab\n        sec_strndx = &shdri[get_te16(&ehdri.e_shstrndx)];\n\n        upx_uint32_t sh_size = get_te32(&sec_strndx->sh_size);\n        mb_shstrtab.alloc(sh_size); shstrtab = (char *)mb_shstrtab.getVoidPtr();\n        fi->seek(0,SEEK_SET);\n        fi->seek(sec_strndx->sh_offset,SEEK_SET);\n        fi->readx(mb_shstrtab, sh_size);\n\n        Elf32_Shdr const *buildid = elf_find_section_name(\".note.gnu.build-id\");\n        if (buildid) {\n            unsigned bid_sh_size = get_te32(&buildid->sh_size);\n            buildid_data.alloc(bid_sh_size);\n            buildid_data.clear();\n            fi->seek(0,SEEK_SET);\n            fi->seek(buildid->sh_offset,SEEK_SET);\n            fi->readx((void *)buildid_data, bid_sh_size);\n\n            o_elf_shnum = 3;\n            memset(&shdrout,0,sizeof(shdrout));\n\n            //setup the build-id\n            memcpy(&shdrout.shdr[1], buildid, sizeof(shdrout.shdr[1]));\n            set_te32(&shdrout.shdr[1].sh_name, 1);\n\n            //setup the shstrtab\n            memcpy(&shdrout.shdr[2], sec_strndx, sizeof(shdrout.shdr[2]));\n            set_te32(&shdrout.shdr[2].sh_name, 20);\n            set_te32(&shdrout.shdr[2].sh_size, 29); //size of our static shstrtab\n        }\n    }\n}\n\nvoid PackLinuxElf32x86::pack1(OutputFile *fo, Filter &ft)\n{\n    super::pack1(fo, ft);\n    if (0!=xct_off)  // shared library\n        return;\n    generateElfHdr(fo, stub_i386_linux_elf_fold, getbrk(phdri, e_phnum) );\n}\n\nvoid PackBSDElf32x86::pack1(OutputFile *fo, Filter &ft)\n{\n    super::pack1(fo, ft);\n    if (0!=xct_off) // shared library\n        return;\n    generateElfHdr(fo, stub_i386_bsd_elf_fold, getbrk(phdri, e_phnum) );\n}\n\nvoid PackLinuxElf32armLe::pack1(OutputFile *fo, Filter &ft)\n{\n    super::pack1(fo, ft);\n    if (0!=xct_off)  // shared library\n        return;\n    unsigned const e_flags = get_te32(&ehdri.e_flags);\n    cprElfHdr3 h3;\n    if (Elf32_Ehdr::ELFOSABI_LINUX==ei_osabi) {\n        memcpy(&h3, stub_arm_v5a_linux_elf_fold, sizeof(Elf32_Ehdr) + 2*sizeof(Elf32_Phdr));\n\n        h3.ehdr.e_ident[Elf32_Ehdr::EI_ABIVERSION] = e_flags>>24;\n    }\n    else {\n        memcpy(&h3, stub_arm_v4a_linux_elf_fold,        sizeof(Elf32_Ehdr) + 2*sizeof(Elf32_Phdr));\n    }\n    // Fighting over .e_ident[EI_ABIVERSION]: Debian armhf is latest culprit.\n    // So copy from input to output; but see PackLinuxElf32::generateElfHdr\n    memcpy(&h3.ehdr.e_ident[0], &ehdri.e_ident[0], sizeof(ehdri.e_ident));\n    set_te32(&h3.ehdr.e_flags, e_flags);\n    generateElfHdr(fo, &h3, getbrk(phdri, e_phnum) );\n}\n\nvoid PackLinuxElf32armBe::pack1(OutputFile *fo, Filter &ft)\n{\n    super::pack1(fo, ft);\n    if (0!=xct_off)  // shared library\n        return;\n    unsigned const e_flags = get_te32(&ehdri.e_flags);\n    cprElfHdr3 h3;\n    memcpy(&h3, stub_armeb_v4a_linux_elf_fold, sizeof(Elf32_Ehdr) + 2*sizeof(Elf32_Phdr));\n    set_te32(&h3.ehdr.e_flags, e_flags);\n    generateElfHdr(fo, &h3, getbrk(phdri, e_phnum) );\n}\n\nvoid PackLinuxElf32mipsel::pack1(OutputFile *fo, Filter &ft)\n{\n    super::pack1(fo, ft);\n    if (0!=xct_off)  // shared library\n        return;\n    cprElfHdr3 h3;\n    memcpy(&h3, stub_mipsel_r3000_linux_elf_fold, sizeof(Elf32_Ehdr) + 2*sizeof(Elf32_Phdr));\n    generateElfHdr(fo, &h3, getbrk(phdri, e_phnum) );\n}\n\nvoid PackLinuxElf32mipseb::pack1(OutputFile *fo, Filter &ft)\n{\n    super::pack1(fo, ft);\n    if (0!=xct_off)  // shared library\n        return;\n    cprElfHdr3 h3;\n    memcpy(&h3, stub_mips_r3000_linux_elf_fold, sizeof(Elf32_Ehdr) + 2*sizeof(Elf32_Phdr));\n    generateElfHdr(fo, &h3, getbrk(phdri, e_phnum) );\n}\n\nvoid PackLinuxElf32ppc::pack1(OutputFile *fo, Filter &ft)\n{\n    super::pack1(fo, ft);\n    if (0!=xct_off)  // shared library\n        return;\n    generateElfHdr(fo, stub_powerpc_linux_elf_fold, getbrk(phdri, e_phnum) );\n}\n\nvoid PackLinuxElf64ppcle::pack1(OutputFile *fo, Filter &ft)\n{\n    super::pack1(fo, ft);\n    if (0!=xct_off)  // shared library\n        return;\n    generateElfHdr(fo, stub_powerpc64le_linux_elf_fold, getbrk(phdri, e_phnum) );\n}\n\nvoid PackLinuxElf64ppc::pack1(OutputFile *fo, Filter &ft)\n{\n    super::pack1(fo, ft);\n    if (0!=xct_off)  // shared library\n        return;\n    generateElfHdr(fo, stub_powerpc64_linux_elf_fold, getbrk(phdri, e_phnum) );\n}\n\nvoid PackLinuxElf64::asl_pack2_Shdrs(OutputFile *fo, unsigned pre_xct_top)\n{\n    if (!fo) {\n        return;\n    }\n    // In order to pacify the runtime linker on Android \"O\" (\"Oreo\"),\n    // we will splice-in a 4KiB page that contains an \"extra\" copy\n    // of the Shdr, any PT_NOTE above xct_off, and shstrtab.\n    // File order: Ehdr, Phdr[], section contents below xct_off,\n    //    Shdr_copy[], PT_NOTEs.hi, shstrtab.\n    if (is_asl)\n        xct_va  += asl_delta;\n    //xct_off += asl_delta;  // not until ::pack3()\n\n    total_in = pre_xct_top;\n\n    // Relocate PT_DYNAMIC (in PT_LOAD with PF_W)\n    Elf64_Dyn *dyn = const_cast<Elf64_Dyn *>(dynseg);\n    for (; dyn->d_tag; ++dyn) {\n        upx_uint64_t d_tag = get_te64(&dyn->d_tag);\n        if (Elf64_Dyn::DT_FINI       == d_tag\n        ||  Elf64_Dyn::DT_FINI_ARRAY == d_tag\n        ||  Elf64_Dyn::DT_INIT_ARRAY == d_tag\n        ||  Elf64_Dyn::DT_PREINIT_ARRAY == d_tag\n        ||  Elf64_Dyn::DT_PLTGOT      == d_tag) {\n            upx_uint64_t d_val = get_te64(&dyn->d_val);\n            set_te64(&dyn->d_val, asl_delta + d_val);\n        }\n    }\n    // Updated dynseg (.dynamic, in PT_DYNAMIC (PT_LOAD{PF_W})) has not been written.\n    // dynseg is in file_image[] but not in low_mem[].\n\n    // Relocate dynsym (DT_SYMTAB) which is below xct_va\n    upx_uint64_t const off_dynsym = get_te64(&sec_dynsym->sh_offset);\n    upx_uint64_t const sz_dynsym  = get_te64(&sec_dynsym->sh_size);\n    if ((upx_uint64_t)file_size < sz_dynsym\n    ||  (upx_uint64_t)file_size < off_dynsym\n    || ((upx_uint64_t)file_size - off_dynsym) < sz_dynsym) {\n        throwCantPack(\"bad DT_SYMTAB\");\n    }\n    Elf64_Sym *dyntym = (Elf64_Sym *)lowmem.subref(\n        \"bad dynsym\", off_dynsym, sz_dynsym);\n    Elf64_Sym *sym = dyntym;\n    for (int j = sz_dynsym / sizeof(Elf64_Sym); --j>=0; ++sym) {\n        upx_uint64_t symval = get_te64(&sym->st_value);\n        unsigned symsec = get_te16(&sym->st_shndx);\n        if (Elf64_Sym::SHN_UNDEF != symsec\n        &&  Elf64_Sym::SHN_ABS   != symsec\n        &&  xct_off <= symval) {\n            set_te64(&sym->st_value, asl_delta + symval);\n        }\n        if (Elf64_Sym::SHN_ABS == symsec && xct_off <= symval) {\n            adjABS(sym, asl_delta);\n        }\n    }\n\n    // Relocate Phdr virtual addresses, but not physical offsets and sizes\n    unsigned char buf_notes[512]; memset(buf_notes, 0, sizeof(buf_notes));\n    unsigned len_notes = 0;\n    Elf64_Phdr *phdr = (Elf64_Phdr *)lowmem.subref(\n        \"bad e_phoff\", e_phoff, e_phnum * sizeof(Elf64_Phdr));\n    for (unsigned j = 0; j < e_phnum; ++j, ++phdr) {\n        upx_uint64_t offset = get_te64(&phdr->p_offset);\n        if (xct_off <= offset) { // above the extra page\n            {\n                //set_te64(&phdr->p_offset, asl_delta + offset);  // physical\n                upx_uint64_t addr = get_te64(&phdr->p_paddr);\n                set_te64(&phdr->p_paddr, asl_delta + addr);\n                             addr = get_te64(&phdr->p_vaddr);\n                set_te64(&phdr->p_vaddr, asl_delta + addr);\n            }\n        }\n        // .p_filesz,.p_memsz are updated in ::pack3\n    }\n\n    Elf64_Ehdr *const ehdr = (Elf64_Ehdr *)&lowmem[0];\n    upx_uint64_t e_entry = get_te64(&ehdr->e_entry);\n    if (xct_off < e_entry) {\n        set_te64(&ehdr->e_entry, asl_delta + e_entry);\n    }\n    // Relocate Shdr; and Rela, Rel (below xct_off)\n    unsigned const pal_xct_top = up8(pre_xct_top);\n    set_te64(&ehdr->e_shoff, up8(pal_xct_top));  // Shdr alignment\n    memcpy(&lowmem[pal_xct_top], shdri, e_shnum * sizeof(Elf64_Shdr));\n    shdro = (Elf64_Shdr *)&lowmem[pal_xct_top];\n    Elf64_Shdr *shdr = shdro;\n    upx_uint64_t sz_shstrtab  = get_te64(&sec_strndx->sh_size);\n    for (unsigned j = 0; j < e_shnum; ++j, ++shdr) {\n        unsigned sh_type = get_te32(&shdr->sh_type);\n        upx_uint64_t sh_size = get_te64(&shdr->sh_size);\n        upx_uint64_t sh_offset = get_te64(&shdr->sh_offset);\n        upx_uint64_t sh_entsize = get_te64(&shdr->sh_entsize);\n        if ((upx_uint64_t)file_size < sh_size\n        ||  (upx_uint64_t)file_size < sh_offset\n        || (Elf64_Shdr::SHT_NOBITS != sh_type\n           && ((upx_uint64_t)file_size - sh_offset) < sh_size) ) {\n            throwCantPack(\"bad SHT_STRNDX\");\n        }\n\n        if (xct_off <= sh_offset) {\n            upx_uint64_t addr = get_te64(&shdr->sh_addr);\n            set_te64(&shdr->sh_addr, asl_delta + addr);\n            set_te64(&shdr->sh_offset, asl_delta + sh_offset);\n        }\n        switch (sh_type) {\n        default: break;\n        case Elf64_Shdr::SHT_RELA: {\n            if (sizeof(Elf64_Rela) != sh_entsize) {\n                char msg[50];\n                snprintf(msg, sizeof(msg), \"bad Rela.sh_entsize %lu\", (long)sh_entsize);\n                throwCantPack(msg);\n            }\n            plt_va = ~0ull;\n            Elf64_Rela *const relb = (Elf64_Rela *)lowmem.subref(\n                 \"bad Rela offset\", sh_offset, sh_size);\n            Elf64_Rela *rela = relb;\n            for (int k = sh_size / sh_entsize; --k >= 0; ++rela) {\n                upx_uint64_t r_addend = get_te64(&rela->r_addend);\n                upx_uint64_t r_offset = get_te64(&rela->r_offset);\n                upx_uint64_t r_info   = get_te64(&rela->r_info);\n                unsigned r_type = ELF64_R_TYPE(r_info);\n                if (xct_off <= r_offset) {\n                    set_te64(&rela->r_offset, asl_delta + r_offset);\n                }\n                if (Elf64_Ehdr::EM_AARCH64 == e_machine) switch (r_type) {\n                    default: {\n                        char msg[90]; snprintf(msg, sizeof(msg),\n                            \"unexpected relocation %#x [%#x]\",\n                            r_type, -1 + (unsigned)(sh_size / sh_entsize) - k);\n                        throwCantPack(msg);\n                    } break;\n                    case R_AARCH64_ABS64: // FALL THROUGH\n                    case R_AARCH64_GLOB_DAT: // FALL THROUGH\n                    case R_AARCH64_RELATIVE: {\n                        if (xct_off <= r_addend) {\n                            set_te64(&rela->r_addend, asl_delta + r_addend);\n                        }\n                    } break;\n                    case R_AARCH64_JUMP_SLOT: {\n                        // .rela.plt contains offset of the \"first time\" target\n                        if (plt_va > r_offset) {\n                            plt_va = r_offset;\n                        }\n                        upx_uint64_t d = elf_get_offset_from_address(r_offset);\n                        upx_uint64_t w = get_te64(&file_image[d]);\n                        if (xct_off <= w) {\n                            set_te64(&file_image[d], asl_delta + w);\n                        }\n                        ++n_jmp_slot;\n                    } break;\n                }\n            }\n        }; break;\n        case Elf64_Shdr::SHT_REL: {\n            if (sizeof(Elf64_Rel) != sh_entsize) {\n                char msg[50];\n                snprintf(msg, sizeof(msg), \"bad Rel.sh_entsize %lu\", (long)sh_entsize);\n                throwCantPack(msg);\n            }\n            Elf64_Rel *rel = (Elf64_Rel *)lowmem.subref(\n                    \"bad Rel sh_offset\", sh_offset, sh_size);\n            for (int k = sh_size / sh_entsize; --k >= 0; ++rel) {\n                upx_uint64_t r_offset = get_te64(&rel->r_offset);\n                if (xct_off <= r_offset) {\n                    set_te64(&rel->r_offset, asl_delta + r_offset);\n                }\n                // r_offset must be in 2nd PT_LOAD; .p_vaddr was already relocated\n                upx_uint64_t d = elf_get_offset_from_address(asl_delta + r_offset);\n                upx_uint64_t w = get_te64(&file_image[d]);\n                upx_uint64_t r_info = get_te64(&rel->r_info);\n                unsigned r_type = ELF64_R_TYPE(r_info);\n                if (xct_off <= w\n                &&  Elf64_Ehdr::EM_AARCH64 == e_machine\n                &&  (  R_AARCH64_RELATIVE  == r_type\n                    || R_AARCH64_JUMP_SLOT == r_type)) {\n                    set_te64(&file_image[d], asl_delta + w);\n                }\n            }\n        }; break;\n        case Elf64_Shdr::SHT_NOTE: {\n            if (!(Elf64_Shdr::SHF_ALLOC & get_te64(&shdr->sh_flags))) {\n                // example: version number of 'gold' linker (static binder)\n                if (sizeof(buf_notes) < (sh_size + len_notes)) {\n                    throwCantPack(\"SHT_NOTEs too big\");\n                }\n                set_te64(&shdro[j].sh_offset,\n                    len_notes + (e_shnum * sizeof(Elf64_Shdr)) + xct_off);\n                memcpy(&buf_notes[len_notes], &file_image[sh_offset], sh_size);\n                len_notes += sh_size;\n            }\n            else { // SHF_ALLOC: in PT_LOAD; but move sh_addr and sh_offset\n                // Not sure why we need this conditional.\n                // Anyway, some Android have multiple SHT_NOTE sections.\n                if (xct_off <= sh_offset) {\n                    upx_uint64_t pos = xct_off + e_shnum * sizeof(Elf64_Shdr);\n                    set_te64(&shdr->sh_addr,   pos);\n                    set_te64(&shdr->sh_offset, pos);\n                }\n            }\n        }; break;\n        } // end switch (sh_type)\n    }\n    // shstrndx will move\n    set_te64(&shdro[get_te16(&ehdri.e_shstrndx)].sh_offset,\n        len_notes + e_shnum * sizeof(Elf64_Shdr) + pal_xct_top);\n\n    // (\"Re-\")write all changes below pal_xct_top\n    fo->seek(0, SEEK_SET);\n    fo->write(lowmem, pal_xct_top);\n    total_in = pal_xct_top;\n\n    // New copy of Shdr\n    Elf64_Shdr blank; memset(&blank, 0, sizeof(blank));\n    set_te64(&blank.sh_offset, xct_off);  // hint for \"upx -d\"\n    fpad8(fo, total_out);  // Shdr alignment\n    fo->write(&blank, sizeof(blank));\n    fo->write(&shdro[1], (-1+ e_shnum) * sizeof(Elf64_Shdr));\n\n    if (len_notes) {\n        fo->write(buf_notes, len_notes);\n    }\n\n    // New copy of Shdr[.e_shstrndx].[ sh_offset, +.sh_size )\n    fo->write(shstrtab,  sz_shstrtab);\n\n    sz_elf_hdrs = fpad8(fo, total_out);\n    total_out = sz_elf_hdrs;\n    //xct_off += asl_delta;  // wait until ::pack3\n    unsigned d = asl_delta + pal_xct_top - sz_elf_hdrs;\n    fo->seek(d, SEEK_CUR);\n    total_out += d;\n}\n\n// asl (ANdroid Shared Library) creates a big mess!\nvoid PackLinuxElf32::asl_pack2_Shdrs(OutputFile *fo, unsigned pre_xct_top)\n{\n    if (!fo) {\n        return;\n    }\n    // In order to pacify the runtime linker on Android \"O\" (\"Oreo\"),\n    // we will splice-in a 4KiB page that contains an \"extra\" copy\n    // of the Shdr, any PT_NOTE above xct_off, and shstrtab.\n    // File order: Ehdr, Phdr[], section contents below xct_off,\n    //    Shdr_copy[], PT_NOTEs.hi, shstrtab.\n    if (is_asl)\n        xct_va  += asl_delta;\n    //xct_off += asl_delta;  // not until ::pack3()\n\n    total_in = pre_xct_top;\n\n    // Relocate PT_DYNAMIC (in PT_LOAD with PF_W)\n    Elf32_Dyn *dyn = const_cast<Elf32_Dyn *>(dynseg);\n    for (; dyn->d_tag; ++dyn) {\n        upx_uint32_t d_tag = get_te32(&dyn->d_tag);\n        if (Elf32_Dyn::DT_FINI       == d_tag\n        ||  Elf32_Dyn::DT_FINI_ARRAY == d_tag\n        ||  Elf32_Dyn::DT_INIT_ARRAY == d_tag\n        ||  Elf32_Dyn::DT_PREINIT_ARRAY == d_tag\n        ||  Elf32_Dyn::DT_PLTGOT      == d_tag) {\n            upx_uint32_t d_val = get_te32(&dyn->d_val);\n            set_te32(&dyn->d_val, asl_delta + d_val);\n        }\n    }\n    // Updated dynseg (.dynamic, in PT_DYNAMIC (PT_LOAD{PF_W})) has not been written.\n    // dynseg is in file_image[] but not in low_mem[].\n\n    // Relocate dynsym (DT_SYMTAB) which is below xct_va\n    upx_uint32_t const off_dynsym = get_te32(&sec_dynsym->sh_offset);\n    upx_uint32_t const sz_dynsym  = get_te32(&sec_dynsym->sh_size);\n    if ((upx_uint32_t)file_size < sz_dynsym\n    ||  (upx_uint32_t)file_size < off_dynsym\n    || ((upx_uint32_t)file_size - off_dynsym) < sz_dynsym) {\n        throwCantPack(\"bad DT_SYMTAB\");\n    }\n    Elf32_Sym *dyntym = (Elf32_Sym *)lowmem.subref(\n        \"bad dynsym\", off_dynsym, sz_dynsym);\n    Elf32_Sym *sym = dyntym;\n    for (int j = sz_dynsym / sizeof(Elf32_Sym); --j>=0; ++sym) {\n        upx_uint32_t symval = get_te32(&sym->st_value);\n        unsigned symsec = get_te16(&sym->st_shndx);\n        if (Elf32_Sym::SHN_UNDEF != symsec\n        &&  Elf32_Sym::SHN_ABS   != symsec\n        &&  xct_off <= symval) {\n            set_te32(&sym->st_value, asl_delta + symval);\n        }\n        if (Elf32_Sym::SHN_ABS == symsec && xct_off <= symval) {\n            adjABS(sym, asl_delta);\n        }\n    }\n\n    // Relocate Phdr virtual addresses, but not physical offsets and sizes\n    unsigned char buf_notes[512]; memset(buf_notes, 0, sizeof(buf_notes));\n    unsigned len_notes = 0;\n    Elf32_Phdr *phdr = (Elf32_Phdr *)lowmem.subref(\n        \"bad e_phoff\", e_phoff, e_phnum * sizeof(Elf32_Phdr));\n    for (unsigned j = 0; j < e_phnum; ++j, ++phdr) {\n        upx_uint32_t offset = get_te32(&phdr->p_offset);\n        if (xct_off <= offset) { // above the extra page\n            {\n                //set_te32(&phdr->p_offset, asl_delta + offset);  // physical\n                upx_uint32_t v_addr = get_te32(&phdr->p_vaddr);\n                                      set_te32(&phdr->p_vaddr, asl_delta + v_addr);\n                upx_uint32_t p_addr = get_te32(&phdr->p_paddr);\n                                      set_te32(&phdr->p_paddr, asl_delta + p_addr);\n            }\n        }\n        // .p_filesz,.p_memsz are updated in ::pack3\n    }\n\n    Elf32_Ehdr *const ehdr = (Elf32_Ehdr *)&lowmem[0];\n    upx_uint32_t e_entry = get_te32(&ehdr->e_entry);\n    if (xct_off <= e_entry) { // FIXME: --android-shlib is different\n        set_te32(&ehdr->e_entry, asl_delta + e_entry);\n    }\n    // Relocate Shdr; and Rela, Rel (below xct_off)\n    unsigned const pal_xct_top = up4(pre_xct_top);\n    set_te32(&ehdr->e_shoff, pal_xct_top);  // Shdr alignment\n    memcpy(&lowmem[pal_xct_top], shdri, e_shnum * sizeof(Elf32_Shdr));\n    shdro = (Elf32_Shdr *)&lowmem[pal_xct_top];\n    Elf32_Shdr *shdr = shdro;\n    upx_uint32_t sz_shstrtab  = get_te32(&sec_strndx->sh_size);\n    for (unsigned j = 0; j < e_shnum; ++j, ++shdr) {\n        unsigned sh_type = get_te32(&shdr->sh_type);\n        unsigned sh_flags = get_te32(&shdr->sh_flags);\n        upx_uint32_t sh_size = get_te32(&shdr->sh_size);\n        upx_uint32_t sh_offset = get_te32(&shdr->sh_offset);\n        upx_uint32_t sh_entsize = get_te32(&shdr->sh_entsize);\n        if ((upx_uint32_t)file_size < sh_size\n        ||  (upx_uint32_t)file_size < sh_offset\n        || (Elf32_Shdr::SHT_NOBITS != sh_type\n           && ((upx_uint32_t)file_size - sh_offset) < sh_size) ) {\n            throwCantPack(\"bad SHT_STRNDX\");\n        }\n\n        if (xct_off <= sh_offset && Elf32_Shdr::SHF_ALLOC & sh_flags) {\n            upx_uint32_t addr = get_te32(&shdr->sh_addr);\n            set_te32(&shdr->sh_addr, asl_delta + addr);\n            set_te32(&shdr->sh_offset, asl_delta + sh_offset);\n        }\n        switch (sh_type) {\n        default: break;\n        case Elf32_Shdr::SHT_RELA: { // 32-bit Elf_Rela is unused (by convention)\n            if (sizeof(Elf32_Rela) != sh_entsize) {\n                char msg[50];\n                snprintf(msg, sizeof(msg), \"bad Rela.sh_entsize %lu\", (long)sh_entsize);\n                throwCantPack(msg);\n            }\n            plt_va = ~0ull;\n            Elf32_Rela *const relb = (Elf32_Rela *)lowmem.subref(\n                 \"bad Rela offset\", sh_offset, sh_size);\n            Elf32_Rela *rela = relb;\n            for (int k = sh_size / sh_entsize; --k >= 0; ++rela) {\n                upx_uint32_t r_addend = get_te32(&rela->r_addend);\n                upx_uint32_t r_offset = get_te32(&rela->r_offset);\n                upx_uint32_t r_info   = get_te32(&rela->r_info);\n                unsigned r_type = ELF32_R_TYPE(r_info);\n                if (xct_off <= r_offset) {\n                    set_te32(&rela->r_offset, asl_delta + r_offset);\n                }\n                if (Elf32_Ehdr::EM_386 == e_machine) switch (r_type) {\n                    default: {\n                        char msg[90]; snprintf(msg, sizeof(msg),\n                            \"unexpected relocation %#x [%#x]\",\n                            r_type, -1 + (unsigned)(sh_size / sh_entsize) - k);\n                        throwCantPack(msg);\n                    } break;\n                    case R_386_32: // FALL THROUGH\n                    case R_386_GLOB_DAT: // FALL THROUGH\n                    case R_386_RELATIVE: {\n                        if (xct_off <= r_addend) {\n                            set_te32(&rela->r_addend, asl_delta + r_addend);\n                        }\n                    } break;\n                    case R_386_JMP_SLOT: {\n                        // .rela.plt contains offset of the \"first time\" target\n                        if (plt_va > r_offset) {\n                            plt_va = r_offset;\n                        }\n                        upx_uint32_t d = elf_get_offset_from_address(r_offset);\n                        upx_uint32_t w = get_te32(&file_image[d]);\n                        if (xct_off <= w) {\n                            set_te32(&file_image[d], asl_delta + w);\n                        }\n                        ++n_jmp_slot;\n                    } break;\n                } // end EM_386 r_type\n                else if (Elf32_Ehdr::EM_ARM == e_machine) switch (r_type) {\n                    default: {\n                        char msg[90]; snprintf(msg, sizeof(msg),\n                            \"unexpected relocation %#x [%#x]\",\n                            r_type, -1 + (unsigned)(sh_size / sh_entsize) - k);\n                        throwCantPack(msg);\n                    } break;\n                    case R_ARM_ABS32: // FALL THROUGH\n                    case R_ARM_GLOB_DAT: // FALL THROUGH\n                    case R_ARM_RELATIVE: {\n                        if (xct_off <= r_addend) {\n                            set_te32(&rela->r_addend, asl_delta + r_addend);\n                        }\n                    } break;\n                    case R_ARM_JUMP_SLOT: {\n                        // .rela.plt contains offset of the \"first time\" target\n                        if (plt_va > r_offset) {\n                            plt_va = r_offset;\n                        }\n                        upx_uint32_t d = elf_get_offset_from_address(r_offset);\n                        upx_uint32_t w = get_te32(&file_image[d]);\n                        if (xct_off <= w) {\n                            set_te32(&file_image[d], asl_delta + w);\n                        }\n                        ++n_jmp_slot;\n                    } break;\n                }  // end EM_ARM r_type\n                else {\n                    char msg[40]; snprintf(msg, sizeof(msg),\n                        \"Unknown architecture %d\", this->e_machine);\n                    throwCantPack(msg);\n                }  // end e_machine\n            }\n        }; break;  // end Elf32_Shdr::SHT_RELA\n        case Elf32_Shdr::SHT_REL: {\n            if (sizeof(Elf32_Rel) != sh_entsize) {\n                char msg[50];\n                snprintf(msg, sizeof(msg), \"bad Rel.sh_entsize %lu\", (long)sh_entsize);\n                throwCantPack(msg);\n            }\n            Elf32_Rel *rel = (Elf32_Rel *)lowmem.subref(\n                    \"bad Rel sh_offset\", sh_offset, sh_size);\n            for (int k = sh_size / sh_entsize; --k >= 0; ++rel) {\n                upx_uint32_t r_offset = get_te32(&rel->r_offset);\n                if (xct_off <= r_offset) {\n                    set_te32(&rel->r_offset, asl_delta + r_offset);\n                }\n                // r_offset must be in 2nd PT_LOAD; .p_vaddr was already relocated\n                upx_uint32_t d = elf_get_offset_from_address(r_offset);\n                upx_uint32_t w = get_te32(&file_image[d]);\n                upx_uint32_t r_info = get_te32(&rel->r_info);\n                unsigned r_type = ELF32_R_TYPE(r_info);\n                //printf(\"d=%#x  w=%#x  r_info=%#x\\n\", d, w, r_info);\n                // FIXME: why change file_image[d] instead of lowmem[d] ?\n                if (Elf32_Ehdr::EM_386 == e_machine) switch (r_type) {\n                    default: {\n                        char msg[90]; snprintf(msg, sizeof(msg),\n                            \"unexpected relocation %#x [%#x]\",\n                            r_type, -1 + (unsigned)(sh_size / sh_entsize) - k);\n                        throwCantPack(msg);\n                    } break;\n                    case R_386_32: // FALL THROUGH\n                    case R_386_GLOB_DAT: // FALL THROUGH\n                    case R_386_RELATIVE: {\n                        if (xct_off <= w) {\n                            set_te32(&file_image[d], asl_delta + w);\n                        }\n                    } break;\n                    case R_386_JMP_SLOT: {\n                        // .rela.plt contains offset of the \"first time\" target\n                        if (plt_va > r_offset) {\n                            plt_va = r_offset;\n                        }\n                        if (xct_off <= w) {\n                            set_te32(&file_image[d], asl_delta + w);\n                        }\n                        ++n_jmp_slot;\n                    } break;\n                } // end EM_386 r_type\n                else if (Elf32_Ehdr::EM_ARM == e_machine) switch (r_type) {\n                    default: {\n                        char msg[90]; snprintf(msg, sizeof(msg),\n                            \"unexpected relocation %#x [%#x]\",\n                            r_type, -1 + (unsigned)(sh_size / sh_entsize) - k);\n                        throwCantPack(msg);\n                    } break;\n                    case R_ARM_ABS32: // FALL THROUGH\n                    case R_ARM_GLOB_DAT: // FALL THROUGH\n                    case R_ARM_RELATIVE: {\n                        if (xct_off <= w) {\n                            set_te32(&file_image[d], asl_delta + w);\n                        }\n                    } break;\n                    case R_ARM_JUMP_SLOT: {\n                        // .rela.plt contains offset of the \"first time\" target\n                        if (plt_va > r_offset) {\n                            plt_va = r_offset;\n                        }\n                        if (xct_off <= w) {\n                            set_te32(&file_image[d], asl_delta + w);\n                        }\n                        ++n_jmp_slot;\n                    } break;\n                }  // end EM_ARM r_type\n                else {\n                    char msg[40]; snprintf(msg, sizeof(msg),\n                        \"Unknown architecture %d\", this->e_machine);\n                    throwCantPack(msg);\n                }  // end e_machine\n            }  // end rel\n        }; break;  // end Elf32_Shdr::SHT_REL\n        case Elf32_Shdr::SHT_NOTE: {\n            if (!(Elf32_Shdr::SHF_ALLOC & sh_flags)) {\n                // example: version number of 'gold' linker (static binder)\n                if (sizeof(buf_notes) < (sh_size + len_notes)) {\n                    throwCantPack(\"SHT_NOTEs too big\");\n                }\n                set_te32(&shdro[j].sh_offset,\n                    len_notes + (e_shnum * sizeof(Elf32_Shdr)) + xct_off);\n                memcpy(&buf_notes[len_notes], &file_image[sh_offset], sh_size);\n                len_notes += sh_size;\n            }\n            else { // SHF_ALLOC: in PT_LOAD; but move sh_addr and sh_offset\n                // Not sure why we need this conditional.\n                // Anyway, some Android have multiple SHT_NOTE sections.\n                if (xct_off <= sh_offset) {\n                    upx_uint32_t pos = xct_off + e_shnum * sizeof(Elf32_Shdr);\n                    //set_te32(&shdr->sh_addr,   pos);\n                    set_te32(&shdr->sh_offset, pos);\n                }\n            }\n        }; break;  // end Elf32_Shdr::SHT_NOTE\n        case Elf32_Shdr::SHT_ARM_ATTRIBUTES: {\n            sec_arm_attr = shdr;\n        }; break;\n        } // end switch (sh_type)\n    }\n    // shstrndx will move\n    set_te32(&shdro[get_te16(&ehdri.e_shstrndx)].sh_offset,\n        len_notes + e_shnum * sizeof(Elf32_Shdr) + up8(pal_xct_top));\n\n    // Write all changes below pal_xct_top\n    // FIXME: why is this any more than Ehdr + Phdrs?\n    if (fo) {\n        fo->seek(0, SEEK_SET);\n        fo->write(lowmem, pal_xct_top);\n    }\n    total_out = pal_xct_top;\n    total_in  = pal_xct_top;\n\n    // New copy of Shdr\n    Elf32_Shdr blank; memset(&blank, 0, sizeof(blank));\n    set_te32(&blank.sh_offset, xct_off);  // hint for \"upx -d\"\n    set_te32(&shdro->sh_offset, xct_off);  // hint for \"upx -d\"\n    total_out = fpad8(fo, total_out);  // Shdr alignment\n    unsigned arm_attr_off = 0;\n    if (sec_arm_attr) {\n        arm_attr_off = get_te32(&sec_arm_attr->sh_offset);\n        set_te32(&sec_arm_attr->sh_offset,\n            total_out + e_shnum*sizeof(Elf32_Shdr)\n            + len_notes + sz_shstrtab);\n    }\n    if (fo) {\n        fo->write(&blank, sizeof(blank));\n        fo->write(&shdro[1], (-1+ e_shnum) * sizeof(Elf32_Shdr));\n        if (len_notes) {\n            fo->write(buf_notes, len_notes);\n        }\n        // New copy of Shdr[.e_shstrndx].[ sh_offset, +.sh_size )\n        fo->write(shstrtab,  sz_shstrtab);\n\n        if (sec_arm_attr) {\n            fo->write(&file_image[arm_attr_off],\n                get_te32(&sec_arm_attr->sh_size));\n        }\n    }\n\n    sz_elf_hdrs = fpad8(fo, total_out);\n    total_out = sz_elf_hdrs;\n    //xct_off += asl_delta;  // wait until ::pack3\n    total_out = fpadN(fo, asl_delta - (sz_elf_hdrs - pal_xct_top));\n}\n\nvoid PackLinuxElf64::pack1(OutputFile * /*fo*/, Filter &ft)\n{\n    fi->seek(0, SEEK_SET);\n    fi->readx(&ehdri, sizeof(ehdri));\n    assert(e_phoff == sizeof(Elf64_Ehdr));  // checked by canPack()\n    sz_phdrs = e_phnum * get_te16(&ehdri.e_phentsize);\n\n// We compress separate pieces (usually each PT_LOAD, plus the gaps in the file\n// that are not covered by any PT_LOAD), but currently at run time there can be\n// only one decompressor method.\n// Therefore we must plan ahead because Packer::compressWithFilters tries\n// to find the smallest result among the available methods, for one piece only.\n// In the future we may allow more than one decompression method at run time.\n// For now we must choose only one, and force PackUnix::packExtent\n// (==> compressWithFilters) to use it.\n    int nfilters = 0;\n    {\n        int const *fp = getFilters();\n        while (FT_END != *fp++) {\n            ++nfilters;\n        }\n    }\n    {\n        int npieces = 1;  // tail after highest PT_LOAD\n        Elf64_Phdr *phdr = phdri;\n        for (unsigned j=0; j < e_phnum; ++phdr, ++j) {\n            if (is_LOAD(phdr)) {\n                unsigned const  flags = get_te32(&phdr->p_flags);\n                unsigned       offset = get_te64(&phdr->p_offset);\n                if (!xct_off  // not shlib\n                  // new-style shlib: PT_LOAD[0] has symbol table\n                  // which must not be compressed, but also lacks PF_X\n                ||    (Elf64_Phdr::PF_X & flags)\n                  // Read-only, non-first PT_LOAD is _assumed_ to be compressible\n                ||  (!(Elf64_Phdr::PF_W & flags) && 0!=offset))\n                {\n                    ++npieces;  // will attempt compression of this PT_LOAD\n                }\n            }\n        }\n        uip->ui_total_passes += npieces;\n    }\n    int methods[256];\n    unsigned nmethods = prepareMethods(methods, ph.method, getCompressionMethods(M_ALL, ph.level));\n    if (1 < nmethods) { // Many are available, but we must choose only one\n        uip->ui_total_passes += 1;  // the batch for output\n        uip->ui_total_passes *= nmethods * (1+ nfilters);  // finding smallest total\n        PackHeader orig_ph = ph;\n        Filter orig_ft = ft;\n        unsigned max_offset = 0;\n        unsigned sz_best= ~0u;\n        int method_best = 0;\n        for (unsigned k = 0; k < nmethods; ++k) { // FIXME: parallelize; cost: working space\n            unsigned sz_this = 0;\n            Elf64_Phdr *phdr = phdri;\n            for (unsigned j=0; j < e_phnum; ++phdr, ++j) {\n                if (is_LOAD(phdr)) {\n                    unsigned const  flags = get_te32(&phdr->p_flags);\n                    unsigned       offset = get_te64(&phdr->p_offset);\n                    unsigned       filesz = get_te64(&phdr->p_filesz);\n                    max_offset = UPX_MAX(max_offset, filesz + offset);\n                    if (!xct_off  // not shlib\n                      // new-style shlib: PT_LOAD[0] has symbol table\n                      // which must not be compressed, but also lacks PF_X\n                    ||    (Elf64_Phdr::PF_X & flags)\n                      // Read-only, non-first PT_LOAD is _assumed_ to be compressible\n                    ||  (!(Elf64_Phdr::PF_W & flags) && 0!=offset))\n                    {\n                        if (xct_off && 0==offset) { // old-style shlib\n                            offset  = xct_off;\n                            filesz -= xct_off;\n                        }\n                        fi->seek(offset, SEEK_SET);\n                        fi->readx(ibuf, filesz);\n                        ft = orig_ft;\n                        ph = orig_ph;\n                        ph.set_method(ph_force_method(methods[k]));\n                        ph.u_len = filesz;\n                        compressWithFilters(&ft, OVERHEAD, NULL_cconf, 10, true);\n                        sz_this += ph.c_len;\n                    }\n                }\n            }\n            unsigned const sz_tail = file_size - max_offset;  // debuginfo, etc.\n            if (sz_tail) {\n                fi->seek(max_offset, SEEK_SET);\n                fi->readx(ibuf, sz_tail);\n                ft = orig_ft;\n                ph = orig_ph;\n                ph.set_method(ph_force_method(methods[k]));\n                ph.u_len = sz_tail;\n                compressWithFilters(&ft, OVERHEAD, NULL_cconf, 10, true);\n                sz_this += ph.c_len;\n            }\n            // FIXME: loader size also depends on method\n            if (sz_best > sz_this) {\n                sz_best = sz_this;\n                method_best = methods[k];\n            }\n        }\n        ft = orig_ft;\n        ph = orig_ph;\n        ph.set_method(ph_force_method(method_best));\n    }\n\n    Elf64_Phdr *phdr = phdri;\n    for (unsigned j=0; j < e_phnum; ++phdr, ++j) {\n        unsigned const type = get_te32(&phdr->p_type);\n        if (PT_GNU_STACK64 == type || PT_NOTE64 == type) {\n            add_phdrx(phdr);  // PT_GNU_STACK64, PT_NOTE64\n        }\n        if (PT_LOAD == type) {\n            unsigned x = get_te64(&phdr->p_align) >> lg2_page;\n            while (x>>=1) {\n                ++lg2_page;\n            }\n        }\n        if (PT_GNU_RELRO64 == type\n        &&  16 < lg2_page) {\n            // x86* allows 4K, 2M, 1G\n            // arm32 and arm64 both allow 4K, 16K, 64K; Apple Silicon uses 16K\n            // Oracle 5.4.17-2136.314.6.2.el8uek.aarch64 demands 64K\n            // PowerPC and PowerPC64 has 4K, 64K, 1M (?), 16M (?)\n            // MIPS  allows any power of 2 from 4K through 64K\n\n            // If 64K < .p_align then we assume that 4K is also accepted.\n            // .p_align can be like 2M, which is a huge over-estimate.\n            // RELRO ends on a page boundary: usually close to actual page_size\n            unsigned offset = get_te64(&phdr->p_offset);\n            unsigned filesz = get_te64(&phdr->p_filesz);\n            if (!(0xfff & (filesz + offset))) { // a 4KiB boundary\n                unsigned b = 12;\n                while (!(~(~0u << b) & (filesz + offset))) {\n                    ++b;\n                }\n                lg2_page = umin(lg2_page, -1+ b);\n            }\n        }\n    }\n    page_size =  1u  <<lg2_page;\n    page_mask = ~0ull<<lg2_page;\n\n    progid = 0;  // getRandomId();  not useful, so do not clutter\n    sz_elf_hdrs = sizeof(ehdri) + sz_phdrs;\n\n    // only execute if option present\n    if (opt->o_unix.preserve_build_id) {\n        // set this so we can use elf_find_section_name\n        e_shnum = get_te16(&ehdri.e_shnum);\n        if (!shdri) {\n            mb_shdr.alloc(e_shnum * sizeof(Elf64_Shdr));\n            shdri = (Elf64_Shdr *)mb_shdr.getVoidPtr();\n            e_shoff = get_te64(&ehdri.e_shoff);\n            fi->seek(e_shoff, SEEK_SET);\n            fi->readx(shdri, e_shnum * sizeof(Elf64_Shdr));\n        }\n        //set the shstrtab\n        sec_strndx = &shdri[get_te16(&ehdri.e_shstrndx)];\n\n        upx_uint64_t sh_size = get_te64(&sec_strndx->sh_size);\n        mb_shstrtab.alloc(sh_size); shstrtab = (char *)mb_shstrtab.getVoidPtr();\n        fi->seek(0,SEEK_SET);\n        fi->seek(sec_strndx->sh_offset,SEEK_SET);\n        fi->readx(mb_shstrtab, sh_size);\n\n        Elf64_Shdr const *buildid = elf_find_section_name(\".note.gnu.build-id\");\n        if (buildid) {\n            unsigned bid_sh_size = get_te64(&buildid->sh_size);  // UPX_RSIZE_MAX_MEM protects us\n            buildid_data.alloc(bid_sh_size);\n            buildid_data.clear();\n            fi->seek(0,SEEK_SET);\n            fi->seek(buildid->sh_offset,SEEK_SET);\n            fi->readx((void *)buildid_data, bid_sh_size);\n\n            o_elf_shnum = 3;\n            memset(&shdrout,0,sizeof(shdrout));\n\n            //setup the build-id\n            memcpy(&shdrout.shdr[1], buildid, sizeof(shdrout.shdr[1]));\n            set_te32(&shdrout.shdr[1].sh_name, 1);\n\n            //setup the shstrtab\n            memcpy(&shdrout.shdr[2], sec_strndx, sizeof(shdrout.shdr[2]));\n            set_te32(&shdrout.shdr[2].sh_name, 20);\n            set_te64(&shdrout.shdr[2].sh_size, 29); //size of our static shstrtab; UPX_RSIZE_MAX_MEM\n        }\n    }\n}\n\nvoid PackLinuxElf64amd::pack1(OutputFile *fo, Filter &ft)\n{\n    super::pack1(fo, ft);\n    if (0!=xct_off)  // shared library\n        return;\n    generateElfHdr(fo, stub_amd64_linux_elf_fold, getbrk(phdri, e_phnum) );\n}\n\nvoid PackLinuxElf64arm::pack1(OutputFile *fo, Filter &ft)\n{\n    super::pack1(fo, ft);\n    if (0!=xct_off)  // shared library\n        return;\n    generateElfHdr(fo, stub_arm64_linux_elf_fold, getbrk(phdri, e_phnum) );\n}\n\n// Determine length of gap between PT_LOAD phdr[k] and closest PT_LOAD\n// which follows in the file (or end-of-file).  Optimize for common case\n// where the PT_LOAD are adjacent ascending by .p_offset.  Assume no overlap.\n\nunsigned PackLinuxElf32::find_LOAD_gap(\n    Elf32_Phdr const *const phdr,\n    unsigned const k,\n    unsigned const nph\n)\n{\n    if (!is_LOAD(&phdr[k])) {\n        return 0;\n    }\n    unsigned const hi = get_te32(&phdr[k].p_offset) +\n                        get_te32(&phdr[k].p_filesz);\n    unsigned lo = ph.u_file_size;\n    if (lo < hi)\n        throwCantPack(\"bad input: PT_LOAD beyond end-of-file\");\n    unsigned j = k;\n    for (;;) { // circular search, optimize for adjacent ascending\n        ++j;\n        if (nph==j) {\n            j = 0;\n        }\n        if (k==j) {\n            break;\n        }\n        if (is_LOAD(&phdr[j])) {\n            unsigned const t = get_te32(&phdr[j].p_offset);\n            if ((t - hi) < (lo - hi)) {\n                lo = t;\n                if (hi==lo) {\n                    break;\n                }\n            }\n        }\n    }\n    return lo - hi;\n}\n\nunsigned PackLinuxElf::pack2_shlib_overlay_init(OutputFile *fo)\n{\n    linfo.l_checksum = 0;  // preliminary\n    linfo.l_magic = UPX_MAGIC_LE32;\n\n    set_le16(&linfo.l_lsize, lsize);  // preliminary (0)\n    linfo.l_version = (unsigned char)ph.version;\n    linfo.l_format =  (unsigned char)ph.format;\n    linfo_off = total_out;\n    fo->write(&linfo, sizeof(linfo));  total_out += sizeof(linfo);\n\n    overlay_offset = total_out;\n\n    p_info hbuf;\n    set_te32(&hbuf.p_progid, 0);\n    set_te32(&hbuf.p_filesize, file_size);\n    set_te32(&hbuf.p_blocksize, blocksize);\n    fo->write(&hbuf, sizeof(hbuf));  total_out += sizeof(hbuf);\n    return total_out;\n}\n\nunsigned PackLinuxElf::pack2_shlib_overlay_write(OutputFile *fo, MemBuffer &mb,\n        unsigned u_len, unsigned c_len)\n{\n    // Write mb with b_info header.\n    b_info tmp;\n    memset(&tmp, 0, sizeof(tmp));\n    set_te32(&tmp.sz_unc, u_len);\n    set_te32(&tmp.sz_cpr, c_len);\n    tmp.b_method = (EM_ARM == e_machine) ? M_NRV2B_8 : M_NRV2B_LE32;\n    tmp.b_extra = 0;\n    fo->write(&tmp, sizeof(tmp));   total_out += sizeof(tmp);\n    b_len += sizeof(b_info);\n    fo->write(mb, c_len); total_out += c_len;\n    return total_out;\n}\n\n// Returns compressed size\nunsigned PackLinuxElf::pack2_shlib_overlay_compress(\n    MemBuffer &bufo,\n    upx_byte const *inp,\n    unsigned u_len\n)\n{\n    ph.saved_u_adler = ph.u_adler;\n    ph.u_adler = upx_adler32(inp, u_len, ph.saved_u_adler);\n    ph.u_len += u_len;\n\n    unsigned const method = (EM_ARM == e_machine) ? M_NRV2B_8 : M_NRV2B_LE32;\n    methods_used |= 1 << method;\n    unsigned c_len = 0;\n    int r = upx_compress(inp, u_len, bufo, &c_len,\n        /* &progress callback */ nullptr,\n        method, 10,\n        /* &config_t */ nullptr, /* &result_t */ nullptr);\n    if (r != UPX_E_OK)\n        throwInternalError(\"header compression failed\");\n    if (c_len >= u_len)\n        throwInternalError(\"header compression size increase\");\n\n    ph.saved_c_adler = ph.c_adler;\n    ph.c_adler = upx_adler32(bufo,  c_len, ph.saved_c_adler);\n    ph.c_len += c_len;\n    return c_len;\n}\n\n// Layout for compressed shared library:\n// 1. If first PT_LOAD is totally below xct_off\n//      (namely, (.p_memsz + .p_offset) <= xct_off )\n//    then it must be Ehdr+Phdrs followed only by PT_DYNAMIC (Dynamic\n//    section) and loader tables (DT_* data), and the order of output is:\n//      A. original first PT_LOAD (Ehdr+Phdrs will be overwritten later)\n//      B. compressed Ehdr+Phdrs (for de-compressor to restore); M_NRV2B_LE32, no filter\n//      C. compressed remaining PT_LOAD segments (except PT_WRITE),\n//         regardless of xct_off.\n//         Until xct_off is covered by some PT_LOAD, then there is a logical\n//         two-pass problem.  The best compression algorithm is not chosen\n//         until the PT_LOAD which contains xct_off, but before that\n//         compression is desired anyway for any preceding PT_LOAD.\n//         So use NRV2B for the \"early\" PT_LOADs, and do not use packExtent\n//         which calls compressWithFilters and also creates a loader.\n//         Instead, do the compression \"by hand\" explicitly using upx_compress\n//         and write().  This may require ELF2 multi-decompressor (NRV2B\n//         on the early PT_LOADs, then something better).\n//\n//         Example input Program Headers:\n//         Type   Offset   VirtAddr   PhysAddr   FileSiz MemSiz  Flg Align\n//         LOAD   0x000000 0x00000000 0x00000000 0x003a4 0x003a4 R   0x1000  Elf hdrs, loader tables\n//         LOAD   0x001000 0x00001000 0x00001000 0x001d4 0x001d4 R E 0x1000  small code\n//         LOAD   0x002000 0x00002000 0x00002000 0x09d40 0x09d40 R   0x1000  large app consts\n//         LOAD   0x00bef0 0x0000cef0 0x0000cef0 0x00118 0x0011c RW  0x1000  writeable\n//\n//         xct_off will have been increased artifically to point to\n//         the large compressable PT_LOAD (0x9d40==MemSiz), in order to avoid\n//         NotCompressable because the earlier PT_LOADs were too short (< 4KiB).\n// 2. If the first PT_LOAD covers xct_off, then the order of output is:\n//      A. original Ehdr+Phdrs (overwritten later)\n//      B. other original content below xct_off [loader tables]\n//      C. compressed Ehdr+Phdrs (for de-compressor to restore); M_NRV2B_LE32, no filter.\n//      D. compressed content above xct_off in first PT_LOAD;\n//         use filter for executable code.\n//      E. compressed remaining PT_LOAD (except PT_WRITE); no filter.\n//\n\nint PackLinuxElf32::pack2_shlib(OutputFile *fo, Filter &ft, unsigned pre_xct_top)\n{\n    // prepare to alter Phdrs and Shdrs\n    lowmem.alloc(up8(xct_off + (!is_asl\n        ? 0\n        : e_shnum * sizeof(Elf32_Shdr))));\n    memcpy(lowmem, file_image, xct_off);  // android omits Shdr from copy now\n\n    MemBuffer elf_buf;\n    elf_buf.allocForCompression(sz_elf_hdrs);\n    unsigned u_len = sz_elf_hdrs;\n    unsigned c_len = pack2_shlib_overlay_compress(elf_buf, lowmem, u_len);\n\n    int n_ptload = 0;\n    Elf32_Phdr *phdr = &phdri[0];\n    for (unsigned k = 0; k < e_phnum; ++phdr, ++k)\n    if (is_LOAD(phdr)) {\n        unsigned p_offset = get_te32(&phdr->p_offset);\n        unsigned p_filesz = get_te32(&phdr->p_filesz);\n        if (!n_ptload) { // first PT_LOAD\n            if (is_asl) { // Copy up to xct_off, then add 2nd copy of Shdrs\n                asl_pack2_Shdrs(fo, pre_xct_top);\n            }\n            else {\n                fo->write(&lowmem[p_offset], sz_elf_hdrs);  total_out += sz_elf_hdrs;\n                total_in  += sz_elf_hdrs;\n                fo->seek(sz_phdrx, SEEK_CUR);  total_out += sz_phdrx;  // leave space\n\n                // Compare PackUnix::packExtent, especially \"if (u_len)\" .\n                //\n\n                unsigned const hi_offset = umin(xct_off, p_filesz + p_offset);\n                if (sz_elf_hdrs < hi_offset) {\n                    // Loader tables in first PT_LOAD, and below xct_off.\n                    //\n                    fo->write(&lowmem[sz_elf_hdrs], hi_offset - sz_elf_hdrs);  total_out += hi_offset - sz_elf_hdrs;\n                    total_in  += hi_offset - sz_elf_hdrs;\n                    Elf32_Phdr *lo_phdr = k + (Elf32_Phdr *)(1+ (Elf32_Ehdr *)&lowmem[0]);\n                    set_te32(&lo_phdr->p_flags, Elf32_Phdr::PF_X | get_te32(&lo_phdr->p_flags));\n                }\n            }\n            pack2_shlib_overlay_init(fo); // set overlay_offset\n            // Compressed ELF headers go first.\n            pack2_shlib_overlay_write(fo, elf_buf, u_len, c_len);\n\n            // The (compressible) remainder above xct_off in first PT_LOAD\n            if (         p_filesz > (xct_off - p_offset)) {\n                Extent x;\n                x.size = p_filesz - (xct_off - p_offset);\n                x.offset = xct_off;\n                packExtent(x, &ft, fo, 0, 0, true);\n            }\n        }  // end first PT_LOAD\n        else if ((p_filesz + p_offset) <= xct_off) {\n            // Not first PT_LOAD, but below xct_offset.  Thus \"interloper\" PT_LOAD,\n            // below xct_off that was increased to a PT_LOAD large enough to compress.\n            // \"Manually\" compress it, do not use PackExtent.\n            MemBuffer buf2; buf2.allocForCompression(p_filesz);\n            c_len = pack2_shlib_overlay_compress(buf2, &lowmem[p_offset], p_filesz); total_in += p_filesz;\n            pack2_shlib_overlay_write(fo, buf2, p_filesz, c_len);\n            Elf32_Phdr *lo_phdr = k + (Elf32_Phdr *)(1+ (Elf32_Ehdr *)&lowmem[0]);\n            set_te32(&lo_phdr->p_type, Elf32_Phdr::PT_NULL);\n        }\n        else if ((xct_off - p_offset) < p_filesz) {\n            unsigned const len = xct_off - p_offset;\n            // Loader tables in non-first PT_LOAD.  (xct_off was increased.)\n            // Bytes below xct_off belong to rtld, so cannot be compressed.\n            // Note that asl_pack2_Shdrs() copies up to xct_off, then adds extra info.\n            // Copy up to xct_off\n            if (len) {\n                fo->write(&lowmem[p_offset], len);  total_out += len;\n                total_in += len;\n\n                // Compressed ELF headers  FIXME: 1st PT_LOAD also did this!\n                pack2_shlib_overlay_write(fo, elf_buf, u_len, c_len);  // set overlay_offset\n            }\n            // The rest, above xct_off.\n            Extent x;\n            x.offset = xct_off;\n            x.size = p_filesz - len;\n            packExtent(x, &ft, fo, 0, 0, true);\n            Elf32_Phdr *lo_phdr = k + (Elf32_Phdr *)(1+ (Elf32_Ehdr *)&lowmem[0]);\n            set_te32(&lo_phdr->p_type, Elf32_Phdr::PT_NULL);\n        }\n        else { // definitely compressible unless writeable\n            if (!(Elf32_Phdr::PF_W & get_te32(&phdr->p_flags))) {\n                // Read-only PT_LOAD, assume not written by relocations.\n                // Also assume not the source for R_*_COPY relocation,\n                // therefore compress it.\n                Extent x;\n                x.offset = p_offset;\n                x.size = p_filesz;\n                packExtent(x, &ft, fo, 0, 0, true);  // choose filter and method, then do it\n                // De-compressing will re-create it, but otherwise ignore it.\n                Elf32_Phdr *phdro = (Elf32_Phdr *)(1+ (Elf32_Ehdr *)&lowmem[0]);\n                set_te32(&phdro[k].p_type, Elf32_Phdr::PT_NULL);\n            }\n            else {\n                // Read-write PT_LOAD.\n                // rtld might relocate, so we cannot compress.\n                // (Could compress if not relocated; complicates run-time.)\n                // Postpone writing until \"slide\", but account for its size.\n                total_in +=  p_filesz;\n            }\n        }\n        ++n_ptload;\n    }\n    return 0;  // FIXME\n}\n\nint PackLinuxElf32::pack2(OutputFile *fo, Filter &ft)\n{\n    Extent x;\n    unsigned k;\n    unsigned const is_shlib = (0!=xct_off) | is_asl;\n    unsigned pre_xct_top = 0;  // offset of end of PT_LOAD _before_ xct_off\n\n    // count passes, set ptload vars\n    uip->ui_total_passes = 0;\n    for (k = 0; k < e_phnum; ++k) {\n        if (is_LOAD(&phdri[k])) {\n            if (!is_shlib) {\n                uip->ui_total_passes++;\n            }\n            else {\n                unsigned p_flags = get_te32(&phdri[k].p_flags);\n                unsigned p_offset = get_te32(&phdri[k].p_offset);\n                unsigned p_filesz = get_te32(&phdri[k].p_filesz);\n                if ((xct_off - p_offset) < p_filesz) { // PT_LOAD covers xct_off\n                    if (!pre_xct_top && xct_off != p_offset) {\n                        pre_xct_top = xct_off;\n                    }\n                }\n                else if (p_offset < xct_off) { // candidate for pre_xct_top\n                    unsigned top = p_filesz + p_offset;\n                    if (pre_xct_top < top) {\n                        pre_xct_top = top;\n                    }\n                }\n                if (Elf32_Phdr::PF_W & p_flags) {\n                    // rtld might write, so cannot compress\n                }\n                else {\n                    // First PT_LOAD (partial) only if has instructions\n                    if (k || xct_off < p_filesz) {\n                        uip->ui_total_passes++;\n                    }\n                }\n            }\n            if (find_LOAD_gap(phdri, k, e_phnum)) {\n                uip->ui_total_passes++;\n            }\n        }\n    }\n\n    // compress extents\n    unsigned hdr_u_len = sizeof(Elf32_Ehdr) + sz_phdrs;\n\n    total_in =  0;\n    total_out = 0;\n    uip->ui_pass = 0;\n    ft.addvalue = 0;\n\n    unsigned nk_f = 0; upx_uint32_t xsz_f = 0;\n    for (k = 0; k < e_phnum; ++k)\n    if (is_LOAD(&phdri[k])\n    &&  Elf32_Phdr::PF_X & get_te32(&phdri[k].p_flags)) {\n        upx_uint32_t xsz = get_te32(&phdri[k].p_filesz);\n        if (xsz_f < xsz) {\n            xsz_f = xsz;\n            nk_f = k;\n        }\n    }\n    if (is_shlib) {\n        pack2_shlib(fo, ft, pre_xct_top);\n    }\n    else { // main program\n        int n_ptload = 0;\n        for (k = 0; k < e_phnum; ++k)\n        if (is_LOAD(&phdri[k])) {\n            if (ft.id < 0x40) {\n                // FIXME: ??    ft.addvalue = phdri[k].p_vaddr;\n            }\n            unsigned p_offset = get_te32(&phdri[k].p_offset);\n            unsigned p_filesz = get_te32(&phdri[k].p_filesz);\n            x.offset = p_offset;\n            x.size   = p_filesz;\n            if ((u32_t)x.size < hdr_u_len) { // FIXME: main program, but how?\n                total_in += x.size;\n            }\n            else {  // main program, not shared library\n                if (0 == n_ptload) { // 1st PT_LOAD must cover Ehdr at 0==p_offset\n                    unsigned const delta = hdr_u_len;\n                    if (ft.id < 0x40) {\n                        // FIXME: ??     ft.addvalue += asl_delta;\n                    }\n                    if ((off_t)delta == x.size) { // PT_LOAD[0] with ElfXX.Ehdr only\n                        // QBE backend - http://c9x.me/compile/\n                        hdr_u_len = 0;  // no fiddling necessary!\n                        // &ft arg to packExtent will be zero because (k != nk_f)\n                    }\n                    else {\n                        total_in += delta - hdr_u_len;\n                        x.offset += delta;\n                        x.size   -= delta;\n                    }\n                }\n                // compressWithFilters() always assumes a \"loader\", so would\n                // throw NotCompressible for small .data Extents, which PowerPC\n                // sometimes marks as PF_X anyway.  So filter only first segment.\n                packExtent(x,\n                    (k==nk_f ? &ft : nullptr ), fo, hdr_u_len, 0, true);\n                hdr_u_len = 0;\n            }\n            ++n_ptload;\n        }\n    }\n    sz_pack2a = fpad4(fo, total_out);  // MATCH01\n    total_out = up4(total_out);\n\n    // Accounting only; ::pack3 will do the compression and output\n    for (k = 0; k < e_phnum; ++k) {\n        total_in += find_LOAD_gap(phdri, k, e_phnum);\n    }\n\n    if (total_in != (u32_t)file_size)\n        throwEOFException();\n\n    return 0;  // omit end-of-compression bhdr for now\n}\n\n// Determine length of gap between PT_LOAD phdr[k] and closest PT_LOAD\n// which follows in the file (or end-of-file).  Optimize for common case\n// where the PT_LOAD are adjacent ascending by .p_offset.  Assume no overlap.\n\nunsigned PackLinuxElf64::find_LOAD_gap(\n    Elf64_Phdr const *const phdr,\n    unsigned const k,\n    unsigned const nph\n)\n{\n    if (!is_LOAD(&phdr[k])) {\n        return 0;\n    }\n    unsigned const hi = get_te64(&phdr[k].p_offset) +\n                        get_te64(&phdr[k].p_filesz);\n    unsigned lo = ph.u_file_size;\n    if (lo < hi)\n        throwCantPack(\"bad input: PT_LOAD beyond end-of-file\");\n    unsigned j = k;\n    for (;;) { // circular search, optimize for adjacent ascending\n        ++j;\n        if (nph==j) {\n            j = 0;\n        }\n        if (k==j) {\n            break;\n        }\n        if (is_LOAD(&phdr[j])) {\n            unsigned const t = get_te64(&phdr[j].p_offset);\n            if ((t - hi) < (lo - hi)) {\n                lo = t;\n                if (hi==lo) {\n                    break;\n                }\n            }\n        }\n    }\n    return lo - hi;\n}\n\nint PackLinuxElf64::pack2_shlib(OutputFile *fo, Filter &ft, unsigned pre_xct_top)\n{\n    // prepare to alter Phdrs and Shdrs\n    lowmem.alloc(up8(xct_off + (!is_asl\n        ? 0\n        : e_shnum * sizeof(Elf64_Shdr))));\n    memcpy(lowmem, file_image, xct_off);  // android omits Shdr from copy now\n\n    MemBuffer elf_buf;\n    elf_buf.allocForCompression(sz_elf_hdrs);\n    unsigned u_len = sz_elf_hdrs;\n    unsigned c_len = pack2_shlib_overlay_compress(elf_buf, lowmem, u_len);\n\n    int n_ptload = 0;\n    Elf64_Phdr *phdr = &phdri[0];\n    for (unsigned k = 0; k < e_phnum; ++phdr, ++k)\n    if (is_LOAD(phdr)) {\n        unsigned p_offset = get_te64_32(&phdr->p_offset);\n        unsigned p_filesz = get_te64_32(&phdr->p_filesz);\n        if (!n_ptload) { // first PT_LOAD\n            if (is_asl) { // Copy up to xct_off, then add 2nd copy of Shdrs\n                asl_pack2_Shdrs(fo, pre_xct_top);\n            }\n            else {\n                fo->write(&lowmem[p_offset], sz_elf_hdrs);  total_out += sz_elf_hdrs;\n                total_in  += sz_elf_hdrs;\n                fo->seek(sz_phdrx, SEEK_CUR);  total_out += sz_phdrx;  // leave space\n\n                // Compare PackUnix::packExtent, especially \"if (u_len)\" .\n                //\n\n                unsigned const hi_offset = umin(xct_off, (unsigned)(p_filesz + p_offset));\n                if (sz_elf_hdrs < hi_offset) {\n                    // Loader tables in first PT_LOAD, and below xct_off.\n                    //\n                    fo->write(&lowmem[sz_elf_hdrs], hi_offset - sz_elf_hdrs);  total_out += hi_offset - sz_elf_hdrs;\n                    total_in  += hi_offset - sz_elf_hdrs;\n                    Elf64_Phdr *lo_phdr = k + (Elf64_Phdr *)(1+ (Elf64_Ehdr *)&lowmem[0]);\n                    set_te32(&lo_phdr->p_flags, Elf64_Phdr::PF_X | get_te32(&lo_phdr->p_flags));\n                }\n            }\n            pack2_shlib_overlay_init(fo); // set overlay_offset\n            // Compressed ELF headers go first.\n            pack2_shlib_overlay_write(fo, elf_buf, u_len, c_len);\n\n            // The (compressible) remainder above xct_off in first PT_LOAD\n            if (         p_filesz > (xct_off - p_offset)) {\n                Extent x;\n                x.size = p_filesz - (xct_off - p_offset);\n                x.offset = xct_off;\n                packExtent(x, &ft, fo, 0, 0, true);\n            }\n        }  // end first PT_LOAD\n        else if ((p_filesz + p_offset) <= xct_off) {\n            // Not first PT_LOAD, but below xct_offset.  Thus \"interloper\" PT_LOAD,\n            // below xct_off that was increased to a PT_LOAD large enough to compress.\n            // \"Manually\" compress it, do not use PackExtent.\n            MemBuffer buf2; buf2.allocForCompression(p_filesz);\n            c_len = pack2_shlib_overlay_compress(buf2, &lowmem[p_offset], p_filesz); total_in += p_filesz;\n            pack2_shlib_overlay_write(fo, buf2, p_filesz, c_len);\n            Elf64_Phdr *lo_phdr = k + (Elf64_Phdr *)(1+ (Elf64_Ehdr *)&lowmem[0]);\n            set_te32(&lo_phdr->p_type, Elf64_Phdr::PT_NULL);\n        }\n        else if ((xct_off - p_offset) < p_filesz) {\n            unsigned const len = xct_off - p_offset;\n            // Loader tables in non-first PT_LOAD.  (xct_off was increased.)\n            // Bytes below xct_off belong to rtld, so cannot be compressed.\n            // Note that asl_pack2_Shdrs() copies up to xct_off, then adds extra info.\n            // Copy up to xct_off\n            if (len) {\n                fo->write(&lowmem[p_offset], len);  total_out += len;\n                total_in += len;\n\n                // Compressed ELF headers  FIXME: 1st PT_LOAD also did this!\n                pack2_shlib_overlay_write(fo, elf_buf, u_len, c_len);  // set overlay_offset\n            }\n            // The rest, above xct_off.\n            Extent x;\n            x.offset = xct_off;\n            x.size = p_filesz - len;\n            packExtent(x, &ft, fo, 0, 0, true);\n            Elf64_Phdr *lo_phdr = k + (Elf64_Phdr *)(1+ (Elf64_Ehdr *)&lowmem[0]);\n            set_te32(&lo_phdr->p_type, Elf64_Phdr::PT_NULL);\n        }\n        else { // definitely compressible unless writeable\n            if (!(Elf64_Phdr::PF_W & get_te32(&phdr->p_flags))) {\n                // Read-only PT_LOAD, assume not written by relocations.\n                // Also assume not the source for R_*_COPY relocation,\n                // therefore compress it.\n                Extent x;\n                x.offset = p_offset;\n                x.size = p_filesz;\n                packExtent(x, &ft, fo, 0, 0, true);  // choose filter and method, then do it\n                // De-compressing will re-create it, but otherwise ignore it.\n                Elf64_Phdr *phdro = (Elf64_Phdr *)(1+ (Elf64_Ehdr *)&lowmem[0]);\n                set_te32(&phdro[k].p_type, Elf32_Phdr::PT_NULL);\n            }\n            else {\n                // Read-write PT_LOAD.\n                // rtld might relocate, so we cannot compress.\n                // (Could compress if not relocated; complicates run-time.)\n                // Postpone writing until \"slide\", but account for its size.\n                total_in +=  p_filesz;\n            }\n        }\n        ++n_ptload;\n    }\n    return 0;  // FIXME\n}\n\nint PackLinuxElf64::pack2(OutputFile *fo, Filter &ft)\n{\n    Extent x;\n    unsigned k;\n    // See comment in Elf32_Linux::canPack().  is_asl does not work.\n    // 64-bit ARM (aarch64) also has no ARM_ATTRIBUTES.\n    //is_asl = (!!saved_opt_android_shlib) << 1;  // bit 1; see is_shlib\n    is_asl = 0;\n    unsigned const is_shlib = (0!=xct_off) | is_asl;\n    unsigned pre_xct_top = 0;  // offset of end of PT_LOAD _before_ xct_off\n\n    if (Elf64_Ehdr::EM_ARM==get_te16(&ehdri.e_machine)) {\n        sec_arm_attr = elf_find_section_type(Elf64_Shdr::SHT_ARM_ATTRIBUTES);\n    }\n    // count passes, set ptload vars\n    uip->ui_total_passes = 0;\n    for (k = 0; k < e_phnum; ++k) {\n        if (is_LOAD(&phdri[k])) {\n            if (!is_shlib) {\n                uip->ui_total_passes++;\n            }\n            else {\n                unsigned p_flags = get_te32(&phdri[k].p_flags);\n                unsigned p_offset = get_te64_32(&phdri[k].p_offset);\n                unsigned p_filesz = get_te64_32(&phdri[k].p_filesz);\n                if ((xct_off - p_offset) < p_filesz) { // PT_LOAD covers xct_off\n                    if (!pre_xct_top && xct_off != p_offset) {\n                        pre_xct_top = xct_off;\n                    }\n                }\n                else if (p_offset < xct_off) { // candidate for pre_xct_top\n                    unsigned top = p_filesz + p_offset;\n                    if (pre_xct_top < top) {\n                        pre_xct_top = top;\n                    }\n                }\n                if (Elf64_Phdr::PF_W & p_flags) {\n                    // rtld might write, so cannot compress\n                }\n                else {\n                    // First PT_LOAD (partial) only if has instructions\n                    if (k || xct_off < p_filesz) {\n                        uip->ui_total_passes++;\n                    }\n                }\n            }\n            if (find_LOAD_gap(phdri, k, e_phnum)) {\n                uip->ui_total_passes++;\n            }\n        }\n    }\n\n    // compress extents\n    unsigned hdr_u_len = sizeof(Elf64_Ehdr) + sz_phdrs;\n\n    total_in =  0;\n    total_out = 0;\n    uip->ui_pass = 0;\n    ft.addvalue = 0;\n\n    unsigned nk_f = 0; upx_uint32_t xsz_f = 0;\n    for (k = 0; k < e_phnum; ++k)\n    if (is_LOAD(&phdri[k])\n    &&  Elf32_Phdr::PF_X & get_te32(&phdri[k].p_flags)) {\n        unsigned xsz = get_te64_32(&phdri[k].p_filesz);\n        if (xsz_f < xsz) {\n            xsz_f = xsz;\n            nk_f = k;\n        }\n    }\n    if (is_shlib) {\n        pack2_shlib(fo, ft, pre_xct_top);\n    }\n    else { // main program\n        int n_ptload = 0;\n        for (k = 0; k < e_phnum; ++k)\n        if (is_LOAD(&phdri[k])) {\n            if (ft.id < 0x40) {\n                // FIXME: ??    ft.addvalue = phdri[k].p_vaddr;\n            }\n            unsigned p_offset = get_te64_32(&phdri[k].p_offset);\n            unsigned p_filesz = get_te64_32(&phdri[k].p_filesz);\n            x.offset = p_offset;\n            x.size   = p_filesz;\n            if ((u32_t)x.size < hdr_u_len) { // FIXME: main program, but how?\n                total_in += x.size;\n            }\n            else {  // main program, not shared library\n                if (0 == n_ptload) { // 1st PT_LOAD must cover Ehdr at 0==p_offset\n                    unsigned const delta = hdr_u_len;\n                    if (ft.id < 0x40) {\n                        // FIXME: ??     ft.addvalue += asl_delta;\n                    }\n                    if ((off_t)delta == x.size) { // PT_LOAD[0] with ElfXX.Ehdr only\n                        // QBE backend - http://c9x.me/compile/\n                        hdr_u_len = 0;  // no fiddling necessary!\n                        // &ft arg to packExtent will be zero because (k != nk_f)\n                    }\n                    else {\n                        total_in += delta - hdr_u_len;\n                        x.offset += delta;\n                        x.size   -= delta;\n                    }\n                }\n                // compressWithFilters() always assumes a \"loader\", so would\n                // throw NotCompressible for small .data Extents, which PowerPC\n                // sometimes marks as PF_X anyway.  So filter only first segment.\n                packExtent(x,\n                    (k==nk_f ? &ft : nullptr ), fo, hdr_u_len, 0, true);\n                hdr_u_len = 0;\n            }\n            ++n_ptload;\n        }\n    }\n    sz_pack2a = fpad4(fo, total_out);  // MATCH01\n    total_out = up4(total_out);\n\n    // Accounting only; ::pack3 will do the compression and output\n    for (k = 0; k < e_phnum; ++k) {\n        total_in += find_LOAD_gap(phdri, k, e_phnum);\n    }\n\n    if (total_in != (u32_t)file_size)\n        throwEOFException();\n\n    return 0;  // omit end-of-compression bhdr for now\n}\n\n// Filter 0x50, 0x51 assume HostPolicy::isLE\nstatic const int *\nARM_getFilters(bool const isBE)\n{\n    static const int f50[] = { 0x50, FT_END };\n    static const int f51[] = { 0x51, FT_END };\n    if (isBE)\n        return f51;\n    return f50;\n}\n\nconst int *\nPackLinuxElf32armBe::getFilters() const\n{\n    return ARM_getFilters(true);\n}\n\nconst int *\nPackLinuxElf32armLe::getFilters() const\n{\n    return ARM_getFilters(false);\n}\n\nconst int *\nPackLinuxElf32mipseb::getFilters() const\n{\n    static const int f_none[] = { FT_END };\n    return f_none;\n}\n\nconst int *\nPackLinuxElf32mipsel::getFilters() const\n{\n    static const int f_none[] = { FT_END };\n    return f_none;\n}\n\n// October 2011: QNX 6.3.0 has no unique signature?\nint PackLinuxElf32::ARM_is_QNX(void)\n{\n    if (Elf32_Ehdr::EM_ARM==get_te16(&ehdri.e_machine)\n    &&  Elf32_Ehdr::ELFDATA2MSB== ehdri.e_ident[Elf32_Ehdr::EI_DATA]\n    &&  Elf32_Ehdr::ELFOSABI_ARM==ehdri.e_ident[Elf32_Ehdr::EI_OSABI]\n    &&  0x100000==(page_mask & get_te32(&phdri[0].p_vaddr))) {\n        Elf32_Phdr const *phdr = phdri;\n        for (int j = get_te16(&ehdri.e_phnum); --j>=0; ++phdr) {\n            if (Elf32_Phdr::PT_INTERP==get_te32(&phdr->p_type)) {\n                char interp[64];\n                unsigned const sz_interp = get_te32(&phdr->p_filesz);\n                unsigned const pos_interp = get_te32(&phdr->p_offset);\n                if (sz_interp <= sizeof(interp)\n                &&  (sz_interp + pos_interp) <= (unsigned)file_size) {\n                    fi->seek(pos_interp, SEEK_SET);\n                    fi->readx(interp, sz_interp);\n                    for (int k = sz_interp - 5; k>=0; --k) {\n                        if (0==memcmp(\"ldqnx\", &interp[k], 5))\n                            return 1;\n                    }\n                }\n            }\n        }\n    }\n    return 0;\n}\n\nvoid PackLinuxElf32::ARM_defineSymbols(Filter const *ft)\n{\n    PackLinuxElf32::defineSymbols(ft);\n\n#define MAP_PRIVATE      2     /* UNIX standard */\n#define MAP_FIXED     0x10     /* UNIX standard */\n#define MAP_ANONYMOUS 0x20     /* UNIX standard */\n#define MAP_PRIVANON     3     /* QNX anonymous private memory */\n    unsigned mflg = MAP_PRIVATE | MAP_ANONYMOUS;\n    if (ARM_is_QNX())\n        mflg = MAP_PRIVANON;\n    linker->defineSymbol(\"MFLG\", mflg);\n}\n\nvoid PackLinuxElf32armLe::defineSymbols(Filter const *ft)\n{\n    ARM_defineSymbols(ft);\n}\n\nvoid PackLinuxElf32armBe::defineSymbols(Filter const *ft)\n{\n    ARM_defineSymbols(ft);\n}\n\nvoid PackLinuxElf64arm::defineSymbols(Filter const *ft)\n{\n    PackLinuxElf64::defineSymbols(ft);\n\n#define MAP_PRIVATE      2     /* UNIX standard */\n#define MAP_FIXED     0x10     /* UNIX standard */\n#define MAP_ANONYMOUS 0x20     /* UNIX standard */\n#define MAP_PRIVANON     3     /* QNX anonymous private memory */\n    unsigned mflg = MAP_PRIVATE | MAP_ANONYMOUS;\n    //if (ARM_is_QNX())\n    //    mflg = MAP_PRIVANON;\n    linker->defineSymbol(\"MFLG\", mflg);\n}\n\nvoid PackLinuxElf32mipseb::defineSymbols(Filter const *ft)\n{\n    PackLinuxElf32::defineSymbols(ft);\n}\n\nvoid PackLinuxElf32mipsel::defineSymbols(Filter const *ft)\n{\n    PackLinuxElf32::defineSymbols(ft);\n}\n\n// ::forward_Shdrs adds info for the benefit of gdb and Android dlopen().\n// De-compression (runtime and offline) ignores the added information\n// because it uses the de-compressed Ehdr etc.\n// All the added space is redundant; libbfd should take a hint:\n// if no Shdrs, then use PT_DYNAMIC instead.\n// (.ARM_attributes (ARM_ATTRIBUTES) is not redundant.)\n//\n// want_types_mask: SHT_PROGBITS is needed else gdb complains:\n//    /build/gdb-MVZsgD/gdb-10.1/gdb/symfile.c:878: internal-error: sect_index_text not initialized\n// and Continuing is not reasonable.\n// However, SHT_PROGBITS with compression gives:\n//    BFD: warning: ./libmain.so.upx has a section extending past end of file\n//    BFD: warning: ./libmain.so.upx has a section extending past end of file\n//    BFD: warning: ./libmain.so.upx has a section extending past end of file\n//    warning: Loadable section \".text\" outside of ELF segments\n//    warning: Loadable section \".plt\" outside of ELF segments\n// because compression gives smaller extents, with no reasonable _Shdr fields.\n// At least gdb can continue.\n\nunsigned PackLinuxElf32::forward_Shdrs(OutputFile *fo, Elf32_Ehdr *const eho)\n{\n    if (!fo) {\n        return 0;\n    }\n    unsigned penalty = total_out;\n    if (sec_arm_attr) { // Forward select _Shdr.  EM_ARM (and Android ?) only.\n        // Keep _Shdr for rtld data (below xct_off).\n        // Discard _Shdr for compressed regions, except \".text\" for gdb.\n        // Keep _Shdr for SHF_WRITE.\n        // Discard _Shdr with (0==sh_addr), except _Shdr[0]\n        // Keep ARM_ATTRIBUTES\n        unsigned const want_types_mask = 0\n            | 1u<<SHT_PROGBITS  // see comment above, and special code below\n            | 1u<<SHT_HASH\n            | 1u<<SHT_DYNAMIC\n            | 1u<<SHT_NOTE\n            | 1u<<SHT_REL\n            | 1u<<SHT_RELA\n            | 1u<<SHT_RELR\n            | 1u<<SHT_DYNSYM  // but not SHT_SYMTAB because compression confuses gdb\n            | 1u<<SHT_STRTAB  // .shstrtab and DYNSYM.sh_link; not SYMTAB.sh_link\n            | 1u<<SHT_INIT_ARRAY\n            | 1u<<SHT_FINI_ARRAY\n            | 1u<<SHT_PREINIT_ARRAY\n            | 1u<<(0x1f & SHT_GNU_versym)\n            | 1u<<(0x1f & SHT_GNU_verneed)\n            | 1u<<(0x1f & SHT_GNU_verdef)\n            | 1u<<(0x1f & SHT_GNU_HASH);\n\n        u32_t xct_off_hi = 0;\n        Elf32_Phdr *ptr = phdri, *ptr_end = &phdri[e_phnum];\n        for (; ptr < ptr_end; ++ptr) {\n            if (is_LOAD(ptr)) {\n                u32_t hi = get_te32(&ptr->p_filesz)\n                    + get_te32(&ptr->p_offset);\n                if (xct_off < hi) {\n                    xct_off_hi = hi;\n                    break;\n                }\n            }\n        }\n\n        MemBuffer mb_ask_for(e_shnum * sizeof(eho->e_shnum));\n        memset(mb_ask_for, 0, mb_ask_for.getSize());\n        unsigned short *const ask_for = (unsigned short *)mb_ask_for.getVoidPtr();\n\n        MemBuffer mb_shdro(e_shnum * sizeof(*shdri));\n        Elf32_Shdr *sh_out0 = (Elf32_Shdr *)mb_shdro.getVoidPtr();\n        Elf32_Shdr *sh_out = sh_out0;\n        Elf32_Shdr *sh_in = shdri;\n        Elf32_Shdr *n_shstrsec = nullptr;\n\n        // Some binutils does tail merging on section names; we don't.\n        // \".plt\" == (4+ \".rel.plt\"); \".hash\" == (4+ \".gnu.hash\")\n        MemBuffer mb_shstrings(100 + 2*get_te32(&sh_in[e_shstrndx].sh_size));\n        char *ptr_shstrings = (char *)&mb_shstrings[0];\n        *ptr_shstrings++ = '\\0';\n\n        memset(sh_out, 0, sizeof(*sh_out));  // blank sh_out[0]\n        ++sh_in; ++sh_out; unsigned n_sh_out = 1;\n\n        for (unsigned j = 1; j < e_shnum; ++j, ++sh_in) {\n            unsigned sh_name   = get_te32(&sh_in->sh_name);\n            unsigned sh_type   = get_te32(&sh_in->sh_type);\n            unsigned sh_flags  = get_te32(&sh_in->sh_flags);\n            //unsigned sh_addr   = get_te32(&sh_in->sh_addr);\n            unsigned sh_offset = get_te32(&sh_in->sh_offset);\n            unsigned sh_size   = get_te32(&sh_in->sh_size);\n            unsigned sh_info   = get_te32(&sh_in->sh_info);\n            char const *name = &shstrtab[sh_name];\n            if (ask_for[j]) { // Some previous _Shdr requested  me\n                // Tell them my new index\n                set_te32(&sh_out0[ask_for[j]].sh_info, n_sh_out);  // sh_info vs st_shndx\n            }\n            if (sh_info < e_shnum) { // wild sh_info abounds!\n                ask_for[sh_info] = j;  // Enter my request, if any\n            }\n            if (   (sh_offset && sh_offset < xct_off)\n                || (j == e_shstrndx)\n                || (Elf32_Shdr::SHF_WRITE & sh_flags)\n                || (sh_type < Elf32_Shdr::SHT_LOPROC\n                    && want_types_mask & (1<<(0x1f & sh_type)))\n                || (Elf32_Shdr::SHT_ARM_ATTRIBUTES == sh_type)\n            ) {\n                *sh_out = *sh_in;  // *sh_in is a candidate for fowarding\n                if (sh_offset > xct_off) { // may slide down: earlier compression\n                    if (sh_offset >= xct_off_hi) { // easy: so_slide down\n                        if (Elf32_Shdr::SHT_ARM_ATTRIBUTES != sh_type) {\n                            slide_sh_offset(sh_out);\n                        }\n                    }\n                    else { // somewhere in compressed; try proportional (aligned)\n                        // But note that PROGBITS without SHF_ALLOC\n                        // will be dropped below.\n                        u32_t const slice = xct_off + (~0xFu & (unsigned)(\n                             (sh_offset - xct_off) *\n                            ((sh_offset - xct_off) / (float)(xct_off_hi - xct_off))));\n                        //set_te32(&sh_out->sh_addr,   slice);\n                        set_te32(&sh_out->sh_offset, slice);\n                    }\n                    u32_t const max_sz = total_out - get_te32(&sh_out->sh_offset);\n                    if (sh_size > max_sz) { // avoid complaint \"extends beyond EOF\"\n                        set_te32(&sh_out->sh_size, max_sz);\n                    }\n                }\n                if (j == e_shstrndx) { // changes Elf32_Ehdr itself\n                    set_te16(&eho->e_shstrndx, sh_out -\n                        (Elf32_Shdr *)mb_shdro.getVoidPtr());\n                }\n                if (Elf32_Shdr::SHT_ARM_ATTRIBUTES == sh_type\n                ||  (SHT_NOTE == sh_type && xct_off < sh_offset)\n                ) { // append a copy\n                    set_te32(&sh_out->sh_offset, total_out);\n                    fi->seek((upx_off_t)sh_offset, SEEK_SET);\n                    fi->read(ibuf,  sh_size);\n                    fo->write(ibuf, sh_size);\n                    total_out +=    sh_size;\n                } else\n                if (SHT_PROGBITS == sh_type) {\n                    if (!(Elf32_Shdr::SHF_ALLOC & sh_flags)) {\n                        // .debug_*, .gnu_debuglink etc.  Typically compressed\n                        // but not in RAM, and gdb (BFD) gets confused.\n                        continue;  // OMIT the commit: do not forward\n                    } else\n                    if (sh_offset <= xct_off\n                    &&  0 == strcmp(\".text\", name) ) {\n                        // .text was compressed (but perhaps omitting some leading\n                        // portion, if less than 4 PT_LOAD)\n                        set_te32(&sh_out->sh_size, so_slide + sh_size);\n                        // FIXME: so_slide is negative; avoid negative result\n                    }\n                } else\n                if (SHT_STRTAB == sh_type) {\n                    if (j == e_shstrndx) {\n                        n_shstrsec = sh_out;\n                    } else\n                    if (strcmp(\".dynstr\",    name)) {\n                        continue;  // OMIT the commit of non-global symbol names\n                    }\n                }\n                set_te32(&sh_out->sh_name, ptr_shstrings - (char *)mb_shstrings.getVoidPtr());\n                do { // stupid MSVC lacks stpcpy()\n                    *ptr_shstrings++ = *name;\n                } while (*name++);\n                ++sh_out; ++n_sh_out;  // actually commit the fowarding\n            }\n        }\n        unsigned len = ptr_shstrings - (char *)mb_shstrings.getVoidPtr();\n        set_te32(&n_shstrsec->sh_offset, total_out);\n        set_te32(&n_shstrsec->sh_size, len);\n        fo->write(mb_shstrings, len);\n        total_out += len;\n\n        total_out = fpad4(fo, total_out);  // align _Shdr[]\n        set_te32(&eho->e_shoff, total_out);\n        len = (char *)sh_out - (char *)mb_shdro.getVoidPtr();\n        set_te16(&eho->e_shnum, len / sizeof(*sh_out));\n        set_te16(&eho->e_shentsize, sizeof(Elf32_Shdr));\n        fo->write(mb_shdro, len);\n        total_out += len;\n\n        // Try to pacify gdb (before DT_INIT) by making it look like\n        // the compressed PT_LOAD extends all the way to the next PT_LOAD,\n        // with no gap in address space.  Thus gdb should not complain about\n        // \"Loadable section \"...\" [Shdr] outside of ELF segments [PT_LOAD]\".\n        // gdb still \"warning: section ... not found in .gnu_debugdata\"\n        // because .gdb_debugdata is not present (or gets removed),\n        // but that is separate and \"just\" a warning.\n        ptr = (Elf32_Phdr *)(1+ eho);\n        if (0)  // FIXME:  This is not required?\n        for (ptr_end = &ptr[e_phnum]; ptr < ptr_end; ++ptr) {\n            if (is_LOAD(ptr)) {\n                Elf32_Phdr *ptr2 = 1+ ptr;\n                for (; ptr2 < ptr_end; ++ptr2) {\n                    if (is_LOAD(ptr2)) {\n                        unsigned pmask = 0u - get_te32(&ptr2->p_align);\n                        set_te32(&ptr->p_memsz,\n                            (pmask & get_te32(&ptr2->p_vaddr)) -\n                            (pmask & get_te32(&ptr ->p_vaddr)) );\n                        ptr  = ptr_end;  // force end of outer loop\n                        ptr2 = ptr_end;  // force end of inner loop\n                    }\n                }\n            }\n        }\n\n        fo->seek(0, SEEK_SET);\n        fo->rewrite(eho, sizeof(*eho));\n        fo->seek(0, SEEK_END);\n    }\n    penalty = total_out - penalty;\n    info(\"Android penalty = %d bytes\", penalty);\n    return penalty;\n}\n\nunsigned PackLinuxElf64::forward_Shdrs(OutputFile *fo, Elf64_Ehdr *const eho)\n{\n    if (!fo) {\n        return 0;\n    }\n    unsigned penalty = total_out;\n    if (Elf64_Ehdr::EM_AARCH64 == e_machine\n    &&  saved_opt_android_shlib) { // Forward select _Shdr\n        // Keep _Shdr for rtld data (below xct_off).\n        // Discard _Shdr for compressed regions, except \".text\" for gdb.\n        // Keep _Shdr with SHF_WRITE.\n        // Keep ARM_ATTRIBUTES\n        // Discard _Shdr with (0==sh_addr), except _Shdr[0]\n        unsigned const want_types_mask =\n              1u<<SHT_SYMTAB\n            | 1u<<SHT_RELA\n            | 1u<<SHT_PROGBITS  // see comment above\n            | 1u<<SHT_HASH\n            | 1u<<SHT_DYNAMIC\n            | 1u<<SHT_NOTE\n            | 1u<<SHT_REL\n            | 1u<<SHT_RELR\n            | 1u<<SHT_DYNSYM\n            | 1u<<SHT_STRTAB  // .shstrtab and .dynstr\n            | 1u<<SHT_INIT_ARRAY\n            | 1u<<SHT_FINI_ARRAY\n            | 1u<<SHT_PREINIT_ARRAY\n            | 1u<<(0x1f & SHT_GNU_versym)\n            | 1u<<(0x1f & SHT_GNU_verneed)\n            | 1u<<(0x1f & SHT_GNU_verdef)\n            | 1u<<(0x1f & SHT_GNU_HASH);\n\n        upx_uint64_t xct_off_hi = 0;\n        Elf64_Phdr const *ptr = phdri, *ptr_end = &phdri[e_phnum];\n        for (; ptr < ptr_end; ++ptr) {\n            if (is_LOAD(ptr)) {\n                upx_uint64_t hi = get_te64(&ptr->p_filesz)\n                    + get_te64(&ptr->p_offset);\n                if (xct_off < hi) {\n                    xct_off_hi = hi;\n                    break;\n                }\n            }\n        }\n\n        MemBuffer mb_ask_for(e_shnum * sizeof(eho->e_shnum));\n        memset(mb_ask_for, 0, mb_ask_for.getSize());\n        unsigned short *const ask_for = (unsigned short *)mb_ask_for.getVoidPtr();\n\n        MemBuffer mb_shdro(e_shnum * sizeof(*shdri));\n        Elf64_Shdr *sh_out0 = (Elf64_Shdr *)mb_shdro.getVoidPtr();\n        Elf64_Shdr *sh_out = sh_out0;\n        Elf64_Shdr *sh_in = shdri;\n\n        memset(sh_out, 0, sizeof(*sh_out));  // blank sh_out[0]\n        ++sh_in; ++sh_out; unsigned n_sh_out = 1;\n\n        for (unsigned j = 1; j < e_shnum; ++j, ++sh_in) {\n            char const *sh_name = &shstrtab[get_te32(&sh_in->sh_name)];\n            (void)sh_name;  // debugging\n            unsigned sh_type = get_te32(&sh_in->sh_type);\n            u64_t sh_flags   = get_te64(&sh_in->sh_flags);\n            u64_t sh_addr    = get_te64(&sh_in->sh_addr);\n            u64_t sh_offset  = get_te64(&sh_in->sh_offset);\n            u64_t sh_size    = get_te64(&sh_in->sh_size);\n            unsigned sh_info = get_te32(&sh_in->sh_info);\n            if (ask_for[j]) { // Some previous _Shdr requested  me\n                // Tell them my new index\n                set_te32(&sh_out0[ask_for[j]].sh_info, n_sh_out);  // sh_info vs st_shndx\n            }\n            if (sh_info < e_shnum) { // wild sh_info abounds!\n                ask_for[sh_info] = j;  // Enter my request, if any\n            }\n            if (   (sh_offset && sh_offset < xct_off)\n                || (Elf64_Shdr::SHF_WRITE & sh_flags)\n                || (j == e_shstrndx)\n                || (sec_arm_attr == sh_in)\n                || (want_types_mask & (1<<(0x1f & sh_type)))\n                || (Elf32_Shdr::SHT_ARM_ATTRIBUTES == sh_type)\n            ) {\n                *sh_out = *sh_in;\n                if (sh_offset > xct_off) { // may slide down: earlier compression\n                    if (sh_offset >= xct_off_hi) { // easy: so_slide down\n                        if (sh_out->sh_addr) // change only if non-zero\n                        set_te64(&sh_out->sh_addr,   so_slide + sh_addr +\n                            (is_asl ? asl_delta : 0));\n                        set_te64(&sh_out->sh_offset, so_slide + sh_offset);\n                    }\n                    else { // somewhere in compressed; try proportional (aligned)\n                        u64_t const slice = xct_off + (~0xFu & (unsigned)(\n                             (sh_offset - xct_off) *\n                            ((sh_offset - xct_off) / (float)(xct_off_hi - xct_off))));\n                        set_te64(&sh_out->sh_addr,   slice);\n                        set_te64(&sh_out->sh_offset, slice);\n                    }\n                    u64_t const max_sz = total_out - get_te64(&sh_out->sh_offset);\n                    if (sh_size > max_sz) { // avoid complaint \"extends beyond EOF\"\n                        set_te64(&sh_out->sh_size, max_sz);\n                    }\n                }\n                if (j == e_shstrndx) { // changes Elf64_Ehdr itself\n                    set_te16(&eho->e_shstrndx, sh_out -\n                        (Elf64_Shdr *)mb_shdro.getVoidPtr());\n                }\n                if (j == e_shstrndx\n                ||  sec_arm_attr == sh_in\n                ||  (SHT_NOTE == sh_type && xct_off < sh_offset)\n                ) { // append a copy\n                    set_te64(&sh_out->sh_offset, total_out);\n                    fi->seek((upx_off_t)sh_offset, SEEK_SET);\n                    fi->read(ibuf,  sh_size);\n                    fo->write(ibuf, sh_size);\n                    total_out +=    sh_size;\n                } else\n                if (SHT_PROGBITS == sh_type) {\n                    if (sh_offset <= xct_off\n                    &&  0 == strcmp(\".text\", shstrtab + get_te32(&sh_in->sh_name)) ) {\n                        // .text was compressed (but perhaps omitting some leading\n                        // portion, if less than 4 PT_LOAD)\n                        set_te64(&sh_out->sh_size, so_slide + sh_size);\n                    } else\n                    if (0 == sh_in->sh_addr) { // .gnu_debuglink etc\n                        set_te64(&sh_out->sh_offset, so_slide + sh_offset);\n                    }\n                }\n                // Exploration for updating Shdrs from Dynamic, to pacify Android.\n                // Motivated by --force-pie with an input shared library;\n                // see https://github.com/upx/upx/issues/694\n                // But then realized that the pointed-to regions typically were\n                // just above Elfhdrs (overlay_offset), so the data would be\n                // incorrect because occupied by compressed PT_LOADS.\n                // But don't lose the code, so comment-out via \"if (0)\".\n                if (0) switch(sh_type) { // start {Shdr, Dynamic} pairs\n                case SHT_DYNSYM: {\n                    set_te64(&sh_out->sh_addr, elf_unsigned_dynamic(Elf64_Dyn::DT_SYMTAB));\n                    sh_out->sh_offset = sh_out->sh_addr;\n                } break;\n                case SHT_STRTAB: {\n                    if (e_shstrndx != j) {\n                        set_te64(&sh_out->sh_addr, elf_unsigned_dynamic(Elf64_Dyn::DT_STRTAB));\n                        sh_out->sh_offset = sh_out->sh_addr;\n                    }\n                } break;\n                case SHT_GNU_versym: {\n                    set_te64(&sh_out->sh_addr, elf_unsigned_dynamic(Elf64_Dyn::DT_VERSYM));\n                    sh_out->sh_offset = sh_out->sh_addr;\n                } break;\n                case SHT_GNU_verneed: {\n                    set_te64(&sh_out->sh_addr, elf_unsigned_dynamic(Elf64_Dyn::DT_VERNEED));\n                    sh_out->sh_offset = sh_out->sh_addr;\n                } break;\n                case SHT_GNU_HASH: {\n                    set_te64(&sh_out->sh_addr, elf_unsigned_dynamic(Elf64_Dyn::DT_GNU_HASH));\n                    sh_out->sh_offset = sh_out->sh_addr;\n                } break;\n                case SHT_HASH: {\n                    set_te64(&sh_out->sh_addr, elf_unsigned_dynamic(Elf64_Dyn::DT_HASH));\n                    sh_out->sh_offset = sh_out->sh_addr;\n                } break;\n                case SHT_RELA: {\n                    if (0==strcmp(\".rela.dyn\", sh_name)) {\n                        set_te64(&sh_out->sh_addr, elf_unsigned_dynamic(Elf64_Dyn::DT_RELA));\n                        sh_out->sh_offset = sh_out->sh_addr;\n                    }\n                    if (0==strcmp(\".rela.plt\", sh_name)) {\n                        set_te64(&sh_out->sh_addr, elf_unsigned_dynamic(Elf64_Dyn::DT_JMPREL));\n                        sh_out->sh_offset = sh_out->sh_addr;\n                    }\n                } break;\n                } // end {Shdr, Dynamic} pairs\n                ++sh_out; ++n_sh_out;\n            }\n        }\n        total_out = fpad8(fo, total_out);\n        set_te64(&eho->e_shoff, total_out);\n        unsigned len = (char *)sh_out - (char *)mb_shdro.getVoidPtr();\n        set_te16(&eho->e_shnum, len / sizeof(*sh_out));\n        set_te16(&eho->e_shentsize, sizeof(Elf64_Shdr));\n        fo->write(mb_shdro, len);\n        total_out += len;\n        fo->seek(0, SEEK_SET);\n        fo->rewrite(eho, sizeof(*eho));\n        fo->seek(0, SEEK_END);\n    }\n    penalty = total_out - penalty;\n    info(\"Android penalty = %d bytes\", penalty);\n    return penalty;\n}\n\nvoid PackLinuxElf32::pack4(OutputFile *fo, Filter &ft)\n{\n    if (!xct_off) {\n        overlay_offset = sz_elf_hdrs + sizeof(linfo);\n    }\n\n    cprElfHdr4 *eho = !xct_off\n            ? (cprElfHdr4 *)(void *)&elfout  // not shlib  FIXME: ugly casting\n            : (cprElfHdr4 *)lowmem.getVoidPtr();  // shlib\n    unsigned penalty = forward_Shdrs(fo, &eho->ehdr); (void)penalty;\n\n    if (opt->o_unix.preserve_build_id) { // FIXME: co-ordinate with forward_Shdrs\n        // calc e_shoff here and write shdrout, then o_shstrtab\n        //NOTE: these are pushed last to ensure nothing is stepped on\n        //for the UPX structure.\n        total_out = fpad4(fo, total_out);\n        set_te32(&eho->ehdr.e_shoff, total_out);\n\n        unsigned const ssize = sizeof(shdrout);\n        unsigned const ssize1 = get_te32(&shdrout.shdr[1].sh_size);\n        unsigned const ssize2 = get_te32(&shdrout.shdr[2].sh_size);\n\n        set_te32(&shdrout.shdr[2].sh_offset,          ssize + total_out);\n        set_te32(&shdrout.shdr[1].sh_offset, ssize2 + ssize + total_out);\n\n        fo->write(&shdrout, ssize); total_out += ssize;\n\n        fo->write(o_shstrtab, ssize2); total_out += ssize2;\n        fo->write(buildid_data, ssize1); total_out += ssize1;\n    }\n\n    // ph.u_len and ph.c_len are leftover from earliest days when there was\n    // only one compressed extent.  Use a good analogy for multiple extents.\n    ph.u_len = file_size;\n    ph.c_len = total_out;\n    super::pack4(fo, ft);  // write PackHeader and overlay_offset\n\n    fo->seek(0, SEEK_SET);\n    if (0!=xct_off) {  // shared library\n        { // Shouldn't this special case be handled earlier?\n            if (overlay_offset < xct_off) {\n                Elf32_Phdr *phdro = (Elf32_Phdr *)&eho->phdr;\n                set_te32(&phdro->p_flags, Elf32_Phdr::PF_X | get_te32(&phdro->p_flags));\n            }\n        }\n        if (!sec_arm_attr && !saved_opt_android_shlib) {\n            // Make it abundantly clear that there are no Elf32_Shdr in this shlib\n            eho->ehdr.e_shoff = 0;\n            set_te16(&eho->ehdr.e_shentsize, sizeof(Elf32_Shdr));  // Android bug: cannot use 0\n            eho->ehdr.e_shnum = 0;\n            eho->ehdr.e_shstrndx = 0;\n        }\n        fo->rewrite(eho, sizeof(ehdri) + e_phnum * sizeof(*phdri));\n        fo->seek(linfo_off, SEEK_SET);\n        fo->rewrite(&linfo, sizeof(linfo));  // new info: l_checksum, l_size\n\n        if (jni_onload_va) {\n            unsigned tmp = sz_pack2 + get_te32(&eho->phdr[C_TEXT].p_vaddr);\n            tmp |= (Elf32_Ehdr::EM_ARM==e_machine);  // THUMB mode\n            set_te32(&tmp, tmp);\n            fo->seek(ptr_udiff_bytes(&jni_onload_sym->st_value, file_image), SEEK_SET);\n            fo->rewrite(&tmp, sizeof(tmp));\n        }\n    }\n    else { // not shlib\n        // Cannot pre-round .p_memsz.  If .p_filesz < .p_memsz, then kernel\n        // tries to make .bss, which requires PF_W.\n        // But strict SELinux (or PaX, grSecurity) disallows PF_W with PF_X.\n        set_te32(&eho->phdr[C_TEXT].p_filesz, sz_pack2 + lsize);\n                  eho->phdr[C_TEXT].p_memsz = eho->phdr[C_TEXT].p_filesz;\n\n        fo->seek(0, SEEK_SET);\n        fo->rewrite(&eho->ehdr, sizeof(Elf32_Ehdr) + 2* sizeof(Elf32_Phdr));  // C_BASE, C_TEXT\n        fo->seek(overlay_offset - sizeof(l_info), SEEK_SET);\n        fo->rewrite(&linfo, sizeof(linfo));\n    }\n}\n\nvoid PackLinuxElf64::pack4(OutputFile *fo, Filter &ft)\n{\n    if (!xct_off) {\n        overlay_offset = sz_elf_hdrs + sizeof(linfo);\n    }\n\n    cprElfHdr4 *eho = !xct_off\n            ? &elfout  // not shlib\n            : (cprElfHdr4 *)lowmem.getVoidPtr();  // shlib\n    unsigned penalty = forward_Shdrs(fo, &eho->ehdr); (void)penalty;\n\n    if (opt->o_unix.preserve_build_id) { // FIXME: co-ordinate with forward_Shdrs\n        // calc e_shoff here and write shdrout, then o_shstrtab\n        //NOTE: these are pushed last to ensure nothing is stepped on\n        //for the UPX structure.\n        total_out = fpad4(fo, total_out);\n        set_te64(&eho->ehdr.e_shoff, total_out);\n\n        unsigned const ssize = sizeof(shdrout);\n        unsigned const ssize1 = get_te64(&shdrout.shdr[1].sh_size);\n        unsigned const ssize2 = get_te64(&shdrout.shdr[2].sh_size);\n\n        set_te64(&shdrout.shdr[2].sh_offset,          ssize + total_out);\n        set_te64(&shdrout.shdr[1].sh_offset, ssize2 + ssize + total_out);\n\n        fo->write(&shdrout, ssize); total_out += ssize;\n\n        fo->write(o_shstrtab, ssize2); total_out += ssize2;\n        fo->write(buildid_data, ssize1); total_out += ssize1;\n    }\n\n    // ph.u_len and ph.c_len are leftover from earliest days when there was\n    // only one compressed extent.  Use a good analogy for multiple extents.\n    ph.u_len = file_size;\n    ph.c_len = total_out;\n    super::pack4(fo, ft);  // write PackHeader and overlay_offset\n\n    fo->seek(0, SEEK_SET);\n    if (0!=xct_off) {  // shared library\n        { // Shouldn't this special case be handled earlier?\n            if (overlay_offset < xct_off) {\n                Elf64_Phdr *phdro = (Elf64_Phdr *)(&eho->phdr);\n                set_te32(&phdro->p_flags, Elf64_Phdr::PF_X | get_te32(&phdro->p_flags));\n            }\n        }\n        if (!sec_arm_attr && !saved_opt_android_shlib) {\n            // Make it abundantly clear that there are no Elf64_Shdr in this shlib\n            eho->ehdr.e_shoff = 0;\n            set_te16(&eho->ehdr.e_shentsize, sizeof(Elf64_Shdr));  // Android bug: cannot use 0\n            eho->ehdr.e_shnum = 0;\n            eho->ehdr.e_shstrndx = 0;\n        }\n\n        fo->rewrite(eho, sizeof(ehdri) + e_phnum * sizeof(*phdri));\n        fo->seek(linfo_off, SEEK_SET);\n        fo->rewrite(&linfo, sizeof(linfo));  // new info: l_checksum, l_size\n\n        if (jni_onload_va) { // FIXME Does this apply to 64-bit, too?\n            upx_uint64_t tmp = sz_pack2 + get_te64(&eho->phdr[C_TEXT].p_vaddr);\n            tmp |= (Elf64_Ehdr::EM_ARM==e_machine);  // THUMB mode; no-op for 64-bit\n            set_te64(&tmp, tmp);\n            fo->seek(ptr_udiff_bytes(&jni_onload_sym->st_value, file_image), SEEK_SET);\n            fo->rewrite(&tmp, sizeof(tmp));\n        }\n    }\n    else { // not shlib\n        // Cannot pre-round .p_memsz.  If .p_filesz < .p_memsz, then kernel\n        // tries to make .bss, which requires PF_W.\n        // But strict SELinux (or PaX, grSecurity) disallows PF_W with PF_X.\n        set_te64(&eho->phdr[C_TEXT].p_filesz, sz_pack2 + lsize);\n                  eho->phdr[C_TEXT].p_memsz = eho->phdr[C_TEXT].p_filesz;\n\n        fo->seek(0, SEEK_SET);\n        fo->rewrite(&eho->ehdr, sizeof(Elf64_Ehdr) + 2* sizeof(Elf64_Phdr));  // C_BASE, C_TEXT\n        fo->seek(overlay_offset - sizeof(l_info), SEEK_SET);\n        fo->rewrite(&linfo, sizeof(linfo));\n    }\n}\n\nvoid\nPackLinuxElf32::unRel32(\n    unsigned dt_rel,\n    Elf32_Rel *rel0,\n    unsigned relsz,\n    MemBuffer &ptload1,\n    unsigned const load_off,\n    OutputFile *fo\n)\n{\n    Elf32_Rel *rel = rel0;\n    for (int k = relsz / sizeof(Elf32_Rel); --k >= 0; ++rel) {\n        unsigned r_offset = get_te32(&rel->r_offset);\n        unsigned r_info   = get_te32(&rel->r_info);\n        unsigned r_type = ELF32_R_TYPE(r_info);\n        if (xct_off <= r_offset) {\n            set_te32(&rel->r_offset, r_offset - asl_delta);\n        }\n        if (Elf32_Ehdr::EM_ARM == e_machine) {\n            if (R_ARM_RELATIVE == r_type) {\n                unsigned d = r_offset - load_off - asl_delta;\n                unsigned w = get_te32(&ptload1[d]);\n                if (xct_off <= w) {\n                    set_te32(&ptload1[d], w - asl_delta);\n                }\n            }\n            if (R_ARM_JUMP_SLOT == r_type) {\n                ++n_jmp_slot;\n                // .rel.plt contains offset of the \"first time\" target\n                unsigned d = r_offset - load_off - asl_delta;\n                if (plt_va > d) {\n                    plt_va = d;\n                }\n                unsigned w = get_te32(&ptload1[d]);\n                if (xct_off <= w) {\n                    set_te32(&ptload1[d], w - asl_delta);\n                }\n            }\n        }\n        if (Elf32_Ehdr::EM_386 == e_machine) {\n            if (R_386_RELATIVE == r_type) {\n                unsigned d = r_offset - load_off - asl_delta;\n                unsigned w = get_te32(&ptload1[d]);\n                if (xct_off <= w) {\n                    set_te32(&ptload1[d], w - asl_delta);\n                }\n            }\n            if (R_386_JMP_SLOT == r_type) {\n                ++n_jmp_slot;\n                // .rel.plt contains offset of the \"first time\" target\n                unsigned d = r_offset - load_off - asl_delta;\n                if (plt_va > d) {\n                    plt_va = d;\n                }\n                unsigned w = get_te32(&ptload1[d]);\n                if (xct_off <= w) {\n                    set_te32(&ptload1[d], w - asl_delta);\n                }\n            }\n        }\n    }\n    fo->seek(dt_rel, SEEK_SET);\n    fo->rewrite(rel0, relsz);\n}\n\nvoid\nPackLinuxElf64::unRela64(\n    upx_uint64_t const dt_rela,\n    Elf64_Rela *const rela0,\n    unsigned const relasz,\n    upx_uint64_t const old_dtinit,\n    OutputFile *const fo\n)\n{\n    Elf64_Rela *rela = rela0;\n    for (int k = relasz / sizeof(Elf64_Rela); --k >= 0; ++rela) {\n        upx_uint64_t r_addend = get_te64(&rela->r_addend);\n        if (xct_off <= r_addend) {\n            r_addend -= asl_delta;\n            set_te64(&rela->r_addend, r_addend);\n        }\n\n        upx_uint64_t r_offset = get_te64(&rela->r_offset);\n        if (xct_off <= r_offset) {\n            //r_offset -= asl_delta;  // keep compressed value vs plt_va\n            set_te64(&rela->r_offset, r_offset - asl_delta);  // uncompressed value\n        }\n\n        // ElfXX_Rela (used only on 64-bit) ignores the contents of memory\n        // at the target designated by r_offset.  The target is completely\n        // overwritten by (r_addend + f_reloc(r_info)).\n        //\n        // Nevertheless, the existing targets of .rela.plt in the .got\n        // seem to have values that matter to somebody. So restore original\n        // values when is_asl.\n        upx_uint64_t r_info   = get_te64(&rela->r_info);\n        unsigned r_type = ELF64_R_TYPE(r_info);\n        if (is_asl && Elf64_Ehdr::EM_AARCH64 == e_machine) {\n            if (R_AARCH64_RELATIVE == r_type) {\n#if 0  //{ FIXME\n                if (old_dtinit == r_addend) {\n                    set_te64(&ptload1[r_offset - plt_va], r_addend);\n                }\n#endif  //}\n            }\n            if (R_AARCH64_JUMP_SLOT == r_type) {\n                ++n_jmp_slot;\n                // .rela.plt contains offset of the \"first time\" target\n                if (jump_slots.getSize() < (r_offset - plt_va)) {\n                    throwInternalError(\"bad r_offset for jump_slots\");\n                }\n                // really upx_uint64_t *, but clang makes it hard to say that\n                unsigned char *slot = r_offset - plt_va\n                    + (unsigned char *)jump_slots.getVoidPtr();\n                upx_uint64_t w = get_te64(slot);\n                if (xct_off <= w) {\n                    set_te64(slot, w - asl_delta);\n                }\n            }\n        }\n        // FIXME: but what about old_dtinit?\n        (void)old_dtinit;\n\n    }  // end each RELA\n    if (fo) {\n        fo->seek(dt_rela, SEEK_SET);\n        fo->rewrite(rela0, relasz);\n    }\n}\n\nvoid\nPackLinuxElf64::un_asl_dynsym( // ibuf has the input\n    unsigned orig_file_size,\n    OutputFile *fo  // else just leave in ibuf\n)\n{\n    // un-Relocate dynsym (DT_SYMTAB) which is below xct_off\n    dynstr = (char const *)elf_find_dynamic(Elf64_Dyn::DT_STRTAB);\n    sec_dynsym = elf_find_section_type(Elf64_Shdr::SHT_DYNSYM);\n    if (dynstr && sec_dynsym) {\n        upx_uint64_t const off_dynsym = get_te64(&sec_dynsym->sh_offset);\n        upx_uint64_t const sz_dynsym  = get_te64(&sec_dynsym->sh_size);\n        if (orig_file_size < sz_dynsym\n        ||  orig_file_size < off_dynsym\n        || (orig_file_size - off_dynsym) < sz_dynsym) {\n            throwCantUnpack(\"bad SHT_DYNSYM\");\n        }\n        Elf64_Sym *const sym0 = (Elf64_Sym *)ibuf.subref(\n            \"bad dynsym\", off_dynsym, sz_dynsym);\n        Elf64_Sym *sym = sym0;\n        for (int j = sz_dynsym / sizeof(Elf64_Sym); --j>=0; ++sym) {\n            upx_uint64_t symval = get_te64(&sym->st_value);\n            unsigned symsec = get_te16(&sym->st_shndx);\n            if (Elf64_Sym::SHN_UNDEF != symsec\n            &&  Elf64_Sym::SHN_ABS   != symsec\n            &&  xct_off <= symval) {\n                set_te64(&sym->st_value, symval - asl_delta);\n            }\n            if (Elf64_Sym::SHN_ABS == symsec && xct_off <= symval) {\n                adjABS(sym, 0ul - (unsigned long)asl_delta);\n            }\n        }\n        if (fo) {\n            unsigned pos = fo->tell();\n            fo->seek(off_dynsym, SEEK_SET);\n            fo->rewrite(sym0, sz_dynsym);\n            fo->seek(pos, SEEK_SET);\n        }\n    }\n}\n\nvoid\nPackLinuxElf32::un_asl_dynsym( // ibuf has the input\n    unsigned orig_file_size,\n    OutputFile *fo  // else just leave in ibuf\n)\n{\n    // un-Relocate dynsym (DT_SYMTAB) which is below xct_off\n    dynstr = (char const *)elf_find_dynamic(Elf32_Dyn::DT_STRTAB);\n    sec_dynsym = elf_find_section_type(Elf32_Shdr::SHT_DYNSYM);\n    if (dynstr && sec_dynsym) {\n        upx_uint32_t const off_dynsym = get_te32(&sec_dynsym->sh_offset);\n        upx_uint32_t const sz_dynsym  = get_te32(&sec_dynsym->sh_size);\n        if (orig_file_size < sz_dynsym\n        ||  orig_file_size < off_dynsym\n        || (orig_file_size - off_dynsym) < sz_dynsym) {\n            throwCantUnpack(\"bad SHT_DYNSYM\");\n        }\n        Elf32_Sym *const sym0 = (Elf32_Sym *)ibuf.subref(\n            \"bad dynsym\", off_dynsym, sz_dynsym);\n        Elf32_Sym *sym = sym0;\n        for (int j = sz_dynsym / sizeof(Elf32_Sym); --j>=0; ++sym) {\n            upx_uint32_t symval = get_te32(&sym->st_value);\n            unsigned symsec = get_te16(&sym->st_shndx);\n            if (Elf32_Sym::SHN_UNDEF != symsec\n            &&  Elf32_Sym::SHN_ABS   != symsec\n            &&  xct_off <= symval) {\n                set_te32(&sym->st_value, symval - asl_delta);\n            }\n            if (Elf32_Sym::SHN_ABS == symsec && xct_off <= symval) {\n                adjABS(sym, 0u - (unsigned)asl_delta);\n            }\n        }\n        if (fo) {\n            unsigned pos = fo->tell();\n            fo->seek(off_dynsym, SEEK_SET);\n            fo->rewrite(sym0, sz_dynsym);\n            fo->seek(pos, SEEK_SET);\n        }\n    }\n}\n\n// File layout of compressed .so (new-style: 3 or 4 PT_LOAD) shared library:\n// 1. new Elf headers: Ehdr, PT_LOAD (r-x), PT_LOAD (rw-, if any), non-PT_LOAD Phdrs\n// 2. Space for (original - 2) PT_LOAD Phdr\n// 3. Remaining original contents of file below xct_off\n// xct_off: (&lowest eXecutable Shdr section; in original PT_LOAD[0] or [1])\n// 3a. If --android-shlib, then 4KiB page of Shdr copy, etc.  (asl_pack2_Shdrs)\n//    And xct_off gets incremented by 4KiB at the right time.\n// 4. l_info (12 bytes)\n// overlay_offset:\n// 5. p_info (12 bytes)\n// 6. compressed original Elf headers (prefixed by b_info as usual)\n// 6a. un-compressed copy of input after Elf headers until xct_off.\n//    *user_init_rp has been modified if no DT_INIT\n// 7. compressed remainder of PT_LOAD above xct_off\n// 8. compressed read-only PT_LOAD above xct_off (if any)  // FIXME: check decompressor\n// 9. uncompressed Read-Write PT_LOAD (slide down N pages)\n// 10. int[6] tables for UPX runtime de-compressor\n// (new) DT_INIT:\n// 11. UPX runtime de-compressing loader\n// 12. compressed gaps between PT_LOADs (and EOF) above xct_off\n// 13. 32-byte pack header\n// 14. 4-byte overlay_offset\n\nvoid PackLinuxElf64::un_shlib_1(\n    OutputFile *const fo,\n    MemBuffer &o_elfhdrs,\n    unsigned &c_adler,\n    unsigned &u_adler,\n    unsigned const orig_file_size\n)\n{\n    // xct_off [input side] was set by ::unpack when is_shlib\n    // yct_off [output side] set here unless is_asl in next 'if' block\n    unsigned yct_off = xct_off;\n\n    // Below xct_off is not compressed (for benefit of rtld.)\n    fi->seek(0, SEEK_SET);\n    fi->readx(ibuf, umin(blocksize, file_size_u32));\n\n    // Determine if the extra page with copy of _Shdrs was spliced in.\n    // This used to be the result of --android-shlib.\n    // But in 2023-02 the forwarding of ARM_ATTRIBUTES (by appending)\n    // takes care of this, so the 5th word before e_entry does not\n    // have the low bit 1, so is_asl should not be set.\n    // However, .so that were compressed before 2023-03\n    // may be marked.\n    e_shoff = get_te64(&ehdri.e_shoff);\n    if (e_shoff && e_shnum\n            // +36: (sizeof(PackHeader) + sizeof(overlay_offset))\n            //    after Shdrs for ARM_ATTRIBUTES\n    &&  (((e_shoff + sizeof(Elf64_Shdr) * e_shnum) + 36) < file_size_u)\n    ) { // possible --android-shlib\n        unsigned x = get_te32(&file_image[get_te64(&ehdri.e_entry) - (1+ 4)*sizeof(int)]);\n        if (1 & x) { // the clincher\n            is_asl = 1;\n            fi->seek(e_shoff, SEEK_SET);\n            mb_shdr.alloc(   sizeof(Elf64_Shdr) * e_shnum);\n            shdri = (Elf64_Shdr *)mb_shdr.getVoidPtr();\n            fi->readx(shdri, sizeof(Elf64_Shdr) * e_shnum);\n            yct_off = get_te64(&shdri->sh_offset);  // for the output file (de-compressed)\n            xct_off = asl_delta + yct_off;  // for the input file (compressed)\n        }\n    }\n\n    // Decompress first Extent.  Old style covers [0, xct_off)\n    // which includes rtld constant data and eXecutable app code below DT_INIT.\n    // In old style, the first compressed Extent is redundant\n    // except for the compressed original Elf headers.\n    // New style covers just Elf headers: the rest below xct_off is\n    // rtld constant data: DT_*HASH, DT_SYMTAB, DT_STRTAB, etc.\n    // New style puts eXecutable app code in second PT_LOAD\n    // in order to mark Elf headers and rtld data as non-eXecutable.\n    fi->seek(overlay_offset - sizeof(l_info), SEEK_SET);\n    struct {\n        struct l_info l;\n        struct p_info p;\n        struct b_info b;\n    } hdr;\n    fi->readx(&hdr, sizeof(hdr));\n    if (hdr.l.l_magic != UPX_MAGIC_LE32\n    ||  get_te16(&hdr.l.l_lsize) != (unsigned)lsize\n    ||  get_te32(&hdr.p.p_filesize) != ph.u_file_size\n    ||  get_te32(&hdr.b.sz_unc) < sz_elf_hdrs  // peek: 1st b_info covers Elf headers\n    ) {\n        throwCantUnpack(\"corrupt l_info/p_info/b_info\");\n    }\n    fi->seek(-(off_t)sizeof(struct b_info), SEEK_CUR); // hdr.b_info was a peek\n\n// The default layout for a shared library created by binutils-2.29\n// (Fedora 28; 2018) has two PT_LOAD: permissions r-x and rw-.\n// xct_off (the lowest address of executable instructions;\n// the highest address of read-only data used by rtld (ld-linux))\n// will be somewhere in the first PT_LOAD.\n//\n// The default layout for a shared library created by binutils-2.31\n// (Fedora 29; 2018) has four PT_LOAD: permissions r--, r-x, r--, rw-.\n// xct_off will be the base of the second [r-x] PT_LOAD.\n//\n// Bytes below xct_off cannot be compressed because they are used\n// by rtld *before* the UPX run-time de-compression stub gets control\n// via DT_INIT. Bytes in a Writeable PT_LOAD cannot be compressed\n// because they may be relocated by rtld, again before stub execution.\n//\n// We need to know which layout of PT_LOAD. It seems risky to steal\n// bits in the input ElfXX_Ehdr or ElfXX_Phdr, so we decompress\n// the first compressed block.  For an old-style shared library\n// the first compressed block covers [0, xct_off) which is redundant\n// with the interval [sz_elf_hdrs, xct_off) because those bytes\n// must be present for use by rtl  (So that is a large inefficiency.)\n// Fortunately p_info.p_blocksize fits in ibuf, and unpackExtent\n// will just decompress it all.  For new style, the first compressed\n// block covers [0, sz_elf_hdrs).\n\n    // Peek: unpack into ibuf, but do not write\n    unsigned const sz_block1 = unpackExtent(sz_elf_hdrs, nullptr,\n        c_adler, u_adler, false, -1);\n    if (sz_block1 < sz_elf_hdrs) {\n        throwCantUnpack(\"corrupt b_info\");\n    }\n    memcpy(o_elfhdrs, ibuf, sz_elf_hdrs); // save de-compressed Elf headers\n    Elf64_Ehdr const *const ehdro = (Elf64_Ehdr const *)(void const *)o_elfhdrs;\n    if (ehdro->e_type   !=ehdri.e_type\n    ||  ehdro->e_machine!=ehdri.e_machine\n    ||  ehdro->e_version!=ehdri.e_version\n        // less strict for EM_PPC64 to workaround earlier bug\n    ||  !( ehdro->e_flags==ehdri.e_flags\n        || Elf64_Ehdr::EM_PPC64 == get_te16(&ehdri.e_machine))\n    ||  ehdro->e_ehsize !=ehdri.e_ehsize\n        // check EI_MAG[0-3], EI_CLASS, EI_DATA, EI_VERSION\n    ||  memcmp(ehdro->e_ident, ehdri.e_ident, Elf64_Ehdr::EI_OSABI)) {\n        throwCantUnpack(\"ElfXX_Ehdr corrupted\");\n    }\n    if (fo) {\n        fo->write(ibuf, sz_block1);\n        total_out = sz_block1;\n    }\n    Elf64_Phdr const *o_phdr = (Elf64_Phdr const *)(1+ ehdro);\n    // Handle compressed PT_LOADs (must not have PF_W)\n    unsigned not_first_LOAD = 0;\n    for (unsigned j = 0; j < e_phnum; ++j, ++o_phdr) {\n        unsigned type = get_te32(&o_phdr->p_type);\n        unsigned flags = get_te32(&o_phdr->p_flags);\n        if (PT_LOAD != type || Elf64_Phdr::PF_W & flags) {\n            continue;\n        }\n        unsigned p_offset = get_te64(&o_phdr->p_offset);\n        unsigned p_filesz = get_te64(&o_phdr->p_filesz);\n        unsigned wanted = p_filesz;\n        if (!not_first_LOAD++) { // first PT_LOAD\n            wanted -= sz_block1;\n            if (sz_block1 >  sz_elf_hdrs) { // old style\n                if (is_asl) {\n                    un_asl_dynsym(orig_file_size, fo);\n                }\n                p_offset += sz_block1;\n            }\n            if (sz_block1 == sz_elf_hdrs) { // new style\n                unsigned const len = (yct_off ? yct_off : xct_off) - sz_elf_hdrs;\n                unsigned const ipos = fi->tell();\n                fi->seek(sz_elf_hdrs, SEEK_SET);\n                fi->readx(&ibuf[sz_elf_hdrs], len);\n                if (is_asl) {\n                    un_asl_dynsym(orig_file_size, nullptr);\n                }\n                if (fo) {\n                    fo->write(&ibuf[sz_elf_hdrs], len);\n                }\n                total_out += len;\n\n// github-issue629: (overlay_offset = 0xa500), so initially (xct_off = 0xa494).\n// But \"yct_off = get_te64(&shdri->sh_offset)\" so if _Shdrs are aligned (??)\n// then (0x10500 == (xct_off = asl_delta + yct_off)), and we read+write\n// more than we need.\n// So assume the excess just lives there, or is overwritten later by seek+write.\n                if (wanted < len) { // FIXME: why does this happen?\n                    wanted = 0;\n                }\n                else {\n                    wanted -= len;\n                }\n                fi->seek(ipos, SEEK_SET);\n                if (total_out == p_filesz) {\n                    continue;   // already entirely re-generated\n                }\n                p_offset = total_out;\n            }\n        }\n        if (fo) {\n            fo->seek(p_offset, SEEK_SET);\n        }\n        unpackExtent(wanted, fo, c_adler, u_adler, false);\n    }\n    funpad4(fi);\n    loader_offset = fi->tell();\n\n    // Handle PT_LOAD with PF_W: writeable, so not compressed.  \"Slide\"\n    o_phdr = (Elf64_Phdr const *)(1+ ehdro);\n    Elf64_Phdr const *i_phdr = phdri;\n    for (unsigned j = 0; j < e_phnum; ++j, ++o_phdr, ++i_phdr) {\n        unsigned type = get_te32(&o_phdr->p_type);\n        unsigned flags = get_te32(&o_phdr->p_flags);\n        if (PT_LOAD != type || !(Elf64_Phdr::PF_W & flags)) {\n            continue;\n        }\n        unsigned filesz = get_te64(&o_phdr->p_filesz);\n        unsigned o_offset = get_te64(&o_phdr->p_offset);\n        unsigned i_offset = get_te64(&i_phdr->p_offset);\n        fi->seek(i_offset, SEEK_SET);\n        fi->readx(ibuf, filesz);\n        total_in += filesz;\n        if (fo) {\n            fo->seek(o_offset, SEEK_SET);\n            fo->write(ibuf, filesz);\n        }\n        total_out = filesz + o_offset;  // high-water mark\n    }\n\n    // Gaps between PT_LOAD will be handled by ::unpack()\n\n    // position fi at loader offset\n    fi->seek(loader_offset, SEEK_SET);\n}\n\nvoid PackLinuxElf32::un_shlib_1(\n    OutputFile *const fo,\n    MemBuffer &o_elfhdrs,\n    unsigned &c_adler,\n    unsigned &u_adler,\n    unsigned const orig_file_size\n)\n{\n    // xct_off [input side] was set by ::unpack when is_shlib\n    // yct_off [output side] set here unless is_asl in next 'if' block\n    unsigned yct_off = xct_off;\n\n    // Below xct_off is not compressed (for benefit of rtld.)\n    fi->seek(0, SEEK_SET);\n    fi->readx(ibuf, umin(blocksize, file_size_u32));\n\n    // Determine if the extra page with copy of _Shdrs was spliced in.\n    // This used to be the result of --android-shlib.\n    // But in 2023-02 the forwarding of ARM_ATTRIBUTES (by appending)\n    // takes care of this, so the 5th word before e_entry does not\n    // have the low bit 1, so is_asl should not be set.\n    // However, .so that were compressed before 2023-03\n    // may be marked.\n    e_shoff = get_te32(&ehdri.e_shoff);\n    if (e_shoff && e_shnum\n            // +36: (sizeof(PackHeader) + sizeof(overlay_offset))\n            //    after Shdrs for ARM_ATTRIBUTES\n    &&  (((e_shoff + sizeof(Elf32_Shdr) * e_shnum) + 36) < file_size_u32)\n    ) { // possible --android-shlib\n        unsigned x = get_te32(&file_image[get_te32(&ehdri.e_entry) - (1+ 4)*sizeof(int)]);\n        if (1 & x) { // the clincher\n            is_asl = 1;\n            fi->seek(e_shoff, SEEK_SET);\n            mb_shdr.alloc(   sizeof(Elf32_Shdr) * e_shnum);\n            shdri = (Elf32_Shdr *)mb_shdr.getVoidPtr();\n            fi->readx(shdri, sizeof(Elf32_Shdr) * e_shnum);\n            yct_off = get_te32(&shdri->sh_offset);  // for the output file (de-compressed)\n            xct_off = asl_delta + yct_off;  // for the input file (compressed)\n        }\n    }\n\n    // Decompress first Extent.  Old style covers [0, xct_off)\n    // which includes rtld constant data and eXecutable app code below DT_INIT.\n    // In old style, the first compressed Extent is redundant\n    // except for the compressed original Elf headers.\n    // New style covers just Elf headers: the rest below xct_off is\n    // rtld constant data: DT_*HASH, DT_SYMTAB, DT_STRTAB, etc.\n    // New style puts eXecutable app code in second PT_LOAD\n    // in order to mark Elf headers and rtld data as non-eXecutable.\n    fi->seek(overlay_offset - sizeof(l_info), SEEK_SET);\n    struct {\n        struct l_info l;\n        struct p_info p;\n        struct b_info b;\n    } hdr;\n    fi->readx(&hdr, sizeof(hdr));\n    if (hdr.l.l_magic != UPX_MAGIC_LE32\n    ||  get_te16(&hdr.l.l_lsize) != (unsigned)lsize\n    ||  get_te32(&hdr.p.p_filesize) != ph.u_file_size\n    ||  get_te32(&hdr.b.sz_unc) < sz_elf_hdrs  // peek: 1st b_info covers Elf headers\n    ) {\n        throwCantUnpack(\"corrupt l_info/p_info/b_info\");\n    }\n    fi->seek(-(off_t)sizeof(struct b_info), SEEK_CUR); // hdr.b_info was a peek\n\n// The default layout for a shared library created by binutils-2.29\n// (Fedora 28; 2018) has two PT_LOAD: permissions r-x and rw-.\n// xct_off (the lowest address of executable instructions;\n// the highest address of read-only data used by rtld (ld-linux))\n// will be somewhere in the first PT_LOAD.\n//\n// The default layout for a shared library created by binutils-2.31\n// (Fedora 29; 2018) has four PT_LOAD: permissions r--, r-x, r--, rw-.\n// xct_off will be the base of the second [r-x] PT_LOAD.\n//\n// Bytes below xct_off cannot be compressed because they are used\n// by rtld *before* the UPX run-time de-compression stub gets control\n// via DT_INIT. Bytes in a Writeable PT_LOAD cannot be compressed\n// because they may be relocated by rtld, again before stub execution.\n//\n// We need to know which layout of PT_LOAD. It seems risky to steal\n// bits in the input ElfXX_Ehdr or ElfXX_Phdr, so we decompress\n// the first compressed block.  For an old-style shared library\n// the first compressed block covers [0, xct_off) which is redundant\n// with the interval [sz_elf_hdrs, xct_off) because those bytes\n// must be present for use by rtl  (So that is a large inefficiency.)\n// Fortunately p_info.p_blocksize fits in ibuf, and unpackExtent\n// will just decompress it all.  For new style, the first compressed\n// block covers [0, sz_elf_hdrs).\n\n    // Peek: unpack into ibuf, but do not write\n    unsigned const sz_block1 = unpackExtent(sz_elf_hdrs, nullptr,\n        c_adler, u_adler, false, -1);\n    if (sz_block1 < sz_elf_hdrs) {\n        throwCantUnpack(\"corrupt b_info\");\n    }\n    memcpy(o_elfhdrs, ibuf, sz_elf_hdrs); // save de-compressed Elf headers\n    Elf32_Ehdr const *const ehdro = (Elf32_Ehdr const *)(void const *)o_elfhdrs;\n    if (ehdro->e_type   !=ehdri.e_type\n    ||  ehdro->e_machine!=ehdri.e_machine\n    ||  ehdro->e_version!=ehdri.e_version\n        // less strict for EM_PPC to workaround earlier bug\n    ||  !( ehdro->e_flags==ehdri.e_flags\n        || Elf32_Ehdr::EM_PPC == get_te16(&ehdri.e_machine))\n    ||  ehdro->e_ehsize !=ehdri.e_ehsize\n        // check EI_MAG[0-3], EI_CLASS, EI_DATA, EI_VERSION\n    ||  memcmp(ehdro->e_ident, ehdri.e_ident, Elf32_Ehdr::EI_OSABI)) {\n        throwCantUnpack(\"ElfXX_Ehdr corrupted\");\n    }\n    if (fo) {\n        fo->write(ibuf, sz_block1);\n        total_out = sz_block1;\n    }\n    Elf32_Phdr const *o_phdr = (Elf32_Phdr const *)(1+ ehdro);\n    // Handle compressed PT_LOADs (must not have PF_W)\n    unsigned not_first_LOAD = 0;\n    for (unsigned j = 0; j < e_phnum; ++j, ++o_phdr) {\n        unsigned type = get_te32(&o_phdr->p_type);\n        unsigned flags = get_te32(&o_phdr->p_flags);\n        if (PT_LOAD != type || Elf32_Phdr::PF_W & flags) {\n            continue;\n        }\n        unsigned p_offset = get_te32(&o_phdr->p_offset);\n        unsigned p_filesz = get_te32(&o_phdr->p_filesz);\n        unsigned wanted = p_filesz;\n        if (!not_first_LOAD++) { // first PT_LOAD\n            wanted -= sz_block1;\n            if (sz_block1 >  sz_elf_hdrs) { // old style\n                if (is_asl) {\n                    un_asl_dynsym(orig_file_size, fo);\n                }\n                p_offset += sz_block1;\n            }\n            if (sz_block1 == sz_elf_hdrs) { // new style\n                unsigned const len = (yct_off ? yct_off : xct_off) - sz_elf_hdrs;\n                unsigned const ipos = fi->tell();\n                fi->seek(sz_elf_hdrs, SEEK_SET);\n                fi->readx(&ibuf[sz_elf_hdrs], len);\n                if (is_asl) {\n                    un_asl_dynsym(orig_file_size, nullptr);\n                }\n                if (fo) {\n                    fo->write(&ibuf[sz_elf_hdrs], len);\n                }\n                total_out += len;\n\n// github-issue629: (overlay_offset = 0xa500), so initially (xct_off = 0xa494).\n// But \"yct_off = get_te32(&shdri->sh_offset)\" so if _Shdrs are aligned (??)\n// then (0x10500 == (xct_off = asl_delta + yct_off)), and we read+write\n// more than we need.\n// So assume the excess just lives there, or is overwritten later by seek+write.\n                if (wanted < len) { // FIXME: why does this happen?\n                    wanted = 0;\n                }\n                else {\n                    wanted -= len;\n                }\n                fi->seek(ipos, SEEK_SET);\n                if (total_out == p_filesz) {\n                    continue;   // already entirely re-generated\n                }\n                p_offset = total_out;\n            }\n        }\n        if (fo) {\n            fo->seek(p_offset, SEEK_SET);\n        }\n        unpackExtent(wanted, fo, c_adler, u_adler, false);\n    }\n    funpad4(fi);\n    loader_offset = fi->tell();\n\n    // Handle PT_LOAD with PF_W: writeable, so not compressed.  \"Slide\"\n    o_phdr = (Elf32_Phdr const *)(1+ ehdro);\n    Elf32_Phdr const *i_phdr = phdri;\n    for (unsigned j = 0; j < e_phnum; ++j, ++o_phdr, ++i_phdr) {\n        unsigned type = get_te32(&o_phdr->p_type);\n        unsigned flags = get_te32(&o_phdr->p_flags);\n        if (PT_LOAD != type || !(Elf32_Phdr::PF_W & flags)) {\n            continue;\n        }\n        unsigned filesz = get_te32(&o_phdr->p_filesz);\n        unsigned o_offset = get_te32(&o_phdr->p_offset);\n        unsigned i_offset = get_te32(&i_phdr->p_offset);\n        fi->seek(i_offset, SEEK_SET);\n        fi->readx(ibuf, filesz);\n        total_in += filesz;\n        if (fo) {\n            fo->seek(o_offset, SEEK_SET);\n            fo->write(ibuf, filesz);\n        }\n        total_out = filesz + o_offset;  // high-water mark\n    }\n\n    // Gaps between PT_LOAD will be handled by ::unpack()\n\n    // position fi at loader offset\n    fi->seek(loader_offset, SEEK_SET);\n}\n\nvoid PackLinuxElf32::un_DT_INIT(\n    unsigned old_dtinit,\n    Elf32_Phdr const *const phdro,\n    Elf32_Phdr const *const dynhdr,  // in phdri\n    OutputFile *fo\n)\n{\n    // DT_INIT must be restored.\n    // If android_shlib, then the asl_delta relocations must be un-done.\n    unsigned n_plt = 0;\n    upx_uint32_t dt_pltrelsz(0), dt_jmprel(0), dt_pltgot(0);\n    upx_uint32_t dt_relsz(0), dt_rel(0);\n    upx_uint32_t const dyn_len = get_te32(&dynhdr->p_filesz);\n    upx_uint32_t const dyn_off = get_te32(&dynhdr->p_offset);\n    if (file_size_u32 < (dyn_len + dyn_off)) {\n        char msg[50]; snprintf(msg, sizeof(msg),\n                \"bad PT_DYNAMIC .p_filesz %#lx\", (long unsigned)dyn_len);\n        throwCantUnpack(msg);\n    }\n    fi->seek(dyn_off, SEEK_SET);\n    fi->readx(ibuf, dyn_len);\n    Elf32_Dyn *dyn = (Elf32_Dyn *)(void *)ibuf;\n    dynseg = dyn; invert_pt_dynamic(dynseg,\n        umin(dyn_len, file_size_u32 - dyn_off));\n    for (unsigned j2= 0; j2 < dyn_len; ++dyn, j2 += sizeof(*dyn)) {\n        upx_uint32_t const tag = get_te32(&dyn->d_tag);\n        upx_uint32_t       val = get_te32(&dyn->d_val);\n        if (is_asl) switch (tag) {\n        case Elf32_Dyn::DT_RELASZ:   { dt_relsz   = val; } break;\n        case Elf32_Dyn::DT_RELA:     { dt_rel     = val; } break;\n        case Elf32_Dyn::DT_JMPREL:   { dt_jmprel   = val; } break;\n        case Elf32_Dyn::DT_PLTRELSZ: { dt_pltrelsz = val;\n            n_plt = dt_pltrelsz / sizeof(Elf32_Rel);\n            if (is_asl) {\n                n_plt += 3;  // FIXME\n            }\n        };  break;\n\n        case Elf32_Dyn::DT_PLTGOT:   { plt_va = dt_pltgot = val; (void)dt_pltgot; }\n        // FALL THROUGH\n        case Elf32_Dyn::DT_PREINIT_ARRAY:\n        case Elf32_Dyn::DT_INIT_ARRAY:\n        case Elf32_Dyn::DT_FINI_ARRAY:\n        case Elf32_Dyn::DT_FINI: if (is_asl) {\n            set_te32(&dyn->d_val, val - asl_delta);\n        }; break;\n        } // end switch() on tag when is_asl\n        if (upx_dt_init == tag) {\n            if (Elf32_Dyn::DT_INIT == tag) { // the easy case\n                set_te32(&dyn->d_val, old_dtinit);\n                if (!old_dtinit) { // compressor took the slot\n                    dyn->d_tag = Elf32_Dyn::DT_NULL;\n                    dyn->d_val = 0;\n                }\n            }\n            // Apparently the hard case is common for some Android IDEs.\n            else if (Elf32_Dyn::DT_INIT_ARRAY    == tag\n            ||       Elf32_Dyn::DT_PREINIT_ARRAY == tag) {\n                // 'val' is the RVA of the first slot, which is the slot that\n                // the compressor changed to be the entry to the run-time stub.\n                Elf32_Dyn *dyn_null = elf_find_dynptr(Elf32_Dyn::DT_NULL);\n                if (!dyn_null)\n                    throwCantUnpack(\"bad PT_DYNAMIC .end\");\n                Elf32_Rel *rp = (Elf32_Rel *)elf_find_dynamic(dyn_null->d_val);\n                dyn_null->d_val = 0;\n                if (rp) {\n                    // Compressor saved the original *rp in dynsym[0]\n                    Elf32_Rel *rp_unc = (Elf32_Rel *)&dynsym[0];  // pointer\n                    rp->r_info = rp_unc->r_info;  // restore original r_info; r_offset not touched\n\n                    unsigned e_entry = get_te32(&ehdri.e_entry);\n                    unsigned init_rva = get_te32(&file_image[e_entry - 3*sizeof(unsigned)]);\n                    unsigned arr_rva = get_te32(&rp_unc->r_offset);\n                    Elf32_Phdr const *phdr = elf_find_Phdr_for_va(arr_rva, phdro, e_phnum);\n                    unsigned arr_off = (arr_rva - get_te32(&phdr->p_vaddr)) + get_te32(&phdr->p_offset);\n\n                    rp_unc->r_offset = 0;    rp_unc->r_info = 0;\n                    if (fo)  {\n                        fo->seek(elf_unsigned_dynamic(Elf32_Dyn::DT_SYMTAB), SEEK_SET);\n                        fo->rewrite(rp_unc, sizeof(Elf32_Rel));  // clear dynsym[0]\n\n                        fo->seek((char *)rp - (char *)&file_image[0], SEEK_SET);\n                        fo->rewrite(rp, sizeof(*rp));  // restore original *rp\n                    }\n\n                    // Set arr[0] to the first user init routine.\n                    unsigned r_info = get_te32(&rp->r_info);\n                    unsigned r_type = ELF32_R_TYPE(r_info);\n                    unsigned word;\n                    if (Elf32_Ehdr::EM_ARM == e_machine) {\n                        if (R_ARM_RELATIVE == r_type) {\n                            set_te32(&word, init_rva);\n                        }\n                        else if (R_ARM_ABS32 == r_type) {\n                            word = 0;\n                        }\n                        else {\n                            char msg[40]; snprintf(msg, sizeof(msg), \"unknown relocation: %#x\",\n                                r_type);\n                            throwCantUnpack(msg);\n                        }\n                    }\n                    else if (Elf32_Ehdr::EM_386 == e_machine) {\n                        if (R_386_RELATIVE == r_type) {\n                        }\n                        else if (R_386_32 == r_type) {\n                        }\n                        if (R_386_RELATIVE == r_type) {\n                            set_te32(&word, init_rva);\n                        }\n                        else if (R_386_32 == r_type) {\n                            word = 0;\n                        }\n                        else {\n                            char msg[40]; snprintf(msg, sizeof(msg), \"unknown relocation: %#x\",\n                                r_type);\n                            throwCantUnpack(msg);\n                        }\n                    }\n                    if (fo) {\n                        fo->seek(arr_off, SEEK_SET);\n                        fo->rewrite(&word, sizeof(unsigned));\n                        fo->seek(0, SEEK_END);\n                    }\n                }\n            }\n        }\n    }\n    if (fo) { // Write updated dt_*.val\n        upx_uint32_t dyn_offo = get_te32(&phdro[dynhdr - phdri].p_offset);\n        fo->seek(dyn_offo, SEEK_SET);\n        fo->rewrite(ibuf, dyn_len);\n    }\n    if (is_asl) {\n        MemBuffer ptload1;  // FIXME.  file_image has the whole file; ibuf is available\n        lowmem.alloc(xct_off);\n        fi->seek(0, SEEK_SET);\n        fi->read(lowmem, xct_off);  // contains relocation tables\n        if (dt_relsz && dt_rel) {\n            Elf32_Rel *const rel0 = (Elf32_Rel *)lowmem.subref(\n                \"bad Rel offset\", dt_rel, dt_relsz);\n            unRel32(dt_rel, rel0, dt_relsz, ptload1, old_dtinit, fo);\n        }\n        if (dt_pltrelsz && dt_jmprel) { // FIXME:  overlap w/ DT_REL ?\n            Elf32_Rel *const jmp0 = (Elf32_Rel *)lowmem.subref(\n                \"bad Jmprel offset\", dt_jmprel, dt_pltrelsz);\n            jump_slots.alloc(n_plt * sizeof(upx_uint32_t));\n            Elf32_Phdr const *phdr = phdri;\n            for (unsigned j = 0; j < e_phnum; ++j, ++phdr) if (is_LOAD(phdr)) {\n                upx_uint32_t vaddr = get_te32(&phdr->p_vaddr);\n                upx_uint32_t filesz = get_te32(&phdr->p_filesz);\n                upx_uint32_t d = plt_va - vaddr;\n                if (d < filesz) {\n                    upx_uint32_t offset = get_te32(&phdr->p_offset);\n                    fi->seek(d + offset, SEEK_SET);\n                    fi->readx(jump_slots, n_plt * sizeof(upx_uint32_t));\n                    break;\n                }\n            }\n            unRel32(dt_jmprel, jmp0, dt_pltrelsz, ptload1, old_dtinit, fo);\n\n            Elf32_Ehdr const *const o_ehdr = (Elf32_Ehdr const *)(void *)lowmem;\n            unsigned const o_phnum = o_ehdr->e_phnum;\n            if (((1<<16) - sizeof(Elf32_Ehdr)) / sizeof(Elf32_Phdr) < o_phnum)\n                throwCantUnpack(\"bad Ehdr.e_phnum %#x\", o_phnum);\n            phdr = phdro;\n            for (unsigned j = 0; j < o_phnum; ++j, ++phdr) if (is_LOAD(phdr)) {\n                upx_uint32_t vaddr = get_te32(&phdr->p_vaddr);\n                upx_uint32_t filesz = get_te32(&phdr->p_filesz);\n                upx_uint32_t d = plt_va - vaddr - asl_delta;\n                if (d < filesz) {\n                    upx_uint32_t offset = get_te32(&phdr->p_offset);\n                    if ((upx_uint32_t)file_size <= offset)\n                        throwCantUnpack(\"bad phdr[%d].p_offset %#zx\", j, (size_t)offset);\n                    if (fo) {\n                        fo->seek(d + offset, SEEK_SET);\n                        fo->rewrite(jump_slots, n_plt * sizeof(upx_uint32_t));\n                    }\n                    break;\n                }\n            }\n        }\n        // Modified relocation tables are re-written by unRel32\n    }\n}\n\nvoid PackLinuxElf64::un_DT_INIT(\n    unsigned old_dtinit,\n    Elf64_Phdr const *const phdro,\n    Elf64_Phdr const *const dynhdr,  // in phdri\n    OutputFile *fo\n)\n{\n    // DT_INIT must be restored.\n    // If android_shlib, then the asl_delta relocations must be un-done.\n    unsigned n_plt = 0;\n    upx_uint64_t dt_pltrelsz(0), dt_jmprel(0), dt_pltgot(0);\n    upx_uint64_t dt_relasz(0), dt_rela(0);\n    upx_uint64_t const dyn_len = get_te64(&dynhdr->p_filesz);\n    upx_uint64_t const dyn_off = get_te64(&dynhdr->p_offset);\n    if (file_size_u < (dyn_len + dyn_off)) {\n        char msg[50]; snprintf(msg, sizeof(msg),\n                \"bad PT_DYNAMIC .p_filesz %#lx\", (long unsigned)dyn_len);\n        throwCantUnpack(msg);\n    }\n    fi->seek(dyn_off, SEEK_SET);\n    fi->readx(ibuf, dyn_len);\n    Elf64_Dyn *dyn = (Elf64_Dyn *)(void *)ibuf;\n    dynseg = dyn; invert_pt_dynamic(dynseg,\n        umin(dyn_len, file_size_u - dyn_off));\n    for (unsigned j2= 0; j2 < dyn_len; ++dyn, j2 += sizeof(*dyn)) {\n        upx_uint64_t const tag = get_te64(&dyn->d_tag);\n        upx_uint64_t       val = get_te64(&dyn->d_val);\n        if (is_asl) switch (tag) {\n        case Elf64_Dyn::DT_RELASZ:   { dt_relasz   = val; } break;\n        case Elf64_Dyn::DT_RELA:     { dt_rela     = val; } break;\n        case Elf64_Dyn::DT_JMPREL:   { dt_jmprel   = val; } break;\n        case Elf64_Dyn::DT_PLTRELSZ: { dt_pltrelsz = val;\n            n_plt = dt_pltrelsz / sizeof(Elf32_Rel);\n            if (is_asl) {\n                n_plt += 3;  // FIXME\n            }\n        };  break;\n\n        case Elf64_Dyn::DT_PLTGOT:   { plt_va = dt_pltgot = val; (void)dt_pltgot;}\n        // FALL THROUGH\n        case Elf64_Dyn::DT_PREINIT_ARRAY:\n        case Elf64_Dyn::DT_INIT_ARRAY:\n        case Elf64_Dyn::DT_FINI_ARRAY:\n        case Elf64_Dyn::DT_FINI: if (is_asl) {\n            set_te64(&dyn->d_val, val - asl_delta);\n        }; break;\n        } // end switch() on tag when is_asl\n        if (upx_dt_init == tag) { // the easy case\n            if (Elf64_Dyn::DT_INIT == tag) {\n                set_te64(&dyn->d_val, old_dtinit);\n                if (!old_dtinit) { // compressor took the slot\n                    dyn->d_tag = Elf64_Dyn::DT_NULL;\n                    dyn->d_val = 0;\n                }\n            }\n            // Apparently the hard case is common for some Android IDEs.\n            // No DT_INIT; only DT_INIT_ARRAY.\n            else if (Elf64_Dyn::DT_INIT_ARRAY    == tag\n            ||       Elf64_Dyn::DT_PREINIT_ARRAY == tag) {\n                // 'val' is the RVA of the first slot, which is the slot that\n                // the compressor changed to be the entry to the run-time stub.\n                Elf64_Dyn *dyn_null = elf_find_dynptr(Elf64_Dyn::DT_NULL);\n                if (!dyn_null)\n                    throwCantUnpack(\"bad PT_DYNAMIC .end\");\n                Elf64_Rela *rp = (Elf64_Rela *)elf_find_dynamic(dyn_null->d_val);\n                dyn_null->d_val = 0;\n                if (rp) {\n                    // Compressor saved the original *rp in dynsym[0]\n                    Elf64_Rela *rp_unc = (Elf64_Rela *)&dynsym[0];  // pointer\n                    rp->r_info = rp_unc->r_info;  // restore original r_info; r_offset not touched\n                    rp->r_addend = rp_unc->r_addend;\n\n                    unsigned arr_rva = get_te64(&rp_unc->r_offset);\n                    Elf64_Phdr const *phdr = elf_find_Phdr_for_va(arr_rva, phdro, e_phnum);\n                    unsigned arr_off = (arr_rva - get_te64(&phdr->p_vaddr)) + get_te64(&phdr->p_offset);\n\n                    if (fo)  {\n                        memset(rp_unc, 0, sizeof(*rp_unc));\n                        fo->seek(elf_unsigned_dynamic(Elf64_Dyn::DT_SYMTAB), SEEK_SET);\n                        fo->rewrite(rp_unc, sizeof(Elf64_Rela));  // clear dynsym[0]\n\n                        fo->seek((char *)rp - (char *)&file_image[0], SEEK_SET);\n                        fo->rewrite(rp, sizeof(*rp));  // restore original *rp\n\n                        // Elf64_Rela overwrites; but put back original.\n                        fo->seek(arr_off, SEEK_SET);\n                        fo->rewrite(rp_unc, sizeof(u64_t));\n\n                        fo->seek(0, SEEK_END);\n                    }\n                }\n            }\n        }\n    }\n    if (fo) { // Write updated dt_*.val\n        upx_uint64_t dyn_offo = get_te64(&phdro[dynhdr - phdri].p_offset);\n        fo->seek(dyn_offo, SEEK_SET);\n        fo->rewrite(ibuf, dyn_len);\n    }\n    if (is_asl) {\n        lowmem.alloc(xct_off);\n        fi->seek(0, SEEK_SET);\n        fi->read(lowmem, xct_off);  // contains relocation tables\n        if (dt_relasz && dt_rela) {\n            Elf64_Rela *const rela0 = (Elf64_Rela *)lowmem.subref(\n                \"bad Rela offset\", dt_rela, dt_relasz);\n            unRela64(dt_rela, rela0, dt_relasz, old_dtinit, fo);\n        }\n        if (dt_pltrelsz && dt_jmprel) { // FIXME:  overlap w/ DT_REL ?\n            Elf64_Rela *const jmp0 = (Elf64_Rela *)lowmem.subref(\n                \"bad Jmprel offset\", dt_jmprel, dt_pltrelsz);\n            jump_slots.alloc(n_plt * sizeof(upx_uint64_t));\n            Elf64_Phdr const *phdr = phdri;\n            for (unsigned j = 0; j < e_phnum; ++j, ++phdr) if (is_LOAD(phdr)) {\n                upx_uint64_t vaddr = get_te64(&phdr->p_vaddr);\n                upx_uint64_t filesz = get_te64(&phdr->p_filesz);\n                upx_uint64_t d = plt_va - vaddr;\n                if (d < filesz) {\n                    upx_uint64_t offset = get_te64(&phdr->p_offset);\n                    fi->seek(d + offset, SEEK_SET);\n                    fi->readx(jump_slots, n_plt * sizeof(upx_uint64_t));\n                    break;\n                }\n            }\n            unRela64(dt_jmprel, jmp0, dt_pltrelsz, old_dtinit, fo);\n\n            Elf64_Ehdr const *const o_ehdr = (Elf64_Ehdr const *)(void *)lowmem;\n            unsigned const o_phnum = o_ehdr->e_phnum;\n            if (((1<<16) - sizeof(Elf64_Ehdr)) / sizeof(Elf64_Phdr) < o_phnum)\n                throwCantUnpack(\"bad Ehdr.e_phnum %#x\", o_phnum);\n            phdr = phdro;\n            for (unsigned j = 0; j < o_phnum; ++j, ++phdr) if (is_LOAD(phdr)) {\n                upx_uint64_t vaddr = get_te64(&phdr->p_vaddr);\n                upx_uint64_t filesz = get_te64(&phdr->p_filesz);\n                upx_uint64_t d = plt_va - vaddr - asl_delta;\n                if (d < filesz) {\n                    upx_uint64_t offset = get_te64(&phdr->p_offset);\n                    if ((upx_uint64_t)file_size <= offset)\n                        throwCantUnpack(\"bad phdr[%d].p_offset %#zx\", j, (size_t)offset);\n                    if (fo) {\n                        fo->seek(d + offset, SEEK_SET);\n                        fo->rewrite(jump_slots, n_plt * sizeof(upx_uint64_t));\n                    }\n                    break;\n                }\n            }\n        }\n        // Modified relocation tables are re-written by unRela64\n    }\n}\n\nvoid PackLinuxElf64::unpack(OutputFile *fo)\n{\n    if (e_phoff != sizeof(Elf64_Ehdr)) {// Phdrs not contiguous with Ehdr\n        throwCantUnpack(\"bad e_phoff\");\n    }\n    unsigned const c_phnum = get_te16(&ehdri.e_phnum);\n    unsigned u_phnum = 0;\n    upx_uint64_t old_dtinit = 0;\n\n    if (Elf64_Ehdr::ET_EXEC == get_te16(&ehdri.e_type)) {\n// 40fddf17153ee3db73a04ff1bf288b91676138d6 2001-02-01 ph.version 11; b_info 12 bytes\n// df9db96bd1c013c07da1d7ec740021d588ab2815 2001-01-17 ph.version 11; no b_info (==> 8 bytes)\n        if (ph.version <= 11\n        &&  get_te64(&ehdri.e_entry) < 0x401180\n        &&  get_te16(&ehdri.e_machine)==Elf64_Ehdr::EM_X86_64) {\n            // old style, 8-byte b_info:\n            // sizeof(b_info.sz_unc) + sizeof(b_info.sz_cpr);\n            szb_info = 2*sizeof(unsigned);\n        }\n    }\n\n    fi->seek(overlay_offset - sizeof(l_info), SEEK_SET);\n    fi->readx(&linfo, sizeof(linfo));\n    if (UPX_MAGIC_LE32 != get_le32(&linfo.l_magic)) {\n        NE32 const *const lp = (NE32 const *)(void const *)&linfo;\n        // Workaround for bug of extra linfo by some asl_pack2_Shdrs().\n        if (0==lp[0] && 0==lp[1] && 0==lp[2]) { // looks like blank extra\n            fi->readx(&linfo, sizeof(linfo));\n            if (UPX_MAGIC_LE32 == get_le32(&linfo.l_magic)) {\n                overlay_offset += sizeof(linfo);\n            }\n            else {\n                throwCantUnpack(\"l_info corrupted\");\n            }\n        }\n        else {\n            throwCantUnpack(\"l_info corrupted\");\n        }\n    }\n    lsize = get_te16(&linfo.l_lsize);\n    p_info hbuf;  fi->readx(&hbuf, sizeof(hbuf));\n    unsigned orig_file_size = get_te32(&hbuf.p_filesize);\n    blocksize = get_te32(&hbuf.p_blocksize);\n    if ((u32_t)file_size > orig_file_size || blocksize > orig_file_size\n        || (orig_file_size >> 8) > (u32_t)file_size  // heuristic anti-fuzz\n        ||      (blocksize >> 8) > (u32_t)file_size\n        || !mem_size_valid(1, blocksize, OVERHEAD))\n        throwCantUnpack(\"p_info corrupted\");\n\n    ibuf.alloc(blocksize + OVERHEAD);\n    b_info bhdr; memset(&bhdr, 0, sizeof(bhdr));\n    fi->readx(&bhdr, szb_info);\n    ph.u_len = get_te32(&bhdr.sz_unc);\n    ph.c_len = get_te32(&bhdr.sz_cpr);\n    ph.set_method(bhdr.b_method, overlay_offset + sizeof(p_info));\n    if (ph.c_len > file_size_u || ph.c_len == 0 || ph.u_len == 0\n    ||  ph.u_len > orig_file_size)\n        throwCantUnpack(\"b_info corrupted\");\n    ph.filter_cto = bhdr.b_cto8;\n    prev_method = bhdr.b_method;  // FIXME if multiple de-compressors\n\n    MemBuffer u(ph.u_len);\n    Elf64_Ehdr *const ehdr = (Elf64_Ehdr *)&u[0];\n    Elf64_Phdr const *phdr = nullptr;\n    total_in = 0;\n    total_out = 0;\n    unsigned c_adler = upx_adler32(nullptr, 0);\n    unsigned u_adler = upx_adler32(nullptr, 0);\n\n    unsigned is_shlib = 0;\n    loader_offset = 0;\n    MemBuffer o_elfhdrs;\n    Elf64_Phdr const *const dynhdr = elf_find_ptype(Elf64_Phdr::PT_DYNAMIC, phdri, c_phnum);\n    // dynseg was set by PackLinuxElf64help1\n    if (dynhdr && !(Elf64_Dyn::DF_1_PIE & elf_unsigned_dynamic(Elf64_Dyn::DT_FLAGS_1))) {\n        // Packed shlib? (ET_DYN without -fPIE)\n        is_shlib = 1;\n        xct_off = overlay_offset - sizeof(l_info);\n        u_phnum = get_te16(&ehdri.e_phnum);\n        o_elfhdrs.alloc(sz_elf_hdrs);\n        un_shlib_1(fo, o_elfhdrs, c_adler, u_adler, orig_file_size);\n        *ehdr = ehdri;\n    }\n    else { // main executable\n        // Uncompress Ehdr and Phdrs: info for control of unpacking\n        if (ibuf.getSize() < ph.c_len)\n            throwCompressedDataViolation();\n\n        fi->readx(ibuf, ph.c_len);\n        // \"clickhouse\" ET_EXEC for amd64 has 0x200000 <= .e_entry\n        // instead of 0x400000 that we checked earlier.\n        if (8 == szb_info\n        &&  Elf64_Ehdr::EM_X86_64 == e_machine\n        &&  Elf64_Ehdr::ET_EXEC   == e_type\n        &&  ph.u_len <= MAX_ELF_HDR_64\n        ) {\n            unsigned b_method = ibuf[0];\n            unsigned b_extra  = ibuf[3];\n            if (M_ZSTD >= b_method && 0 == b_extra) {\n                unsigned where = fi->seek( -(upx_off_t)(ph.c_len + szb_info), SEEK_CUR);\n                szb_info = 12;\n                fi->readx(&bhdr, szb_info);\n                ph.filter_cto = bhdr.b_cto8;\n                ph.set_method(bhdr.b_method, where);\n                prev_method = bhdr.b_method;  // FIXME if multiple de-compressors\n                fi->readx(ibuf, ph.c_len);\n            }\n        }\n        if (ph.u_len < sizeof(*ehdr))\n            throwCantUnpack(\"ElfXX_Ehdr corrupted\");\n        decompress(ibuf, (upx_byte *)ehdr, false);\n        if (ehdr->e_type   !=ehdri.e_type\n        ||  ehdr->e_machine!=ehdri.e_machine\n        ||  ehdr->e_version!=ehdri.e_version\n            // less strict for EM_PPC64 to workaround earlier bug\n        ||  !( ehdr->e_flags==ehdri.e_flags\n            || Elf64_Ehdr::EM_PPC64 == get_te16(&ehdri.e_machine))\n        ||  ehdr->e_ehsize !=ehdri.e_ehsize\n            // check EI_MAG[0-3], EI_CLASS, EI_DATA, EI_VERSION\n        ||  memcmp(ehdr->e_ident, ehdri.e_ident, Elf64_Ehdr::EI_OSABI)) {\n            throwCantUnpack(\"ElfXX_Ehdr corrupted\");\n        }\n        // Rewind: prepare for data phase\n        fi->seek(- (off_t) (szb_info + ph.c_len), SEEK_CUR);\n\n        u_phnum = get_te16(&ehdr->e_phnum);\n        if ((umin(MAX_ELF_HDR_64, ph.u_len) - sizeof(Elf64_Ehdr))/sizeof(Elf64_Phdr) < u_phnum) {\n            throwCantUnpack(\"bad compressed e_phnum\");\n        }\n        o_elfhdrs.alloc(sizeof(Elf64_Ehdr) + u_phnum * sizeof(Elf64_Phdr));\n        memcpy(o_elfhdrs, ehdr, o_elfhdrs.getSize());\n\n        // Decompress each PT_LOAD.\n        bool first_PF_X = true;\n        phdr = (Elf64_Phdr *) (void *) (1+ ehdr);  // uncompressed\n        for (unsigned j=0; j < u_phnum; ++phdr, ++j) {\n            if (is_LOAD(phdr)) {\n                unsigned const filesz = get_te64(&phdr->p_filesz);\n                unsigned const offset = get_te64(&phdr->p_offset);\n                if (fo) {\n                    fo->seek(offset, SEEK_SET);\n                    if (total_out < offset) {\n                        total_out = offset;  // FIXME: can it be re-write?\n                    }\n                }\n                if (Elf64_Phdr::PF_X & get_te32(&phdr->p_flags)) {\n                    unpackExtent(filesz, fo,\n                        c_adler, u_adler, first_PF_X);\n                    first_PF_X = false;\n                }\n                else {\n                    unpackExtent(filesz, fo,\n                        c_adler, u_adler, false);\n                }\n            }\n        }\n    }\n\n    upx_uint64_t const e_entry = get_te64(&ehdri.e_entry);\n    unsigned off_entry = 0;\n    phdr = phdri;\n    load_va = 0;\n    for (unsigned j=0; j < c_phnum; ++j, ++phdr) {\n        if (is_LOAD(phdr)) {\n            upx_uint64_t offset = get_te64(&phdr->p_offset);\n            upx_uint64_t vaddr  = get_te64(&phdr->p_vaddr);\n            upx_uint64_t filesz = get_te64(&phdr->p_filesz);\n            if (!load_va) {\n                load_va = vaddr;\n            }\n            if ((e_entry - vaddr) < filesz) {\n                off_entry = (e_entry - vaddr) + offset;\n                break;\n            }\n        }\n    }\n    unsigned d_info[6];\n    unsigned sz_d_info = sizeof(d_info);\n    if (!is_shlib) {\n        if (get_te32(&phdri[0].p_flags) & Elf64_Phdr::PF_X) {\n            // Old style, such as upx-3.91 thru upx-3.95\n            switch (this->e_machine) {\n                default: {\n                    char msg[40]; snprintf(msg, sizeof(msg),\n                        \"Unknown architecture %d\", this->e_machine);\n                    throwCantUnpack(msg);\n                }; break;\n                case Elf64_Ehdr::EM_AARCH64: sz_d_info = 4 * sizeof(unsigned); break;\n                case Elf64_Ehdr::EM_PPC64:   sz_d_info = 3 * sizeof(unsigned); break;\n                case Elf64_Ehdr::EM_X86_64:  sz_d_info = 2 * sizeof(unsigned); break;\n            }\n        }\n        loader_offset = off_entry - sz_d_info;\n    }\n\n    if (0x1000==get_te64(&phdri[0].p_filesz)  // detect C_BASE style\n    &&  0==get_te64(&phdri[1].p_offset)\n    &&  0==get_te64(&phdri[0].p_offset)\n    &&     get_te64(&phdri[1].p_filesz) == get_te64(&phdri[1].p_memsz)) {\n        fi->seek(up4(get_te64(&phdri[1].p_memsz)), SEEK_SET);  // past the loader\n    }\n    else if (is_shlib\n    ||  (off_entry + up4(lsize) + ph.getPackHeaderSize() + sizeof(overlay_offset))\n            < up4(file_size)) {\n        // Loader is not at end; skip past it.\n        if (loader_offset) {\n            fi->seek(loader_offset, SEEK_SET);\n        }\n        else {\n            funpad4(fi);  // MATCH01\n        }\n        fi->readx(d_info, sz_d_info);\n        if (is_shlib && 0==old_dtinit) {\n            old_dtinit = get_te32(&d_info[2 + (0==d_info[0])]);\n            is_asl = 1u& get_te32(&d_info[0 + (0==d_info[0])]);\n        }\n        fi->seek(lsize - sz_d_info, SEEK_CUR);\n    }\n\n    // The gaps between PT_LOAD and after last PT_LOAD\n    phdr = (Elf64_Phdr const *)(1+ (Elf64_Ehdr const *)(void const *)o_elfhdrs);\n    upx_uint64_t hi_offset(0);\n    for (unsigned j = 0; j < u_phnum; ++j) {\n        upx_uint64_t const offset = get_te64(&phdr[j].p_offset);\n        if (is_LOAD(&phdr[j])\n        &&  hi_offset < offset) {\n            hi_offset = offset;\n        }\n    }\n    for (unsigned j = 0; j < u_phnum; ++j) {\n        unsigned const size = find_LOAD_gap(phdr, j, u_phnum);\n        if (size) {\n            unsigned const where = get_te64(&phdr[j].p_offset) +\n                                   get_te64(&phdr[j].p_filesz);\n            if (fo)\n                fo->seek(where, SEEK_SET);\n            { // Recover from some piracy [also serves as error tolerance :-) ]\n              // Getting past the loader is problematic, due to unintended\n              // variances between released versions:\n              //   l_info.l_lsize might be rounded up by 8 instead of by 4, and\n              //   sz_d_info might have changed.\n                b_info b_peek, *bp = &b_peek;\n                fi->readx(bp, sizeof(b_peek));\n                upx_off_t pos = fi->seek(-(off_t)sizeof(b_peek), SEEK_CUR);\n                unsigned sz_unc = get_te32(&bp->sz_unc);\n                unsigned sz_cpr = get_te32(&bp->sz_cpr);\n                unsigned word3  = get_te32(&bp->b_method);\n                unsigned method = bp->b_method;\n                unsigned ftid = bp->b_ftid;\n                unsigned cto8 = bp->b_cto8;\n                if (!( ((sz_cpr == sz_unc) && (0 == word3) && (size == sz_unc)) // incompressible literal\n                    || ((sz_cpr <  sz_unc)\n                        && (method == prev_method || M_NRV2B_LE32 == prev_method)\n                        && (0 == ftid) && (0 == cto8)) )\n                ) {\n                    opt->info_mode++;\n                    infoWarning(\"bad b_info at %#zx\", (size_t)pos);\n                    unsigned const N_PEEK(16 * sizeof(int)), H_PEEK(N_PEEK >> 1);\n                    unsigned char peek_arr[N_PEEK];\n                    fi->seek(pos - H_PEEK, SEEK_SET);\n                    fi->readx(peek_arr, sizeof(peek_arr));\n                    fi->seek(pos, SEEK_SET);\n                    bool const is_be = ELFDATA2MSB == ehdri.e_ident[EI_DATA];\n                    if (is_be) {\n                        // Does the right thing for sz_unc and sz_cpr,\n                        // but swaps b_method and b_extra.  Need find_be32() :-)\n                        for (unsigned k = 0; k < N_PEEK; k += sizeof(int)) {\n                            set_le32(&peek_arr[k], get_be32(&peek_arr[k]));\n                        }\n                    }\n                    int boff = find_le32(peek_arr, sizeof(peek_arr), size);\n                    if (boff < 0\n                    || sizeof(peek_arr) < (boff + sizeof(b_info))) {\n                        throwCantUnpack(\"b_info corrupted\");\n                    }\n                    bp = (b_info *)(void *)&peek_arr[boff];\n\n                    sz_unc = get_le32(&bp->sz_unc);\n                    sz_cpr = get_le32(&bp->sz_cpr);\n                    word3  = get_le32(&bp->b_method);\n                    ftid = bp->b_ftid;\n                    cto8 = bp->b_cto8;\n                    if (0 <= boff  // found\n                    && ( ((sz_cpr == sz_unc) && (0 == word3) && (size == sz_unc)) // incompressible literal\n                      || ((sz_cpr <  sz_unc) && (0 == ftid) && (0 == cto8)\n                          && ((is_be ? bp->b_extra : bp->b_method) == prev_method)) )\n                    ) {\n                        pos -= H_PEEK;\n                        pos += boff;\n                        infoWarning(\"... recovery at %#zx\", (size_t)pos);\n                        fi->seek(pos, SEEK_SET);\n                    }\n                    opt->info_mode--;\n                }\n            }\n            unpackExtent(size, fo,\n                c_adler, u_adler, false,\n                (hi_offset != get_te64(&phdr[j].p_offset)));\n        }\n    }\n\n    // check for end-of-file\n    fi->readx(&bhdr, szb_info);\n    ph.set_method(bhdr.b_method, ~0u);\n    unsigned const sz_unc = ph.u_len = get_te32(&bhdr.sz_unc);\n\n    if (sz_unc == 0) { // uncompressed size 0 -> EOF\n        // note: magic is always stored le32\n        unsigned const sz_cpr = get_le32(&bhdr.sz_cpr);\n        if (sz_cpr != UPX_MAGIC_LE32)  // sz_cpr must be h->magic\n            throwCompressedDataViolation();\n    }\n    else { // extra bytes after end?\n        throwCompressedDataViolation();\n    }\n\n    if (is_shlib) {\n        un_DT_INIT(old_dtinit, (Elf64_Phdr *)(1+ (Elf64_Ehdr *)(void *)o_elfhdrs), dynhdr, fo);\n    }\n\n    // update header with totals\n    ph.c_len = total_in;\n    ph.u_len = total_out;\n\n    // all bytes must be written\n    if (fo && total_out != orig_file_size)\n        throwEOFException();\n\n    // finally test the checksums\n    if (ph.c_adler != c_adler || ph.u_adler != u_adler)\n        throwChecksumError();\n}\n\n\n/*************************************************************************\n//\n**************************************************************************/\n\nPackLinuxElf32x86::PackLinuxElf32x86(InputFile *f) : super(f)\n{\n    e_machine = Elf32_Ehdr::EM_386;\n    ei_class  = Elf32_Ehdr::ELFCLASS32;\n    ei_data   = Elf32_Ehdr::ELFDATA2LSB;\n    ei_osabi  = Elf32_Ehdr::ELFOSABI_LINUX;\n}\n\nPackLinuxElf32x86::~PackLinuxElf32x86()\n{\n}\n\ntribool PackLinuxElf32x86::canUnpack() // bool, except -1: format known, but not packed\n{\n    if (super::canUnpack()) {\n        return true;\n    }\n    return false;\n}\n\nLinker* PackLinuxElf32x86::newLinker() const\n{\n    return new ElfLinkerX86;\n}\n\nPackBSDElf32x86::PackBSDElf32x86(InputFile *f) : super(f)\n{\n    e_machine = Elf32_Ehdr::EM_386;\n    ei_class  = Elf32_Ehdr::ELFCLASS32;\n    ei_data   = Elf32_Ehdr::ELFDATA2LSB;\n}\n\nPackBSDElf32x86::~PackBSDElf32x86()\n{\n}\n\nPackFreeBSDElf32x86::PackFreeBSDElf32x86(InputFile *f) : super(f)\n{\n    ei_osabi  = Elf32_Ehdr::ELFOSABI_FREEBSD;\n}\n\nPackFreeBSDElf32x86::~PackFreeBSDElf32x86()\n{\n}\n\nPackNetBSDElf32x86::PackNetBSDElf32x86(InputFile *f) : super(f)\n{\n    ei_osabi  = Elf32_Ehdr::ELFOSABI_NETBSD;\n    osabi_note = \"NetBSD\";\n}\n\nPackNetBSDElf32x86::~PackNetBSDElf32x86()\n{\n}\n\nPackOpenBSDElf32x86::PackOpenBSDElf32x86(InputFile *f) : super(f)\n{\n    ei_osabi  = Elf32_Ehdr::ELFOSABI_OPENBSD;\n    osabi_note = \"OpenBSD\";\n}\n\nPackOpenBSDElf32x86::~PackOpenBSDElf32x86()\n{\n}\n\nint const *\nPackLinuxElf32x86::getFilters() const\n{\n    static const int filters[] = {\n        // 0x49 is 5-byte CALL or JMP, and 6-byte Jxx\n        // 0x46 is 5-byte CALL or JMP\n        0x49, 0x46,\n// FIXME 2002-11-11: We use stub/fold_elf86.asm, which calls the\n// decompressor multiple times, and unfilter is independent of decompress.\n// Currently only filters 0x49, 0x46, 0x80..0x87 can handle this;\n// and 0x80..0x87 are regarded as \"untested\".\n#if 0\n        0x26, 0x24, 0x11, 0x14, 0x13, 0x16, 0x25, 0x15, 0x12,\n#endif\n#if 0\n        0x83, 0x36, 0x26,\n              0x86, 0x80,\n        0x84, 0x87, 0x81,\n        0x82, 0x85,\n        0x24, 0x16, 0x13, 0x14, 0x11, 0x25, 0x15, 0x12,\n#endif\n    FT_END };\n    return filters;\n}\n\nPackLinuxElf32armLe::PackLinuxElf32armLe(InputFile *f) : super(f)\n{\n    e_machine = Elf32_Ehdr::EM_ARM;\n    ei_class  = Elf32_Ehdr::ELFCLASS32;\n    ei_data   = Elf32_Ehdr::ELFDATA2LSB;\n    ei_osabi  = Elf32_Ehdr::ELFOSABI_ARM;\n}\n\nPackLinuxElf32armLe::~PackLinuxElf32armLe()\n{\n}\n\nPackLinuxElf32mipseb::PackLinuxElf32mipseb(InputFile *f) : super(f)\n{\n    e_machine = Elf32_Ehdr::EM_MIPS;\n    ei_class  = Elf32_Ehdr::ELFCLASS32;\n    ei_data   = Elf32_Ehdr::ELFDATA2MSB;\n    ei_osabi  = Elf32_Ehdr::ELFOSABI_LINUX;\n}\n\nPackLinuxElf32mipseb::~PackLinuxElf32mipseb()\n{\n}\n\nPackLinuxElf32mipsel::PackLinuxElf32mipsel(InputFile *f) : super(f)\n{\n    e_machine = Elf32_Ehdr::EM_MIPS;\n    ei_class  = Elf32_Ehdr::ELFCLASS32;\n    ei_data   = Elf32_Ehdr::ELFDATA2LSB;\n    ei_osabi  = Elf32_Ehdr::ELFOSABI_LINUX;\n}\n\nPackLinuxElf32mipsel::~PackLinuxElf32mipsel()\n{\n}\n\nLinker* PackLinuxElf32armLe::newLinker() const\n{\n    return new ElfLinkerArmLE();\n}\n\nLinker* PackLinuxElf32mipseb::newLinker() const\n{\n    return new ElfLinkerMipsBE();\n}\n\nLinker* PackLinuxElf32mipsel::newLinker() const\n{\n    return new ElfLinkerMipsLE();\n}\n\nPackLinuxElf32armBe::PackLinuxElf32armBe(InputFile *f) : super(f)\n{\n    e_machine = Elf32_Ehdr::EM_ARM;\n    ei_class  = Elf32_Ehdr::ELFCLASS32;\n    ei_data   = Elf32_Ehdr::ELFDATA2MSB;\n    ei_osabi  = Elf32_Ehdr::ELFOSABI_ARM;\n}\n\nPackLinuxElf32armBe::~PackLinuxElf32armBe()\n{\n}\n\nLinker* PackLinuxElf32armBe::newLinker() const\n{\n    return new ElfLinkerArmBE();\n}\n\nunsigned\nPackLinuxElf32::elf_get_offset_from_address(unsigned addr) const\n{\n    return elf_get_offset_from_Phdrs(addr, phdri);\n}\n\nunsigned\nPackLinuxElf32::elf_get_offset_from_Phdrs(unsigned addr, Elf32_Phdr const *phdr0) const\n{\n    Elf32_Phdr const *phdr = phdr0;\n    int j = e_phnum;\n    for (; --j>=0; ++phdr) if (is_LOAD(phdr)) {\n        unsigned const t = addr - get_te32(&phdr->p_vaddr);\n        if (t < get_te32(&phdr->p_filesz)) {\n            unsigned const p_offset = get_te32(&phdr->p_offset);\n            if (file_size_u <= p_offset) { // FIXME: weak\n                char msg[40]; snprintf(msg, sizeof(msg),\n                    \"bad Elf32_Phdr[%d].p_offset %x\",\n                    -1+ e_phnum - j, p_offset);\n                throwCantPack(msg);\n            }\n            return t + p_offset;\n        }\n    }\n    return 0;\n}\n\nu32_t  // returns .p_offset\nPackLinuxElf32::check_pt_load(Elf32_Phdr const *const phdr)\n{\n    u32_t filesz = get_te32(&phdr->p_filesz);\n    u32_t offset = get_te32(&phdr->p_offset), offend = filesz + offset;\n    u32_t vaddr  = get_te32(&phdr->p_vaddr);\n    u32_t paddr  = get_te32(&phdr->p_paddr);\n    u32_t align  = get_te32(&phdr->p_align);\n\n    if ((-1+ align) & (paddr ^ vaddr)\n    ||  file_size_u32 <= (u32_t)offset\n    ||  file_size_u32 <  (u32_t)offend\n    ||  file_size_u32 <  (u32_t)filesz) {\n        char msg[50]; snprintf(msg, sizeof(msg), \"bad PT_LOAD phdr[%u]\",\n            (unsigned)(phdr - phdri));\n        throwCantPack(msg);\n    }\n    return offset;\n}\n\nElf32_Dyn const *\nPackLinuxElf32::elf_has_dynamic(unsigned int key) const\n{\n    Elf32_Dyn const *dynp= dynseg;\n    if (dynp)\n    for (; Elf32_Dyn::DT_NULL!=dynp->d_tag; ++dynp) if (get_te32(&dynp->d_tag)==key) {\n        return dynp;\n    }\n    return nullptr;\n}\n\nunsigned  // checked .p_offset; sz_dynseg set\nPackLinuxElf32::check_pt_dynamic(Elf32_Phdr const *const phdr)\n{\n    unsigned t = get_te32(&phdr->p_offset), s = sizeof(Elf32_Dyn) + t;\n    unsigned vaddr = get_te32(&phdr->p_vaddr);\n    unsigned filesz = get_te32(&phdr->p_filesz), memsz = get_te32(&phdr->p_memsz);\n    unsigned align = get_te32(&phdr->p_align);\n    if (file_size_u < t || s < t\n    ||  file_size_u < filesz\n    ||  file_size_u < (filesz + t)\n    ||  t < (e_phnum*sizeof(Elf32_Phdr) + sizeof(Elf32_Ehdr))\n    ||  (3 & t) || (7 & (filesz | memsz))  // .balign 4; 8==sizeof(Elf32_Dyn)\n    ||  (-1+ align) & (t ^ vaddr)\n    ||  file_size_u <= memsz\n    ||  filesz < sizeof(Elf32_Dyn)\n    ||  memsz  < sizeof(Elf32_Dyn)\n    ||  filesz < memsz) {\n        char msg[50]; snprintf(msg, sizeof(msg), \"bad PT_DYNAMIC phdr[%u]\",\n            (unsigned)(phdr - phdri));\n        throwCantPack(msg);\n    }\n    sz_dynseg = memsz;\n    return t;\n}\n\nElf32_Dyn *PackLinuxElf32::elf_find_dynptr(unsigned int key) const\n{\n    Elf32_Dyn *dynp= dynseg;\n    if (dynp) {\n        Elf32_Dyn *const last = (Elf32_Dyn *)(sz_dynseg + (char *)dynseg);\n        for (; dynp < last; ++dynp) {\n            if (get_te32(&dynp->d_tag)==key) {\n                return dynp;\n            }\n            if (Elf32_Dyn::DT_NULL == dynp->d_tag) {\n                return nullptr;\n            }\n        }\n    }\n    return nullptr;\n}\n\nElf64_Dyn *PackLinuxElf64::elf_find_dynptr(unsigned int key) const\n{\n    Elf64_Dyn *dynp= dynseg;\n    if (dynp) {\n        Elf64_Dyn *const last = (Elf64_Dyn *)(sz_dynseg + (char *)dynseg);\n        for (; dynp < last; ++dynp) {\n            if (get_te64(&dynp->d_tag)==key) {\n                return dynp;\n            }\n            if (Elf64_Dyn::DT_NULL == dynp->d_tag) {\n                return nullptr;\n            }\n        }\n    }\n    return nullptr;\n}\n\nvoid *\nPackLinuxElf32::elf_find_dynamic(unsigned int key) const\n{\n    Elf32_Dyn const *dynp= elf_find_dynptr(key);\n    if (dynp) {\n        unsigned const t= elf_get_offset_from_address(get_te32(&dynp->d_val));\n        if (t && t < file_size_u) {\n            return t + file_image;\n        }\n    }\n    return nullptr;\n}\n\nvoid *\nPackLinuxElf64::elf_find_dynamic(unsigned int key) const\n{\n    Elf64_Dyn const *dynp= elf_find_dynptr(key);\n    if (dynp) {\n        upx_uint64_t const t= elf_get_offset_from_address(get_te64(&dynp->d_val));\n        if (t && t < file_size_u) {\n            return t + file_image;\n        }\n    }\n    return nullptr;\n}\n\nupx_uint64_t\nPackLinuxElf64::elf_unsigned_dynamic(unsigned int key) const\n{\n    Elf64_Dyn const *dynp= elf_find_dynptr(key);\n    if (dynp) {\n        return get_te64(&dynp->d_val);\n    }\n    return 0;\n}\n\nupx_uint64_t\nPackLinuxElf32::elf_unsigned_dynamic(unsigned int key) const\n{\n    Elf32_Dyn const *dynp= elf_find_dynptr(key);\n    if (dynp) {\n        return get_te32(&dynp->d_val);\n    }\n    return 0;\n}\n\nupx_uint64_t\nPackLinuxElf64::elf_get_offset_from_address(upx_uint64_t addr) const\n{\n    Elf64_Phdr const *phdr = phdri;\n    int j = e_phnum;\n    for (; --j>=0; ++phdr) if (is_LOAD(phdr)) {\n        upx_uint64_t const t = addr - get_te64(&phdr->p_vaddr);\n        if (t < get_te64(&phdr->p_filesz)) {\n            upx_uint64_t const p_offset = get_te64(&phdr->p_offset);\n            if (file_size_u <= p_offset) { // FIXME: weak\n                char msg[40]; snprintf(msg, sizeof(msg),\n                    \"bad Elf64_Phdr[%d].p_offset %#lx\",\n                    -1+ e_phnum - j, (long unsigned)p_offset);\n                throwCantPack(msg);\n            }\n            return t + p_offset;\n        }\n    }\n    return 0;\n}\n\nu64_t  // returns .p_offset\nPackLinuxElf64::check_pt_load(Elf64_Phdr const *const phdr)\n{\n    u64_t filesz = get_te64(&phdr->p_filesz);\n    u64_t offset = get_te64(&phdr->p_offset), offend = filesz + offset;\n    u64_t vaddr  = get_te64(&phdr->p_vaddr);\n    u64_t paddr  = get_te64(&phdr->p_paddr);\n    u64_t align  = get_te64(&phdr->p_align);\n\n    if ((-1+ align) & (paddr ^ vaddr)\n    ||  file_size_u <= (u64_t)offset\n    ||  file_size_u <  (u64_t)offend\n    ||  file_size_u <  (u64_t)filesz) {\n        char msg[50]; snprintf(msg, sizeof(msg), \"bad PT_LOAD phdr[%u]\",\n            (unsigned)(phdr - phdri));\n        throwCantPack(msg);\n    }\n    return offset;\n}\n\nElf64_Dyn const *\nPackLinuxElf64::elf_has_dynamic(unsigned int key) const\n{\n    Elf64_Dyn const *dynp= dynseg;\n    if (dynp)\n    for (; Elf64_Dyn::DT_NULL!=dynp->d_tag; ++dynp) if (get_te64(&dynp->d_tag)==key) {\n        return dynp;\n    }\n    return nullptr;\n}\n\nupx_uint64_t  // checked .p_offset; sz_dynseg set\nPackLinuxElf64::check_pt_dynamic(Elf64_Phdr const *const phdr)\n{\n    upx_uint64_t t = get_te64(&phdr->p_offset), s = sizeof(Elf64_Dyn) + t;\n    upx_uint64_t vaddr = get_te64(&phdr->p_vaddr);\n    upx_uint64_t filesz = get_te64(&phdr->p_filesz), memsz = get_te64(&phdr->p_memsz);\n    upx_uint64_t align = get_te64(&phdr->p_align);\n    if (file_size_u < t || s < t\n    ||  file_size_u < filesz\n    ||  file_size_u < (filesz + t)\n    ||  t < (e_phnum*sizeof(Elf64_Phdr) + sizeof(Elf64_Ehdr))\n    ||  (7 & t) || (0xf & (filesz | memsz))  // .balign 8; 16==sizeof(Elf64_Dyn)\n    ||  (-1+ align) & (t ^ vaddr)\n    ||  file_size_u <= memsz\n    ||  filesz < sizeof(Elf64_Dyn)\n    ||  memsz  < sizeof(Elf64_Dyn)\n    ||  filesz < memsz) {\n        char msg[50]; snprintf(msg, sizeof(msg), \"bad PT_DYNAMIC phdr[%u]\",\n            (unsigned)(phdr - phdri));\n        throwCantPack(msg);\n    }\n    sz_dynseg = memsz;\n    return t;\n}\n\nvoid\nPackLinuxElf64::sort_DT64_offsets(Elf64_Dyn const *const dynp0)\n{\n    mb_dt_offsets.alloc(sizeof(unsigned) * sizeof(dt_keys)/sizeof(dt_keys[0]));\n    mb_dt_offsets.clear();\n    dt_offsets = (unsigned *)mb_dt_offsets.getVoidPtr();\n    unsigned n_off = 0, k;\n    for (unsigned j=0; ((k = dt_keys[j]),  k); ++j) {\n        dt_offsets[n_off] = 0;  // default to \"not found\"\n        u64_t rva = 0;\n        if (k < DT_NUM) { // in range of easy table\n            if (!dt_table[k]) {\n                continue;\n            }\n            rva = get_te64(&dynp0[-1+ dt_table[k]].d_val);\n        }\n        else if (file_image) { // why is this guard necessary?\n            rva = elf_unsigned_dynamic(k);  // zero if not found\n        }\n        if (!rva) { // not present in input\n            continue;\n        }\n        Elf64_Phdr const *const phdr = elf_find_Phdr_for_va(rva, phdri, e_phnum);\n        if (!phdr) {\n            char msg[60]; snprintf(msg, sizeof(msg), \"bad DT_{%#x} = %#llx (no Phdr)\",\n                k, rva);\n            throwCantPack(msg);\n        }\n        dt_offsets[n_off] = (rva - get_te64(&phdr->p_vaddr)) + get_te64(&phdr->p_offset);\n\n        if (file_size <= dt_offsets[n_off]) {\n            char msg[60]; snprintf(msg, sizeof(msg), \"bad DT_{%#x} = %#x (beyond EOF)\",\n                k, dt_offsets[n_off]);\n                throwCantPack(msg);\n        }\n        n_off += !!dt_offsets[n_off];\n    }\n    dt_offsets[n_off++] = file_size;  // sentinel\n    upx_qsort(dt_offsets, n_off, sizeof(dt_offsets[0]), qcmp_unsigned);\n}\n\nunsigned PackLinuxElf64::find_dt_ndx(u64_t rva)\n{\n    unsigned *const dto = (unsigned *)mb_dt_offsets.getVoidPtr();\n    unsigned const dto_size = mb_dt_offsets.getSize() / sizeof(*dto);\n    for (unsigned j = 0; j < dto_size && dto[j]; ++j) { // linear search of short table\n        if (rva == dto[j]) {\n            return j;\n        }\n    }\n    return ~0u;\n}\n\nunsigned PackLinuxElf64::elf_find_table_size(unsigned dt_type, unsigned sh_type)\n{\n    Elf64_Shdr const *sec = elf_find_section_type(sh_type);\n    if (sec) { // Cheat the easy way: use _Shdr.  (No _Shdr anyway for de-compression)\n        return get_te64(&sec->sh_size);\n    }\n    // Honest hard work: use _Phdr\n    unsigned x_rva;\n    if (dt_type < DT_NUM) {\n        unsigned const x_ndx = dt_table[dt_type];\n        if (!x_ndx) { // no such entry\n            return 0;\n        }\n        x_rva = get_te64(&dynseg[-1+ x_ndx].d_val);\n    }\n    else {\n        x_rva = elf_unsigned_dynamic(dt_type);\n    }\n    Elf64_Phdr const *const x_phdr = elf_find_Phdr_for_va(x_rva, phdri, e_phnum);\n    if (!x_phdr)\n        return ~0u;  // corrupted Phdrs?\n    unsigned const           d_off =             x_rva - get_te64(&x_phdr->p_vaddr);\n    unsigned const           y_ndx = find_dt_ndx(d_off + get_te64(&x_phdr->p_offset));\n    if (~0u != y_ndx) {\n        return dt_offsets[1+ y_ndx] - dt_offsets[y_ndx];\n    }\n    return ~0u;\n}\n\nvoid\nPackLinuxElf64::invert_pt_dynamic(Elf64_Dyn const *dynp, upx_uint64_t headway)\n{\n    if (dt_table[Elf64_Dyn::DT_NULL]) {\n        return;  // not 1st time; do not change upx_dt_init\n    }\n    Elf64_Dyn const *const dynp0 = dynp;\n    unsigned ndx = 0;\n    unsigned const limit = headway / sizeof(*dynp);\n    if (dynp)\n    for (; ; ++ndx, ++dynp) {\n        if (limit <= ndx) {\n            throwCantPack(\"DT_NULL not found\");\n        }\n        upx_uint64_t const d_tag = get_te64(&dynp->d_tag);\n        if (d_tag>>32) { // outrageous\n            throwCantPack(\"bad Elf64_Dyn[%d].d_tag %#lx\",\n                ndx, (long unsigned)d_tag);\n        }\n        if (d_tag < DT_NUM) {\n            if (Elf64_Dyn::DT_NEEDED != d_tag\n            &&  dt_table[d_tag]\n            &&    get_te64(&dynp->d_val)\n               != get_te64(&dynp0[-1+ dt_table[d_tag]].d_val)) {\n                throwCantPack(\"duplicate DT_%#x: [%#x] [%#x]\",\n                    (unsigned)d_tag, -1+ dt_table[d_tag], ndx);\n            }\n            dt_table[d_tag] = 1+ ndx;\n        }\n        if (Elf64_Dyn::DT_NULL == d_tag) {\n            break;  // check here so that dt_table[DT_NULL] is set\n        }\n    }\n    sort_DT64_offsets(dynp0);\n\n    upx_dt_init = 0;\n         if (dt_table[Elf64_Dyn::DT_INIT])          upx_dt_init = Elf64_Dyn::DT_INIT;\n    else if (dt_table[Elf64_Dyn::DT_PREINIT_ARRAY]) upx_dt_init = Elf64_Dyn::DT_PREINIT_ARRAY;\n    else if (dt_table[Elf64_Dyn::DT_INIT_ARRAY])    upx_dt_init = Elf64_Dyn::DT_INIT_ARRAY;\n\n    unsigned const z_str = dt_table[Elf64_Dyn::DT_STRSZ];\n    strtab_max = !z_str ? 0 : get_te64(&dynp0[-1+ z_str].d_val);\n    unsigned const z_tab = dt_table[Elf64_Dyn::DT_STRTAB];\n    unsigned const tmp1 = !z_tab ? 0 : get_te64(&dynp0[-1+ z_tab].d_val);\n    if (tmp1 < sz_elf_hdrs) {\n        throwCantPack(\"bad DT_STRTAB %#x\", tmp1);\n    }\n    unsigned const strtab_beg = !z_tab ? 0 : elf_get_offset_from_address(tmp1);\n\n    if (!z_str || !z_tab || !(strtab_max + strtab_beg)\n    || (this->file_size - strtab_beg) < strtab_max  // strtab overlaps EOF\n        // last string in table must have terminating NUL\n    ||  '\\0' != ((char *)file_image.getVoidPtr())[-1+ strtab_max + strtab_beg]\n    ) {\n        throwCantPack(\"bad DT_STRSZ %#x\", strtab_max);\n    }\n\n    { // Find end of DT_SYMTAB\n        unsigned const tmp2 = elf_find_table_size(Elf64_Dyn::DT_SYMTAB,\n            Elf64_Shdr::SHT_DYNSYM);\n        symnum_max = (~0u == tmp2) ? 0 : tmp2 / sizeof(Elf64_Sym);\n    }\n\n    unsigned v_sym = dt_table[Elf64_Dyn::DT_SYMTAB];\n    if (v_sym) {\n        v_sym = elf_get_offset_from_address(get_te64(&dynp0[-1+ v_sym].d_val));\n    }\n\n    unsigned v_hsh = dt_table[Elf64_Dyn::DT_HASH];\n    if (v_hsh) {\n        v_hsh = elf_get_offset_from_address(get_te64(&dynp0[-1+ v_hsh].d_val));\n    }\n    if (v_hsh && file_image) {\n        hashtab = (unsigned const *)elf_find_dynamic(Elf64_Dyn::DT_HASH);\n        if (!hashtab) {\n            throwCantPack(\"bad DT_HASH %#x\", v_hsh);\n        }\n        // Find end of DT_HASH\n        hashend = (unsigned const *)(void const *)(elf_find_table_size(\n            Elf64_Dyn::DT_HASH, Elf64_Shdr::SHT_HASH) + (char const *)hashtab);\n        if (!hashtab || (char const *)hashend <= (char const *)&hashtab[2]\n        ||  file_image.getSizeInBytes()\n            < (unsigned)((char const *)&hashtab[2] - (char *)&file_image[0]) )\n        {\n            throwCantPack(\"bad DT_HASH %#x\", v_hsh);\n        }\n\n        unsigned const nbucket = get_te32(&hashtab[0]);\n        unsigned const *const buckets = &hashtab[2];\n        unsigned const *const chains = &buckets[nbucket]; (void)chains;\n        if ((unsigned)(file_size - ((char const *)buckets - (char const *)(void const *)file_image))\n                <= sizeof(unsigned)*nbucket ) {\n            throwCantPack(\"bad nbucket %#x\\n\", nbucket);\n        }\n\n        if ((unsigned)(hashend - buckets) < nbucket\n        || !v_sym || file_size_u <= v_sym\n        || ((v_hsh < v_sym) && (v_sym - v_hsh) < sizeof(*buckets)*(2+ nbucket))\n        ) {\n            throwCantPack(\"bad DT_HASH nbucket=%#x  len=%#x\",\n                nbucket, (v_sym - v_hsh));\n        }\n        unsigned chmax = 0;\n        for (unsigned j= 0; j < nbucket; ++j) {\n            unsigned x = get_te32(&buckets[j]);\n            if (chmax < x) {\n                chmax = x;\n            }\n        }\n        if ((v_hsh < v_sym) && (v_sym - v_hsh) <\n                (sizeof(*buckets)*(2+ nbucket) + sizeof(*chains)*(1+ chmax))) {\n            throwCantPack(\"bad DT_HASH nbucket=%#x  len=%#x\",\n                nbucket, (v_sym - v_hsh));\n        }\n    }\n    unsigned const v_gsh = elf_unsigned_dynamic(Elf64_Dyn::DT_GNU_HASH);\n    if (v_gsh && file_image) {\n        // Not similar to DT_HASH because DT_GNU_HASH is not small (0x6ffffef5).\n        gashtab = (unsigned const *)elf_find_dynamic(Elf64_Dyn::DT_GNU_HASH);\n        gashend = (unsigned const *)(void const *)(elf_find_table_size(\n            Elf64_Dyn::DT_GNU_HASH, Elf64_Shdr::SHT_GNU_HASH) + (char const *)gashtab);\n        if (!gashtab || (char const *)gashend <= (char const *)&gashtab[4]\n        ||  file_image.getSizeInBytes()\n            < (unsigned)((char const *)&gashtab[4] - (char *)&file_image[0]) )\n        {\n            throwCantPack(\"bad DT_GNU_HASH %#x\", v_gsh);\n        }\n\n        unsigned const n_bucket = get_te32(&gashtab[0]);\n        unsigned const symbias  = get_te32(&gashtab[1]);\n        unsigned const n_bitmask = get_te32(&gashtab[2]);\n        unsigned const gnu_shift = get_te32(&gashtab[3]);\n        upx_uint64_t const *const bitmask = (upx_uint64_t const *)(void const *)&gashtab[4];\n        unsigned     const *const buckets = (unsigned const *)&bitmask[n_bitmask];\n        unsigned     const *const hasharr = &buckets[n_bucket]; (void)hasharr;\n        if (!n_bucket || (1u<<31) <= n_bucket  /* fie on fuzzers */\n        || (unsigned)(gashend - buckets) < n_bucket\n        || (file_size + file_image) <= (void const *)hasharr) {\n            throwCantPack(\"bad n_bucket %#x\\n\", n_bucket);\n        }\n        // It would be better to detect zeroes shifted into low 6 bits of:\n        //    (077 & (hash_32 >> gnu_shift))\n        // but compilers can be stupid.\n        if (31 < gnu_shift) {\n            throwCantPack(\"bad gnu_shift %#x\", gnu_shift);\n        }\n        // unsigned const *const gashend = &hasharr[n_bucket];\n        // minimum, except:\n        // Rust and Android trim unused zeroes from high end of hasharr[]\n        unsigned bmax = 0;\n        for (unsigned j= 0; j < n_bucket; ++j) {\n            unsigned bj = get_te32(&buckets[j]);\n            if (bj) {\n                if (bj < symbias) {\n                    throwCantPack(\"bad DT_GNU_HASH bucket[%d] < symbias{%#x}\\n\",\n                            bj, symbias);\n                }\n                if (bmax < bj) {\n                    bmax = bj;\n                }\n            }\n        }\n        if (1==n_bucket  && 0==buckets[0]\n        &&  1==n_bitmask && 0==bitmask[0]) {\n            // 2021-09-11 Rust on RaspberryPi apparently uses this to minimize space.\n            // But then the DT_GNU_HASH symbol lookup algorithm always fails?\n            // https://github.com/upx/upx/issues/525\n        } else\n        if (bmax) {\n            if ((1+ bmax) < symbias) {\n                throwCantPack(\"bad DT_GNU_HASH (1+ max_bucket)=%#x < symbias=%#x\",\n                    1+ bmax, symbias);\n            }\n            bmax -= symbias;\n        }\n\n        unsigned r = 0;\n        if (!n_bucket || !n_bitmask || !v_sym\n        || (r=1, ((-1+ n_bitmask) & n_bitmask))  // not a power of 2\n        || (r=2, (8*sizeof(upx_uint64_t) <= gnu_shift))  // shifted result always == 0\n        || (r=3, (n_bucket>>30))  // fie on fuzzers\n        || (r=4, (n_bitmask>>30))\n        || (r=5, ((file_size/sizeof(unsigned))\n                <= ((sizeof(*bitmask)/sizeof(unsigned))*n_bitmask + 2*n_bucket)))  // FIXME: weak\n        || (r=6, ((v_gsh < v_sym) && (v_sym - v_gsh) < (sizeof(unsigned)*4  // headers\n                + sizeof(*bitmask)*n_bitmask  // bitmask\n                + sizeof(*buckets)*n_bucket  // buckets\n                + sizeof(*hasharr)*(!bmax ? 0 : (1+ bmax))  // hasharr\n            )) )\n        ) {\n            throwCantPack(\"bad DT_GNU_HASH n_bucket=%#x  n_bitmask=%#x  len=%#lx  r=%d\",\n                n_bucket, n_bitmask, (long unsigned)(v_sym - v_gsh), r);\n        }\n    }\n    e_shstrndx = get_te16(&ehdri.e_shstrndx);  // who omitted this?\n    if (e_shnum <= e_shstrndx\n    &&  !(0==e_shnum && 0==e_shstrndx) ) {\n        throwCantPack(\"bad .e_shstrndx %d >= .e_shnum %d\", e_shstrndx, e_shnum);\n    }\n}\n\nunsigned PackLinuxElf::gnu_hash(char const *q)\n{\n    unsigned char const *p = (unsigned char const *)q;\n    unsigned h;\n\n    for (h= 5381; 0!=*p; ++p) {\n        h += *p + (h << 5);\n    }\n    return h;\n}\n\nunsigned PackLinuxElf::elf_hash(char const *p)\n{\n    unsigned h;\n    for (h= 0; 0!=*p; ++p) {\n        h = *p + (h<<4);\n        {\n            unsigned const t = 0xf0000000u & h;\n            h &= ~t;\n            h ^= t>>24;\n        }\n    }\n    return h;\n}\n\nElf32_Sym const *PackLinuxElf32::elf_lookup(char const *name) const\n{\n    if (hashtab && dynsym && dynstr) {\n        unsigned const n_bucket = get_te32(&hashtab[0]);\n        unsigned const *const buckets = &hashtab[2];\n        unsigned const *const chains = &buckets[n_bucket];\n        // Find the end of DT_HASH and DT_DYNSYM. Perhaps elf_find_table_size()\n        // depends on too many valid input values?\n        void const *l_hash = nullptr, *l_sym = nullptr;\n        for (unsigned j = 0; j < DT_NUM; ++j) {\n            void const *const ptr = dt_offsets[j] + (char const *)file_image.getVoidPtr();\n            if (!l_hash && hashtab == ptr) {\n                l_hash = dt_offsets[1+ j] + (char const *)file_image.getVoidPtr();\n            }\n            if (!l_sym && dynsym == ptr) {\n                l_sym = dt_offsets[1+ j] + (char const *)file_image.getVoidPtr();\n            }\n            if (l_sym && l_hash)\n                break;  // found both\n            if (this->file_size == (off_t)dt_offsets[j])\n                break;  // end sentinel\n        }\n        if (n_bucket) {\n            void const *EOM = file_size + (char const *)file_image.getVoidPtr();\n            unsigned const m = elf_hash(name) % n_bucket;\n            unsigned n_visit = 0;\n            unsigned si;\n            if (l_hash <= &buckets[m])\n                throwCantPack(\"bad DT_HASH %u\", m);\n            for (si= get_te32(&buckets[m]); si; si = get_te32(&chains[si])) {\n                if (l_sym <= &dynsym[si])\n                    throwCantPack(\"bad DT_HASH chain %d\\n\", si);\n                char const *const p= get_dynsym_name(si, (unsigned)-1);\n                if (p && 0==strcmp(name, p))\n                    return &dynsym[si];\n                if (l_sym <= &dynsym[n_visit++])\n                    throwCantPack(\"circular DT_HASH chain %d\\n\", si);\n                // Detect next si out-of-bounds\n                if ((unsigned)((unsigned int const *)EOM - chains) <= si)\n                    throwCantPack(\"bad DT_HASH chain %d\\n\", si);\n            }\n        }\n    }\n    if (gashtab && dynsym && dynstr) {\n        unsigned const n_bucket = get_te32(&gashtab[0]);\n        unsigned const symbias  = get_te32(&gashtab[1]);\n        unsigned const n_bitmask = get_te32(&gashtab[2]);\n        unsigned const gnu_shift = get_te32(&gashtab[3]);\n        unsigned const *const bitmask = &gashtab[4];\n        unsigned const *const buckets = &bitmask[n_bitmask];\n        unsigned const *const hasharr = &buckets[n_bucket];\n        if (31 < gnu_shift) {\n            throwCantPack(\"bad gnu_shift %#x\", gnu_shift);\n        }\n        if ((file_size + file_image) <= (void const *)hasharr) {\n            throwCantPack(\"bad n_bucket %#x\\n\", n_bucket);\n        }\n        if (!n_bitmask\n        || (unsigned)(file_size - ((char const *)bitmask - (char const *)(void const *)file_image))\n                <= sizeof(unsigned)*n_bitmask ) {\n            throwCantPack(\"bad n_bitmask %#x\\n\", n_bitmask);\n        }\n        if (n_bucket) { // -rust-musl can have \"empty\" hashtab\n            unsigned const h = gnu_hash(name);\n            unsigned const hbit1 = 037& h;\n            unsigned const hbit2 = 037& (h>>gnu_shift);\n            unsigned const w = get_te32(&bitmask[(n_bitmask -1) & (h>>5)]);\n\n            if (1& (w>>hbit1) & (w>>hbit2)) {\n                unsigned const hhead = get_te32(&buckets[h % n_bucket]);\n                if (symnum_max <= hhead || (hhead && hhead < symbias)) {\n                    throwCantPack(\"bad DT_GNU_HASH symnum_max{%#x} <= buckets[%d]{%#x} < symbias{%#x}\\n\",\n                            symnum_max, h % n_bucket, hhead, symbias);\n                }\n                if (hhead) {\n                    Elf32_Sym const *dsp = &dynsym[hhead];\n                    unsigned const *hp = &hasharr[hhead - symbias];\n                    unsigned k;\n                    do {\n                        if (gashend <= hp) {\n                            throwCantPack(\"bad DT_GNU_HASH[%#x]  head=%u\",\n                                (unsigned)(hp - hasharr), hhead);\n                        }\n                        k = get_te32(hp);\n                        if (0==((h ^ k)>>1)) {\n                            unsigned const st_name = get_te32(&dsp->st_name);\n                            char const *const p = get_str_name(st_name, (unsigned)-1);\n                            if (0==strcmp(name, p)) {\n                                return dsp;\n                            }\n                        }\n                    } while (++dsp, ++hp, 0==(1u& k));\n                }\n            }\n        }\n    }\n    // 2021-12-25  FIXME: Some Rust programs use\n    //    (1==n_bucket && 0==buckets[0] && 1==n_bitmask && 0==bitmask[0])\n    // to minimize space in DT_GNU_HASH. This causes the fancy lookup to fail.\n    // Is a fallback to linear search assumed?\n    // 2022-03-12  Some Rust programs have 0==n_bucket.\n    return nullptr;\n\n}\n\nElf64_Sym const *PackLinuxElf64::elf_lookup(char const *name) const\n{\n    if (hashtab && dynsym && dynstr) {\n        unsigned const n_bucket = get_te32(&hashtab[0]);\n        unsigned const *const buckets = &hashtab[2];\n        unsigned const *const chains = &buckets[n_bucket];\n        // Find the end of DT_HASH and DT_DYNSYM. Perhaps elf_find_table_size()\n        // depends on too many valid input values?\n        void const *l_hash = nullptr, *l_sym = nullptr;\n        for (unsigned j = 0; j < DT_NUM; ++j) {\n            void const *const ptr = dt_offsets[j] + (char const *)file_image.getVoidPtr();\n            if (!l_hash && hashtab == ptr) {\n                l_hash = dt_offsets[1+ j] + (char const *)file_image.getVoidPtr();\n            }\n            if (!l_sym && dynsym == ptr) {\n                l_sym = dt_offsets[1+ j] + (char const *)file_image.getVoidPtr();\n            }\n            if (l_sym && l_hash)\n                break;  // found both\n            if (this->file_size == (off_t)dt_offsets[j])\n                break;  //end\n        }\n        if (n_bucket) { // -rust-musl can have \"empty\" hashtab\n            void const *const EOM = file_size + (char const *)file_image.getVoidPtr();\n            unsigned const m = elf_hash(name) % n_bucket;\n            unsigned n_visit = 0;\n            unsigned si;\n            if (l_hash <= &buckets[m])\n                throwCantPack(\"bad DT_HASH %u\", m);\n            for (si= get_te32(&buckets[m]); si; si = get_te32(&chains[si])) {\n                if (l_sym <= &dynsym[si])\n                    throwCantPack(\"bad DT_HASH chain %d\\n\", si);\n                char const *const p= get_dynsym_name(si, (unsigned)-1);\n                if (p && 0==strcmp(name, p))\n                    return &dynsym[si];\n                if (l_sym <= &dynsym[n_visit++])\n                    throwCantPack(\"circular DT_HASH chain %d\\n\", si);\n                // Detect next si out-of-bounds\n                if ((unsigned)((unsigned int const *)EOM - chains) <= si)\n                    throwCantPack(\"bad DT_HASH chain %d\\n\", si);\n            }\n        }\n    }\n    if (gashtab && dynsym && dynstr) {\n        unsigned const n_bucket = get_te32(&gashtab[0]);\n        unsigned const symbias  = get_te32(&gashtab[1]);\n        unsigned const n_bitmask = get_te32(&gashtab[2]);\n        unsigned const gnu_shift = get_te32(&gashtab[3]);\n        upx_uint64_t const *const bitmask = (upx_uint64_t const *)(void const *)&gashtab[4];\n        unsigned     const *const buckets = (unsigned const *)&bitmask[n_bitmask];\n        unsigned     const *const hasharr = &buckets[n_bucket];\n\n        if (31 < gnu_shift) {\n            throwCantPack(\"bad gnu_shift %#x\", gnu_shift);\n        }\n        if ((file_size + file_image) <= (void const *)hasharr) {\n            throwCantPack(\"bad n_bucket %#x\\n\", n_bucket);\n        }\n        if (!n_bitmask\n        || (unsigned)(file_size - ((char const *)bitmask - (char const *)(void const *)file_image))\n                <= sizeof(unsigned)*n_bitmask ) {\n            throwCantPack(\"bad n_bitmask %#x\\n\", n_bitmask);\n        }\n        if (n_bucket) { // -rust-musl can have \"empty\" gashtab\n            unsigned const h = gnu_hash(name);\n            unsigned const hbit1 = 077& h;\n            unsigned const hbit2 = 077& (h>>gnu_shift);\n            upx_uint64_t const w = get_te64(&bitmask[(n_bitmask -1) & (h>>6)]);\n            if (1& (w>>hbit1) & (w>>hbit2)) {\n                unsigned hhead = get_te32(&buckets[h % n_bucket]);\n                if (symnum_max <= hhead || (hhead && hhead < symbias)) {\n                    throwCantPack(\"bad DT_GNU_HASH symnum_max{%#x} <= buckets[%d]{%#x} < symbias{%#x}\\n\",\n                            symnum_max, h % n_bucket, hhead, symbias);\n                }\n                if (hhead) {\n                    Elf64_Sym const *dsp = &dynsym[hhead];\n                    unsigned const *hp = &hasharr[hhead - symbias];\n                    unsigned k;\n                    do {\n                        if (gashend <= hp) {\n                            throwCantPack(\"bad gnu_hash[%#tx]  head=%u\",\n                                hp - hasharr, hhead);\n                        }\n                        k = get_te32(hp);\n                        if (0==((h ^ k)>>1)) {\n                            unsigned const st_name = get_te32(&dsp->st_name);\n                            char const *const p = get_str_name(st_name, (unsigned)-1);\n                            if (0==strcmp(name, p)) {\n                                return dsp;\n                            }\n                        }\n                    } while (++dsp, ++hp, 0==(1u& k));\n                }\n            }\n        }\n    }\n    // 2021-12-25  FIXME: Some Rust programs use\n    //    (1==n_bucket && 0==buckets[0] && 1==n_bitmask && 0==bitmask[0])\n    // to minimize space in DT_GNU_HASH. This causes the fancy lookup to fail.\n    // Is a fallback to linear search assumed?\n    // 2022-03-12  Some Rust programs have 0==n_bucket.\n    return nullptr;\n\n}\n\nvoid PackLinuxElf32::unpack(OutputFile *fo)\n{\n    if (e_phoff != sizeof(Elf32_Ehdr)) {// Phdrs not contiguous with Ehdr\n        throwCantUnpack(\"bad e_phoff\");\n    }\n    unsigned const c_phnum = get_te16(&ehdri.e_phnum);\n    unsigned u_phnum = 0;\n    upx_uint32_t old_dtinit = 0;\n\n    if (Elf32_Ehdr::ET_EXEC == get_te16(&ehdri.e_type)) {\n// 40fddf17153ee3db73a04ff1bf288b91676138d6 2001-02-01 ph.version 11; b_info 12 bytes\n// df9db96bd1c013c07da1d7ec740021d588ab2815 2001-01-17 ph.version 11; no b_info (==> 8 bytes)\n        if (ph.version <= 11\n        &&  get_te32(&ehdri.e_entry) < 0x401180\n        &&  get_te16(&ehdri.e_machine)==Elf32_Ehdr::EM_386) {\n            // old style, 8-byte b_info:\n            // sizeof(b_info.sz_unc) + sizeof(b_info.sz_cpr);\n            szb_info = 2*sizeof(unsigned);\n        }\n    }\n\n    fi->seek(overlay_offset - sizeof(l_info), SEEK_SET);\n    fi->readx(&linfo, sizeof(linfo));\n    if (UPX_MAGIC_LE32 != get_le32(&linfo.l_magic)) {\n        NE32 const *const lp = (NE32 const *)(void const *)&linfo;\n        // Workaround for bug of extra linfo by some asl_pack2_Shdrs().\n        if (0==lp[0] && 0==lp[1] && 0==lp[2]) { // looks like blank extra\n            fi->readx(&linfo, sizeof(linfo));\n            if (UPX_MAGIC_LE32 == get_le32(&linfo.l_magic)) {\n                overlay_offset += sizeof(linfo);\n            }\n            else {\n                throwCantUnpack(\"l_info corrupted\");\n            }\n        }\n        else {\n            throwCantUnpack(\"l_info corrupted\");\n        }\n    }\n    lsize = get_te16(&linfo.l_lsize);\n    p_info hbuf;  fi->readx(&hbuf, sizeof(hbuf));\n    unsigned orig_file_size = get_te32(&hbuf.p_filesize);\n    blocksize = get_te32(&hbuf.p_blocksize);\n    if ((u32_t)file_size > orig_file_size || blocksize > orig_file_size\n        || (orig_file_size >> 8) > (u32_t)file_size  // heuristic anti-fuzz\n        ||      (blocksize >> 8) > (u32_t)file_size\n        || !mem_size_valid(1, blocksize, OVERHEAD))\n        throwCantUnpack(\"p_info corrupted\");\n\n    ibuf.alloc(blocksize + OVERHEAD);\n    b_info bhdr; memset(&bhdr, 0, sizeof(bhdr));\n    fi->readx(&bhdr, szb_info);\n    ph.u_len = get_te32(&bhdr.sz_unc);\n    ph.c_len = get_te32(&bhdr.sz_cpr);\n    ph.set_method(bhdr.b_method, overlay_offset + sizeof(p_info));\n    if (ph.c_len > (unsigned)file_size || ph.c_len == 0 || ph.u_len == 0\n    ||  ph.u_len > orig_file_size)\n        throwCantUnpack(\"b_info corrupted\");\n    ph.filter_cto = bhdr.b_cto8;\n    prev_method = bhdr.b_method;  // FIXME if multiple de-compressors\n\n    MemBuffer u(ph.u_len);\n    Elf32_Ehdr *const ehdr = (Elf32_Ehdr *)&u[0];\n    Elf32_Phdr const *phdr = nullptr;\n    total_in = 0;\n    total_out = 0;\n    unsigned c_adler = upx_adler32(nullptr, 0);\n    unsigned u_adler = upx_adler32(nullptr, 0);\n\n    unsigned is_shlib = 0;\n    loader_offset = 0;\n    MemBuffer o_elfhdrs;\n    Elf32_Phdr const *const dynhdr = elf_find_ptype(Elf32_Phdr::PT_DYNAMIC, phdri, c_phnum);\n    // dynseg was set by PackLinuxElf32help1\n    if (dynhdr && !(Elf32_Dyn::DF_1_PIE & elf_unsigned_dynamic(Elf32_Dyn::DT_FLAGS_1))) {\n        // Packed shlib? (ET_DYN without -fPIE)\n        is_shlib = 1;\n        xct_off = overlay_offset - sizeof(l_info);\n        u_phnum = get_te16(&ehdri.e_phnum);\n        o_elfhdrs.alloc(sz_elf_hdrs);\n        un_shlib_1(fo, o_elfhdrs, c_adler, u_adler, orig_file_size);\n        *ehdr = ehdri;\n    }\n    else { // main executable\n        // Uncompress Ehdr and Phdrs: info for control of unpacking\n        if (ibuf.getSize() < ph.c_len)\n            throwCompressedDataViolation();\n        fi->readx(ibuf, ph.c_len);\n        if (ph.u_len < sizeof(*ehdr))\n            throwCantUnpack(\"ElfXX_Ehdr corrupted\");\n        decompress(ibuf, (upx_byte *)ehdr, false);\n        if (ehdr->e_type   !=ehdri.e_type\n        ||  ehdr->e_machine!=ehdri.e_machine\n        ||  ehdr->e_version!=ehdri.e_version\n            // less strict for EM_PPC to workaround earlier bug\n        ||  !( ehdr->e_flags==ehdri.e_flags\n            || Elf32_Ehdr::EM_PPC == get_te16(&ehdri.e_machine))\n        ||  ehdr->e_ehsize !=ehdri.e_ehsize\n            // check EI_MAG[0-3], EI_CLASS, EI_DATA, EI_VERSION\n        ||  memcmp(ehdr->e_ident, ehdri.e_ident, Elf32_Ehdr::EI_OSABI)) {\n            throwCantUnpack(\"ElfXX_Ehdr corrupted\");\n        }\n        // Rewind: prepare for data phase\n        fi->seek(- (off_t) (szb_info + ph.c_len), SEEK_CUR);\n\n        u_phnum = get_te16(&ehdr->e_phnum);\n        if ((umin(MAX_ELF_HDR_32, ph.u_len) - sizeof(Elf32_Ehdr))/sizeof(Elf32_Phdr) < u_phnum) {\n            throwCantUnpack(\"bad compressed e_phnum\");\n        }\n        o_elfhdrs.alloc(sizeof(Elf32_Ehdr) + u_phnum * sizeof(Elf32_Phdr));\n        memcpy(o_elfhdrs, ehdr, o_elfhdrs.getSize());\n\n        // Decompress each PT_LOAD.\n        bool first_PF_X = true;\n        phdr = (Elf32_Phdr *) (void *) (1+ ehdr);  // uncompressed\n        for (unsigned j=0; j < u_phnum; ++phdr, ++j) {\n            if (is_LOAD(phdr)) {\n                unsigned const filesz = get_te32(&phdr->p_filesz);\n                unsigned const offset = get_te32(&phdr->p_offset);\n                if (fo) {\n                    fo->seek(offset, SEEK_SET);\n                    if (total_out < offset) {\n                        total_out = offset;  // FIXME: can it be re-write?\n                    }\n                }\n                if (Elf32_Phdr::PF_X & get_te32(&phdr->p_flags)) {\n                    unpackExtent(filesz, fo,\n                        c_adler, u_adler, first_PF_X);\n                    first_PF_X = false;\n                }\n                else {\n                    unpackExtent(filesz, fo,\n                        c_adler, u_adler, false);\n                }\n            }\n        }\n    }\n\n    upx_uint32_t const e_entry = get_te32(&ehdri.e_entry);\n    unsigned off_entry = 0;\n    phdr = phdri;\n    load_va = 0;\n    for (unsigned j=0; j < c_phnum; ++j, ++phdr) {\n        if (is_LOAD(phdr)) {\n            upx_uint32_t offset = get_te32(&phdr->p_offset);\n            upx_uint32_t vaddr  = get_te32(&phdr->p_vaddr);\n            upx_uint32_t filesz = get_te32(&phdr->p_filesz);\n            if (!load_va) {\n                load_va = vaddr;\n            }\n            if ((e_entry - vaddr) < filesz) {\n                off_entry = (e_entry - vaddr) + offset;\n                break;\n            }\n        }\n    }\n    unsigned d_info[6];\n    unsigned sz_d_info = sizeof(d_info);\n    if (!is_shlib) {\n        if (get_te32(&phdri[0].p_flags) & Elf32_Phdr::PF_X) {\n            // Old style, such as upx-3.91 thru upx-3.95\n            switch (this->e_machine) {\n                default: {\n                    char msg[40]; snprintf(msg, sizeof(msg),\n                        \"Unknown architecture %d\", this->e_machine);\n                    throwCantUnpack(msg);\n                }; break;\n      ","size_bytes":360000},"src/p_lx_exc.cpp":{"content":"/* p_lx_exc.cpp --\n\n   This file is part of the Resize executable compressor.\n\n   Copyright (C) 2025 WHO-AM-I-404\n   Based on UPX - Ultimate Packer for eXecutables\n   Copyright (C) 1996-2025 Markus Franz Xaver Johannes Oberhumer\n   Copyright (C) 1996-2025 Laszlo Molnar\n   Copyright (C) 2001-2025 John F. Reiser\n   All Rights Reserved.\n\n   Resize and the UCL library are free software; you can redistribute them\n   and/or modify them under the terms of the GNU General Public License as\n   published by the Free Software Foundation; either version 2 of\n   the License, or (at your option) any later version.\n\n   This program is distributed in the hope that it will be useful,\n   but WITHOUT ANY WARRANTY; without even the implied warranty of\n   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n   GNU General Public License for more details.\n\n   You should have received a copy of the GNU General Public License\n   along with this program; see the file COPYING.\n   If not, write to the Free Software Foundation, Inc.,\n   59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.\n\n   WHO-AM-I-404 <who-am-i-404@proton.me>\n   Based on original work by:\n   Markus F.X.J. Oberhumer <markus@oberhumer.com>\n   Laszlo Molnar <ezerotven+github@gmail.com>\n\n   John F. Reiser\n   <jreiser@users.sourceforge.net>\n */\n\n\n#include \"conf.h\"\n\n#include \"file.h\"\n#include \"filter.h\"\n#include \"linker.h\"\n#include \"packer.h\"\n#include \"p_elf.h\"\n#include \"p_unix.h\"\n#include \"p_lx_exc.h\"\n\n#define PT_LOAD     Elf32_Phdr::PT_LOAD\n#define PT_DYNAMIC  Elf32_Phdr::PT_DYNAMIC\n#if 0 // UNUSED\n#define DT_NULL     Elf32_Dyn::DT_NULL\n#define DT_NEEDED   Elf32_Dyn::DT_NEEDED\n#define DT_STRTAB   Elf32_Dyn::DT_STRTAB\n#define DT_STRSZ    Elf32_Dyn::DT_STRSZ\n#endif\n\n\n/*************************************************************************\n// linux/386 (generic \"execve\" format)\n**************************************************************************/\n\nPackLinuxI386::PackLinuxI386(InputFile *f) : super(f),\n    ei_osabi(Elf32_Ehdr::ELFOSABI_LINUX), osabi_note(nullptr)\n{\n    bele = &N_BELE_RTP::le_policy;\n}\n\nPackBSDI386::PackBSDI386(InputFile *f) : super(f)\n{\n    // Shell scripts need help specifying the target operating system.\n    // Elf input will override this with .e_ident[EI_OSABI] or PT_NOTE.\n    // [2006-09-27: Today's only runtime stub for shell is for linux.]\n    if (Elf32_Ehdr::ELFOSABI_LINUX==opt->o_unix.osabi0) {\n        // Disallow an incompatibility.\n        ei_osabi = Elf32_Ehdr::ELFOSABI_NONE;\n    }\n    else {\n        ei_osabi = opt->o_unix.osabi0;  // might be ELFOSABI_NONE\n    }\n}\n\nstatic const CLANG_FORMAT_DUMMY_STATEMENT\n#include \"stub/i386-linux.elf.execve-entry.h\"\nstatic const CLANG_FORMAT_DUMMY_STATEMENT\n#include \"stub/i386-linux.elf.execve-fold.h\"\n\nstatic const CLANG_FORMAT_DUMMY_STATEMENT\n#include \"stub/i386-bsd.elf.execve-entry.h\"\nstatic const CLANG_FORMAT_DUMMY_STATEMENT\n#include \"stub/i386-bsd.elf.execve-fold.h\"\n\n\nconst int *PackLinuxI386::getCompressionMethods(int method, int level) const\n{\n    return Packer::getDefaultCompressionMethods_le32(method, level);\n}\n\nconst int *PackLinuxI386::getFilters() const\n{\n    static const int filters[] = {\n        0x49, 0x46,\n        0x26, 0x24, 0x11, 0x14, 0x13, 0x16, 0x25, 0x15, 0x12,\n#if 0\n// 0x80..0x87 are regarded as \"untested\".\n        0x83, 0x86, 0x80, 0x84, 0x87, 0x81, 0x82, 0x85,\n        0x24, 0x16, 0x13, 0x14, 0x11, 0x25, 0x15, 0x12,\n#endif\n    FT_END };\n    return filters;\n}\n\nstatic void\nset_stub_brk(Elf_LE32_Phdr *const phdr1, unsigned brka)\n{\n#define PAGE_MASK (~0ul<<12)\n        // linux-2.6.14 binfmt_elf.c: SIGKILL if (0==.p_memsz) on a page boundary\n        unsigned const brkb = brka | ((0==(~PAGE_MASK & brka)) ? 0x20 : 0);\n        phdr1->p_type = PT_LOAD;  // be sure\n        phdr1->p_offset = ~PAGE_MASK & brkb;\n        phdr1->p_vaddr = brkb;\n        phdr1->p_paddr = brkb;\n        phdr1->p_filesz = 0;\n        phdr1->p_memsz =  0;\n        if (0==phdr1->p_flags) {\n            phdr1->p_flags = Elf32_Phdr::PF_R|Elf32_Phdr::PF_W;\n        }\n        if (0==phdr1->p_align) {\n            phdr1->p_align = 0x1000;\n        }\n#undef PAGE_MASK\n}\n\nvoid\nPackLinuxI386::generateElfHdr(\n    OutputFile *fo,\n    void const *proto,\n    unsigned const brka\n)\n{\n    cprElfHdr2 *const h2 = (cprElfHdr2 *)(void *)&elfout;\n    cprElfHdr3 *const h3 = (cprElfHdr3 *)(void *)&elfout;\n    memcpy(h3, proto, sizeof(*h3));  // reads beyond, but OK\n\n    assert(h2->ehdr.e_phoff     == sizeof(Elf32_Ehdr));\n    assert(h2->ehdr.e_shoff     == 0);\n    assert(h2->ehdr.e_ehsize    == sizeof(Elf32_Ehdr));\n    assert(h2->ehdr.e_phentsize == sizeof(Elf32_Phdr));\n    assert(h2->ehdr.e_shnum     == 0);\n\n#if 0  //{\n    unsigned identsize;\n    char const *const ident = getIdentstr(&identsize);\n#endif  //}\n    h2->phdr[0].p_filesz = sizeof(*h2);  // + identsize;\n    h2->phdr[0].p_memsz  = h2->phdr[0].p_filesz;\n\n    // Info for OS kernel to set the brk()\n    if (brka) {\n        set_stub_brk(&h2->phdr[1], brka);\n    }\n\n    if (ph.format==UPX_F_LINUX_i386\n    ||  ph.format==UPX_F_LINUX_SH_i386\n    ||  ph.format==UPX_F_BSD_i386\n    ) {\n        // SELinux, PAx, grSecurity demand no PF_W if PF_X.\n        // kernel-2.6.12-2.3.legacy_FC3 has a bug which demands\n        // a PT_LOAD with PF_W, else SIGSEGV when clearing page fragment\n        // on low page of \".bss\", which is the high page of .text.\n        // So the minimum number of PT_LOAD is 2.\n        assert(h2->ehdr.e_phnum==2);\n        memset(&h2->linfo, 0, sizeof(h2->linfo));\n        fo->write(h2, sizeof(*h2));\n    }\n    else if (ph.format==UPX_F_LINUX_ELFI_i386) {\n        assert(h3->ehdr.e_phnum==3);\n        memset(&h3->linfo, 0, sizeof(h3->linfo));\n        fo->write(h3, sizeof(*h3));\n    }\n    else {\n        assert(false);  // unknown ph.format, PackUnix::generateElfHdr\n    }\n}\n\nvoid\nPackLinuxI386::pack1(OutputFile *fo, Filter &)\n{\n    // create a pseudo-unique program id for our paranoid stub\n    progid = getRandomId();\n\n    generateElfHdr(fo, stub_i386_linux_elf_execve_fold, 0);\n}\n\nvoid\nPackBSDI386::pack1(OutputFile *fo, Filter &)\n{\n    // create a pseudo-unique program id for our paranoid stub\n    progid = getRandomId();\n\n    generateElfHdr(fo, stub_i386_bsd_elf_execve_fold, 0);\n}\n\nvoid\nPackLinuxI386::pack4(OutputFile *fo, Filter &ft)\n{\n    overlay_offset = sizeof(elfout.ehdr) +\n        (elfout.ehdr.e_phentsize * elfout.ehdr.e_phnum) +\n        sizeof(l_info) +\n        ((elfout.ehdr.e_phnum==3) ? (unsigned) elfout.phdr[2].p_memsz : 0) ;\n    unsigned nw = fo->getBytesWritten();\n    elfout.phdr[0].p_filesz = nw;\n    nw = 0u-((0u-elfout.phdr[0].p_align) & (0u-nw));  // ALIGN_UP\n    super::pack4(fo, ft);  // write PackHeader and overlay_offset\n    set_stub_brk(&elfout.phdr[1], nw + elfout.phdr[0].p_vaddr);\n\n#if 0  // {\n    // /usr/bin/strip from RedHat 8.0 (binutils-2.13.90.0.2-2)\n    // generates a 92-byte [only] output, because the \"linking view\"\n    // is empty.  This code supplies a \"linking view\".\n    // However, 'strip' then generates _plausible_ junk that gets\n    // \"Illegal instruction\"  because 'strip' changes p_hdr[1].p_align,\n    // .p_offset, and .p_vaddr incorrectly.  So the \"cure\" is worse than\n    // the disease.  It is obvious that a 92-byte file is bad,\n    // but it is not obvious that the changed .p_align is bad.\n    // Also, having a totally empty \"linking view\" is easier for 'strip'\n    // to fix: just detect that, and do nothing.\n    // So, we don't use this code for now [2003-01-11].\n\n    // Supply a \"linking view\" that covers everything,\n    // so that 'strip' does not omit everything.\n    Elf_LE32_Shdr shdr;\n    // The section header string table.\n    char const shstrtab[] = \"\\0.\\0.shstrtab\";\n\n    unsigned eod = elfout.phdr[0].p_filesz;\n    elfout.ehdr.e_shoff = eod;\n    elfout.ehdr.e_shentsize = sizeof(shdr);\n    elfout.ehdr.e_shnum = 3;\n    elfout.ehdr.e_shstrndx = 2;\n\n    // An empty Elf32_Shdr for space as a null index.\n    memset(&shdr, 0, sizeof(shdr));\n    shdr.sh_type = Elf32_Shdr::SHT_NULL;\n    fo->write(&shdr, sizeof(shdr));\n\n    // Cover all the bits we need at runtime.\n    memset(&shdr, 0, sizeof(shdr));\n    shdr.sh_name = 1;\n    shdr.sh_type = Elf32_Shdr::SHT_PROGBITS;\n    shdr.sh_flags = Elf32_Shdr::SHF_ALLOC;\n    shdr.sh_addr = elfout.phdr[0].p_vaddr;\n    shdr.sh_offset = overlay_offset;\n    shdr.sh_size = eod - overlay_offset;\n    shdr.sh_addralign = 4096;\n    fo->write(&shdr, sizeof(shdr));\n\n    // A section header for the section header string table.\n    memset(&shdr, 0, sizeof(shdr));\n    shdr.sh_name = 3;\n    shdr.sh_type = Elf32_Shdr::SHT_STRTAB;\n    shdr.sh_offset = 3*sizeof(shdr) + eod;\n    shdr.sh_size = sizeof(shstrtab);\n    fo->write(&shdr, sizeof(shdr));\n\n    fo->write(shstrtab, sizeof(shstrtab));\n#endif  // }\n\n\n    // Cannot pre-round .p_memsz.  If .p_filesz < .p_memsz, then kernel\n    // tries to make .bss, which requires PF_W.\n    // But strict SELinux (or PaX, grSecurity) disallows PF_W with PF_X.\n#if 0  /*{*/\n#undef PAGE_MASK\n#define PAGE_MASK (~0u<<12)\n    // pre-calculate for benefit of runtime disappearing act via munmap()\n    elfout.phdr[0].p_memsz =  PAGE_MASK & (~PAGE_MASK + elfout.phdr[0].p_filesz);\n#undef PAGE_MASK\n#else  /*}{*/\n    elfout.phdr[0].p_memsz =  elfout.phdr[0].p_filesz;\n#endif  /*}*/\n\n    // rewrite Elf header\n    fo->seek(0, SEEK_SET);\n    fo->rewrite(&elfout, overlay_offset);\n}\n\nLinker *PackLinuxI386::newLinker() const\n{\n    return new ElfLinkerX86;\n}\n\nvoid\nPackLinuxI386::buildLinuxLoader(\n    upx_byte const *const proto,\n    unsigned        const szproto,\n    upx_byte const *const fold,\n    unsigned        const szfold,\n    Filter const *ft\n)\n{\n    initLoader(proto, szproto);\n\n    unsigned fold_hdrlen = 0;\n  if (0 < szfold) {\n    cprElfHdr1 const *const hf = (cprElfHdr1 const *)fold;\n    fold_hdrlen = usizeof(hf->ehdr) + hf->ehdr.e_phentsize * hf->ehdr.e_phnum +\n         usizeof(l_info);\n    if (0 == get_le32(fold_hdrlen + fold)) {\n        // inconsistent SIZEOF_HEADERS in *.lds (ld, binutils)\n        fold_hdrlen = upx::umax(0x80u, fold_hdrlen);\n    }\n  }\n    // This adds the definition to the \"library\", to be used later.\n    // NOTE: the stub is NOT compressed!  The savings is not worth it.\n    linker->addSection(\"FOLDEXEC\", fold + fold_hdrlen, szfold - fold_hdrlen, 0);\n\n    n_mru = ft->n_mru;\n\n// Rely on \"+80CXXXX\" [etc] in getDecompressorSections() packer_c.cpp */\n//    // Here is a quick summary of the format of the output file:\n//    linker->setLoaderAlignOffset(\n//            // Elf32_Edhr\n//        sizeof(elfout.ehdr) +\n//            // Elf32_Phdr: 1 for exec86, 2 for sh86, 3 for elf86\n//        (elfout.ehdr.e_phentsize * elfout.ehdr.e_phnum) +\n//            // checksum UPX! lsize version format\n//        sizeof(l_info) +\n//            // PT_DYNAMIC with DT_NEEDED \"forwarded\" from original file\n//        ((elfout.ehdr.e_phnum==3) ? (unsigned) elfout.phdr[2].p_memsz : 0) +\n//            // p_progid, p_filesize, p_blocksize\n//        sizeof(p_info) +\n//            // compressed data\n//        b_len + ph.c_len );\n//            // entry to stub\n    addLoader(\"LEXEC000\", nullptr);\n\n    if (ft->id) {\n        if (n_mru) {\n            addLoader(\"LEXEC009\", nullptr);\n        }\n    }\n    addLoader(\"LEXEC010\", nullptr);\n    linker->defineSymbol(\"filter_cto\", ft->cto);\n    linker->defineSymbol(\"filter_length\",\n                         (ft->id & 0xf) % 3 == 0 ? ft->calls :\n                         ft->lastcall - ft->calls * 4);\n    addLoader(getDecompressorSections(), nullptr);\n    addLoader(\"LEXEC015\", nullptr);\n    if (ft->id) {\n        {  // decompr, unfilter not separate\n            if (0x80==(ft->id & 0xF0)) {\n                addLoader(\"LEXEC110\", nullptr);\n                if (n_mru) {\n                    addLoader(\"LEXEC100\", nullptr);\n                }\n                // bug in APP: jmp and label must be in same .asx/.asy\n                addLoader(\"LEXEC016\", nullptr);\n            }\n        }\n        addFilter32(ft->id);\n        {  // decompr always unfilters\n            addLoader(\"LEXEC017\", nullptr);\n        }\n    }\n    else {\n        addLoader(\"LEXEC017\", nullptr);\n    }\n\n    addLoader(\"IDENTSTR\", nullptr);\n    addLoader(\"LEXEC020\", nullptr);\n    addLoader(\"FOLDEXEC\", nullptr);\n    if (M_IS_LZMA(ph.method)) {\n        const lzma_compress_result_t *res = &ph.compress_result.result_lzma;\n        upx_uint32_t properties = // lc, lp, pb, dummy\n            (res->lit_context_bits << 0) |\n            (res->lit_pos_bits << 8) |\n            (res->pos_bits << 16);\n        if (bele->isBE()) // big endian - bswap32\n            properties = bswap32(properties);\n        linker->defineSymbol(\"lzma_properties\", properties);\n\n        // These lengths assume only one block (typ. 524288 bytes: 0.5 MiB).\n        // i386 handles more than one block, and computes the lengths\n        // dynamically from struct b_info.  Why do others need these?\n        if (linker->findSymbol(\"lzma_c_len\", false)) {\n            // -2 for properties\n            linker->defineSymbol(\"lzma_c_len\", ph.c_len - 2);\n        }\n        if (linker->findSymbol(\"lzma_u_len\", false)) {\n            linker->defineSymbol(\"lzma_u_len\", ph.c_len);\n        }\n\n        unsigned const stack = getDecompressorWrkmemSize();\n        linker->defineSymbol(\"lzma_stack_adjust\", 0u - stack);\n    }\n    if (0x80==(ft->id & 0xF0)) {\n        int const mru = ft->n_mru ? 1+ ft->n_mru : 0;\n        if (mru && mru!=256) {\n            unsigned const is_pwr2 = (0==((mru -1) & mru));\n            linker->defineSymbol(\"NMRU\", mru - is_pwr2);\n        }\n    }\n    relocateLoader();\n}\n\nvoid\nPackLinuxI386::buildLoader(Filter const *ft)\n{\n    unsigned const sz_fold = sizeof(stub_i386_linux_elf_execve_fold);\n    MemBuffer buf(sz_fold);\n    memcpy(buf, stub_i386_linux_elf_execve_fold, sz_fold);\n\n    // patch loader\n    // note: we only can use /proc/<pid>/fd when exetype > 0.\n    //   also, we sleep much longer when compressing a script.\n    checkPatch(nullptr, 0, 0, 0);  // reset\n    patch_le32(buf,sz_fold,\"UPX4\",exetype > 0 ? 3 : 15);   // sleep time\n    patch_le32(buf,sz_fold,\"UPX3\",progid);\n    patch_le32(buf,sz_fold,\"UPX2\",exetype > 0 ? 0 : 0x7fffffff);\n\n    buildLinuxLoader(\n        stub_i386_linux_elf_execve_entry, sizeof(stub_i386_linux_elf_execve_entry),\n        buf, sz_fold, ft );\n}\n\nvoid\nPackBSDI386::buildLoader(Filter const *ft)\n{\n    unsigned const sz_fold = sizeof(stub_i386_bsd_elf_execve_fold);\n    MemBuffer buf(sz_fold);\n    memcpy(buf, stub_i386_bsd_elf_execve_fold, sz_fold);\n\n    // patch loader\n    // note: we only can use /proc/<pid>/fd when exetype > 0.\n    //   also, we sleep much longer when compressing a script.\n    checkPatch(nullptr, 0, 0, 0);  // reset\n    patch_le32(buf,sz_fold,\"UPX4\",exetype > 0 ? 3 : 15);   // sleep time\n    patch_le32(buf,sz_fold,\"UPX3\",progid);\n    patch_le32(buf,sz_fold,\"UPX2\",exetype > 0 ? 0 : 0x7fffffff);\n\n    buildLinuxLoader(\n        stub_i386_bsd_elf_execve_entry, sizeof(stub_i386_bsd_elf_execve_entry),\n        buf, sz_fold, ft );\n}\n\n// FIXME: getLoaderPrefixSize is unused?\nint PackLinuxI386::getLoaderPrefixSize() const\n{\n    return 116;\n}\n\n\n/*************************************************************************\n// some ELF utility functions\n**************************************************************************/\n\n// basic check of a Linux ELF Ehdr\nint PackLinuxI386::checkEhdr(const Elf_LE32_Ehdr *ehdr) const\n{\n    const unsigned char * const buf = ehdr->e_ident;\n\n    if (memcmp(buf, \"\\x7f\\x45\\x4c\\x46\\x01\\x01\\x01\", 7)) // ELF 32-bit LSB\n        return -1;\n\n    // now check the ELF header\n    if (!memcmp(buf+8, \"FreeBSD\", 7))                  // branded\n        return 1;\n    if (ehdr->e_type != Elf32_Ehdr::ET_EXEC\n    &&  ehdr->e_type != Elf32_Ehdr::ET_DYN )           // executable\n        return 2;\n    if (ehdr->e_machine != Elf32_Ehdr::EM_386)         // Intel 80386\n        return 3;\n    if (ehdr->e_version != Elf32_Ehdr::EV_CURRENT)     // version\n        return 4;\n    if (ehdr->e_phnum < 1)\n        return 5;\n    if (ehdr->e_phentsize != sizeof(Elf32_Phdr))\n        return 6;\n\n    // check for Linux kernels\n    if (ehdr->e_entry == 0xC0100000)                    // uncompressed vmlinux\n        return 1000;\n    if (ehdr->e_entry == 0x00001000)                    // compressed vmlinux\n        return 1001;\n    if (ehdr->e_entry == 0x00100000)                    // compressed bvmlinux\n        return 1002;\n\n    // FIXME: add more checks for kernels\n\n    // FIXME: add special checks for other ELF i386 formats, like\n    //        NetBSD, OpenBSD, Solaris, ....\n\n    // success\n    return 0;\n}\n\n\n\n/*************************************************************************\n//\n**************************************************************************/\n\ntribool PackLinuxI386::canPack()\n{\n    if (exetype != 0)\n        return super::canPack();\n\n    Elf_LE32_Ehdr ehdr;\n    unsigned char *buf = ehdr.e_ident;\n\n    fi->seek(0, SEEK_SET);\n    fi->readx(&ehdr, sizeof(ehdr));\n    fi->seek(0, SEEK_SET);\n\n    exetype = 0;\n    const unsigned l = get_le32(buf);\n\n    int elf = checkEhdr(&ehdr);\n    if (elf >= 0) {\n        // NOTE: ELF executables are now handled by p_lx_elf.cpp,\n        //   so we only handle them here if force_execve\n        if (elf == 0 && opt->o_unix.force_execve) {\n            exetype = 1;\n\n            unsigned osabi0 = ehdr.e_ident[Elf32_Ehdr::EI_OSABI];\n            switch (osabi0) {\n            case Elf32_Ehdr::ELFOSABI_LINUX:\n            case Elf32_Ehdr::ELFOSABI_FREEBSD:\n            case Elf32_Ehdr::ELFOSABI_NETBSD:\n            case Elf32_Ehdr::ELFOSABI_OPENBSD:\n                ei_osabi = osabi0;  // Proudly declares its osabi in Ehdr.\n                break;\n            default:\n            unsigned const e_phnum = get_te16(&ehdr.e_phnum);\n            if (e_phnum<=(512/sizeof(Elf32_Phdr))) {\n                union {\n                    unsigned char buf2[512];\n                    //Elf32_Phdr phdr;\n                } u;\n                fi->seek(get_te32(&ehdr.e_phoff), SEEK_SET);\n                fi->readx(u.buf2, sizeof(u.buf2));\n                fi->seek(0, SEEK_SET);\n                Elf32_Phdr const *phdr = (Elf32_Phdr *) u.buf2;\n                for (unsigned j=0; j < e_phnum; ++phdr, ++j) {\n                    if (phdr->PT_NOTE == get_te32(&phdr->p_type)) {\n                        unsigned const offset = get_te32(&phdr->p_offset);\n                        struct Elf32_Note note; memset(&note, 0, sizeof(note));\n                        fi->seek(offset, SEEK_SET);\n                        fi->readx(&note, sizeof(note));\n                        fi->seek(0, SEEK_SET);\n                        if (4==get_te32(&note.descsz)\n                        &&  1==get_te32(&note.type)\n                        &&  0==note.end ) {\n                            if (0==strcmp(\"NetBSD\", (char const *)note.text)) {\n                                ei_osabi = Elf32_Ehdr::ELFOSABI_NETBSD;\n                                break;\n                            }\n                            if (0==strcmp(\"OpenBSD\", (char const *)note.text)) {\n                                ei_osabi = Elf32_Ehdr::ELFOSABI_OPENBSD;\n                                break;\n                            }\n                        }\n                    }\n                }\n            }\n            }\n        }\n        if (UPX_F_BSD_i386==getFormat()\n        && !(Elf32_Ehdr::ELFOSABI_FREEBSD==ei_osabi\n          || Elf32_Ehdr::ELFOSABI_NETBSD ==ei_osabi\n          || Elf32_Ehdr::ELFOSABI_OPENBSD==ei_osabi )) {\n            return false;\n        }\n    }\n    else if (l == 0x00640107 || l == 0x00640108 || l == 0x0064010b || l == 0x006400cc)\n    {\n        // OMAGIC / NMAGIC / ZMAGIC / QMAGIC\n        exetype = 2;\n        // FIXME: N_TRSIZE, N_DRSIZE\n        // FIXME: check for aout shared libraries\n    }\n    else { // shell scripts and other interpreters\n        if (Elf32_Ehdr::ELFOSABI_LINUX!=ei_osabi) {\n            return false;  // so far, only Linux has runtime stub for shell\n        }\n        else if (!memcmp(buf, \"#!/\", 3))                    // #!/bin/sh\n            exetype = -1;\n        else if (!memcmp(buf, \"#! /\", 4))                   // #! /bin/sh\n            exetype = -1;\n        else if (!memcmp(buf, \"\\xca\\xfe\\xba\\xbe\", 4))       // Java bytecode\n            exetype = -2;\n    }\n\n    return super::canPack();\n}\n\n\nvoid PackLinuxI386::patchLoader() { }\n\n\nvoid PackLinuxI386::patchLoaderChecksum()\n{\n    unsigned char *const ptr = getLoader();\n    l_info *const lp = (l_info *)(sizeof(elfout.ehdr) +\n        (elfout.ehdr.e_phnum * elfout.ehdr.e_phentsize) + (char *)&elfout );\n    // checksum for loader + p_info\n    lp->l_checksum = 0;\n    lp->l_magic = UPX_ELF_MAGIC;\n    set_te16(&lp->l_lsize, (upx_uint16_t) lsize);\n    lp->l_version = (unsigned char) ph.version;\n    lp->l_format  = (unsigned char) ph.format;\n    // INFO: lp->l_checksum is currently unused\n    set_te32(&lp->l_checksum, upx_adler32(ptr, lsize));\n}\n\n\nvoid PackLinuxI386::updateLoader(OutputFile *fo)\n{\n    elfout.ehdr.e_entry = fo->getBytesWritten() + elfout.phdr[0].p_vaddr;\n}\n\n/* vim:set ts=4 sw=4 et: */\n","size_bytes":21084},"src/p_lx_interp.cpp":{"content":"/* p_lx_interp.cpp --\n\n   This file is part of the Resize executable compressor.\n\n   Copyright (C) 2025 WHO-AM-I-404\n   Based on UPX - Ultimate Packer for eXecutables\n   Copyright (C) 1996-2025 Markus Franz Xaver Johannes Oberhumer\n   Copyright (C) 1996-2025 Laszlo Molnar\n   Copyright (C) 2000-2025 John F. Reiser\n   All Rights Reserved.\n\n   Resize and the UCL library are free software; you can redistribute them\n   and/or modify them under the terms of the GNU General Public License as\n   published by the Free Software Foundation; either version 2 of\n   the License, or (at your option) any later version.\n\n   This program is distributed in the hope that it will be useful,\n   but WITHOUT ANY WARRANTY; without even the implied warranty of\n   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n   GNU General Public License for more details.\n\n   You should have received a copy of the GNU General Public License\n   along with this program; see the file COPYING.\n   If not, write to the Free Software Foundation, Inc.,\n   59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.\n\n   WHO-AM-I-404 <who-am-i-404@proton.me>\n   Based on original work by:\n   Markus F.X.J. Oberhumer <markus@oberhumer.com>\n   Laszlo Molnar <ezerotven+github@gmail.com>\n\n   John F. Reiser\n   <jreiser@users.sourceforge.net>\n */\n\n\n#include \"conf.h\"\n\n#include \"file.h\"\n#include \"filter.h\"\n#include \"linker.h\"\n#include \"packer.h\"\n#include \"p_elf.h\"\n#include \"p_unix.h\"\n#include \"p_lx_exc.h\"\n#include \"p_lx_elf.h\"\n#include \"p_lx_interp.h\"\n\n#define PT_LOAD     Elf32_Phdr::PT_LOAD\n#define PT_INTERP   Elf32_Phdr::PT_INTERP\n\n\n/*************************************************************************\n//\n**************************************************************************/\n\nstatic const CLANG_FORMAT_DUMMY_STATEMENT\n#include \"stub/i386-linux.elf.interp-entry.h\"\nstatic const CLANG_FORMAT_DUMMY_STATEMENT\n#include \"stub/i386-linux.elf.interp-fold.h\"\n\nPackLinuxElf32x86interp::PackLinuxElf32x86interp(InputFile *f) :\n    super(f)\n{\n}\n\nPackLinuxElf32x86interp::~PackLinuxElf32x86interp()\n{\n}\n\ntribool PackLinuxElf32x86interp::canPack()\n{\n    if (opt->o_unix.make_ptinterp) {\n        return true;\n    }\n    if (!opt->o_unix.use_ptinterp) {\n        return false;\n    }\n    return super::canPack();\n}\n\nvoid PackLinuxElf32x86interp::pack1(OutputFile *fo, Filter &)\n{\n    fi->seek(0, SEEK_SET);\n    fi->readx(&ehdri, sizeof(ehdri));\n    assert(ehdri.e_phoff == sizeof(Elf32_Ehdr));  // checked by canPack()\n    sz_phdrs = ehdri.e_phnum * ehdri.e_phentsize;\n\n    phdri = New(Elf32_Phdr, ehdri.e_phnum);\n    fi->seek(ehdri.e_phoff, SEEK_SET);\n    fi->readx(phdri, sz_phdrs);\n\n#define E Elf32_Ehdr\n    cprElfHdr3 h3;\n    memset(&h3, 0, sizeof(h3));\n    memcpy(h3.ehdr.e_ident, \"\\177ELF\", 4);\n    h3.ehdr.e_ident[E::EI_CLASS] = E::ELFCLASS32;\n    h3.ehdr.e_ident[E::EI_DATA] = E::ELFDATA2LSB;\n    h3.ehdr.e_ident[E::EI_VERSION] = E::EV_CURRENT;\n    h3.ehdr.e_ident[E::EI_OSABI] = E::ELFOSABI_LINUX;\n    h3.ehdr.e_ident[E::EI_ABIVERSION] = E::EV_CURRENT;\n    h3.ehdr.e_type = E::ET_EXEC;\n    h3.ehdr.e_machine = E::EM_386;\n    h3.ehdr.e_version = 1;\n    h3.ehdr.e_phoff = sizeof(Elf32_Ehdr);\n    h3.ehdr.e_ehsize = sizeof(Elf32_Ehdr);\n    h3.ehdr.e_phentsize = sizeof(Elf32_Phdr);\n    h3.ehdr.e_phnum = 3;\n    h3.phdr[0].p_type = PT_LOAD;\n    h3.phdr[0].p_flags = Elf32_Phdr::PF_X | Elf32_Phdr::PF_R;\n    h3.phdr[0].p_align = 0x1000;\n    h3.phdr[1].p_type = PT_LOAD;\n    h3.phdr[1].p_flags = Elf32_Phdr::PF_W | Elf32_Phdr::PF_R;\n    h3.phdr[1].p_align = 1;\n    h3.phdr[2].p_type = PT_INTERP;\n    // h3.phdr[2].p_offset = (char *)&h3.phdr[2].p_vaddr - (char *)&h3;\n    h3.phdr[2].p_offset = offsetof(cprElfHdr3, phdr[2].p_vaddr);\n    memcpy(&h3.phdr[2].p_vaddr, \"/upxrun\", h3.phdr[2].p_filesz = 8);\n    h3.phdr[2].p_align = 1;\n\n    if (opt->o_unix.make_ptinterp) { // unusual \"once per release\"\n        *(cprElfHdr3 *)(void *)&elfout = h3;\n        elfout.ehdr.e_phnum = 1;\n        fo->write(&elfout, elfout.ehdr.e_ehsize + elfout.ehdr.e_phentsize);\n    }\n    else { // usual case\n        generateElfHdr(fo, &h3, getbrk(phdri, ehdri.e_phnum));\n    }\n#undef E\n}\n\nint PackLinuxElf32x86interp::pack2(OutputFile *fo, Filter &ft)\n{\n    if (opt->o_unix.make_ptinterp) {\n        return 1;  // ignore current input file!\n    }\n    return super::pack2(fo, ft);\n}\n\n#undef PAGE_MASK\n#define PAGE_MASK (~0u<<12)\n\noff_t PackLinuxElf32x86interp::pack3(OutputFile *fo, Filter &/*ft*/)\n{\n    unsigned base = getbase(phdri, ehdri.e_phnum);\n    unsigned sz = PAGE_MASK & (~PAGE_MASK + elfout.phdr[0].p_filesz);\n    if (base < (0x11000 + sz)) {\n        base =  0x11000 + sz;\n    }\n    if (opt->o_unix.make_ptinterp) {\n        base = 0x10000;\n    }\n    elfout.phdr[0].p_paddr = elfout.phdr[0].p_vaddr = base - sz;\n    if (opt->o_unix.make_ptinterp) {\n        initLoader(stub_i386_linux_elf_interp_entry, sizeof(stub_i386_linux_elf_interp_entry));\n        linker->addSection(\"FOLDEXEC\", stub_i386_linux_elf_interp_fold, sizeof(stub_i386_linux_elf_interp_fold), 0);\n\n        addLoader(\"LXPTI000\", nullptr);\n\n        addLoader(\"LXPTI040\", nullptr);\n        ph.method = M_NRV2B_LE32; addLoader(getDecompressorSections(), nullptr);\n        addLoader(\"LXPTI090\", nullptr);\n\n        addLoader(\"LXPTI041\", nullptr);\n        ph.method = M_NRV2D_LE32; addLoader(getDecompressorSections(), nullptr);\n        addLoader(\"LXPTI090\", nullptr);\n\n        addLoader(\"LXPTI042\", nullptr);\n        ph.method = M_NRV2E_LE32; addLoader(getDecompressorSections(), nullptr);\n        addLoader(\"LXPTI090\", nullptr);\n\n        //addLoader(\"LXPTI043\", nullptr);\n        //ph.method = M_CL1B_LE32;  addLoader(getDecompressorSections(), nullptr);\n        //addLoader(\"LXPTI090\", nullptr);\n\n        addLoader(\"LXPTI091\", nullptr);\n\n        addLoader(\"LXPTI140\", nullptr);\n\n        addLoader(\"LXUNF002,LXUNF008,LXUNF010\", nullptr);\n        addFilter32(0x46);\n        addLoader(\"LXUNF042,LXUNF035\", nullptr);\n\n        addLoader(\"LXUNF002,LXUNF008,LXUNF010\", nullptr);\n        addFilter32(0x49);\n        addLoader(\"LXUNF042,LXUNF035\", nullptr);\n\n        addLoader(\"LXPTI200\", nullptr);\n        addLoader(\"FOLDEXEC\", nullptr);\n        upx_byte const *p = getLoader();\n        lsize = getLoaderSize();\n        updateLoader(fo);\n        fo->write(p, lsize);\n        elfout.phdr[0].p_filesz = fo->getBytesWritten();\n    }\n    else {\n        updateLoader(fo);\n    }\n    return fo->getBytesWritten();\n}\n\n\nvoid PackLinuxElf32x86interp::unpack(OutputFile *fo)\n{\n#define MAX_INTERP_HDR 512\n    union {\n        unsigned char buf[MAX_INTERP_HDR];\n        //struct { Elf32_Ehdr ehdr; Elf32_Phdr phdr; } e;\n    } u;\n    Elf32_Ehdr *const ehdr = (Elf32_Ehdr *) u.buf;\n    Elf32_Phdr const *phdr = (Elf32_Phdr *) (u.buf + sizeof(*ehdr));\n\n    {\n        fi->seek(0, SEEK_SET);\n        fi->readx(u.buf, MAX_INTERP_HDR);\n        unsigned const e_entry = get_te32(&ehdr->e_entry);\n        if (e_entry < 0x401180) { /* old style, 8-byte b_info */\n            szb_info = 2*sizeof(unsigned);\n        }\n    }\n\n    fi->seek(overlay_offset, SEEK_SET);\n    p_info hbuf;\n    fi->readx(&hbuf, sizeof(hbuf));\n    unsigned orig_file_size = get_te32(&hbuf.p_filesize);\n    blocksize = get_te32(&hbuf.p_blocksize);\n    if (file_size > (off_t)orig_file_size || blocksize > orig_file_size)\n        throwCantUnpack(\"file header corrupted\");\n\n    ibuf.alloc(blocksize + OVERHEAD);\n    b_info bhdr; memset(&bhdr, 0, sizeof(bhdr));\n    fi->readx(&bhdr, szb_info);\n    ph.u_len = get_te32(&bhdr.sz_unc);\n    ph.c_len = get_te32(&bhdr.sz_cpr);\n    ph.filter_cto = bhdr.b_cto8;\n\n    // Uncompress Ehdr and Phdrs.\n    fi->readx(ibuf, ph.c_len);\n    decompress(ibuf, (upx_byte *)ehdr, false);\n\n    total_in = 0;\n    total_out = 0;\n    unsigned c_adler = upx_adler32(nullptr, 0);\n    unsigned u_adler = upx_adler32(nullptr, 0);\n    off_t ptload0hi=0, ptload1lo=0, ptload1sz=0;\n\n    // decompress PT_LOAD\n    bool first_PF_X = true;\n    fi->seek(- (off_t) (szb_info + ph.c_len), SEEK_CUR);\n    for (unsigned j=0; j < ehdr->e_phnum; ++phdr, ++j) {\n        if (PT_LOAD==phdr->p_type) {\n            if (0==ptload0hi) {\n                ptload0hi = phdr->p_filesz + phdr->p_offset;\n            }\n            else if (0==ptload1lo) {\n                ptload1lo = phdr->p_offset;\n                ptload1sz = phdr->p_filesz;\n            }\n            if (fo)\n                fo->seek(phdr->p_offset, SEEK_SET);\n            if (Elf32_Phdr::PF_X & phdr->p_flags) {\n                unpackExtent(phdr->p_filesz, fo,\n                    c_adler, u_adler, first_PF_X, szb_info);\n                first_PF_X = false;\n            }\n            else {\n                unpackExtent(phdr->p_filesz, fo,\n                    c_adler, u_adler, false, szb_info);\n            }\n        }\n    }\n\n    if (0!=ptload1sz && ptload0hi < ptload1lo) {  // alignment hole?\n        if (fo)\n            fo->seek(ptload0hi, SEEK_SET);\n        unpackExtent(ptload1lo - ptload0hi, fo,\n            c_adler, u_adler, false, szb_info);\n    }\n    if (total_out != orig_file_size) {  // non-PT_LOAD stuff\n        if (fo)\n            fo->seek(0, SEEK_END);\n        unpackExtent(orig_file_size - total_out, fo,\n            c_adler, u_adler, false, szb_info);\n    }\n\n    // check for end-of-file\n    fi->readx(&bhdr, szb_info);\n    unsigned const sz_unc = ph.u_len = get_te32(&bhdr.sz_unc);\n\n    if (sz_unc == 0) { // uncompressed size 0 -> EOF\n        // note: magic is always stored le32\n        unsigned const sz_cpr = get_le32(&bhdr.sz_cpr);\n        if (sz_cpr != UPX_MAGIC_LE32)  // sz_cpr must be h->magic\n            throwCompressedDataViolation();\n    }\n    else { // extra bytes after end?\n        throwCompressedDataViolation();\n    }\n\n    // update header with totals\n    ph.c_len = total_in;\n    ph.u_len = total_out;\n\n    // all bytes must be written\n    if (total_out != orig_file_size)\n        throwEOFException();\n\n    // finally test the checksums\n    if (ph.c_adler != c_adler || ph.u_adler != u_adler)\n        throwChecksumError();\n#undef MAX_INTERP_HDR\n}\n\n/* vim:set ts=4 sw=4 et: */\n","size_bytes":10035},"src/p_lx_sh.cpp":{"content":"/* p_lx_sh.cpp --\n\n   This file is part of the Resize executable compressor.\n\n   Copyright (C) 2025 WHO-AM-I-404\n   Based on UPX - Ultimate Packer for eXecutables\n   Copyright (C) 1996-2025 Markus Franz Xaver Johannes Oberhumer\n   Copyright (C) 1996-2025 Laszlo Molnar\n   Copyright (C) 2000-2025 John F. Reiser\n   All Rights Reserved.\n\n   Resize and the UCL library are free software; you can redistribute them\n   and/or modify them under the terms of the GNU General Public License as\n   published by the Free Software Foundation; either version 2 of\n   the License, or (at your option) any later version.\n\n   This program is distributed in the hope that it will be useful,\n   but WITHOUT ANY WARRANTY; without even the implied warranty of\n   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n   GNU General Public License for more details.\n\n   You should have received a copy of the GNU General Public License\n   along with this program; see the file COPYING.\n   If not, write to the Free Software Foundation, Inc.,\n   59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.\n\n   WHO-AM-I-404 <who-am-i-404@proton.me>\n   Based on original work by:\n   Markus F.X.J. Oberhumer <markus@oberhumer.com>\n   Laszlo Molnar <ezerotven+github@gmail.com>\n\n   John F. Reiser\n   <jreiser@users.sourceforge.net>\n */\n\n\n#include \"conf.h\"\n\n#include \"file.h\"\n#include \"filter.h\"\n#include \"packer.h\"\n#include \"p_elf.h\"\n#include \"p_unix.h\"\n#include \"p_lx_exc.h\"\n#include \"p_lx_sh.h\"\n\n#define PT_LOAD     Elf_LE32_Phdr::PT_LOAD\n\n\n/*************************************************************************\n//\n**************************************************************************/\n\nstatic const CLANG_FORMAT_DUMMY_STATEMENT\n#include \"stub/i386-linux.elf.shell-entry.h\"\nstatic const CLANG_FORMAT_DUMMY_STATEMENT\n#include \"stub/i386-linux.elf.shell-fold.h\"\n\n\nPackLinuxI386sh::PackLinuxI386sh(InputFile *f) :\n    super(f), o_shname(0), l_shname(0)\n{\n}\n\nPackLinuxI386sh::~PackLinuxI386sh()\n{\n}\n\nvoid\nPackLinuxI386sh::buildLoader(Filter const *ft)\n{\n    unsigned const sz_fold = sizeof(stub_i386_linux_elf_shell_fold);\n    MemBuffer buf(sz_fold);\n    memcpy(buf, stub_i386_linux_elf_shell_fold, sz_fold);\n\n    checkPatch(nullptr, 0, 0, 0);  // reset\n    patch_le32(buf,sz_fold,\"UPX3\",l_shname);\n    patch_le32(buf,sz_fold,\"UPX2\",o_shname);\n\n    // get fresh filter\n    Filter fold_ft = *ft;\n    fold_ft.init(ft->id, ft->addvalue);\n    int preferred_ctos[2] = { ft->cto, -1 };\n    fold_ft.preferred_ctos = preferred_ctos;\n\n    // filter\n    optimizeFilter(&fold_ft, buf, sz_fold);\n    unsigned fold_hdrlen = sizeof(l_info) + sizeof(Elf32_Ehdr) +\n        sizeof(Elf32_Phdr) * get_te16(&((Elf32_Ehdr const *)(void *)buf)->e_phnum);\n    if (0 == get_le32(buf + fold_hdrlen)) {\n        // inconsistent SIZEOF_HEADERS in *.lds (ld, binutils)\n        fold_hdrlen = upx::umax(0x80u, fold_hdrlen);\n    }\n    bool success = fold_ft.filter(buf + fold_hdrlen, sz_fold - fold_hdrlen);\n    UNUSED(success);\n\n    buildLinuxLoader(\n        stub_i386_linux_elf_shell_entry, sizeof(stub_i386_linux_elf_shell_entry),\n        buf, sz_fold, ft );\n}\n\nvoid PackLinuxI386sh::patchLoader() { }\n\n\nbool PackLinuxI386sh::getShellName(char *buf)\n{\n    exetype = -1;\n    l_shname = (int) strcspn(buf, \" \\t\\n\\v\\f\\r\");\n    buf[l_shname] = 0;\n    static char const *const shname[] = { // known shells that accept \"-c\" arg\n        \"ash\", \"bash\", \"bsh\", \"csh\", \"ksh\", \"pdksh\", \"sh\", \"tcsh\", \"zsh\",\n        \"python\", \"python2\", \"python3\",\n        nullptr\n    };\n    const char *bname = strrchr(buf, '/');\n    if (bname == nullptr)\n        return false;\n    for (int j = 0; nullptr != shname[j]; ++j) {\n        if (0 == strcmp(shname[j], bname + 1)) {\n            bool const s = bool(super::canPack());\n            if (s) {\n                opt->o_unix.blocksize = blocksize = file_size;\n            }\n            unsigned size = fi->st_size();\n            if (size > (125<<10)) { // 128KB but allow 3KB for environment\n                printWarn(fi->getName(), \"Likely E2BIG for size=%u\", size);\n                return false;\n            }\n            return s;\n        }\n    }\n    return false;\n}\n\n\ntribool PackLinuxI386sh::canPack()\n{\n#if defined(__linux__)  //{\n    // only compress i386sh scripts when running under Linux\n    char buf[512];\n\n    fi->readx(buf, sizeof(buf));\n    fi->seek(0, SEEK_SET);\n    buf[sizeof(buf) - 1] = 0;\n    if (!memcmp(buf, \"#!/\", 3)) {                       // #!/bin/sh\n        o_shname = 2;\n        return getShellName(&buf[o_shname]);\n    }\n    else if (!memcmp(buf, \"#! /\", 4)) {                 // #! /bin/sh\n        o_shname = 3;\n        return getShellName(&buf[o_shname]);\n    }\n#endif  //}\n    return false;\n}\n\n\nvoid\nPackLinuxI386sh::pack1(OutputFile *fo, Filter &)\n{\n    generateElfHdr(fo, stub_i386_linux_elf_shell_fold, 0x08048000);\n}\n\noff_t\nPackLinuxI386sh::pack3(OutputFile *fo, Filter &ft)\n{\n    return elfout.phdr[0].p_filesz = super::pack3(fo,ft);\n}\n\n/* vim:set ts=4 sw=4 et: */\n","size_bytes":4983},"src/p_mach.cpp":{"content":"/* p_mach.cpp -- pack Mach Object executable\n\n   This file is part of the Resize executable compressor.\n\n   Copyright (C) 2004-2025 John Reiser\n   All Rights Reserved.\n\n   Resize and the UCL library are free software; you can redistribute them\n   and/or modify them under the terms of the GNU General Public License as\n   published by the Free Software Foundation; either version 2 of\n   the License, or (at your option) any later version.\n\n   This program is distributed in the hope that it will be useful,\n   but WITHOUT ANY WARRANTY; without even the implied warranty of\n   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n   GNU General Public License for more details.\n\n   You should have received a copy of the GNU General Public License\n   along with this program; see the file COPYING.\n   If not, write to the Free Software Foundation, Inc.,\n   59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.\n\n   John Reiser\n   <jreiser@users.sourceforge.net>\n */\n\n\n#define ALLOW_INT_PLUS_MEMBUFFER 1\n#include \"conf.h\"\n\n#include \"file.h\"\n#include \"filter.h\"\n#include \"linker.h\"\n#include \"packer.h\"\n#define WANT_MACH_SEGMENT_ENUM\n#define WANT_MACH_SECTION_ENUM\n#include \"p_mach_enum.h\"\n#include \"p_mach.h\"\n#include \"ui.h\"\n\n#if (ACC_CC_CLANG)\n#  pragma clang diagnostic ignored \"-Wcast-align\"\n#endif\n#if (ACC_CC_GNUC >= 0x040200)\n#  pragma GCC diagnostic ignored \"-Wcast-align\"\n#endif\n#if defined(__CHERI__) && defined(__CHERI_PURE_CAPABILITY__)\n#  pragma clang diagnostic ignored \"-Wcheri-capability-misuse\" // TODO later\n#endif\n\nstatic const CLANG_FORMAT_DUMMY_STATEMENT\n#include \"stub/i386-darwin.macho-entry.h\"\nstatic const CLANG_FORMAT_DUMMY_STATEMENT\n#include \"stub/i386-darwin.macho-fold.h\"\nstatic const CLANG_FORMAT_DUMMY_STATEMENT\n#include \"stub/i386-darwin.macho-upxmain.h\"\nstatic const CLANG_FORMAT_DUMMY_STATEMENT\n#include \"stub/i386-darwin.dylib-entry.h\"\n\nstatic const CLANG_FORMAT_DUMMY_STATEMENT\n#include \"stub/amd64-darwin.macho-entry.h\"\nstatic const CLANG_FORMAT_DUMMY_STATEMENT\n#include \"stub/amd64-darwin.macho-fold.h\"\nstatic const CLANG_FORMAT_DUMMY_STATEMENT\n#include \"stub/amd64-darwin.macho-upxmain.h\"\nstatic const CLANG_FORMAT_DUMMY_STATEMENT\n#include \"stub/amd64-darwin.dylib-entry.h\"\n\nstatic const CLANG_FORMAT_DUMMY_STATEMENT\n#include \"stub/arm.v5a-darwin.macho-entry.h\"\nstatic const CLANG_FORMAT_DUMMY_STATEMENT\n#include \"stub/arm.v5a-darwin.macho-fold.h\"\n\nstatic const CLANG_FORMAT_DUMMY_STATEMENT\n#include \"stub/arm64-darwin.macho-entry.h\"\nstatic const CLANG_FORMAT_DUMMY_STATEMENT\n#include \"stub/arm64-darwin.macho-fold.h\"\n\nstatic const CLANG_FORMAT_DUMMY_STATEMENT\n#include \"stub/powerpc-darwin.macho-entry.h\"\nstatic const CLANG_FORMAT_DUMMY_STATEMENT\n#include \"stub/powerpc-darwin.macho-fold.h\"\nstatic const CLANG_FORMAT_DUMMY_STATEMENT\n#include \"stub/powerpc-darwin.macho-upxmain.h\"\nstatic const CLANG_FORMAT_DUMMY_STATEMENT\n#include \"stub/powerpc-darwin.dylib-entry.h\"\n\nstatic const CLANG_FORMAT_DUMMY_STATEMENT\n#include \"stub/powerpc64-darwin.macho-entry.h\"\nstatic const CLANG_FORMAT_DUMMY_STATEMENT\n#include \"stub/powerpc64-darwin.macho-fold.h\"\nstatic const CLANG_FORMAT_DUMMY_STATEMENT\n#include \"stub/powerpc64-darwin.dylib-entry.h\"\n\n// Packing a Darwin (Mach-o) Mac OS X dylib (dynamic shared library)\n// is restricted.  UPX gets control as the -init function, at the very\n// end of processing by dyld.  Relocation, loading of dependent libraries,\n// etc., already have taken place before decompression.  So the Mach-o\n// headers, the __IMPORT segment, the __LINKEDIT segment, anything\n// that is modified by relocation, etc., cannot be compressed.\n// We simplify arbitrarily by compressing only the __TEXT segment,\n// which must be the first segment.\n\nstruct Lc_seg_info {\n    unsigned char segment_cmd;\n    unsigned char segcmdsize;\n    unsigned char seccmdsize;\n    unsigned char routines_cmd;\n    unsigned char routinessize;\n};\nstatic const Lc_seg_info lc_seg_info[2] = {\n    {LC_SEGMENT,     sizeof(Mach32_segment_command), sizeof(Mach32_section_command),\n     LC_ROUTINES,    sizeof(Mach32_routines_command)},\n    {LC_SEGMENT_64,  sizeof(Mach64_segment_command), sizeof(Mach64_section_command),\n     LC_ROUTINES_64, sizeof(Mach64_routines_command)},\n};\n\n// Used to validate LC_ commands in order to defend against fuzzers.\n// = 0 : illegal or unknown to us\n// > 0 : actual size\n// < 0 : neg. of minimum size; total must be (0 mod 4) or (0 mod 8)\n//\nstatic const upx_int8_t lc_cmd_size[] = {\n// 2021-12: gcc 11.2.1 does not support 'sizeof' in designated initializer.\n// 2021-12: gcc 11.2.1 does not support [enum] as designator.\n// 2021-12: \"clang++-10 -std=c++14\":\n//          error: array designators are a C99 extension [-Werror,-Wc99-designator]\n// 2021-12: \"Microsoft (R) C/C++ Optimizing Compiler Version 19.29.30138 for x64\":\n//          error C2143: syntax error: missing ']' before 'constant'\n// Therefore, use the old brittle style with explicit consecutive enumeration.\n// #define P(where, value) [(where)] = (value)\n#   define P(where, value)             (value)\n    P(0x00, 0),\n    P(0x01 /*LC_SEGMENT*/, -56),  // see lc_seg_info[]\n    P(0x02 /*LC_SYMTAB*/, 24), // sizeof(Mach32_symtab_command)\n    P(0x03 /*LC_SYMSEG*/, 0), // obsolete\n    P(0x04 /*LC_THREAD*/, -16), // uint32_t[4] + XXX_thread_state\n    P(0x05 /*LC_UNIXTHREAD*/, -16), // uint32_t[4] + XXX_thread_state\n    P(0x06 /*LC_LOADFVMLIB*/, 0),\n    P(0x07 /*LC_IDFVMLIB*/, 0),\n    P(0x08 /*LC_IDENT*/, 0), // obsolete\n    P(0x09 /*LC_FVMFILE*/, 0), // Apple internal\n    P(0x0a /*LC_PREPAGE*/, 0), // Apple internal\n    P(0x0b /*LC_DYSYMTAB*/, 80), // sizeof(Mach32_dysymtab_command\n    P(0x0c /*LC_LOAD_DYLIB*/, -24), // sizeof(dylib_command) + string\n    P(0x0d /*LC_ID_DYLIB*/, -24), // sizeof(dylib_command) + string\n    P(0x0e /*LC_LOAD_DYLINKER*/, -12), // sizeof(dylinker_command) + string\n    P(0x0f /*LC_ID_DYLINKER*/, -12), // sizeof(dylinker_command) + string\n    P(0x10 /*LC_PREBOUND_DYLIB*/, 0),\n    P(0x11 /*LC_ROUTINES*/, 0),  // FIXME\n    P(0x12 /*LC_SUB_FRAMEWORK*/, 0),\n    P(0x13 /*LC_SUB_UMBRELLA*/, 0),\n    P(0x14 /*LC_SUB_CLIENT*/, 0),\n    P(0x15 /*LC_SUB_LIBRARY*/, 0),\n    P(0x16 /*lC_TWOLEVEL_HINTS*/, -16), // sizeof(Mach32_twolevel_hints_command) + hints\n    P(0x17 /*LC_PREBIND_CKSUM*/, 0),\n    P(0x18 /*lo(LC_LOAD_WEAK_DYLIB)*/, -24), // sizeof(dylib_command) + string\n    P(0x19 /*LC_SEGMENT_64*/, -72),  // see lc_seg_info[]\n    P(0x1a /*LC_ROUTINES_64*/, 0),  // FIXME\n    P(0x1b /*LC_UUID*/, 24), // sizeof(Mach32_uuid_command)\n    P(0x1c /*LC_RPATH*/, -12), // sizeof(rpath_command) + string\n    P(0x1d /*LC_CODE_SIGNATURE*/, 16), // sizeof(linkedit_data_command)\n    P(0x1e /*LC_SEGMENT_SPLIT_INFO*/, 16), // sizeof(linkedit_data_command)\n    P(0x1F /*lo(LC_REEXPORT_DYLIB)*/, -24), // sizeof(dylib_command) + string\n    P(0x20 /*LC_LAZY_LOAD_DYLIB*/, 8), // ???\n    P(0x21 /*LC_ENCRYPTION_INFO*/, 20), // sizeof(encryption_info_command)\n    P(0x22 /*LC_DYLD_INFO*/, 48), // sizeof(dyld_info_command)\n    P(0x23 /*LC_LOAD_UPWARD_DYLIB*/, 0),\n    P(0x24 /*LC_VERSION_MIN_MACOSX*/, 16), // sizeof(Mach32_version_min_command)\n    P(0x25 /*LC_VERSION_MIN_IPHONEOS*/, 16), // sizeof(Mach32_version_min_command)\n    P(0x26 /*LC_FUNCTION_STARTS*/, 16), // sizeof(linkedit_data_command)\n    P(0x27 /*LC_DYLD_ENVIRONMENT*/, -12), // sizeof(dylinker_command) + string\n    P(0x28 /*lo(LC_MAIN)*/, 24), // sizeof(entry_point_command)\n    P(0x29 /*LC_DATA_IN_CODE*/, 16), // sizeof(linkedit_data_command)\n    P(0x2a /*LC_SOURCE_VERSION*/, 16), // sizeof(Mach32_source_version_command)\n    P(0x2b /*LC_DYLIB_CODE_SIGN_DRS*/, 16), // sizeof(linkedit_data_command)\n    P(0x2c /*LC_ENCRYPTION_INFO_64*/, 24), // sizeof(encryption_info_command_64)\n    P(0x2d /*LC_LINKER_OPTION*/, 0),\n    P(0x2e /*LC_LINKER_OPTIMIZATION_HINT*/, 0),\n    P(0x2f /*LC_VERSION_MIN_TVOS*/, 16), // sizeof(Mach32_version_min_command)\n    P(0x30 /*LC_VERSION_MIN_WATCHOS*/, 16), // sizeof(Mach32_version_min_command)\n    P(0x31 /*LC_NOTE*/, -40), // sizeof(note_command) + data\n    P(0x32 /*LC_BUILD_VERSION*/, -24), // sizeof(Mach32_build_version_command) + N*2*4\n    P(0x33 /*lo(LC_DYLD_EXPORTS_TRIE)*/, 16), // sizeof(linkedit_data_command)\n    P(0x34 /*lo(LC_DYLD_CHAINED_FIXUPS)*/, 16), // sizeof(linkedit_data_command)\n    P(0x35 /*lo(LC_FILESET_ENTRY)*/, -32), // sizeof(fileset_entry_command) + ???\n#undef P\n};\n\nstatic int is_bad_linker_command(\n    unsigned cmd, unsigned cmdsize,\n    unsigned headway, unsigned lc_seg, unsigned szAddr)\n{\n    cmd &= ~LC_REQ_DYLD;\n   return !cmd  // there is no LC_ cmd 0\n   || sizeof(lc_cmd_size) <= cmd  // beyond table of known sizes\n   || !lc_cmd_size[cmd]  // obsolete, or proper size not known to us\n   || !cmdsize || ((-1+ szAddr) & cmdsize)  // size not aligned\n   || headway < cmdsize  // not within header area\n   || (lc_seg == cmd  // lc_seg must have following lc_sections\n       && (cmdsize - lc_seg_info[szAddr>>3].segcmdsize) %\n                     lc_seg_info[szAddr>>3].seccmdsize)\n   || (0 < lc_cmd_size[cmd] &&  lc_cmd_size[cmd] != (int)cmdsize)  // not known size\n   || (0 > lc_cmd_size[cmd] && -lc_cmd_size[cmd]  > (int)cmdsize)  // below minimum size\n   ;\n}\n\n#if 0 // NOT USED\nstatic const unsigned lc_routines[2] = {\n    0x11, 0x1a\n    //Mach_command::LC_ROUTINES,\n    //Mach_command::LC_ROUTINES_64\n};\n#endif\n\ntemplate <class T>\nPackMachBase<T>::PackMachBase(InputFile *f, unsigned cputype, unsigned filetype,\n        unsigned flavor, unsigned count, unsigned size, unsigned page_shift) :\n    super(f), my_page_size(1ull<<page_shift), my_page_mask(~0ull<<page_shift),\n    my_cputype(cputype), my_filetype(filetype), my_thread_flavor(flavor),\n    my_thread_state_word_count(count), my_thread_command_size(size),\n    n_segment(0), rawmseg(nullptr), msegcmd(nullptr), o__mod_init_func(0),\n    prev_mod_init_func(0), pagezero_vmsize(0)\n{\n    MachClass::compileTimeAssertions();\n    bele = N_BELE_CTP::getRTP((const BeLePolicy*) nullptr);\n    memset(&cmdUUID, 0, sizeof(cmdUUID));\n    memset(&cmdSRCVER, 0, sizeof(cmdSRCVER));\n    memset(&cmdVERMIN, 0, sizeof(cmdVERMIN));\n    memset(&linkitem, 0, sizeof(linkitem));\n}\n\ntemplate <class T>\nPackMachBase<T>::~PackMachBase()\n{\n}\n\nPackDylibI386::PackDylibI386(InputFile *f) : super(f)\n{\n    my_filetype = Mach_header::MH_DYLIB;\n}\n\nPackDylibAMD64::PackDylibAMD64(InputFile *f) : super(f)\n{\n    my_filetype = Mach_header::MH_DYLIB;\n}\n\nPackDylibPPC32::PackDylibPPC32(InputFile *f) : super(f)\n{\n    my_filetype = Mach_header::MH_DYLIB;\n}\nPackDylibPPC64::PackDylibPPC64(InputFile *f) : super(f)\n{\n    my_filetype = Mach_header::MH_DYLIB;\n}\n\ntemplate <class T>\nconst int *PackMachBase<T>::getCompressionMethods(int method, int level) const\n{\n    // There really is no LE bias.\n    return Packer::getDefaultCompressionMethods_le32(method, level);\n}\n\nconst int *PackMachARMEL::getCompressionMethods(int method, int level) const\n{\n    // Un-aligned fetch does not work on 32-bit ARM, so use 8-bit methods\n    return Packer::getDefaultCompressionMethods_8(method, level);\n}\n\nPackMachPPC32::PackMachPPC32(InputFile *f) : super(f, Mach_header::CPU_TYPE_POWERPC,\n        Mach_header::MH_EXECUTE, Mach_thread_command::PPC_THREAD_STATE,\n        sizeof(Mach_ppc_thread_state)>>2, sizeof(threado), 12)\n{ }\n\nPackMachPPC64::PackMachPPC64(InputFile *f) : super(f, Mach_header::CPU_TYPE_POWERPC64,\n        Mach_header::MH_EXECUTE, Mach_thread_command::PPC_THREAD_STATE64,\n        sizeof(Mach_ppc_thread_state64)>>2, sizeof(threado), 16)\n{ }\n\nconst int *PackMachPPC32::getFilters() const\n{\n    static const int filters[] = { 0xd0, FT_END };\n    return filters;\n}\n\nconst int *PackMachPPC64::getFilters() const\n{\n    static const int filters[] = { 0xd0, FT_END };\n    return filters;\n}\n\nPackMachI386::PackMachI386(InputFile *f) : super(f, Mach_header::CPU_TYPE_I386,\n        Mach_header::MH_EXECUTE, (unsigned)Mach_thread_command::x86_THREAD_STATE32,\n        sizeof(Mach_i386_thread_state)>>2, sizeof(threado), 12)\n{ }\n\nint const *PackMachI386::getFilters() const\n{\n    static const int filters[] = { 0x49, FT_END };\n    return filters;\n}\n\nPackMachAMD64::PackMachAMD64(InputFile *f) : super(f, Mach_header::CPU_TYPE_X86_64,\n        Mach_header::MH_EXECUTE, (unsigned)Mach_thread_command::x86_THREAD_STATE64,\n        sizeof(Mach_AMD64_thread_state)>>2, sizeof(threado), 12)\n{ }\n\nint const *PackMachAMD64::getFilters() const\n{\n    static const int filters[] = { 0x49, FT_END };\n    return filters;\n}\n\nPackMachARMEL::PackMachARMEL(InputFile *f) : super(f, Mach_header::CPU_TYPE_ARM,\n        Mach_header::MH_EXECUTE, (unsigned)Mach_thread_command::ARM_THREAD_STATE,\n        sizeof(Mach_ARM_thread_state)>>2, sizeof(threado), 12)\n{ }\n\nPackMachARM64EL::PackMachARM64EL(InputFile *f) : super(f, Mach_header::CPU_TYPE_ARM64,\n        Mach_header::MH_EXECUTE, (unsigned)Mach_thread_command::ARM_THREAD_STATE64,\n        sizeof(Mach_ARM64_thread_state)>>2, sizeof(threado), 14)\n{ }\n\nint const *PackMachARMEL::getFilters() const\n{\n    static const int filters[] = { 0x50, FT_END };\n    return filters;\n}\n\nint const *PackMachARM64EL::getFilters() const\n{\n    static const int filters[] = { 0x52, FT_END };\n    return filters;\n}\n\nLinker *PackMachPPC32::newLinker() const\n{\n    return new ElfLinkerPpc32;\n}\n\nLinker *PackMachPPC64::newLinker() const\n{\n    return new ElfLinkerPpc64;\n}\n\nLinker *PackMachI386::newLinker() const\n{\n    return new ElfLinkerX86;\n}\n\nLinker *PackMachAMD64::newLinker() const\n{\n    return new ElfLinkerAMD64;\n}\n\nLinker *PackMachARMEL::newLinker() const\n{\n    return new ElfLinkerArmLE;\n}\n\nLinker *PackMachARM64EL::newLinker() const\n{\n    return new ElfLinkerArm64LE;\n}\n\ntemplate <class T>\nvoid\nPackMachBase<T>::addStubEntrySections(Filter const *)\n{\n    addLoader(\"MACOS000\", nullptr);\n   //addLoader(getDecompressorSections(), nullptr);\n    addLoader(\n        ( M_IS_NRV2E(ph.method) ? \"NRV_HEAD,NRV2E,NRV_TAIL\"\n        : M_IS_NRV2D(ph.method) ? \"NRV_HEAD,NRV2D,NRV_TAIL\"\n        : M_IS_NRV2B(ph.method) ? \"NRV_HEAD,NRV2B,NRV_TAIL\"\n        : M_IS_LZMA(ph.method)  ? \"LZMA_ELF00,LZMA_DEC20,LZMA_DEC30\"\n        : nullptr), nullptr);\n    if (hasLoaderSection(\"CFLUSH\"))\n        addLoader(\"CFLUSH\");\n    addLoader(\"ELFMAINY,IDENTSTR,+40,ELFMAINZ,FOLDEXEC\", nullptr);\n}\n\nvoid PackMachI386::addStubEntrySections(Filter const * /*ft*/)\n{\n    addLoader(\"MACHMAINX\", nullptr);  // different for MY_DYLIB vs MH_EXECUTE\n    if (my_filetype==Mach_header::MH_EXECUTE) {\n        addLoader(\"MACH_UNC\", nullptr);\n    }\n   //addLoader(getDecompressorSections(), nullptr);\n    addLoader(\n        ( M_IS_NRV2E(ph.method) ? \"NRV_HEAD,NRV2E,NRV_TAIL\"\n        : M_IS_NRV2D(ph.method) ? \"NRV_HEAD,NRV2D,NRV_TAIL\"\n        : M_IS_NRV2B(ph.method) ? \"NRV_HEAD,NRV2B,NRV_TAIL\"\n        : M_IS_LZMA(ph.method)  ? \"LZMA_ELF00,LZMA_DEC20,LZMA_DEC30\"\n        : nullptr), nullptr);\n    if (hasLoaderSection(\"CFLUSH\"))\n        addLoader(\"CFLUSH\");\n    addLoader(\"MACHMAINY,IDENTSTR,+40,MACHMAINZ,FOLDEXEC\", nullptr);\n}\n\nvoid PackMachAMD64::addStubEntrySections(Filter const * /*ft*/)\n{\n    addLoader(\"MACHMAINX\", nullptr);  // different for MY_DYLIB vs MH_EXECUTE\n    if (my_filetype==Mach_header::MH_EXECUTE) {\n        addLoader(\"MACH_UNC\", nullptr);\n    }\n   //addLoader(getDecompressorSections(), nullptr);\n    addLoader(\n        ( M_IS_NRV2E(ph.method) ? \"NRV_HEAD,NRV2E,NRV_TAIL\"\n        : M_IS_NRV2D(ph.method) ? \"NRV_HEAD,NRV2D,NRV_TAIL\"\n        : M_IS_NRV2B(ph.method) ? \"NRV_HEAD,NRV2B,NRV_TAIL\"\n        : M_IS_LZMA(ph.method)  ? \"LZMA_ELF00,LZMA_DEC20,LZMA_DEC30\"\n        : nullptr), nullptr);\n    if (hasLoaderSection(\"CFLUSH\"))\n        addLoader(\"CFLUSH\");\n    addLoader(\"MACHMAINY,IDENTSTR,+40,MACHMAINZ,FOLDEXEC\", nullptr);\n}\n\nvoid PackMachPPC32::addStubEntrySections(Filter const * /*ft*/)\n{\n    if (my_filetype!=Mach_header::MH_EXECUTE) {\n        addLoader(\"MACHMAINX\", nullptr);\n    }\n    else {\n        addLoader(\"PPC32BXX\", nullptr);\n    }\n    addLoader(\"MACH_UNC\", nullptr);\n   //addLoader(getDecompressorSections(), nullptr);\n    addLoader(\n        ( M_IS_NRV2E(ph.method) ? \"NRV_HEAD,NRV2E,NRV_TAIL\"\n        : M_IS_NRV2D(ph.method) ? \"NRV_HEAD,NRV2D,NRV_TAIL\"\n        : M_IS_NRV2B(ph.method) ? \"NRV_HEAD,NRV2B,NRV_TAIL\"\n        : M_IS_LZMA(ph.method)  ? \"LZMA_ELF00,LZMA_DEC20,LZMA_DEC30\"\n        : nullptr), nullptr);\n    if (hasLoaderSection(\"CFLUSH\"))\n        addLoader(\"CFLUSH\");\n    addLoader(\"MACHMAINY,IDENTSTR,+40,MACHMAINZ\", nullptr);\n    if (my_filetype!=Mach_header::MH_EXECUTE) {\n        addLoader(\"FOLDEXEC\", nullptr);\n    }\n}\n\nvoid PackMachARMEL::addStubEntrySections(Filter const * /*ft*/)\n{\n    addLoader(\"MACHMAINX\", nullptr);\n   //addLoader(getDecompressorSections(), nullptr);\n    addLoader(\n        ( M_IS_NRV2E(ph.method) ? \"NRV_HEAD,NRV2E,NRV_TAIL\"\n        : M_IS_NRV2D(ph.method) ? \"NRV_HEAD,NRV2D,NRV_TAIL\"\n        : M_IS_NRV2B(ph.method) ? \"NRV_HEAD,NRV2B,NRV_TAIL\"\n        : M_IS_LZMA(ph.method)  ? \"LZMA_ELF00,LZMA_DEC20,LZMA_DEC30\"\n        : nullptr), nullptr);\n    if (hasLoaderSection(\"CFLUSH\"))\n        addLoader(\"CFLUSH\");\n    addLoader(\"MACHMAINY,IDENTSTR,+40,MACHMAINZ,FOLDEXEC\", nullptr);\n}\n\nvoid PackMachARM64EL::addStubEntrySections(Filter const * /*ft*/)\n{\n    addLoader(\"MACHMAINX\", nullptr);\n   //addLoader(getDecompressorSections(), nullptr);\n    addLoader(\n        ( M_IS_NRV2E(ph.method) ? \"NRV_HEAD,NRV2E,NRV_TAIL\"\n        : M_IS_NRV2D(ph.method) ? \"NRV_HEAD,NRV2D,NRV_TAIL\"\n        : M_IS_NRV2B(ph.method) ? \"NRV_HEAD,NRV2B,NRV_TAIL\"\n        : M_IS_LZMA(ph.method)  ? \"LZMA_ELF00,LZMA_DEC20,LZMA_DEC30\"\n        : nullptr), nullptr);\n    if (hasLoaderSection(\"CFLUSH\"))\n        addLoader(\"CFLUSH\");\n    addLoader(\"MACHMAINY,IDENTSTR,+40,MACHMAINZ,FOLDEXEC\", nullptr);\n}\n\ntemplate <class T>\nvoid PackMachBase<T>::defineSymbols(Filter const *)\n{\n    // empty\n}\n\n\ntemplate <class T>\nvoid\nPackMachBase<T>::buildMachLoader(\n    upx_byte const *const proto,\n    unsigned        const szproto,\n    upx_byte const *const fold,\n    unsigned        const szfold,\n    Filter const *ft\n)\n{\n    initLoader(proto, szproto);\n\n    struct b_info h; memset(&h, 0, sizeof(h));\n    unsigned fold_hdrlen = 0;\n  if (0 < szfold) {\n    h.sz_unc = (szfold < fold_hdrlen) ? 0 : (szfold - fold_hdrlen);\n    h.b_method = (unsigned char) ph.method;\n    h.b_ftid = (unsigned char) ph.filter;\n    h.b_cto8 = (unsigned char) ph.filter_cto;\n  }\n    unsigned char const *const uncLoader = fold_hdrlen + fold;\n\n    MemBuffer cprLoader_buf(sizeof(h) + h.sz_unc);\n    unsigned char *const cprLoader = (unsigned char *)cprLoader_buf.getVoidPtr();\n  if (0 < szfold) {\n    unsigned sz_cpr = 0;\n    int r = upx_compress(uncLoader, h.sz_unc, sizeof(h) + cprLoader, &sz_cpr,\n        nullptr, ph.method, 10, nullptr, nullptr );\n    h.sz_cpr = sz_cpr;\n    if (r != UPX_E_OK || h.sz_cpr >= h.sz_unc)\n        throwInternalError(\"loader compression failed\");\n  }\n    memcpy(cprLoader, &h, sizeof(h));\n\n    // This adds the definition to the \"library\", to be used later.\n    linker->addSection(\"FOLDEXEC\", cprLoader, sizeof(h) + h.sz_cpr, 0);\n\n    int const GAP = 128;  // must match stub/l_mac_ppc.S\n    int const NO_LAP = 64;  // must match stub/src/*darwin*.S\n    segTEXT.vmsize = h.sz_unc - h.sz_cpr + GAP + NO_LAP;\n\n    addStubEntrySections(ft);\n\n    defineSymbols(ft);\n    relocateLoader();\n}\n\ntemplate <class T>\nvoid\nPackMachBase<T>::buildLoader(const Filter *ft)\n{\n    buildMachLoader(\n        stub_entry, sz_stub_entry,\n        stub_fold,  sz_stub_fold,  ft );\n}\n\ntemplate <class T>\nvoid PackMachBase<T>::patchLoader() { }\n\ntemplate <class T>\nvoid PackMachBase<T>::updateLoader(OutputFile *) {}\n\ntemplate <class T>\nvoid PackMachBase<T>::patchLoaderChecksum()\n{\n    unsigned char *const ptr = getLoader();\n    l_info *const lp = &linfo;\n    // checksum for loader; also some PackHeader info\n    lp->l_checksum = 0;\n    lp->l_magic = UPX_MAGIC_LE32;  // LE32 always\n    set_te16(&lp->l_lsize, (upx_uint16_t) lsize);\n    lp->l_version = (unsigned char) ph.version;\n    lp->l_format  = (unsigned char) ph.format;\n    // INFO: lp->l_checksum is currently unused\n    set_te32(&lp->l_checksum, upx_adler32(ptr, lsize));\n}\n\ntemplate <class T>\nint __acc_cdecl_qsort\nPackMachBase<T>::compare_segment_command(void const *const aa, void const *const bb)\n{\n    Mach_segment_command const *const a = (Mach_segment_command const *)aa;\n    Mach_segment_command const *const b = (Mach_segment_command const *)bb;\n    unsigned const lc_seg = lc_seg_info[sizeof(Addr)>>3].segment_cmd;\n    unsigned const xa = a->cmd - lc_seg;\n    unsigned const xb = b->cmd - lc_seg;\n           if (xa < xb)        return -1;  // LC_SEGMENT first\n           if (xa > xb)        return  1;\n    // Ascending by .fileoff so that find_SEGMENT_gap works\n    if (a->fileoff < b->fileoff)\n                               return -1;\n    if (a->fileoff > b->fileoff)\n                               return  1;\n    // Ascending by .vmaddr\n    if (a->vmaddr < b->vmaddr) return -1;\n    if (a->vmaddr > b->vmaddr) return  1;\n    // Descending by .vmsize\n    if ((a->vmsize != 0) != (b->vmsize != 0))\n        return (a->vmsize != 0) ? -1 : 1;\n    // What could remain?\n    // try to make sort order deterministic and just compare more fields\n#define CMP(field) \\\n    if (a->field != b->field) return a->field < b->field ? -1 : 1\n    CMP(vmsize);\n    CMP(cmdsize);\n    CMP(filesize);\n    CMP(maxprot);\n    CMP(initprot);\n    CMP(nsects);\n    CMP(flags);\n#undef CMP\n    return 0;\n}\n\n// At 2013-02-03 part of the source for codesign was\n//    http://opensource.apple.com/source/cctools/cctools-836/libstuff/ofile.c\n\nunsigned const blankLINK = 16;  // size of our empty __LINK segment\n// Note: \"readelf --segments\"  ==>  \"otool -hl\" or \"otool -hlv\" etc. (Xcode on MacOS)\n\ntemplate <class T>\nvoid PackMachBase<T>::pack4(OutputFile *fo, Filter &ft)  // append PackHeader\n{\n    // offset of p_info in compressed file\n    overlay_offset = secTEXT.offset + sizeof(linfo);\n    super::pack4(fo, ft);\n\n    if (Mach_header::MH_EXECUTE == my_filetype) {\n        unsigned len = fo->getBytesWritten();\n        MemBuffer page(my_page_size); memset(page, 0, my_page_size);\n        fo->write(page, ~my_page_mask & (0u - len));\n        len +=          ~my_page_mask & (0u - len) ;\n\n        segTEXT.filesize = len;\n        segTEXT.vmsize   = len;  // FIXME?  utilize GAP + NO_LAP + sz_unc - sz_cpr\n        secTEXT.offset = overlay_offset - sizeof(linfo);\n        secTEXT.addr = segTEXT.vmaddr   + secTEXT.offset;\n        secTEXT.size = segTEXT.filesize - secTEXT.offset;\n        secXHDR.offset = overlay_offset - sizeof(linfo);\n        if (my_filetype==Mach_header::MH_EXECUTE) {\n            secXHDR.offset -= sizeof(linkitem);\n        }\n        secXHDR.addr += secXHDR.offset;\n        unsigned offLINK = segLINK.fileoff;\n\n\n        segLINK.fileoff = len;  // must be in the file\n        segLINK.vmaddr =  len + segTEXT.vmaddr;\n        fo->write(page, blankLINK); len += blankLINK;\n        segLINK.vmsize = my_page_size;\n        segLINK.filesize = blankLINK;\n\n        // Get a writeable copy of the stub to make editing easier.\n        ByteArray(upxstub, sz_stub_main);\n        memcpy(upxstub, stub_main, sz_stub_main);\n\n        Mach_header *const mhp = (Mach_header *)upxstub;\n        mhp->cpusubtype = my_cpusubtype;\n        mhp->flags = mhdro.flags;\n        char *tail = (char *)(1+ mhp);\n        char *const lcp_end = mhdro.sizeofcmds + tail;\n        Mach_command *lcp = (Mach_command *)(1+ mhp);\n        Mach_command *lcp_next;\n        unsigned const ncmds = mhdro.ncmds;\n        //unsigned cmdsize = mhdro.sizeofcmds;\n        unsigned delta = 0;\n\n    for (unsigned j = 0; j < ncmds; ++j) {\n        unsigned skip = 0;\n        unsigned sz_cmd = lcp->cmdsize;\n        lcp_next = (Mach_command *)(sz_cmd + (char *)lcp);\n\n        switch (lcp->cmd) {\n        case Mach_command::LC_SEGMENT: // fall through\n        case Mach_command::LC_SEGMENT_64: {\n            Mach_segment_command *const segptr = (Mach_segment_command *)lcp;\n            if (!strcmp(\"__PAGEZERO\", segptr->segname)) {\n                segptr->vmsize = pagezero_vmsize;\n            }\n            if (!strcmp(\"__TEXT\", segptr->segname)) {\n                sz_cmd = (segTEXT.nsects * sizeof(secTEXT)) + sizeof(segTEXT);\n                mhp->sizeofcmds += sizeof(secTEXT) * (1 - segptr->nsects);\n                memcpy(tail, &segTEXT, sz_cmd); tail += sz_cmd;\n                goto next;\n            }\n            if (!strcmp(\"__LINKEDIT\", segptr->segname)) {\n                segLINK.initprot = Mach_command::VM_PROT_READ;\n                delta = offLINK - segptr->fileoff;  // relocation constant\n\n                sz_cmd = sizeof(segLINK);\n                if (Mach_header::CPU_TYPE_I386==mhdri.cputype\n                &&  Mach_header::MH_EXECUTE==mhdri.filetype) {\n                    segLINK.maxprot = 0\n                        | Mach_command::VM_PROT_EXECUTE\n                        | Mach_command::VM_PROT_WRITE\n                        | Mach_command::VM_PROT_READ;\n                    segLINK.initprot = 0\n                        | Mach_command::VM_PROT_WRITE\n                        | Mach_command::VM_PROT_READ;\n                }\n                memcpy(tail, &segLINK, sz_cmd); tail += sz_cmd;\n                goto next;\n            }\n        } break;\n        case Mach_command::LC_DYLD_INFO_ONLY: {\n            Mach_dyld_info_only_command *p = (Mach_dyld_info_only_command *)lcp;\n            if (p->rebase_off)    p->rebase_off    += delta;\n            if (p->bind_off)      p->bind_off      += delta;\n            if (p->lazy_bind_off) p->lazy_bind_off += delta;\n            if (p->export_off)    p->export_off    += delta;\n                // But we don't want any exported symbols.\n                p->export_off = 0;\n                p->export_size = 0;\n            skip = 1;\n        } break;\n        case Mach_command::LC_SYMTAB: {\n            // Apple codesign requires that string table is last in the file.\n            Mach_symtab_command *p = (Mach_symtab_command *)lcp;\n            p->symoff = segLINK.filesize + segLINK.fileoff;\n            p->nsyms = 0;\n            p->stroff = segLINK.fileoff;\n            p->strsize = segLINK.filesize;\n            skip = 1;\n        } break;\n        case Mach_command::LC_DYSYMTAB: {\n            Mach_dysymtab_command *p = (Mach_dysymtab_command *)lcp;\n            if (p->tocoff)         p->tocoff         += delta;\n            if (p->modtaboff)      p->modtaboff      += delta;\n            if (p->extrefsymoff)   p->extrefsymoff   += delta;\n            if (p->indirectsymoff) p->indirectsymoff += delta;\n            if (p->extreloff)      p->extreloff      += delta;\n            if (p->locreloff)      p->locreloff      += delta;\n                // But we don't want any symbols.\n                p->ilocalsym = 0;\n                p->nlocalsym = 0;\n                p->iextdefsym = 0;\n                p->nextdefsym = 0;\n                p->iundefsym = 0;\n                p->nundefsym = 0;\n            skip = 1;\n        } break;\n        case Mach_command::LC_MAIN: {\n                // Replace later with LC_UNIXTHREAD.\n// LC_MAIN requires libSystem.B.dylib to provide the environment for main(), and CALLs the entryoff.\n// LC_UNIXTHREAD does not need libSystem.B.dylib, and JMPs to the .rip with %rsp/argc and argv= 8+%rsp\n            threado_setPC(segTEXT.vmaddr +\n                (((Mach_main_command const *)lcp)->entryoff - segTEXT.fileoff));\n            skip = 1;\n        } break;\n        case Mach_command::LC_UNIXTHREAD: { // pre-LC_MAIN\n            skip = 1;\n        } break;\n        case Mach_command::LC_LOAD_DYLIB: {\n            skip = 1;\n        } break;\n\n        case Mach_command::LC_FUNCTION_STARTS:\n        case Mach_command::LC_DATA_IN_CODE: {\n            Mach_linkedit_data_command *p = (Mach_linkedit_data_command *)lcp;\n            if (p->dataoff) p->dataoff += delta;\n            skip = 1;\n        } break;\n        case Mach_command::LC_LOAD_DYLINKER: {\n            skip = 1;\n        } break;\n        case Mach_command::LC_SOURCE_VERSION: { // copy from saved original\n            memcpy(lcp, &cmdSRCVER, sizeof(cmdSRCVER));\n            if (Mach_command::LC_SOURCE_VERSION != cmdSRCVER.cmd) {\n                skip = 1;  // was not seen\n            }\n        } break;\n        case Mach_command::LC_VERSION_MIN_MACOSX: { // copy from saved original\n            memcpy(lcp, &cmdVERMIN, sizeof(cmdVERMIN));\n            if (Mach_command::LC_VERSION_MIN_MACOSX != cmdVERMIN.cmd) {\n                skip = 1;  // was not seen\n            }\n        } break;\n        } // end switch\n\n        if (skip) {\n            mhp->ncmds -= 1;\n            mhp->sizeofcmds -= sz_cmd;\n        }\n        else {\n            if (tail != (char *)lcp) {\n                memmove(tail, lcp, sz_cmd);\n            }\n            tail += sz_cmd;\n        }\nnext:\n        lcp = lcp_next;\n    }  // end for each Mach_command\n\n        // Append LC_UNIXTHREAD\n        unsigned const sz_threado = threado_size();\n        mhp->ncmds += 1;\n        mhp->sizeofcmds += sz_threado;\n        fo->seek(0, SEEK_SET);\n        fo->rewrite(mhp, tail - (char *)mhp);\n        threado_rewrite(fo);\n        tail += sz_threado;\n        //\n        // Zero any remaining tail.\n        if (tail < lcp_end) {\n            unsigned sz_cmd = lcp_end - tail;\n            memset(tail, 0, sz_cmd);\n            fo->rewrite(tail, sz_cmd);\n        }\n        // Rewrite linfo in file.\n        fo->seek(sz_mach_headers, SEEK_SET);\n        fo->rewrite(&linfo, sizeof(linfo));\n        fo->seek(0, SEEK_END);\n    }\n}\n\n// At 2013-02-03 part of the source for codesign was:\n//    http://opensource.apple.com/source/cctools/cctools-836/libstuff/ofile.c\n\ntemplate <class T>\nvoid PackMachBase<T>::pack4dylib(  // append PackHeader\n    OutputFile *const fo,\n    Filter &ft,\n    Addr init_address\n)\n{\n    fo->seek(0, SEEK_SET);\n    fo->rewrite(&mhdro, sizeof(mhdro));  // segTEXT.nsect=1 (only secTEXT)\n    fo->rewrite(&segTEXT, sizeof(segTEXT));  // .vmsize\n    unsigned opos = sizeof(mhdro);\n\n    // Append each non-__TEXT segment, page aligned.\n    int slide = 0;\n    unsigned o_end_txt = 0;\n    unsigned hdrpos = sizeof(mhdro);\n    Mach_segment_command const *seg = rawmseg;\n    Mach_segment_command const *const endseg =\n        (Mach_segment_command const *)(mhdri.sizeofcmds + (char const *)seg);\n    for ( ; seg < endseg; seg = (Mach_segment_command const *)(\n            seg->cmdsize + (char const *)seg )\n    ) switch (seg->cmd & ~Mach_command::LC_REQ_DYLD) {\n    default:  // unknown if any file offset field must slide\n        fprintf(stderr, \"Unrecognized Macho cmd  offset=0x%lx  cmd=0x%lx  size=0x%lx\\n\",\n            (unsigned long)((const char *)seg - (const char *)rawmseg),\n            (unsigned long)seg->cmd, (unsigned long)seg->cmdsize);\n        // fall through\n    case Mach_command::LC_VERSION_MIN_MACOSX:\n    case Mach_command::LC_SOURCE_VERSION:\n    case Mach_command::LC_THREAD:\n    case Mach_command::LC_UNIXTHREAD:\n    case Mach_command::LC_LOAD_DYLIB:\n    case Mach_command::LC_ID_DYLIB:\n    case Mach_command::LC_LOAD_DYLINKER:\n    case Mach_command::LC_UUID:\n    case Mach_command::LC_RPATH:\n    case Mach_command::LC_REEXPORT_DYLIB: { // contain no file offset fields\n        fo->seek(hdrpos, SEEK_SET);\n        fo->rewrite(seg, seg->cmdsize);\n        hdrpos += seg->cmdsize;\n    } break;\n\n    case Mach_command::LC_CODE_SIGNATURE:\n    case Mach_command::LC_SEGMENT_SPLIT_INFO:\n    case Mach_command::LC_DYLIB_CODE_SIGN_DRS:\n    case Mach_command::LC_DATA_IN_CODE:\n    case Mach_command::LC_FUNCTION_STARTS: {\n        Mach_linkedit_data_command cmd; memcpy(&cmd, seg, sizeof(cmd));\n        if (o_end_txt <= cmd.dataoff) { cmd.dataoff += slide; }\n        fo->seek(hdrpos, SEEK_SET);\n        fo->rewrite(&cmd, sizeof(cmd));\n        hdrpos += sizeof(cmd);\n    } break;\n    case Mach_command::LC_DYLD_INFO_ONLY & ~Mach_command::LC_REQ_DYLD: {\n        Mach_dyld_info_only_command cmd; memcpy(&cmd, seg, sizeof(cmd));\n        if (o_end_txt <= cmd.rebase_off)    { cmd.rebase_off    += slide; }\n        if (o_end_txt <= cmd.bind_off)      { cmd.bind_off      += slide; }\n        if (o_end_txt <= cmd.weak_bind_off) { cmd.weak_bind_off += slide; }\n        if (o_end_txt <= cmd.lazy_bind_off) { cmd.lazy_bind_off += slide; }\n        if (o_end_txt <= cmd.export_off)    { cmd.export_off    += slide; }\n        fo->seek(hdrpos, SEEK_SET);\n        fo->rewrite(&cmd, sizeof(cmd));\n        hdrpos += sizeof(cmd);\n    } break;\n    case Mach_command::LC_TWOLEVEL_HINTS: {\n        Mach_twolevel_hints_command cmd; memcpy(&cmd, seg, sizeof(cmd));\n        if (o_end_txt <= cmd.offset) { cmd.offset += slide; }\n        fo->seek(hdrpos, SEEK_SET);\n        fo->rewrite(&cmd, sizeof(cmd));\n        hdrpos += sizeof(cmd);\n    } break;\n    case Mach_command::LC_ROUTINES_64:\n    case Mach_command::LC_ROUTINES: {\n        Mach_routines_command cmd; memcpy(&cmd, seg, sizeof(cmd));\n        cmd.reserved1 = cmd.init_address;\n        cmd.init_address = init_address;\n        fo->seek(hdrpos, SEEK_SET);\n        fo->rewrite(&cmd, sizeof(cmd));\n        hdrpos += sizeof(cmd);\n    } break;\n    case Mach_command::LC_SEGMENT_64:\n    case Mach_command::LC_SEGMENT: {\n        // non-__TEXT might be observed and relocated by dyld before us.\n        Mach_segment_command segcmdtmp = *seg;\n        bool const is_text = 0==strncmp(&seg->segname[0], \"__TEXT\", 1+ 6);\n        {\n            if (is_text) {\n                slide = 0;\n                segTEXT.vmsize = segTEXT.filesize = fo->getBytesWritten();\n                segTEXT.maxprot  |= Mach_command::VM_PROT_WRITE;\n                segcmdtmp = segTEXT;\n                opos = o_end_txt = segcmdtmp.filesize + segcmdtmp.fileoff;\n            }\n            else {\n                opos += ~my_page_mask & (0u - opos);  // advance to my_page_size boundary\n                slide = opos - segcmdtmp.fileoff;\n                segcmdtmp.fileoff = opos;\n            }\n\n            fo->seek(hdrpos, SEEK_SET);\n            fo->rewrite(&segcmdtmp, sizeof(segcmdtmp));\n            hdrpos += sizeof(segcmdtmp);\n\n            // Update the sections.\n            Mach_section_command const *secp =\n                (Mach_section_command const *)(const void*)(const char*)(1+ seg);\n            if (is_text) {\n                secTEXT.offset = secp->offset;\n                secTEXT.addr = segTEXT.vmaddr   + secTEXT.offset;\n                secTEXT.size = segTEXT.filesize - secTEXT.offset;\n                secp = &secTEXT;\n            }\n            unsigned const nsects = (is_text ? 1 : segcmdtmp.nsects);\n            Mach_section_command seccmdtmp;\n            for (unsigned j = 0; j < nsects; ++secp, ++j) {\n                seccmdtmp = *secp;\n                if (o_end_txt <= seccmdtmp.offset) { seccmdtmp.offset += slide; }\n                if (o_end_txt <= seccmdtmp.reloff) { seccmdtmp.reloff += slide; }\n                fo->rewrite(&seccmdtmp, sizeof(seccmdtmp));\n                hdrpos += sizeof(seccmdtmp);\n            }\n\n            if (!is_text) {\n                unsigned const len = seg->filesize;\n                MemBuffer data(len);\n                fi->seek(seg->fileoff, SEEK_SET);\n                fi->readx(data, len);\n                unsigned const pos = o__mod_init_func - seg->fileoff;\n                if (pos < seg->filesize) {\n                    if (*(unsigned *)(pos + data) != (unsigned)prev_mod_init_func) {\n                        throwCantPack(\"__mod_init_func inconsistent\");\n                    }\n                    *(unsigned *)(pos + data) = (unsigned)entryVMA;\n                }\n                fo->seek(opos, SEEK_SET);\n                fo->write(data, len);\n                opos += len;\n            }\n        }\n    } break;\n    case Mach_command::LC_SYMTAB: {\n        Mach_symtab_command cmd; memcpy(&cmd, seg, sizeof(cmd));\n        if (o_end_txt <= cmd.symoff) { cmd.symoff += slide; }\n        if (o_end_txt <= cmd.stroff) { cmd.stroff += slide; }\n        fo->seek(hdrpos, SEEK_SET);\n        fo->rewrite(&cmd, sizeof(cmd));\n        hdrpos += sizeof(cmd);\n    } break;\n    case Mach_command::LC_DYSYMTAB: {\n        Mach_dysymtab_command cmd; memcpy(&cmd, seg, sizeof(cmd));\n        if (o_end_txt <= cmd.tocoff)         { cmd.tocoff         += slide; }\n        if (o_end_txt <= cmd.modtaboff)      { cmd.modtaboff      += slide; }\n        if (o_end_txt <= cmd.extrefsymoff)   { cmd.extrefsymoff   += slide; }\n        if (o_end_txt <= cmd.indirectsymoff) { cmd.indirectsymoff += slide; }\n        if (o_end_txt <= cmd.extreloff)      { cmd.extreloff      += slide; }\n        if (o_end_txt <= cmd.locreloff)      { cmd.locreloff      += slide; }\n        fo->seek(hdrpos, SEEK_SET);\n        fo->rewrite(&cmd, sizeof(cmd));\n        hdrpos += sizeof(cmd);\n    } break;\n    }  // end 'switch'\n    fo->seek(opos, SEEK_SET);  // BUG: \"fo->seek(0, SEEK_END);\" is broken\n\n    PackMachBase<T>::pack4(fo, ft);\n}\n\nvoid PackDylibI386::pack4(OutputFile *fo, Filter &ft)  // append PackHeader\n{\n    pack4dylib(fo, ft, threado.state.eip);\n}\n\nvoid PackDylibAMD64::pack4(OutputFile *fo, Filter &ft)  // append PackHeader\n{\n    pack4dylib(fo, ft, threado.state.rip);\n}\n\nvoid PackDylibPPC32::pack4(OutputFile *fo, Filter &ft)  // append PackHeader\n{\n    pack4dylib(fo, ft, threado.state.srr0);\n}\n\nvoid PackDylibPPC64::pack4(OutputFile *fo, Filter &ft)  // append PackHeader\n{\n    pack4dylib(fo, ft, threado.state64.srr0);\n}\n\ntemplate <class T>\noff_t PackMachBase<T>::pack3(OutputFile *fo, Filter &ft)  // append loader\n{\n    TE32 disp;\n    upx_uint64_t const zero = 0;\n    unsigned len = fo->getBytesWritten();\n    fo->write(&zero, 3& (0u-len));\n    len += (3& (0u-len));\n\n    disp = len;  // backward offset to Mach_header\n    fo->write(&disp, sizeof(disp));\n    len += sizeof(disp);\n\n    if (my_filetype!=Mach_header::MH_DYLIB) {\n        disp = len - sz_mach_headers;  // backward offset to start of compressed data\n        fo->write(&disp, sizeof(disp));\n        len += sizeof(disp);\n    }\n    segTEXT.vmsize = segTEXT.filesize;\n    threado_setPC(entryVMA= len + segTEXT.vmaddr);\n\n    return super::pack3(fo, ft);\n}\n\noff_t PackDylibI386::pack3(OutputFile *fo, Filter &ft)  // append loader\n{\n    TE32 disp;\n    upx_uint32_t const zero = 0;\n    off_t len = fo->getBytesWritten();\n    fo->write(&zero, 3& (0u-len));\n    len += (3& (0u-len)) + 4*sizeof(disp);\n\n    disp = prev_mod_init_func;\n    fo->write(&disp, sizeof(disp));  // user .init_address\n\n    disp = secTEXT.offset + sizeof(l_info) + sizeof(p_info);\n    fo->write(&disp, sizeof(disp));  // src offset(compressed __TEXT)\n\n    disp = len - disp - 3*sizeof(disp);\n    fo->write(&disp, sizeof(disp));  // length(compressed __TEXT)\n\n    unsigned const save_sz_mach_headers(sz_mach_headers);\n    sz_mach_headers = 0;\n    len = super::pack3(fo, ft);\n    sz_mach_headers = save_sz_mach_headers;\n    return len;\n}\n\noff_t PackDylibAMD64::pack3(OutputFile *fo, Filter &ft)  // append loader\n{\n    TE32 disp;\n    upx_uint64_t const zero = 0;\n    off_t len = fo->getBytesWritten();\n    fo->write(&zero, 3& (0u-len));\n    // len += (3& (0u-len)) + 3*sizeof(disp);\n\n    disp = prev_mod_init_func;\n    fo->write(&disp, sizeof(disp));  // user .init_address\n\n    disp = secTEXT.offset + sizeof(l_info) + sizeof(p_info);\n    fo->write(&disp, sizeof(disp));  // src offset(b_info)\n\n    disp = rawmseg[0].vmsize;\n    fo->write(&disp, sizeof(disp));  // __TEXT.vmsize when expanded\n\n    unsigned const save_sz_mach_headers(sz_mach_headers);\n    sz_mach_headers = 0;\n    len = super::pack3(fo, ft);\n    sz_mach_headers = save_sz_mach_headers;\n    return len;\n}\n\noff_t PackDylibPPC32::pack3(OutputFile *fo, Filter &ft)  // append loader\n{\n    TE32 disp;\n    upx_uint32_t const zero = 0;\n    off_t len = fo->getBytesWritten();\n    fo->write(&zero, 3& (0u-len));\n    len += (3& (0u-len)) + 4*sizeof(disp);\n\n    disp = prev_mod_init_func;\n    fo->write(&disp, sizeof(disp));  // user .init_address\n\n    disp = secTEXT.offset + sizeof(l_info) + sizeof(p_info);\n    fo->write(&disp, sizeof(disp));  // src offset(compressed __TEXT)\n\n    disp = len - disp - 3*sizeof(disp);\n    fo->write(&disp, sizeof(disp));  // length(compressed __TEXT)\n\n    unsigned const save_sz_mach_headers(sz_mach_headers);\n    sz_mach_headers = 0;\n    len = super::pack3(fo, ft);\n    sz_mach_headers = save_sz_mach_headers;\n    return len;\n}\n\noff_t PackDylibPPC64::pack3(OutputFile *fo, Filter &ft)  // append loader\n{\n    TE64 disp;\n    upx_uint64_t const zero = 0;\n    off_t len = fo->getBytesWritten();\n    fo->write(&zero, 3& (0u-len));\n    len += (3& (0u-len)) + 4*sizeof(disp);\n\n    disp = prev_mod_init_func;\n    fo->write(&disp, sizeof(disp));  // user .init_address\n\n    disp = secTEXT.offset + sizeof(l_info) + sizeof(p_info);\n    fo->write(&disp, sizeof(disp));  // src offset(compressed __TEXT)\n\n    disp = len - disp - 3*sizeof(disp);\n    fo->write(&disp, sizeof(disp));  // length(compressed __TEXT)\n\n    unsigned const save_sz_mach_headers(sz_mach_headers);\n    sz_mach_headers = 0;\n    len = super::pack3(fo, ft);\n    sz_mach_headers = save_sz_mach_headers;\n    return len;\n}\n\n// Determine length of gap between PT_LOAD phdri[k] and closest PT_LOAD\n// which follows in the file (or end-of-file).  Optimize for common case\n// where the PT_LOAD are adjacent ascending by .p_offset.  Assume no overlap.\n\ntemplate <class T>\nunsigned PackMachBase<T>::find_SEGMENT_gap(\n    unsigned const k, unsigned pos_eof\n)\n{\n    unsigned const lc_seg = lc_seg_info[sizeof(Addr)>>3].segment_cmd;\n    if (lc_seg!=msegcmd[k].cmd\n    ||  0==msegcmd[k].filesize ) {\n        return 0;\n    }\n    unsigned const hi = msegcmd[k].fileoff + msegcmd[k].filesize;\n    unsigned lo = pos_eof;\n    unsigned j = k;\n    for (;;) { // circular search, optimize for adjacent ascending\n        ++j;\n        if (n_segment==j) {\n            j = 0;\n        }\n        if (k==j) {\n            break;\n        }\n        if (lc_seg==msegcmd[j].cmd\n        &&  0!=msegcmd[j].filesize ) {\n            unsigned const t = (unsigned) msegcmd[j].fileoff;\n            if ((t - hi) < (lo - hi)) {\n                lo = t;\n                if (hi==lo) {\n                    break;\n                }\n            }\n        }\n    }\n    return lo - hi;\n}\n\ntemplate <class T>\nint  PackMachBase<T>::pack2(OutputFile *fo, Filter &ft)  // append compressed body\n{\n    unsigned const lc_seg = lc_seg_info[sizeof(Addr)>>3].segment_cmd;\n    Extent x;\n    unsigned k;\n\n    // count passes, set ptload vars\n    uip->ui_total_passes = 0;\n    for (k = 0; k < n_segment; ++k) {\n        if (lc_seg==msegcmd[k].cmd\n        &&  0!=msegcmd[k].filesize ) {\n            uip->ui_total_passes++;\n            if (my_filetype==Mach_header::MH_DYLIB) {\n                break;\n            }\n            if (find_SEGMENT_gap(k, fi->st_size())) {\n                uip->ui_total_passes++;\n            }\n        }\n    }\n\n    // compress extents\n    total_in = 0;\n    total_out = 0;\n\n    unsigned hdr_u_len = mhdri.sizeofcmds + sizeof(mhdri);\n\n    uip->ui_pass = 0;\n    ft.addvalue = 0;\n\n    // Packer::compressWithFilters chooses a filter for us, and the stubs\n    // can handle only one filter, and most filters are for executable\n    // instructions.  So filter only the largest executable segment.\n    unsigned exe_filesize_max = 0;\n    for (k = 0; k < n_segment; ++k)\n    if (lc_seg==msegcmd[k].cmd\n    &&  0!=(Mach_command::VM_PROT_EXECUTE & msegcmd[k].initprot)\n    &&  exe_filesize_max < msegcmd[k].filesize) {\n        exe_filesize_max = (unsigned) msegcmd[k].filesize;\n    }\n\n    int nx = 0;\n    for (k = 0; k < n_segment; ++k)\n    if (lc_seg==msegcmd[k].cmd\n    &&  0!=msegcmd[k].filesize ) {\n        x.offset = msegcmd[k].fileoff;\n        x.size   = msegcmd[k].filesize;\n        if (0 == nx) { // 1st LC_SEGMENT must cover Mach_header at 0==fileoffset\n            unsigned const delta = mhdri.sizeofcmds + sizeof(mhdri);\n            x.offset    += delta;\n            x.size      -= delta;\n        }\n        bool const do_filter = (msegcmd[k].filesize==exe_filesize_max)\n            && 0!=(Mach_command::VM_PROT_EXECUTE & msegcmd[k].initprot);\n        Mach_segment_command const *ptr = rawmseg;\n        unsigned b_extra = 0;\n        for (unsigned j= 0; j < mhdri.ncmds; ++j) {\n            if (msegcmd[k].cmd    == ptr->cmd\n            &&  msegcmd[k].vmaddr == ptr->vmaddr\n            &&  msegcmd[k].vmsize == ptr->vmsize) {\n                b_extra = j;\n                break;\n            }\n            ptr = (Mach_segment_command const *)(ptr->cmdsize + (char const *)ptr);\n        }\n        packExtent(x,\n            (do_filter ? &ft : nullptr), fo, hdr_u_len, b_extra );\n        if (do_filter) {\n            exe_filesize_max = 0;\n        }\n        hdr_u_len = 0;\n        ++nx;\n        if (my_filetype==Mach_header::MH_DYLIB) {\n            break;\n        }\n    }\n    if (my_filetype!=Mach_header::MH_DYLIB)\n    for (k = 0; k < n_segment; ++k) {\n        x.size = find_SEGMENT_gap(k, fi->st_size());\n        if (x.size) {\n            x.offset = msegcmd[k].fileoff +msegcmd[k].filesize;\n            packExtent(x, nullptr, fo);\n        }\n    }\n\n    if (my_filetype!=Mach_header::MH_DYLIB)\n    if ((off_t)total_in != file_size)\n        throwEOFException();\n    segTEXT.filesize = fo->getBytesWritten();\n    secTEXT.size = segTEXT.filesize - overlay_offset + sizeof(linfo);\n\n    return 1;\n}\n\nvoid PackMachPPC32::pack1_setup_threado(OutputFile *const fo)\n{\n    threado.cmd = Mach_command::LC_UNIXTHREAD;\n    threado.cmdsize = sizeof(threado);\n    threado.flavor = my_thread_flavor;\n    threado.count =  my_thread_state_word_count;\n    memset(&threado.state, 0, sizeof(threado.state));\n    fo->write(&threado, sizeof(threado));\n}\n\nvoid PackMachPPC64::pack1_setup_threado(OutputFile *const fo)\n{\n    threado.cmd = Mach_command::LC_UNIXTHREAD;\n    threado.cmdsize = sizeof(threado);\n    threado.flavor = my_thread_flavor;\n    threado.count =  my_thread_state_word_count;\n    memset(&threado.state64, 0, sizeof(threado.state64));\n    fo->write(&threado, sizeof(threado));\n}\n\nvoid PackMachI386::pack1_setup_threado(OutputFile *const fo)\n{\n    threado.cmd = Mach_command::LC_UNIXTHREAD;\n    threado.cmdsize = sizeof(threado);\n    threado.flavor = my_thread_flavor;\n    threado.count =  my_thread_state_word_count;\n    memset(&threado.state, 0, sizeof(threado.state));\n    fo->write(&threado, sizeof(threado));\n}\n\nvoid PackMachAMD64::pack1_setup_threado(OutputFile *const fo)\n{\n    threado.cmd = Mach_command::LC_UNIXTHREAD;\n    threado.cmdsize = sizeof(threado);\n    threado.flavor = my_thread_flavor;\n    threado.count =  my_thread_state_word_count;\n    memset(&threado.state, 0, sizeof(threado.state));\n    fo->write(&threado, sizeof(threado));\n}\n\nvoid PackMachARMEL::pack1_setup_threado(OutputFile *const fo)\n{\n    threado.cmd = Mach_command::LC_UNIXTHREAD;\n    threado.cmdsize = sizeof(threado);\n    threado.flavor = my_thread_flavor;\n    threado.count =  my_thread_state_word_count;\n    memset(&threado.state, 0, sizeof(threado.state));\n    fo->write(&threado, sizeof(threado));\n}\n\nvoid PackMachARM64EL::pack1_setup_threado(OutputFile *const fo)\n{\n    threado.cmd = Mach_command::LC_UNIXTHREAD;\n    threado.cmdsize = sizeof(threado);\n    threado.flavor = my_thread_flavor;\n    threado.count =  my_thread_state_word_count;\n    memset(&threado.state, 0, sizeof(threado.state));\n    fo->write(&threado, sizeof(threado));\n}\n\ntemplate <class T>\nvoid PackMachBase<T>::pack1(OutputFile *const fo, Filter &/*ft*/)  // generate executable header\n{\n    unsigned const lc_seg = lc_seg_info[sizeof(Addr)>>3].segment_cmd;\n    mhdro = mhdri;\n    if (my_filetype==Mach_header::MH_EXECUTE) {\n        memcpy(&mhdro, stub_main, sizeof(mhdro));\n        mhdro.flags = mhdri.flags & ~(\n              Mach_header::MH_DYLDLINK  // no dyld at this time\n            | Mach_header::MH_TWOLEVEL  // dyld-specific\n            | Mach_header::MH_BINDATLOAD  // dyld-specific\n            );\n        COMPILE_TIME_ASSERT(sizeof(mhdro.flags) == sizeof(unsigned))\n    }\n    unsigned pos = sizeof(mhdro);\n    fo->write(&mhdro, sizeof(mhdro));\n\n    memset(&segZERO, 0, sizeof(segZERO));\n    segZERO.cmd = lc_seg;\n    segZERO.cmdsize = sizeof(segZERO);\n    strncpy((char *)segZERO.segname, \"__PAGEZERO\", sizeof(segZERO.segname));\n    segZERO.vmsize = pagezero_vmsize;\n\n    segTEXT.cmd = lc_seg;\n    segTEXT.cmdsize = sizeof(segTEXT) + sizeof(secTEXT);\n    strncpy((char *)segTEXT.segname, \"__TEXT\", sizeof(segTEXT.segname));\n    if (my_filetype==Mach_header::MH_EXECUTE) {\n        if (Mach_header::MH_PIE & mhdri.flags) {\n            segTEXT.vmaddr = segZERO.vmsize;  // contiguous\n        }\n        else { // not MH_PIE\n            // Start above all eventual mappings.\n            // Cannot enlarge segZERO.vmsize because MacOS 10.13 (HighSierra)\n            // won't permit re-map of PAGEZERO.\n            // Stub will fill with PROT_NONE first.\n            segTEXT.vmaddr = vma_max;\n        }\n    }\n    if (my_filetype==Mach_header::MH_DYLIB) {\n        segTEXT.vmaddr = 0;\n    }\n    segTEXT.vmsize = 0;    // adjust later\n    segTEXT.fileoff = 0;\n    segTEXT.filesize = 0;  // adjust later\n    segTEXT.maxprot =\n        Mach_command::VM_PROT_READ |\n        Mach_command::VM_PROT_WRITE |\n        Mach_command::VM_PROT_EXECUTE;\n    segTEXT.initprot =\n        Mach_command::VM_PROT_READ |\n        Mach_command::VM_PROT_EXECUTE;\n    segTEXT.nsects = 1;  // secTEXT\n    segTEXT.flags = 0;\n\n    memset(&secTEXT, 0, sizeof(secTEXT));\n    strncpy((char *)secTEXT.sectname, \"__text\", sizeof(secTEXT.sectname));\n    memcpy(secTEXT.segname, segTEXT.segname, sizeof(secTEXT.segname));\n    secTEXT.align = 2;  // (1<<2) ==> 4\n    secTEXT.flags = Mach_section_command::S_REGULAR\n        | Mach_section_command::S_ATTR_SOME_INSTRUCTIONS\n        | Mach_section_command::S_ATTR_PURE_INSTRUCTIONS;\n\n    segXHDR = segTEXT;\n    segXHDR.cmdsize = sizeof(segXHDR) + sizeof(secXHDR);\n    segXHDR.vmaddr = segZERO.vmsize;\n    segXHDR.vmsize = my_page_size;\n    segXHDR.filesize = my_page_size;\n    segXHDR.nsects = 1;\n    strncpy((char *)segXHDR.segname,  \"UPX_DATA\", sizeof(segXHDR.segname));\n\n    memset(&secXHDR, 0, sizeof(secXHDR));\n    strncpy((char *)secXHDR.sectname, \"upx_data\", sizeof(secXHDR.sectname));\n    memcpy(secXHDR.segname,  segXHDR.segname, sizeof(secXHDR.segname));\n    secXHDR.addr = segXHDR.vmaddr;\n    secXHDR.size = 0;  // empty so far\n    secXHDR.align = 2;  // (1<<2) ==> 4\n\n    segLINK = segTEXT;\n    segLINK.cmdsize = sizeof(segLINK);\n    strncpy((char *)segLINK.segname, \"__LINKEDIT\", sizeof(segLINK.segname));\n    segLINK.initprot = Mach_command::VM_PROT_READ;\n    segLINK.nsects = 0;\n    segLINK.vmsize = 0;\n    // Adjust later: .vmaddr .vmsize .fileoff .filesize\n\n    unsigned gap = 0;\n    if (my_filetype == Mach_header::MH_EXECUTE) {\n        unsigned cmdsize = mhdro.sizeofcmds;\n        Mach_header const *const ptr0 = (Mach_header const *)stub_main;\n        Mach_command const *ptr1 = (Mach_command const *)(1+ ptr0);\n        for (unsigned j = 0; j < mhdro.ncmds -1; ++j, (cmdsize -= ptr1->cmdsize),\n                ptr1 = (Mach_command const *)(ptr1->cmdsize + (char const *)ptr1)) {\n            if (lc_seg == ptr1->cmd) {\n                Mach_segment_command const *const segptr = (Mach_segment_command const *)ptr1;\n                Mach_section_command const *const secptr = (Mach_section_command const *)(1+ segptr);\n                if (!strcmp(\"__TEXT\", segptr->segname)) {\n                    strncpy((char *)secTEXT.segname,   \"__TEXT\", sizeof(secTEXT.segname));\n                    strncpy((char *)secTEXT.sectname, \"upxTEXT\", sizeof(secTEXT.sectname));\n                    secTEXT.addr   = secptr->addr;\n                    secTEXT.size   = secptr->size;  // update later\n                    secTEXT.offset = secptr->offset;\n                    secTEXT.align  = secptr->align;\n                }\n                if (!strcmp(\"__LINKEDIT\", segptr->segname)) {\n                    // Mach_command before __LINKEDIT\n                    pos += (char const *)ptr1 - (char const *)(1+ ptr0);\n                    fo->write((1+ ptr0), (char const *)ptr1 - (char const *)(1+ ptr0));\n\n                    // Mach_command __LINKEDIT and after\n                    pos += cmdsize;\n                    fo->write((char const *)ptr1, cmdsize);\n\n                    // 400: space for LC_UUID, LC_RPATH, LC_CODE_SIGNATURE, etc.\n                    gap = 400 + threado_size();\n                    secTEXT.offset = gap + pos;\n                    secTEXT.addr = secTEXT.offset + segTEXT.vmaddr;\n                    break;\n                }\n            }\n        }\n        unsigned const sz_threado = threado_size();\n        MemBuffer space(sz_threado); memset(space, 0, sz_threado);\n        fo->write(space, sz_threado);\n        UNUSED(cmdsize);\n    }\n    else if (my_filetype == Mach_header::MH_DYLIB) {\n        Mach_command const *ptr = (Mach_command const *)rawmseg;\n        unsigned cmdsize = mhdri.sizeofcmds;\n        for (unsigned j = 0; j < mhdri.ncmds; ++j, (cmdsize -= ptr->cmdsize),\n                ptr = (Mach_command const *)(ptr->cmdsize + (char const *)ptr)) {\n            if (lc_seg == ptr->cmd) {\n                Mach_segment_command const *const segptr = (Mach_segment_command const *)ptr;\n                Mach_section_command const *const secptr = (Mach_section_command const *)(1+ segptr);\n                if (!strcmp(\"__TEXT\", segptr->segname)) {\n                    if (!(1 <= segptr->nsects)) {\n                        throwCantPack(\"TEXT.nsects == 0\");\n                    }\n                    strncpy((char *)secTEXT.sectname, \"upxTEXT\", sizeof(secTEXT.sectname));\n                    secTEXT.addr   = secptr->addr;\n                    secTEXT.size   = secptr->size;  // update later\n                    secTEXT.offset = secptr->offset;\n                    secTEXT.align  = secptr->align;\n                    fo->write(&segTEXT, sizeof(segTEXT));\n                    fo->write(&secTEXT, sizeof(secTEXT));\n                }\n                else { // not __TEXT\n                    fo->write(ptr, ptr->cmdsize);\n                }\n            }\n            else { // not LC_SEGMENT*\n                fo->write(ptr, ptr->cmdsize);\n            }\n        }\n        memset(&linkitem, 0, sizeof(linkitem));\n        fo->write(&linkitem, sizeof(linkitem));\n        UNUSED(cmdsize);\n    }\n    sz_mach_headers = fo->getBytesWritten();\n    gap = secTEXT.offset - sz_mach_headers;\n    MemBuffer filler(gap); filler.clear();\n    fo->write(filler, gap);\n    sz_mach_headers += gap;\n\n    memset((char *)&linfo, 0, sizeof(linfo));\n    fo->write(&linfo, sizeof(linfo));\n\n    return;\n}\n\n#define WANT_MACH_HEADER_ENUM 1\n#include \"p_mach_enum.h\"\n\n#define MAX_N_CMDS 256\n\ntemplate <class T>\nvoid PackMachBase<T>::unpack(OutputFile *fo)\n{\n    unsigned const lc_seg = lc_seg_info[sizeof(Addr)>>3].segment_cmd;\n    fi->seek(0, SEEK_SET);\n    fi->readx(&mhdri, sizeof(mhdri));\n    if ((MH_MAGIC + (sizeof(Addr)>>3)) != mhdri.magic\n    &&  Mach_fat_header::FAT_MAGIC != mhdri.magic) {\n        throwCantUnpack(\"file header corrupted\");\n    }\n    unsigned const sz_cmds = mhdri.sizeofcmds;\n    if ((sizeof(mhdri) + sz_cmds) > (size_t)fi->st_size()) {\n        throwCantUnpack(\"file header corrupted\");\n    }\n    rawmseg_buf.dealloc();  // discard \"same\" contents from ::canUnpack()\n    rawmseg_buf.alloc(sz_cmds);\n    rawmseg = (Mach_segment_command *)rawmseg_buf.getVoidPtr();\n    fi->readx(rawmseg, mhdri.sizeofcmds);\n\n    // FIXME forgot space left for LC_CODE_SIGNATURE;\n    // but canUnpack() sets overlay_offset anyway.\n    //overlay_offset = sizeof(mhdri) + mhdri.sizeofcmds + sizeof(linfo);\n\n    fi->seek(overlay_offset, SEEK_SET);\n    p_info hbuf;\n    fi->readx(&hbuf, sizeof(hbuf));\n    unsigned const orig_file_size = get_te32(&hbuf.p_filesize);\n    blocksize = get_te32(&hbuf.p_blocksize);  // emacs-21.2.1 was 0x01d47e6c (== 30703212)\n    if (blocksize > orig_file_size || blocksize > UPX_RSIZE_MAX_MEM)\n        throwCantUnpack(\"file header corrupted\");\n    if (file_size > (off_t)orig_file_size) {\n        opt->info_mode += !opt->info_mode ? 1 : 0;  // make visible\n        opt->backup = 1;\n        infoWarning(\"packed size too big; discarding appended data, keeping backup\");\n    }\n\n    ibuf.alloc(blocksize + OVERHEAD);\n    b_info bhdr; memset(&bhdr, 0, sizeof(bhdr));\n    fi->readx(&bhdr, sizeof(bhdr));\n    ph.u_len = get_te32(&bhdr.sz_unc);\n    ph.c_len = get_te32(&bhdr.sz_cpr);\n    if ((unsigned)file_size < ph.c_len || ph.c_len == 0 || ph.u_len == 0)\n        throwCantUnpack(\"file header corrupted\");\n    ph.method = bhdr.b_method;\n    if (ph.method < M_NRV2B_LE32\n    ||  ph.method > M_BZIP2)\n        throwCantUnpack(\"file header bad method\");\n    ph.filter = bhdr.b_ftid;\n    ph.filter_cto = bhdr.b_cto8;\n\n    // Uncompress Macho headers\n    fi->readx(ibuf, ph.c_len);\n    MemBuffer mhdr_buf(ph.u_len);\n    Mach_header *const mhdr = (Mach_header *)mhdr_buf.getVoidPtr();\n    decompress(ibuf, (upx_byte *)mhdr, false);\n    if (mhdri.magic      != mhdr->magic\n    ||  mhdri.cputype    != mhdr->cputype\n    ||  mhdri.cpusubtype != mhdr->cpusubtype\n    ||  mhdri.filetype   != mhdr->filetype)\n        throwCantUnpack(\"file header corrupted\");\n    unsigned const ncmds = mhdr->ncmds;\n    if (!ncmds || MAX_N_CMDS < ncmds) { // arbitrary limit\n        char msg[40]; snprintf(msg, sizeof(msg),\n            \"bad Mach_header.ncmds = %d\", ncmds);\n        throwCantUnpack(msg);\n    }\n\n    msegcmd_buf.alloc(sizeof(Mach_segment_command) * ncmds);\n    msegcmd = (Mach_segment_command *)msegcmd_buf.getVoidPtr();\n    unsigned char const *ptr = (unsigned char const *)(1+mhdr);\n    unsigned headway = mhdr_buf.getSize() - sizeof(*mhdr);\n    for (unsigned j= 0; j < ncmds; ++j) {\n        unsigned cmdsize = ((Mach_command const *)ptr)->cmdsize;\n        if (is_bad_linker_command( ((Mach_command const *)ptr)->cmd, cmdsize,\n                headway, lc_seg, sizeof(Addr))) {\n            char msg[50]; snprintf(msg, sizeof(msg),\n                \"bad packed Mach load_command @%#x\", ptr_udiff_bytes(ptr, mhdr));\n            throwCantUnpack(msg);\n        }\n        memcpy(&msegcmd[j], ptr, upx::umin(usizeof(Mach_segment_command), cmdsize));\n        headway -= cmdsize;\n        ptr     += cmdsize;\n    }\n\n    // Put LC_SEGMENT together at the beginning\n    upx_qsort(msegcmd, ncmds, sizeof(*msegcmd), compare_segment_command);\n    n_segment = 0;\n    for (unsigned j= 0; j < ncmds; ++j) {\n        n_segment += (lc_seg==msegcmd[j].cmd);\n    }\n\n    total_in = 0;\n    total_out = 0;\n    unsigned c_adler = upx_adler32(nullptr, 0);\n    unsigned u_adler = upx_adler32(nullptr, 0);\n\n    fi->seek(- (off_t)(sizeof(bhdr) + ph.c_len), SEEK_CUR);\n    for (unsigned k = 0; k < ncmds; ++k) {\n        if (msegcmd[k].cmd==lc_seg && msegcmd[k].filesize!=0) {\n            if (!strcmp(\"__TEXT\", msegcmd[k].segname)) {\n                segTEXT = msegcmd[k];\n            }\n            if (fo)\n                fo->seek(msegcmd[k].fileoff, SEEK_SET);\n            unpackExtent(msegcmd[k].filesize, fo,\n                c_adler, u_adler, false, sizeof(bhdr));\n            if (my_filetype==Mach_header::MH_DYLIB) {\n                break;  // only the first lc_seg when MH_DYLIB\n            }\n        }\n    }\n    Mach_segment_command const *sc = (Mach_segment_command const *)(void *)(1+ mhdr);\n    if (my_filetype==Mach_header::MH_DYLIB) { // rest of lc_seg are not compressed\n        upx_uint64_t cpr_mod_init_func(0);\n                TE32 unc_mod_init_func; *(int *)&unc_mod_init_func = 0;\n        Mach_segment_command const *rc = rawmseg;\n        rc = (Mach_segment_command const *)(rc->cmdsize + (char const *)rc);\n        sc = (Mach_segment_command const *)(sc->cmdsize + (char const *)sc);\n        for (\n            unsigned k=1;  // skip first lc_seg, which was uncompressed above\n            k < ncmds;\n            (++k), (sc = (Mach_segment_command const *)(sc->cmdsize + (char const *)sc)),\n                   (rc = (Mach_segment_command const *)(rc->cmdsize + (char const *)rc))\n        ) {\n            if (lc_seg==rc->cmd\n            &&  0!=rc->filesize ) {\n                if (!strcmp(\"__DATA\", rc->segname)) {\n                    cpr_mod_init_func = get_mod_init_func(rc);\n                    fi->seek(cpr_mod_init_func - 4*sizeof(TE32), SEEK_SET);\n                    fi->readx(&unc_mod_init_func, sizeof(unc_mod_init_func));\n                }\n                fi->seek(rc->fileoff, SEEK_SET);\n                if (fo)\n                    fo->seek(sc->fileoff, SEEK_SET);\n                unsigned const len = rc->filesize;\n                MemBuffer data(len);\n                fi->readx(data, len);\n                if (!strcmp(\"__DATA\", rc->segname)) {\n                    set_te32(&data[o__mod_init_func - rc->fileoff], unc_mod_init_func);\n                }\n                if (fo)\n                    fo->write(data, len);\n            }\n        }\n    }\n    else\n    for (unsigned j = 0; j < ncmds; ++j) {\n        unsigned const size = find_SEGMENT_gap(j, orig_file_size);\n        if (size) {\n            unsigned const where = msegcmd[j].fileoff +msegcmd[j].filesize;\n            if (fo)\n                fo->seek(where, SEEK_SET);\n            unpackExtent(size, fo,\n                c_adler, u_adler, false, sizeof(bhdr));\n        }\n    }\n}\n\n// The prize is the value of overlay_offset: the offset of compressed data\ntemplate <class T>\ntribool PackMachBase<T>::canUnpack()\n{\n    unsigned const lc_seg = lc_seg_info[sizeof(Addr)>>3].segment_cmd;\n    fi->seek(0, SEEK_SET);\n    fi->readx(&mhdri, sizeof(mhdri));\n\n    if (((unsigned) Mach_header::MH_MAGIC + (sizeof(Addr)>>3)) !=mhdri.magic\n    ||  my_cputype   !=mhdri.cputype\n    ||  my_filetype  !=mhdri.filetype\n    )\n        return false;\n    my_cpusubtype = mhdri.cpusubtype;\n\n    unsigned const ncmds = mhdri.ncmds;\n    int headway = (int)mhdri.sizeofcmds;\n    if (!ncmds || MAX_N_CMDS < ncmds || file_size < headway\n     ||  headway < 4*4 ) {\n        char msg[80]; snprintf(msg, sizeof(msg),\n            \"bad Mach_header ncmds=%d  sizeofcmds=0x%x\", ncmds, headway);\n        throwCantUnpack(msg);\n    }\n    // old style:   LC_SEGMENT + LC_UNIXTHREAD  [smaller, varies by $ARCH]\n    // new style: 3*LC_SEGMENT + LC_MAIN        [larger]\n    if ((2 == ncmds\n        && headway < (int)(sizeof(Mach_segment_command) + 4*4))\n    ||  (3 <= ncmds\n        && headway < (int)(3 * sizeof(Mach_segment_command)\n                    + sizeof(Mach_main_command)))) {\n        infoWarning(\"Mach_header.sizeofcmds = %d too small\", headway);\n        throwCantUnpack(\"file corrupted\");\n    }\n    sz_mach_headers = headway + sizeof(mhdri);\n    if (2048 < headway) {\n        infoWarning(\"Mach_header.sizeofcmds(%d) > 2048\", headway);\n    }\n    if (!headway) {\n        throwCantPack(\"Mach_header.sizeofcmds == 0\");\n    }\n    rawmseg_buf.alloc(mhdri.sizeofcmds);\n    rawmseg = (Mach_segment_command *)rawmseg_buf.getVoidPtr();\n    fi->readx(rawmseg, mhdri.sizeofcmds);\n\n    Mach_segment_command const *ptrTEXT = nullptr;\n    upx_uint64_t rip = 0;\n    unsigned style = 0;\n    off_t offLINK = 0;\n    unsigned pos_next = 0;\n    unsigned nseg = 0;\n    Mach_command const *ptr = (Mach_command const *)rawmseg;\n    for (unsigned j= 0; j < ncmds;\n            ptr = (Mach_command const *)(ptr->cmdsize + (char const *)ptr), ++j) {\n        if (headway < (int)sizeof(Mach_command)) {\n            char buf[200]; snprintf(buf, sizeof(buf),\n                \"bad Mach_command[%u]{@0x%zx,+0x%x}\",\n                    j, (sizeof(mhdri) + ((char const *)ptr - (char const *)rawmseg)), headway);\n            throwCantPack(buf);\n        }\n        unsigned const cmd = ptr->cmd;\n        unsigned const cmdsize = ptr->cmdsize;\n        if (is_bad_linker_command(cmd, cmdsize, headway, lc_seg, sizeof(Addr))) {\n                opt->info_mode += 1;\n                infoWarning(\"bad Mach_command[%u]{@0x%zx,+0x%x}=0x%x: file_size=0x%lx  cmdsize=0x%lx\",\n                    j, (sizeof(mhdri) + ((char const *)ptr - (char const *)rawmseg)), headway,\n                    cmd, (unsigned long) file_size, (unsigned long)ptr->cmdsize);\n                opt->info_mode -= 1;\n                throwCantUnpack(\"file corrupted\");\n        }\n        headway -= cmdsize;\n        if (headway < 0) {\n            infoWarning(\"Mach_command[%u]{@%lu}.cmdsize = %u\", j,\n                (unsigned long) (sizeof(mhdri) + mhdri.sizeofcmds - (headway + ptr->cmdsize)),\n                (unsigned)ptr->cmdsize);\n            throwCantUnpack(\"sum(.cmdsize) exceeds .sizeofcmds\");\n        }\n        if (lc_seg == ptr->cmd) {\n            Mach_segment_command const *const segptr = (Mach_segment_command const *)ptr;\n            if ((unsigned long)file_size < segptr->filesize\n            ||  (unsigned long)file_size < segptr->fileoff\n            ||  (unsigned long)file_size < (segptr->filesize + segptr->fileoff)) {\n                infoWarning(\"bad Mach_segment_command[%u]{@0x%zx,+0x%x}: file_size=0x%lx  cmdsize=0x%lx\"\n                      \"  filesize=0x%lx  fileoff=0x%lx\",\n                    j, (sizeof(mhdri) + ((char const *)ptr - (char const *)rawmseg)), headway,\n                    (unsigned long) file_size, (unsigned long)ptr->cmdsize,\n                    (unsigned long)segptr->filesize, (unsigned long)segptr->fileoff);\n                throwCantUnpack(\"file corrupted\");\n            }\n            ++nseg;\n            if (!strcmp(\"__XHDR\", segptr->segname)) {\n                // PackHeader precedes __LINKEDIT (pre-Sierra MacOS 10.12)\n                style = 391;  // UPX 3.91\n            }\n            if (!strcmp(\"__TEXT\", segptr->segname)) {\n                ptrTEXT = segptr;\n                style = 391;  // UPX 3.91\n            }\n            if (!strcmp(\"UPX_DATA\", segptr->segname)) {\n                // PackHeader follows loader at __LINKEDIT (Sierra MacOS 10.12)\n                style = 392;  // UPX 3.92\n            }\n            if (!strcmp(\"__LINKEDIT\", segptr->segname)) {\n                offLINK = segptr->fileoff;\n                if (segptr->filesize == blankLINK) {\n                    style = 395;\n                }\n                if (offLINK < (off_t) pos_next) {\n                    offLINK = pos_next;\n                }\n            }\n            pos_next = segptr->filesize + segptr->fileoff;\n        }\n        else if (Mach_command::LC_UNIXTHREAD==ptr->cmd) {\n            rip = entryVMA = threadc_getPC(ptr);\n        }\n    }\n    if (3==nseg && 395 != style) { // __PAGEZERO, __TEXT, __LINKEDIT;  no __XHDR, no UPX_DATA\n        style = 392;\n    }\n    if (391==style && 0==offLINK && 2==ncmds && ptrTEXT) { // pre-3.91 ?\n        offLINK = ptrTEXT->fileoff + ptrTEXT->filesize;  // fake __LINKEDIT at EOF\n    }\n    if (0 == style || 0 == offLINK) {\n        return false;\n    }\n\n    int const small = 32 + sizeof(overlay_offset);\n    unsigned bufsize = my_page_size + sizeof(PackHeader) + sizeof(overlay_offset);\n    if (391 == style) { // PackHeader precedes __LINKEDIT\n        fi->seek(offLINK - bufsize, SEEK_SET);\n    } else\n    if (392 == style) {\n        if (MH_DYLIB == my_filetype) {\n            fi->seek(fi->st_size() - bufsize, SEEK_SET);\n        }\n        else { // PackHeader follows loader at __LINKEDIT\n            if ((off_t)bufsize > (fi->st_size() - offLINK)) {\n                bufsize = fi->st_size() - offLINK;\n                if (bufsize < sizeof(struct b_info)) {\n                    throwCantUnpack(\"bad offLINK %p %p\",\n                        (void *)offLINK, (void *)file_size);\n                }\n            }\n            fi->seek(offLINK, SEEK_SET);\n        }\n    } else\n    if (395 == style) {\n        fi->seek(offLINK - bufsize, SEEK_SET);\n    }\n    MemBuffer buf(bufsize);\n    MemBuffer buf3(upx::max(bufsize, 0x1008u));\n    buf3.clear();\n\n    fi->readx(buf, bufsize);\n    // Do not overwrite buf[]; For scratch space, then use buf3 instead.\n\n    int i = bufsize;\n    while (i > small && 0 == buf[--i]) { } // why is this search so slow?\n    i -= small;\n    // allow incompressible extents\n    if (i < 1 || !getPackHeader(buf + i, bufsize - i, true)) {\n        // Breadcrumbs failed.\n        // Pirates might overwrite the UPX! marker.  Try harder.\n        upx_uint64_t const rip_off = ptrTEXT ? (rip - ptrTEXT->vmaddr) : 0;\n        if (ptrTEXT && rip && rip_off < ptrTEXT->vmsize) {\n            fi->seek(ptrTEXT->fileoff + rip_off, SEEK_SET);\n            fi->readx(buf3, bufsize);\n            unsigned char const *b = &buf3[0];\n            unsigned disp = *(TE32 const *)&b[1];\n            if (CPU_TYPE_X86_64 == my_cputype) { // Emulate the code\n                if (0xe8==b[0] && disp < bufsize\n                    // This has been obsoleted by amd64-darwin.macho-entry.S\n                    // searching for \"executable_path=\" etc.\n                &&  0x5d==b[5+disp] && 0xe8==b[6+disp]) {\n                    unsigned disp2 = 0u - *(TE32 const *)&b[7+disp];\n                    if (disp2 < (12+disp) && 0x5b==b[11+disp-disp2]) {\n                        struct b_info const *bptr = (struct b_info const *)&b[11+disp];\n                        // This is the folded stub.\n                        // FIXME: check b_method?\n                        if (bptr->sz_cpr < bptr->sz_unc && bptr->sz_unc < 0x1000) {\n                            b = bptr->sz_cpr + (unsigned char const *)(1+ bptr);\n                            // FIXME: check PackHeader::putPackHeader(), packhead.cpp\n                            overlay_offset = *(TE32 const *)(32 + b);\n                            if (overlay_offset < 0x1000) {\n                                return true;  // success\n                            }\n                            overlay_offset = 0;  // failure\n                        }\n                    }\n                }\n            }\n            if (395 == style) { // Desperation\n                infoWarning(\"file corrupted: %s\", fi->getName());\n                fi->seek(file_size - bufsize, SEEK_SET);\n                fi->readx(buf3, bufsize);\n                unsigned const *p = (unsigned const *)&buf3[bufsize];\n                for (; buf3 < (void const *)--p; ) {\n                    unsigned x = *p;\n                    if (x) {\n                        if (!(3& x) && x < bufsize) {\n                            fi->seek(0, SEEK_SET);\n                            fi->readx(buf3, bufsize);\n                            p = (unsigned const *)&buf3[x];\n                            if (0 == p[0] && 0 != p[1] && p[1] == p[2]  // p_info\n                            &&  sz_mach_headers < p[3] && p[4] < p[3]  // b_info\n                            ) {\n                                overlay_offset = x;\n                                infoWarning(\"attempting recovery, overlay_offset = %#x\",\n                                    overlay_offset);\n                                return true;\n                            }\n                        }\n                        break;\n                    }\n                }\n            }\n        }\n        if (391==style) {\n            TE32 const *uptr = (TE32 const *)&buf[bufsize];\n            while (0==*--uptr) /*empty*/ ;\n            overlay_offset = *uptr;\n            if (mhdri.sizeofcmds <= overlay_offset && overlay_offset < 0x1000) {\n                return true;  // success\n            }\n            overlay_offset = 0;\n            return false;\n        }\n        if (392==style) {\n            overlay_offset = 0x100c;  // (l_info precedes;) p_info; b_info; cpr_data\n            // p_info isn't used for execution, so it has less value for checking:\n            //      0== .p_progid\n            //      .p_filesize == .p_blocksize\n            fi->seek(overlay_offset, SEEK_SET);\n            fi->readx(buf3, bufsize);\n            struct p_info const *const p_ptr = (struct p_info const *)&buf3[0];\n            struct b_info const *const b_ptr = (struct b_info const *)(1+ p_ptr);\n            TE32 const *uptr = (TE32 const *)(1+ b_ptr);\n            if (b_ptr->sz_unc < 0x4000\n            &&  b_ptr->sz_cpr < b_ptr->sz_unc ) {\n                unsigned const method = b_ptr->b_method;\n                if ((M_NRV2B_LE32 == method || M_NRV2E_LE32 == method)\n                &&  (0xff>>2)==(uptr[0] >> (2+ 24))  // 1st 6 bytes are unique literals\n                &&  (Mach_header::MH_MAGIC + (sizeof(Addr)>>3)) == uptr[1]) {\n                    return true;\n                }\n                unsigned const magic = get_te32(&uptr[1]);  // FIXME:  probable bug\n                if ((M_NRV2B_8 == method || M_NRV2E_8 == method)\n                && 0xfc==(0xfc & uptr[0])\n                &&  (Mach_header::MH_MAGIC + (sizeof(Addr)>>3)) == magic) {\n                    return true;\n                }\n                // FIXME: M_LZMA\n            }\n\n            overlay_offset = 0;\n            // The first non-zero word scanning backwards from __LINKEDIT.fileoff\n            // is the total length of compressed data which precedes it\n            //(distance to l_info), so that's another method.\n            fi->seek(offLINK - 0x1000, SEEK_SET);\n            fi->readx(buf3, 0x1000);\n            unsigned const *const lo = (unsigned const *)&buf3[0];\n            unsigned const *p;\n            for (p = (unsigned const *)&buf3[0x1000]; p > lo; ) if (*--p) {\n                overlay_offset  = *(TE32 const *)p;\n                if ((unsigned)file_size < (overlay_offset + sizeof(PackHeader) + sizeof(overlay_offset)))\n                    throwCantUnpack(\"file corrupted\");\n                if ((off_t)overlay_offset < offLINK) {\n                    overlay_offset = ((char const *)p - (char const *)lo) +\n                        (offLINK - 0x1000) - overlay_offset + sizeof(l_info);\n                    if ((unsigned)file_size < (overlay_offset + sizeof(PackHeader) + sizeof(overlay_offset)))\n                        throwCantUnpack(\"file corrupted\");\n                    fi->seek(overlay_offset, SEEK_SET);\n                    fi->readx(buf3, bufsize);\n                    if (b_ptr->sz_unc < 0x4000\n                    &&  b_ptr->sz_cpr < b_ptr->sz_unc ) {\n                        return true;\n                    }\n                }\n            }\n        }\n    }\n\n    overlay_offset = 0;  // impossible value\n    int l = ph.buf_offset + ph.getPackHeaderSize();\n    if (0 <= l && (unsigned)(l + sizeof(TE32)) <=bufsize) {\n        overlay_offset = get_te32(buf + i + l);\n    }\n    if (       overlay_offset < sz_mach_headers\n    ||  (off_t)overlay_offset >= file_size) {\n        infoWarning(\"file corrupted: %s\", fi->getName());\n        MemBuffer buf2(upx::umin(1u<<14, file_size_u32));\n        fi->seek(sz_mach_headers, SEEK_SET);\n        fi->readx(buf2, buf2.getSize());\n        unsigned const *p = (unsigned const *)&buf2[0];\n        unsigned const *const e_buf2 = (unsigned const *)&buf2[buf2.getSize() - 4*sizeof(*p)];\n        for (; p <= e_buf2; ++p)\n        if (   0==p[0]  // p_info.p_progid\n        &&     0!=p[1]  // p_info.p_filesize\n        &&  p[2]==p[1]  // p_info.p_blocksize == p_info.p_filesize\n        &&  (unsigned)file_size < get_te32(&p[1])  // compression was worthwhile\n        &&  sz_mach_headers==get_te32(&p[3])  // b_info.sz_unc\n        ) {\n            overlay_offset = ((char const *)p - (char const *)&buf2[0]) + sz_mach_headers;\n            if (!(3&overlay_offset  // not word aligned\n                    ||        overlay_offset < sz_mach_headers\n                    || (off_t)overlay_offset >= file_size)) {\n                infoWarning(\"attempting recovery, overlay_offset = %#x\", overlay_offset);\n                return true;\n            }\n        }\n        throwCantUnpack(\"file corrupted\");\n    }\n    return true;\n}\n\ntemplate <class T>\nupx_uint64_t PackMachBase<T>::get_mod_init_func(Mach_segment_command const *segptr)\n{\n    for (Mach_section_command const *secptr = (Mach_section_command const *)(1+ segptr);\n        ptr_udiff_bytes(secptr, segptr) < segptr->cmdsize;\n        ++secptr\n    ) {\n        if (sizeof(Addr) == secptr->size\n        && !strcmp(\"__mod_init_func\", secptr->sectname)) {\n            o__mod_init_func = secptr->offset;\n            fi->seek(o__mod_init_func, SEEK_SET);\n            Addr tmp;\n            fi->readx(&tmp, sizeof(Addr));\n            return tmp;\n        }\n    }\n    return 0;\n}\n\ntemplate <class T>\ntribool PackMachBase<T>::canPack()\n{\n    unsigned const lc_seg = lc_seg_info[sizeof(Addr)>>3].segment_cmd;\n    fi->seek(0, SEEK_SET);\n    fi->readx(&mhdri, sizeof(mhdri));\n\n    if (((unsigned) Mach_header::MH_MAGIC + (sizeof(Addr)>>3)) !=mhdri.magic\n    ||  my_cputype   !=mhdri.cputype\n    ||  my_filetype  !=mhdri.filetype\n    )\n        return false;\n    my_cpusubtype = mhdri.cpusubtype;\n\n    unsigned const ncmds = mhdri.ncmds;\n    if (!ncmds || MAX_N_CMDS < ncmds) { // arbitrary, but guard against garbage\n        throwCantPack(\"%d < Mach_header.ncmds\", MAX_N_CMDS);\n    }\n    unsigned const sz_mhcmds = (unsigned)mhdri.sizeofcmds;\n    unsigned headway = upx::umin(sz_mhcmds, file_size_u32 - usizeof(mhdri));\n    if (headway < sz_mhcmds) {\n        char buf[32]; snprintf(buf, sizeof(buf), \"bad sizeofcmds %d\", sz_mhcmds);\n        throwCantPack(buf);\n    }\n    if (!sz_mhcmds\n    ||  32768 < sz_mhcmds) { // somewhat arbitrary, but *-darwin.macho-upxmain.c\n        throwCantPack(\"32768 < Mach_header.sizeofcmds (or ==0)\");\n    }\n    rawmseg_buf.alloc(headway);\n    rawmseg = (Mach_segment_command *)(void *)rawmseg_buf;\n    fi->readx(rawmseg, mhdri.sizeofcmds);\n\n    msegcmd_buf.alloc(sizeof(Mach_segment_command) * ncmds);\n    msegcmd = (Mach_segment_command *)msegcmd_buf.getVoidPtr();\n    unsigned char const *ptr = (unsigned char const *)rawmseg;\n    for (unsigned j= 0; j < ncmds; ++j) {\n        Mach_segment_command const *segptr = (Mach_segment_command const *)ptr;\n        if (headway < sizeof(Mach_command)) {\n            char buf[200]; snprintf(buf, sizeof(buf),\n                \"bad Mach_command[%u]{@0x%zx,+0x%x}\",\n                    j, (sizeof(mhdri) + ((char const *)segptr - (char const *)rawmseg)), headway);\n            throwCantPack(buf);\n        }\n        unsigned const cmd     = segptr->cmd &~ LC_REQ_DYLD;\n        unsigned const cmdsize = segptr->cmdsize;\n        if (is_bad_linker_command(cmd, cmdsize, headway, lc_seg, sizeof(Addr))) {\n            char buf[200]; snprintf(buf, sizeof(buf),\n                \"bad Mach_command[%u]{@0x%zx,+0x%x}=0x%x: file_size=0x%lx  cmdsize=0x%x\",\n                    j, (sizeof(mhdri) + ((char const *)segptr - (char const *)rawmseg)), headway,\n                    cmd, (unsigned long) file_size, cmdsize);\n            throwCantPack(buf);\n        }\n        headway -= cmdsize;\n        if (lc_seg == cmd) {\n            msegcmd[j] = *segptr;\n            if (!strcmp(\"__TEXT\", segptr->segname)) {\n                Mach_section_command const *secp =\n                    (Mach_section_command const *)(const void*)(const char*)(1+ segptr);\n                unsigned const offset = secp->offset;\n                if (offset < file_size) {\n                    struct l_info h;\n                    fi->seek(offset, SEEK_SET);\n                    fi->readx(&h, sizeof(h));\n                    checkAlreadyPacked(&h, sizeof(h));\n                }\n            }\n            if (!strcmp(\"__DATA\", segptr->segname)) {\n                prev_mod_init_func = get_mod_init_func(segptr);\n            }\n        }\n        else {\n            memcpy(&msegcmd[j], ptr, 2*sizeof(unsigned)); // cmd and cmdsize\n        }\n        switch (((Mach_uuid_command const *)ptr)->cmd) {\n        default: break;\n        case Mach_command::LC_UUID: {\n            memcpy(&cmdUUID, ptr, sizeof(cmdUUID));  // remember the UUID\n            // Set output UUID to be 1 more than the input UUID.\n            for (unsigned k = 0; k < sizeof(cmdUUID.uuid); ++k) {\n                if (0 != ++cmdUUID.uuid[k]) { // no Carry\n                    break;\n                }\n            }\n        } break;\n        case Mach_command::LC_VERSION_MIN_MACOSX: {\n            memcpy(&cmdVERMIN, ptr, sizeof(cmdVERMIN));\n        } break;\n        case Mach_command::LC_SOURCE_VERSION: {\n            memcpy(&cmdSRCVER, ptr, sizeof(cmdSRCVER));\n        } break;\n        }\n        ptr += (unsigned) ((Mach_command const *)ptr)->cmdsize;\n    }\n    if (Mach_header::MH_DYLIB==my_filetype && 0==o__mod_init_func) {\n        infoWarning(\"missing -init function\");\n        return false;\n    }\n\n    // Put LC_SEGMENT together at the beginning\n    upx_qsort(msegcmd, ncmds, sizeof(*msegcmd), compare_segment_command);\n\n    if (lc_seg==msegcmd[0].cmd && 0==msegcmd[0].vmaddr\n    &&  !strcmp(\"__PAGEZERO\", msegcmd[0].segname)) {\n        pagezero_vmsize = msegcmd[0].vmsize;\n    }\n\n    // Check alignment of non-null LC_SEGMENT.\n    vma_max = 0;\n    for (unsigned j= 0; j < ncmds; ++j) {\n        if (lc_seg==msegcmd[j].cmd) {\n            ++n_segment;\n            if (~my_page_mask & (msegcmd[j].fileoff | msegcmd[j].vmaddr)) {\n                return false;\n            }\n            upx_uint64_t t = msegcmd[j].vmsize + msegcmd[j].vmaddr;\n            if (vma_max < t) {\n                vma_max = t;\n            }\n            // Segments need not be contiguous (esp. \"rust\"/\"go\")\n            sz_segment = msegcmd[j].filesize + msegcmd[j].fileoff - msegcmd[0].fileoff;\n        }\n    }\n    vma_max = my_page_mask & (~my_page_mask + vma_max);\n\n    // info: currently the header is 36 (32+4) bytes before EOF\n    unsigned char buf[256];\n    fi->seek(-(off_t)sizeof(buf), SEEK_END);\n    fi->readx(buf, sizeof(buf));\n    checkAlreadyPacked(buf, sizeof(buf));\n\n    // set options\n    opt->o_unix.blocksize = file_size;\n    if (!n_segment) {\n        return false;\n    }\n    static struct {\n        unsigned cputype;\n        unsigned short filetype;\n        unsigned short sz_stub_entry;\n        unsigned short sz_stub_fold;\n        unsigned short sz_stub_main;\n        upx_byte const *stub_entry;\n        upx_byte const *stub_fold;\n        upx_byte const *stub_main;\n    } const stub_list[] = {\n        {CPU_TYPE_I386, MH_EXECUTE,\n            sizeof(stub_i386_darwin_macho_entry),\n            sizeof(stub_i386_darwin_macho_fold),\n            sizeof(stub_i386_darwin_macho_upxmain_exe),\n                   stub_i386_darwin_macho_entry,\n                   stub_i386_darwin_macho_fold,\n                   stub_i386_darwin_macho_upxmain_exe\n        },\n        {CPU_TYPE_I386, MH_DYLIB,\n            sizeof(stub_i386_darwin_dylib_entry), 0, 0,\n                   stub_i386_darwin_dylib_entry,  nullptr, nullptr\n        },\n        {CPU_TYPE_X86_64, MH_EXECUTE,\n            sizeof(stub_amd64_darwin_macho_entry),\n            sizeof(stub_amd64_darwin_macho_fold),\n            0, //sizeof(stub_amd64_darwin_macho_upxmain_exe),\n                   stub_amd64_darwin_macho_entry,\n                   stub_amd64_darwin_macho_fold,\n                   nullptr // stub_amd64_darwin_macho_upxmain_exe\n        },\n        {CPU_TYPE_X86_64, MH_DYLIB,\n            sizeof(stub_amd64_darwin_dylib_entry), 0, 0,\n                   stub_amd64_darwin_dylib_entry,  nullptr, nullptr\n        },\n        {CPU_TYPE_ARM, MH_EXECUTE,\n            sizeof(stub_arm_v5a_darwin_macho_entry),\n            sizeof(stub_arm_v5a_darwin_macho_fold),\n            0,\n                   stub_arm_v5a_darwin_macho_entry,\n                   stub_arm_v5a_darwin_macho_fold,\n                   nullptr\n        },\n        {CPU_TYPE_ARM64, MH_EXECUTE,\n            sizeof(stub_arm64_darwin_macho_entry),\n            sizeof(stub_arm64_darwin_macho_fold),\n            0,\n                   stub_arm64_darwin_macho_entry,\n                   stub_arm64_darwin_macho_fold,\n                   nullptr\n        },\n        {CPU_TYPE_POWERPC, MH_EXECUTE,\n            sizeof(stub_powerpc_darwin_macho_entry),\n            sizeof(stub_powerpc_darwin_macho_fold),\n            sizeof(stub_powerpc_darwin_macho_upxmain_exe),\n                   stub_powerpc_darwin_macho_entry,\n                   stub_powerpc_darwin_macho_fold,\n                   stub_powerpc_darwin_macho_upxmain_exe\n        },\n        {CPU_TYPE_POWERPC, MH_DYLIB,\n            sizeof(stub_powerpc_darwin_dylib_entry), 0, 0,\n                   stub_powerpc_darwin_dylib_entry,  nullptr, nullptr\n        },\n        {CPU_TYPE_POWERPC64, MH_EXECUTE,\n            sizeof(stub_powerpc64_darwin_macho_entry),\n            sizeof(stub_powerpc64_darwin_macho_fold),\n            0,\n                   stub_powerpc64_darwin_macho_entry,\n                   stub_powerpc64_darwin_macho_fold,\n                   nullptr\n        },\n        {CPU_TYPE_POWERPC64, MH_DYLIB,\n            sizeof(stub_powerpc64_darwin_dylib_entry), 0, 0,\n                   stub_powerpc64_darwin_dylib_entry,  nullptr, nullptr\n        },\n        {0,0, 0,0,0, nullptr,nullptr,nullptr}\n    };\n    for (unsigned j = 0; stub_list[j].cputype; ++j) {\n        if (stub_list[j].cputype  == my_cputype\n        &&  stub_list[j].filetype == my_filetype) {\n            sz_stub_entry = stub_list[j].sz_stub_entry;\n               stub_entry = stub_list[j].stub_entry;\n            sz_stub_fold  = stub_list[j].sz_stub_fold;\n               stub_fold  = stub_list[j].stub_fold;\n            sz_stub_main  = stub_list[j].sz_stub_main;\n               stub_main  = stub_list[j].stub_main;\n            if (!stub_main) { // development stub\n                static struct {\n                    Mach_header mhdri;\n                    Mach_segment_command segZERO;\n                    Mach_segment_command segTEXT;\n                    Mach_section_command secTEXT;\n                    Mach_segment_command segLINK;\n                    Mach_version_min_command cmdVERMIN;\n                    Mach_source_version_command cmdSRCVER;\n                } fsm;  // fake_stub_main\n                fsm.mhdri = mhdri;\n                fsm.mhdri.ncmds = 5;\n                fsm.mhdri.sizeofcmds = sizeof(fsm) - sizeof(fsm.mhdri);\n                fsm.mhdri.flags = MH_NOUNDEFS | MH_PIE;\n\n                fsm.segZERO.cmd = LC_SEGMENT + (fsm.mhdri.cputype >> 24)\n                    * (LC_SEGMENT_64 - LC_SEGMENT);\n                fsm.segZERO.cmdsize = sizeof(Mach_segment_command);\n                strncpy(fsm.segZERO.segname, \"__PAGEZERO\", sizeof(fsm.segZERO.segname));\n                fsm.segZERO.vmaddr = 0;\n                fsm.segZERO.vmsize = (4<<16);\n                if __acc_cte(8==sizeof(void *)) fsm.segZERO.vmsize <<= (32 - 18);\n                fsm.segZERO.fileoff = 0;\n                fsm.segZERO.filesize = 0;\n                fsm.segZERO.maxprot = 0;\n                fsm.segZERO.initprot = 0;\n                fsm.segZERO.nsects = 0;\n                fsm.segZERO.flags = 0;\n\n                unsigned const slop = 400;\n                fsm.segTEXT.cmd = fsm.segZERO.cmd;\n                fsm.segTEXT.cmdsize = sizeof(Mach_segment_command)\n                    + sizeof(Mach_section_command);\n                strncpy(fsm.segTEXT.segname, \"__TEXT\", sizeof(fsm.segTEXT.segname));\n                fsm.segTEXT.vmaddr = fsm.segZERO.vmsize;\n                fsm.segTEXT.vmsize = slop + threado_size() + sizeof(fsm);  // dummy\n                fsm.segTEXT.fileoff = 0;\n                fsm.segTEXT.filesize = fsm.segTEXT.vmsize;  // dummy\n                fsm.segTEXT.maxprot = VM_PROT_EXECUTE | VM_PROT_READ;\n                fsm.segTEXT.initprot = VM_PROT_EXECUTE | VM_PROT_READ;\n                fsm.segTEXT.nsects = 1;\n                fsm.segTEXT.flags = 0;\n\n                strncpy(fsm.secTEXT.sectname, \"__text\", sizeof(fsm.secTEXT.sectname));\n                memcpy(fsm.secTEXT.segname, fsm.segTEXT.segname, sizeof(fsm.secTEXT.segname));\n                unsigned const d = slop + fsm.mhdri.sizeofcmds;\n                fsm.secTEXT.addr = fsm.segTEXT.vmaddr + d;  // dummy\n                fsm.secTEXT.size = fsm.segTEXT.vmsize - d;  // dummy\n                fsm.secTEXT.offset = d;  // dummy\n                fsm.secTEXT.align = 3;  // (1<<2)\n                fsm.secTEXT.reloff = 0;\n                fsm.secTEXT.nreloc = 0;\n                fsm.secTEXT.flags = S_REGULAR | S_ATTR_PURE_INSTRUCTIONS | S_ATTR_SOME_INSTRUCTIONS;\n                fsm.secTEXT.reserved1 = 0;\n                fsm.secTEXT.reserved2 = 0;\n\n                fsm.segLINK = fsm.segTEXT;\n                fsm.segLINK.cmdsize = sizeof(Mach_segment_command);\n                strncpy(fsm.segLINK.segname, \"__LINKEDIT\", sizeof(fsm.segLINK.segname));\n                fsm.segLINK.vmaddr = fsm.segTEXT.vmaddr + fsm.segTEXT.vmsize;  // dummy\n                fsm.segLINK.vmsize = 0x1000;  // dummy\n                fsm.segLINK.fileoff = fsm.segTEXT.fileoff + fsm.segTEXT.filesize;\n                fsm.segLINK.filesize = fsm.segLINK.vmsize;\n                fsm.segLINK.maxprot = VM_PROT_READ;\n                fsm.segLINK.initprot = VM_PROT_READ;\n                fsm.segLINK.nsects = 0;\n\n                fsm.cmdVERMIN.cmd = LC_VERSION_MIN_MACOSX;  // LC_VERSION_MIN_IPHONEOS\n                fsm.cmdVERMIN.cmdsize = 4*4;\n                fsm.cmdVERMIN.version = (10<<16)|(12<<8);\n                fsm.cmdVERMIN.sdk = fsm.cmdVERMIN.version;\n\n                fsm.cmdSRCVER.cmd = LC_SOURCE_VERSION;\n                fsm.cmdSRCVER.cmdsize = 4*4;\n                fsm.cmdSRCVER.version = 0;\n                fsm.cmdSRCVER.__pad = 0;\n\n                sz_stub_main  = sizeof(fsm);\n                   stub_main  = (unsigned char const *)&fsm;\n            }\n            break;\n        }\n    }\n    // disable macOS packing until we do support macOS 13+\n    //   https://github.com/upx/upx/issues/612\n    if (my_cputype == CPU_TYPE_X86_64 || my_cputype == CPU_TYPE_ARM64) {\n        bool force = opt->darwin_macho.force_macos || is_envvar_true(\"UPX_DEBUG_FORCE_PACK_MACOS\");\n        if (!force)\n            throwCantPack(\"macOS is currently not supported (try --force-macos)\");\n    }\n    return true;\n}\n\n// instantiate instances\ntemplate class PackMachBase<MachClass_BE32>;\n// template class PackMachBase<MachClass_BE64>; // currently not used\ntemplate class PackMachBase<MachClass_LE32>;\ntemplate class PackMachBase<MachClass_LE64>;\n\n\nPackMachFat::PackMachFat(InputFile *f) : super(f)\n{\n    bele = &N_BELE_RTP::le_policy;  // sham\n}\n\nPackMachFat::~PackMachFat()\n{\n}\n\nunsigned PackMachFat::check_fat_head()\n{\n    struct Mach_fat_arch const *const arch = &fat_head.arch[0];\n    unsigned nfat = fat_head.fat.nfat_arch;\n    if (Mach_fat_header::FAT_MAGIC!=fat_head.fat.magic\n    ||  N_FAT_ARCH < nfat) {\n        return 0;\n    }\n    for (unsigned j=0; j < nfat; ++j) {\n        unsigned const align = arch[j].align;\n        if (24 < align) {\n            char msg[80]; snprintf(msg, sizeof(msg),\n                \"bad fat_arch alignment 0x%x > 24\", align);\n            throwCantPack(msg);\n        }\n        unsigned const mask = ~(~0u<<align);\n        unsigned const size = arch[j].size;\n        unsigned const offset = arch[j].offset;\n        if (align < 12 || align > 24) { // heuristic\n            throwUnknownExecutableFormat(\"align\", 0);\n        }\n        if (mask > size) {\n            throwUnknownExecutableFormat(\"size\", 0);\n        }\n        if (mask & offset\n        ||  (unsigned)fi->st_size_orig() < size + offset\n        ||  (unsigned)fi->st_size_orig() <= offset) {  // redundant unless overflow\n            throwUnknownExecutableFormat(\"offset\", 0);\n        }\n    }\n    return nfat;\n}\n\nconst int *PackMachFat::getCompressionMethods(int /*method*/, int /*level*/) const\n{\n    static const int m_nrv2e[] = { M_NRV2E_LE32, M_END };\n    return m_nrv2e;  // sham\n}\n\nconst int *PackMachFat::getFilters() const\n{\n    static const int filters[] = { 0x49, FT_END };\n    return filters;  // sham\n}\n\nvoid PackMachFat::pack(OutputFile *fo)\n{\n    unsigned const in_size = this->file_size;\n    fo->write(&fat_head, sizeof(fat_head.fat) +\n        fat_head.fat.nfat_arch * sizeof(fat_head.arch[0]));\n    unsigned length = 0;\n    for (unsigned j=0; j < fat_head.fat.nfat_arch; ++j) {\n        unsigned base = fo->unset_extent();  // actual length\n        base += ~(~0u<<fat_head.arch[j].align) & (0-base);  // align up\n        fo->seek(base, SEEK_SET);\n        fo->set_extent(base, ~0u);\n\n        ph.u_file_size = fat_head.arch[j].size;\n        fi->set_extent(fat_head.arch[j].offset, fat_head.arch[j].size);\n        fi->seek(0, SEEK_SET);\n        switch (fat_head.arch[j].cputype) {\n        case PackMachFat::CPU_TYPE_I386: {\n            typedef N_Mach::Mach_header<MachClass_LE32::MachITypes> Mach_header;\n            Mach_header hdr;\n            fi->readx(&hdr, sizeof(hdr));\n            if (hdr.filetype==Mach_header::MH_EXECUTE) {\n                PackMachI386 packer(fi);\n                packer.initPackHeader();\n                packer.canPack();\n                packer.updatePackHeader();\n                packer.pack(fo);\n            }\n            else if (hdr.filetype==Mach_header::MH_DYLIB) {\n                PackDylibI386 packer(fi);\n                packer.initPackHeader();\n                packer.canPack();\n                packer.updatePackHeader();\n                packer.pack(fo);\n            }\n        } break;\n        case PackMachFat::CPU_TYPE_X86_64: {\n            typedef N_Mach::Mach_header<MachClass_LE64::MachITypes> Mach_header;\n            Mach_header hdr;\n            fi->readx(&hdr, sizeof(hdr));\n            if (hdr.filetype==Mach_header::MH_EXECUTE) {\n                PackMachAMD64 packer(fi);\n                packer.initPackHeader();\n                packer.canPack();\n                packer.updatePackHeader();\n                packer.pack(fo);\n            }\n            else if (hdr.filetype==Mach_header::MH_DYLIB) {\n                PackDylibAMD64 packer(fi);\n                packer.initPackHeader();\n                packer.canPack();\n                packer.updatePackHeader();\n                packer.pack(fo);\n            }\n        } break;\n        case PackMachFat::CPU_TYPE_POWERPC: {\n            typedef N_Mach::Mach_header<MachClass_BE32::MachITypes> Mach_header;\n            Mach_header hdr;\n            fi->readx(&hdr, sizeof(hdr));\n            if (hdr.filetype==Mach_header::MH_EXECUTE) {\n                PackMachPPC32 packer(fi);\n                packer.initPackHeader();\n                packer.canPack();\n                packer.updatePackHeader();\n                packer.pack(fo);\n            }\n            else if (hdr.filetype==Mach_header::MH_DYLIB) {\n                PackDylibPPC32 packer(fi);\n                packer.initPackHeader();\n                packer.canPack();\n                packer.updatePackHeader();\n                packer.pack(fo);\n            }\n        } break;\n        case PackMachFat::CPU_TYPE_POWERPC64: {\n            typedef N_Mach::Mach_header<MachClass_LE64::MachITypes> Mach_header;\n            Mach_header hdr;\n            fi->readx(&hdr, sizeof(hdr));\n            if (hdr.filetype==Mach_header::MH_EXECUTE) {\n                PackMachPPC64 packer(fi);\n                packer.initPackHeader();\n                packer.canPack();\n                packer.updatePackHeader();\n                packer.pack(fo);\n            }\n            else if (hdr.filetype==Mach_header::MH_DYLIB) {\n                PackDylibPPC64 packer(fi);\n                packer.initPackHeader();\n                packer.canPack();\n                packer.updatePackHeader();\n                packer.pack(fo);\n            }\n        } break;\n        }  // switch cputype\n        fat_head.arch[j].offset = base;\n        length = fo->unset_extent();\n        fat_head.arch[j].size = length - base;\n    }\n    ph.u_file_size = in_size;\n    fi->set_extent(0, in_size);\n\n    fo->seek(0, SEEK_SET);\n    fo->rewrite(&fat_head, sizeof(fat_head.fat) +\n        fat_head.fat.nfat_arch * sizeof(fat_head.arch[0]));\n    fo->set_extent(0, length);\n}\n\nvoid PackMachFat::unpack(OutputFile *fo)\n{\n    if (fo) {  // test mode (\"-t\") sets fo = nullptr\n        fo->seek(0, SEEK_SET);\n        fo->write(&fat_head, sizeof(fat_head.fat) +\n            fat_head.fat.nfat_arch * sizeof(fat_head.arch[0]));\n    }\n    unsigned const nfat = check_fat_head();\n    unsigned length;\n    for (unsigned j=0; j < nfat; ++j) {\n        unsigned base = (fo ? fo->unset_extent() : 0);  // actual length\n        base += ~(~0u<<fat_head.arch[j].align) & (0-base);  // align up\n        if (fo) {\n            fo->seek(base, SEEK_SET);\n            fo->set_extent(base, ~0u);\n        }\n\n        ph.u_file_size = fat_head.arch[j].size;\n        fi->set_extent(fat_head.arch[j].offset, fat_head.arch[j].size);\n        fi->seek(0, SEEK_SET);\n        switch (fat_head.arch[j].cputype) {\n        case PackMachFat::CPU_TYPE_I386: {\n            N_Mach::Mach_header<MachClass_LE32::MachITypes> hdr;\n            typedef N_Mach::Mach_header<MachClass_LE32::MachITypes> Mach_header;\n            fi->readx(&hdr, sizeof(hdr));\n            if (hdr.filetype==Mach_header::MH_EXECUTE) {\n                PackMachI386 packer(fi);\n                packer.initPackHeader();\n                packer.canUnpack();\n                packer.unpack(fo);\n            }\n            else if (hdr.filetype==Mach_header::MH_DYLIB) {\n                PackDylibI386 packer(fi);\n                packer.initPackHeader();\n                packer.canUnpack();\n                packer.unpack(fo);\n            }\n        } break;\n        case PackMachFat::CPU_TYPE_X86_64: {\n            N_Mach::Mach_header<MachClass_LE64::MachITypes> hdr;\n            typedef N_Mach::Mach_header<MachClass_LE64::MachITypes> Mach_header;\n            fi->readx(&hdr, sizeof(hdr));\n            if (hdr.filetype==Mach_header::MH_EXECUTE) {\n                PackMachAMD64 packer(fi);\n                packer.initPackHeader();\n                packer.canUnpack();\n                packer.unpack(fo);\n            }\n            else if (hdr.filetype==Mach_header::MH_DYLIB) {\n                PackDylibAMD64 packer(fi);\n                packer.initPackHeader();\n                packer.canUnpack();\n                packer.unpack(fo);\n            }\n        } break;\n        case PackMachFat::CPU_TYPE_POWERPC: {\n            N_Mach::Mach_header<MachClass_BE32::MachITypes> hdr;\n            typedef N_Mach::Mach_header<MachClass_BE32::MachITypes> Mach_header;\n            fi->readx(&hdr, sizeof(hdr));\n            if (hdr.filetype==Mach_header::MH_EXECUTE) {\n                PackMachPPC32 packer(fi);\n                packer.initPackHeader();\n                packer.canUnpack();\n                packer.unpack(fo);\n            }\n            else if (hdr.filetype==Mach_header::MH_DYLIB) {\n                PackDylibPPC32 packer(fi);\n                packer.initPackHeader();\n                packer.canUnpack();\n                packer.unpack(fo);\n            }\n        } break;\n        case PackMachFat::CPU_TYPE_POWERPC64: {\n            N_Mach::Mach_header<MachClass_LE64::MachITypes> hdr;\n            typedef N_Mach::Mach_header<MachClass_LE64::MachITypes> Mach_header;\n            fi->readx(&hdr, sizeof(hdr));\n            if (hdr.filetype==Mach_header::MH_EXECUTE) {\n                PackMachPPC64 packer(fi);\n                packer.initPackHeader();\n                packer.canUnpack();\n                packer.unpack(fo);\n            }\n            else if (hdr.filetype==Mach_header::MH_DYLIB) {\n                PackDylibPPC64 packer(fi);\n                packer.initPackHeader();\n                packer.canUnpack();\n                packer.unpack(fo);\n            }\n        } break;\n        }  // switch cputype\n        fat_head.arch[j].offset = base;\n        length = (fo ? fo->unset_extent() : 0);\n        fat_head.arch[j].size = length - base;\n    }\n    if (fo) {\n        fo->unset_extent();\n        fo->seek(0, SEEK_SET);\n        fo->rewrite(&fat_head, sizeof(fat_head.fat) +\n            fat_head.fat.nfat_arch * sizeof(fat_head.arch[0]));\n    }\n}\n\ntribool PackMachFat::canPack()\n{\n    struct Mach_fat_arch const *const arch = &fat_head.arch[0];\n\n    fi->readx(&fat_head, sizeof(fat_head));\n    unsigned const nfat = check_fat_head();\n    if (0==nfat)\n        return false;\n    for (unsigned j=0; j < nfat; ++j) {\n        fi->set_extent(arch[j].offset, arch[j].size);\n        fi->seek(0, SEEK_SET);\n        switch (arch[j].cputype) {\n        default:\n            infoWarning(\"unknown cputype 0x%x: %s\",\n                (unsigned)arch[j].cputype, fi->getName());\n            return false;\n        case PackMachFat::CPU_TYPE_I386: {\n            PackMachI386 packer(fi);\n            if (!packer.canPack()) {\n                PackDylibI386 pack2r(fi);\n                if (!pack2r.canPack())\n                    return false;\n            }\n        } break;\n        case PackMachFat::CPU_TYPE_X86_64: {\n            PackMachAMD64 packer(fi);\n            if (!packer.canPack()) {\n                PackDylibI386 pack2r(fi);\n                if (!pack2r.canPack())\n                    return false;\n            }\n        } break;\n        case PackMachFat::CPU_TYPE_ARM64: {\n            PackMachARM64EL packer(fi);\n            if (!packer.canPack()) {\n                //PackDylibARM64EL pack2r(fi);  FIXME: not yet\n                //if (!pack2r.canPack())\n                    return false;\n            }\n        } break;\n        case PackMachFat::CPU_TYPE_POWERPC: {\n            PackMachPPC32 packer(fi);\n            if (!packer.canPack()) {\n                PackDylibPPC32 pack2r(fi);\n                if (!pack2r.canPack())\n                    return false;\n            }\n        } break;\n        case PackMachFat::CPU_TYPE_POWERPC64: {\n            PackMachPPC64 packer(fi);\n            if (!packer.canPack()) {\n                PackDylibPPC64 pack2r(fi);\n                if (!pack2r.canPack())\n                    return false;\n            }\n        } break;\n        }  // switch cputype\n    }\n\n    // info: currently the header is 36 (32+4) bytes before EOF\n    unsigned char buf[256];\n    fi->seek(-(off_t)sizeof(buf), SEEK_END);\n    fi->readx(buf, sizeof(buf));\n    checkAlreadyPacked(buf, sizeof(buf));\n\n    return true;\n}\n\ntribool PackMachFat::canUnpack()\n{\n    struct Mach_fat_arch const *const arch = &fat_head.arch[0];\n\n    fi->readx(&fat_head, sizeof(fat_head));\n    unsigned const nfat = check_fat_head();\n    if (0 == nfat) {\n        return false;\n    }\n    for (unsigned j=0; j < nfat; ++j) {\n        fi->set_extent(arch[j].offset, arch[j].size);\n        fi->seek(0, SEEK_SET);\n        switch (arch[j].cputype) {\n        default: return false;\n        case PackMachFat::CPU_TYPE_I386: {\n            PackMachI386 packer(fi);\n            if (!packer.canUnpack()) {\n                PackDylibI386 pack2r(fi);\n                if (!pack2r.canUnpack())\n                    return 0;\n                else\n                    ph.format = pack2r.getFormat(); // FIXME: copy entire PackHeader\n            }\n            else\n                ph.format = packer.getFormat(); // FIXME: copy entire PackHeader\n        } break;\n        case PackMachFat::CPU_TYPE_X86_64: {\n            PackMachAMD64 packer(fi);\n            if (!packer.canUnpack()) {\n                PackDylibAMD64 pack2r(fi);\n                if (!pack2r.canUnpack())\n                    return 0;\n                else\n                    ph.format = pack2r.getFormat(); // FIXME: copy entire PackHeader\n            }\n            else\n                ph.format = packer.getFormat(); // FIXME: copy entire PackHeader\n        } break;\n        case PackMachFat::CPU_TYPE_POWERPC: {\n            PackMachPPC32 packer(fi);\n            if (!packer.canUnpack()) {\n                PackDylibPPC32 pack2r(fi);\n                if (!pack2r.canUnpack())\n                    return 0;\n                else\n                    ph.format = pack2r.getFormat(); // FIXME: copy entire PackHeader\n            }\n            else\n                ph.format = packer.getFormat(); // FIXME: copy entire PackHeader\n        } break;\n        case PackMachFat::CPU_TYPE_POWERPC64: {\n            PackMachPPC64 packer(fi);\n            if (!packer.canUnpack()) {\n                PackDylibPPC64 pack2r(fi);\n                if (!pack2r.canUnpack())\n                    return 0;\n                else\n                    ph.format = pack2r.getFormat(); // FIXME: copy entire PackHeader\n            }\n            else\n                ph.format = packer.getFormat(); // FIXME: copy entire PackHeader\n        } break;\n        }  // switch cputype\n    }\n    return 1;\n}\n\nvoid PackMachFat::buildLoader(const Filter * /*ft*/)\n{\n    assert(false);\n}\n\nLinker* PackMachFat::newLinker() const\n{\n    return new ElfLinkerX86;  // sham\n}\n\nvoid PackMachFat::list()\n{\n    assert(false);\n}\n\n/* vim:set ts=4 sw=4 et: */\n","size_bytes":103968},"src/p_ps1.cpp":{"content":"/* p_ps1.cpp --\n\n   This file is part of the Resize executable compressor.\n\n   Copyright (C) 2025 WHO-AM-I-404\n   Based on UPX - Ultimate Packer for eXecutables\n   Copyright (C) 1996-2025 Markus Franz Xaver Johannes Oberhumer\n   Copyright (C) 1996-2025 Laszlo Molnar\n   Copyright (C) 2002-2025 Jens Medoch\n   All Rights Reserved.\n\n   Resize and the UCL library are free software; you can redistribute them\n   and/or modify them under the terms of the GNU General Public License as\n   published by the Free Software Foundation; either version 2 of\n   the License, or (at your option) any later version.\n\n   This program is distributed in the hope that it will be useful,\n   but WITHOUT ANY WARRANTY; without even the implied warranty of\n   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n   GNU General Public License for more details.\n\n   You should have received a copy of the GNU General Public License\n   along with this program; see the file COPYING.\n   If not, write to the Free Software Foundation, Inc.,\n   59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.\n\n   WHO-AM-I-404 <who-am-i-404@proton.me>\n   Based on original work by:\n   Markus F.X.J. Oberhumer <markus@oberhumer.com>\n   Laszlo Molnar <ezerotven+github@gmail.com>\n\n   Jens Medoch\n   <jssg@users.sourceforge.net>\n */\n\n#include \"conf.h\"\n#include \"file.h\"\n#include \"filter.h\"\n#include \"packer.h\"\n#include \"p_ps1.h\"\n#include \"linker.h\"\n\nstatic const CLANG_FORMAT_DUMMY_STATEMENT\n#include \"stub/mipsel.r3000-ps1.h\"\n\n#define CD_SEC        2048\n#define PS_HDR_SIZE   CD_SEC\n#define PS_RAM_SIZE   ram_size\n#define PS_MIN_SIZE   (PS_HDR_SIZE * 3)\n#define PS_MAX_SIZE   ((PS_RAM_SIZE * 95) / 100)\n#define PS_STACK_SIZE (PS_RAM_SIZE / 256)\n\n#define SZ_IH_BKUP  (10 * sizeof(LE32))\n#define HD_CODE_OFS (sizeof(ps1_exe_t) + sz_cbh)\n\n#define K0_BS    (0x80000000)\n#define K1_BS    (0xa0000000)\n#define EXE_BS   (ih.epc & K0_BS)\n#define FIX_PSVR ((K1_BS - EXE_BS) + (PS_HDR_SIZE - HD_CODE_OFS))\n\n// lui / addiu\n#define MIPS_HI(a)   (((a) >> 16) + (((a) &0x8000) >> 15))\n#define MIPS_LO(a)   ((a) &0xffff)\n#define MIPS_PC16(a) ((a) >> 2)\n#define MIPS_PC26(a) (((a) &0x0fffffff) >> 2)\n\n/*************************************************************************\n// ps1 exe looks like this:\n// 1. <header>  2048 bytes\n// 2. <body>    plain binary\n//\n// header:  contains the ps1_exe_t structure 188 bytes at offset zero\n//          rest is filled with zeros to reach the required\n//          cd mode 2 data sector size of 2048 bytes\n// body:    contains the binary data / code of the executable\n//          reqiures: executable code must be aligned to 4\n//                    must be aligned to 2048 to run from a CD\n//          optional: not aligned to 2048 (for console run only)\n**************************************************************************/\n\nPackPs1::PackPs1(InputFile *f)\n    : super(f), isCon(!opt->ps1_exe.boot_only), is32Bit(!opt->ps1_exe.do_8bit) {\n    bele = &N_BELE_RTP::le_policy;\n\n    COMPILE_TIME_ASSERT(sizeof(ps1_exe_t) == 136)\n    COMPILE_TIME_ASSERT(sizeof(ps1_exe_hb_t) == 44)\n    COMPILE_TIME_ASSERT(sizeof(ps1_exe_chb_t) == 5)\n    COMPILE_TIME_ASSERT_ALIGNED1(ps1_exe_t)\n    COMPILE_TIME_ASSERT_ALIGNED1(ps1_exe_hb_t)\n    COMPILE_TIME_ASSERT_ALIGNED1(ps1_exe_chb_t)\n\n    COMPILE_TIME_ASSERT(PS_HDR_SIZE > sizeof(ps1_exe_t))\n    COMPILE_TIME_ASSERT(SZ_IH_BKUP == 40)\n\n    fdata_size = file_size - PS_HDR_SIZE;\n    ram_size = !opt->ps1_exe.do_8mib ? 0x200000 : 0x800000;\n}\n\nconst int *PackPs1::getCompressionMethods(int method, int level) const {\n    if (is32Bit)\n        return Packer::getDefaultCompressionMethods_le32(method, level);\n    else\n        return Packer::getDefaultCompressionMethods_8(method, level);\n}\n\nconst int *PackPs1::getFilters() const { return nullptr; }\n\nLinker *PackPs1::newLinker() const { return new ElfLinkerMipsLE; }\n\n/*************************************************************************\n// util\n//   readFileHeader() reads ih and checks for illegal values\n//   checkFileHeader() checks ih for legal but unsupported values\n**************************************************************************/\n\nint PackPs1::readFileHeader() {\n    fi->seek(0, SEEK_SET);\n    fi->readx(&ih, sizeof(ih));\n    if (memcmp(&ih.id[0], \"PS-X EXE\", 8) != 0 && memcmp(&ih.id[0], \"EXE X-SP\", 8) != 0)\n        return 0;\n    if (ih.text != 0 || ih.data != 0)\n        return 0;\n    return UPX_F_PS1_EXE;\n}\n\nbool PackPs1::readBkupHeader() {\n    fi->seek(sizeof(ps1_exe_t) + 8, SEEK_SET);\n    fi->readx(&bh, sizeof(bh));\n\n    if (bh.ih_csum != upx_adler32(&bh, SZ_IH_BKUP)) {\n        byte buf[sizeof(bh)];\n        fi->seek(sizeof(ps1_exe_t), SEEK_SET);\n        fi->readx(buf, sizeof(bh));\n        if (!getBkupHeader(buf, (byte *) &bh))\n            return false;\n    }\n    return true;\n}\n\n#define INIT_BH_BKUP(p, l)                                                                         \\\n    do {                                                                                           \\\n        (p)->id = '1';                                                                             \\\n        (p)->len = l;                                                                              \\\n    } while (0)\n#define ADLER16(a) (((a) >> 16) ^ ((a) &0xffff))\n\nvoid PackPs1::putBkupHeader(const byte *src, byte *dst, unsigned *len) {\n    unsigned sz_cbh = MemBuffer::getSizeForCompression(SZ_IH_BKUP);\n\n    if (src && dst) {\n        ByteArray(cpr_bh, sz_cbh);\n\n        memset(cpr_bh, 0, sizeof(bh));\n        ps1_exe_chb_t *p = (ps1_exe_chb_t *) cpr_bh;\n\n        int r = upx_compress(src, SZ_IH_BKUP, &p->ih_bkup, &sz_cbh, nullptr, M_NRV2E_8, 10, nullptr,\n                             nullptr);\n        if (r != UPX_E_OK || sz_cbh >= SZ_IH_BKUP)\n            throwInternalError(\"header compression failed\");\n        INIT_BH_BKUP(p, sz_cbh);\n        *len = ALIGN_UP(sz_cbh + usizeof(ps1_exe_chb_t) - 1, 4u);\n        p->ih_csum = ADLER16(upx_adler32(&ih.epc, SZ_IH_BKUP));\n        memcpy(dst, cpr_bh, SZ_IH_BKUP);\n    } else\n        throwInternalError(\"header compression failed\");\n}\n\n#define ADLER16_HI(a, b) ((((a) &0xffff) ^ (b)) << 16)\n#define ADLER16_LO(a, b) (((a) >> 16) ^ (b))\n#define RE_ADLER16(a, b) (ADLER16_HI(a, b) | ADLER16_LO(a, b))\n\nbool PackPs1::getBkupHeader(byte *p, byte *dst) {\n    ps1_exe_chb_t *src = (ps1_exe_chb_t *) p;\n\n    if (src && (src->id == '1' && src->len < SZ_IH_BKUP) && dst) {\n        ByteArray(unc_bh, MemBuffer::getSizeForDecompression(SZ_IH_BKUP));\n\n        unsigned sz_bh = SZ_IH_BKUP;\n        int r = upx_decompress((const byte *) &src->ih_bkup, src->len, unc_bh, &sz_bh, M_NRV2E_8,\n                               nullptr);\n        if (r == UPX_E_OUT_OF_MEMORY)\n            throwOutOfMemoryException();\n        if (r != UPX_E_OK || sz_bh != SZ_IH_BKUP)\n            throwInternalError(\"header decompression failed\");\n        unsigned ad = upx_adler32(unc_bh, SZ_IH_BKUP);\n        unsigned ch = src->ih_csum;\n        if (ad != RE_ADLER16(ad, ch))\n            throwInternalError(\"backup header damaged\");\n        memcpy(dst, unc_bh, SZ_IH_BKUP);\n    } else\n        return false;\n    return true;\n}\n\nbool PackPs1::checkFileHeader() {\n    if (fdata_size != ih.tx_len || (ih.tx_len & 3)) {\n        if (!opt->force)\n            throwCantPack(\"file size entry damaged (try --force)\");\n        else {\n            opt->info_mode += !opt->info_mode ? 1 : 0;\n            infoWarning(\"fixing damaged header, keeping backup file\");\n            opt->backup = 1;\n            ih.tx_len = fdata_size;\n        }\n    }\n    if (!opt->force && (ih.da_ptr != 0 || ih.da_len != 0 || ih.bs_ptr != 0 || ih.bs_len != 0)) {\n        infoWarning(\"unsupported header field entry\");\n        return false;\n    }\n    if (ih.is_ptr < (EXE_BS | (PS_RAM_SIZE - PS_STACK_SIZE))) {\n        if (!opt->force)\n            return false;\n        else\n            infoWarning(\"%s: stack pointer offset low\", fi->getName());\n    }\n    return true;\n}\n\n/*************************************************************************\n//\n**************************************************************************/\n\ntribool PackPs1::canPack() {\n    byte buf[PS_HDR_SIZE - sizeof(ps1_exe_t)];\n\n    if (!readFileHeader())\n        return false;\n\n    fi->readx(buf, sizeof(buf));\n    checkAlreadyPacked(buf, sizeof(buf));\n\n    for (size_t i = 0; i < sizeof(buf); i++)\n        if (buf[i] != 0) {\n            if (!opt->force)\n                throwCantPack(\"unknown data in header (try --force)\");\n            else {\n                opt->info_mode += !opt->info_mode ? 1 : 0;\n                infoWarning(\"clearing header, keeping backup file\");\n                opt->backup = 1;\n                break;\n            }\n        }\n    if (!checkFileHeader())\n        throwCantPack(\"unsupported header flags (try --force)\");\n    if (!opt->force && file_size < PS_MIN_SIZE)\n        throwCantPack(\"file is too small (try --force)\");\n    if (!opt->force && file_size_u > PS_MAX_SIZE)\n        throwCantPack(\"file is too big (try --force)\");\n    return true;\n}\n\n/*************************************************************************\n//\n**************************************************************************/\n\nvoid PackPs1::buildLoader(const Filter *) {\n    const char *method = nullptr;\n\n    if (ph.method == M_NRV2B_8)\n        method = isCon ? \"nrv2b.small,8bit.sub,nrv.done\" : \"nrv2b.8bit,nrv.done\";\n    else if (ph.method == M_NRV2D_8)\n        method = isCon ? \"nrv2d.small,8bit.sub,nrv.done\" : \"nrv2d.8bit,nrv.done\";\n    else if (ph.method == M_NRV2E_8)\n        method = isCon ? \"nrv2e.small,8bit.sub,nrv.done\" : \"nrv2e.8bit,nrv.done\";\n    else if (ph.method == M_NRV2B_LE32)\n        method = isCon ? \"nrv2b.small,32bit.sub,nrv.done\" : \"nrv2b.32bit,nrv.done\";\n    else if (ph.method == M_NRV2D_LE32)\n        method = isCon ? \"nrv2d.small,32bit.sub,nrv.done\" : \"nrv2d.32bit,nrv.done\";\n    else if (ph.method == M_NRV2E_LE32)\n        method = isCon ? \"nrv2e.small,32bit.sub,nrv.done\" : \"nrv2e.32bit,nrv.done\";\n    else if (M_IS_LZMA(ph.method))\n        method = \"nrv2b.small,8bit.sub,nrv.done,lzma.prep\";\n    else\n        throwInternalError(\"unknown compression method\");\n\n    unsigned sa_tmp = sa_cnt;\n    if (ph.overlap_overhead > sa_cnt) {\n        if (!opt->force) {\n            infoWarning(\"not in-place decompressible\");\n            throwCantPack(\"packed data overlap (try --force)\");\n        } else\n            sa_tmp += overlap = ALIGN_UP((ph.overlap_overhead - sa_tmp), 4u);\n    }\n\n    if (isCon || M_IS_LZMA(ph.method))\n        foundBss = findBssSection();\n\n    if (M_IS_LZMA(ph.method) && !buildPart2) {\n        initLoader(stub_mipsel_r3000_ps1, sizeof(stub_mipsel_r3000_ps1));\n        addLoader(\"decompressor.start\", isCon ? \"LZMA_DEC20\" : \"LZMA_DEC10\", \"lzma.init\", nullptr);\n        addLoader(sa_tmp > (0x10000 << 2) ? \"memset.long\" : \"memset.short\",\n                  !foundBss ? \"con.exit\" : \"bss.exit\", nullptr);\n    } else {\n        if (M_IS_LZMA(ph.method) && buildPart2) {\n            sz_lcpr = MemBuffer::getSizeForCompression(sz_lunc);\n            byte *cprLoader = New(byte, sz_lcpr); // FIXME: does this leak? => should put into class\n            int r = upx_compress(getLoader(), sz_lunc, cprLoader, &sz_lcpr, nullptr, M_NRV2B_8, 10,\n                                 nullptr, nullptr);\n            if (r != UPX_E_OK || sz_lcpr >= sz_lunc)\n                throwInternalError(\"loader compression failed\");\n            initLoader(stub_mipsel_r3000_ps1, sizeof(stub_mipsel_r3000_ps1),\n                       isCon || !M_IS_LZMA(ph.method) ? 0 : 1);\n            linker->addSection(\"lzma.exec\", cprLoader, sz_lcpr, 0);\n        } else\n            initLoader(stub_mipsel_r3000_ps1, sizeof(stub_mipsel_r3000_ps1));\n\n        pad_code = ALIGN_UP_GAP((ph.c_len + (isCon ? sz_lcpr : 0)), 4u);\n        assert(pad_code < 4);\n        static const byte pad_buffer[4] = {0, 0, 0, 0};\n        linker->addSection(\"pad.code\", pad_buffer, pad_code, 0);\n\n        if (isCon) {\n            if (M_IS_LZMA(ph.method))\n                addLoader(!foundBss ? \"con.start\" : \"bss.con.start\", method,\n                          ih.tx_ptr & 0xffff ? \"dec.ptr\" : \"dec.ptr.hi\", \"con.entry\", \"pad.code\",\n                          \"lzma.exec\", nullptr);\n            else\n                addLoader(!foundBss ? \"con.start\" : \"bss.con.start\", \"con.mcpy\",\n                          ph.c_len & 3 ? \"con.padcd\" : \"\",\n                          ih.tx_ptr & 0xffff ? \"dec.ptr\" : \"dec.ptr.hi\", \"con.entry\", method,\n                          sa_cnt ? sa_cnt > (0x10000 << 2) ? \"memset.long\" : \"memset.short\" : \"\",\n                          !foundBss ? \"con.exit\" : \"bss.exit\", \"pad.code\", nullptr);\n        } else {\n            if (M_IS_LZMA(ph.method))\n                addLoader(!foundBss ? \"cdb.start.lzma\" : \"bss.cdb.start.lzma\", \"pad.code\",\n                          !foundBss ? \"cdb.entry.lzma\" : \"bss.cdb.entry.lzma\", method,\n                          \"cdb.lzma.cpr\", ih.tx_ptr & 0xffff ? \"dec.ptr\" : \"dec.ptr.hi\",\n                          \"lzma.exec\", nullptr);\n            else {\n                assert(foundBss != true);\n                addLoader(\"cdb.start\", \"pad.code\", \"cdb.entry\",\n                          ih.tx_ptr & 0xffff ? \"cdb.dec.ptr\" : \"cdb.dec.ptr.hi\", method,\n                          sa_cnt ? sa_cnt > (0x10000 << 2) ? \"memset.long\" : \"memset.short\" : \"\",\n                          \"cdb.exit\", nullptr);\n            }\n        }\n        addLoader(\"UPX1HEAD\", \"IDENTSTR\", nullptr);\n    }\n}\n\n#define OPTYPE(x) (((x) >> 13) & 0x7)\n#define OPCODE(x) (((x) >> 10) & 0x7)\n#define REG1(x)   (((x) >> 5) & 0x1f)\n#define REG2(x)   ((x) &0x1f)\n\n#define MIPS_IMM(a, b) ((((a) - (((b) &0x8000) >> 15)) << 16) | (b))\n\n// Type\n#define REGIMM 1\n#define STORE  5\n// Op\n#define LUI    7\n#define ADDIU  1\n#define SW     3\n\n#define IS_LUI(a)     ((OPTYPE(a) == REGIMM && OPCODE(a) == LUI))\n#define IS_ADDIU(a)   ((OPTYPE(a) == REGIMM && OPCODE(a) == ADDIU))\n#define IS_SW_ZERO(a) ((OPTYPE(a) == STORE && OPCODE(a) == SW) && REG2(a) == 0)\n\n#define BSS_CHK_LIMIT (18)\n\nbool PackPs1::findBssSection() {\n    byte reg;\n    const LE32 *const p1 = ACC_CCAST(const LE32 *, ibuf + (ih.epc - ih.tx_ptr));\n\n    if ((ih.epc - ih.tx_ptr + (BSS_CHK_LIMIT * 4)) > fdata_size)\n        return false;\n\n    // check 18 opcodes for sw zero,0(x)\n    for (signed i = BSS_CHK_LIMIT; i >= 0; i--) {\n        upx_uint16_t op = p1[i] >> 16;\n        if (IS_SW_ZERO(op)) {\n            // found! get reg (x) for bss_start\n            reg = REG1(op);\n            for (; i >= 0; i--) {\n                const bss_nfo *const p = ACC_CCAST(const bss_nfo *, &p1[i]);\n                upx_uint16_t op1 = p->op1, op2 = p->op2;\n\n                // check for la (x),bss_start\n                if ((IS_LUI(op1) && REG2(op1) == reg) && (IS_ADDIU(op2) && REG1(op2) == reg)) {\n                    op1 = p->op3, op2 = p->op4;\n\n                    // check for la (y),bss_end\n                    if (IS_LUI(op1) && IS_ADDIU(op2)) {\n                        // bss section info found!\n                        bss_start = MIPS_IMM(p->hi1, p->lo1);\n                        bss_end = MIPS_IMM(p->hi2, p->lo2);\n\n                        if (0 < ALIGN_DOWN(bss_end - bss_start, 4u)) {\n                            unsigned wkmem_sz = M_IS_LZMA(ph.method) ? 32768 : 800;\n                            unsigned end_offs = ih.tx_ptr + fdata_size + overlap;\n                            if (bss_end > (end_offs + wkmem_sz))\n                                return isCon || (!isCon && M_IS_LZMA(ph.method));\n                            else\n                                return false;\n                        }\n                    } else\n                        return false;\n                }\n            }\n        }\n    }\n    return false;\n}\n\n/*************************************************************************\n//\n**************************************************************************/\n\nvoid PackPs1::pack(OutputFile *fo) {\n    ibuf.alloc(fdata_size);\n    obuf.allocForCompression(fdata_size);\n    const byte *p_scan = ibuf + fdata_size;\n\n    // read file\n    fi->seek(PS_HDR_SIZE, SEEK_SET);\n    fi->readx(ibuf, fdata_size);\n\n    // scan EOF for 2048 bytes sector alignment\n    // the removed space will secure in-place decompression\n    while (!(*--p_scan)) {\n        if (sa_cnt++ > (0x10000 << 5) || sa_cnt >= fdata_size - 1024)\n            break;\n    }\n\n    if (sa_cnt > (0x10000 << 2))\n        sa_cnt = ALIGN_DOWN(sa_cnt, 32u);\n    else\n        sa_cnt = ALIGN_DOWN(sa_cnt, 4u);\n\n    // prepare packheader\n    ph.u_len = (fdata_size - sa_cnt);\n    ph.filter = 0;\n    Filter ft(ph.level);\n\n    // compress (max_match = 65535)\n    upx_compress_config_t cconf;\n    cconf.reset();\n    cconf.conf_ucl.max_match = 65535;\n    cconf.conf_lzma.max_num_probs = 1846 + (768 << 4); // ushort: ~28 KiB stack\n    compressWithFilters(&ft, sa_cnt, &cconf);\n\n    if (overlap) {\n        opt->info_mode += !opt->info_mode ? 1 : 0;\n        infoWarning(\"overlap - relocating load address (+%d bytes)\", overlap);\n        sa_cnt += overlap;\n    }\n\n    /*\n        if (bss_start && bss_end && !foundBss)\n            infoWarning(\"%s: .bss section too small - use stack\", fi->getName());\n    */\n\n    unsigned lzma_init = 0;\n\n    if (M_IS_LZMA(ph.method)) {\n        sz_lunc = getLoaderSize();\n\n        lzma_init = 0u - (sz_lunc - linker->getSymbolOffset(\"lzma.init\"));\n        defineDecompressorSymbols();\n        linker->defineSymbol(\"entry\", ih.epc);\n        linker->defineSymbol(\"SC\", sa_cnt > (0x10000 << 2) ? sa_cnt >> 5 : sa_cnt >> 2);\n        relocateLoader();\n\n        buildPart2 = true;\n        buildLoader(&ft);\n    }\n\n    memcpy(&oh, &ih, sizeof(ih));\n\n    unsigned sz_cbh;\n    putBkupHeader((const byte *) &ih.epc, (byte *) &bh, &sz_cbh);\n\n    if (ih.is_ptr < (EXE_BS | (PS_RAM_SIZE - PS_STACK_SIZE)))\n        oh.is_ptr = (EXE_BS | (PS_RAM_SIZE - 16));\n\n    if (ih.da_ptr != 0 || ih.da_len != 0 || ih.bs_ptr != 0 || ih.bs_len != 0)\n        oh.da_ptr = oh.da_len = oh.bs_ptr = oh.bs_len = 0;\n\n    const int lsize = getLoaderSize();\n\n    unsigned filelen = ALIGN_UP(ih.tx_len, 4u);\n\n    const unsigned decomp_data_start = ih.tx_ptr;\n    const unsigned comp_data_start = (decomp_data_start + filelen + overlap) - ph.c_len;\n\n    const int h_len = lsize - getLoaderSectionStart(\"UPX1HEAD\");\n    int d_len = 0;\n    int e_len = 0;\n\n    if (isCon) {\n        e_len = lsize - h_len;\n        d_len = e_len - getLoaderSectionStart(\"con.entry\");\n    } else {\n        const char *entry_lzma = !foundBss ? \"cdb.entry.lzma\" : \"bss.cdb.entry.lzma\";\n\n        d_len = (lsize - h_len) -\n                getLoaderSectionStart(M_IS_LZMA(ph.method) ? entry_lzma : \"cdb.entry\");\n        e_len = (lsize - d_len) - h_len;\n    }\n\n    linker->defineSymbol(\"entry\", ih.epc);\n    linker->defineSymbol(\"SC\", MIPS_LO(sa_cnt > (0x10000 << 2) ? sa_cnt >> 5 : sa_cnt >> 2));\n    linker->defineSymbol(\"DECO\", decomp_data_start);\n    linker->defineSymbol(\"ldr_sz\", M_IS_LZMA(ph.method) ? sz_lunc + 16 : (d_len - pad_code));\n\n    if (foundBss) {\n        if (M_IS_LZMA(ph.method))\n            linker->defineSymbol(\"wrkmem\",\n                                 bss_end - 160 - getDecompressorWrkmemSize() - (sz_lunc + 16));\n        else\n            linker->defineSymbol(\"wrkmem\", bss_end - 16 - (d_len - pad_code));\n    }\n\n    const unsigned entry = comp_data_start - e_len;\n    oh.epc = oh.tx_ptr = entry;\n    oh.tx_len = ph.c_len + e_len;\n\n    unsigned pad = 0;\n\n    if (!opt->ps1_exe.no_align || !isCon) {\n        pad = oh.tx_len;\n        oh.tx_len = ALIGN_UP(oh.tx_len, CD_SEC + 0u);\n        pad = oh.tx_len - pad;\n        oh.tx_ptr -= pad;\n    }\n\n    ibuf.clear(0, fdata_size);\n    byte *paddata = ibuf;\n\n    if (M_IS_LZMA(ph.method)) {\n        linker->defineSymbol(\"lzma_init_off\", lzma_init);\n        linker->defineSymbol(\"gb_e\", linker->getSymbolOffset(\"gb8_e\"));\n    } else if (isCon)\n        linker->defineSymbol(\"gb_e\", linker->getSymbolOffset(is32Bit ? \"gb32_e\" : \"gb8_e\"));\n\n    if (isCon) {\n        linker->defineSymbol(\"PAD\", pad_code);\n        if (M_IS_LZMA(ph.method))\n            linker->defineSymbol(\"DCRT\", (entry + getLoaderSectionStart(\"lzma.exec\")));\n        else\n            linker->defineSymbol(\"DCRT\", (entry + (e_len - d_len)));\n    } else {\n        linker->defineSymbol(\"PSVR\", FIX_PSVR);\n        linker->defineSymbol(\"CPDO\", comp_data_start);\n        if (M_IS_LZMA(ph.method)) {\n            unsigned entry_lzma =\n                getLoaderSectionStart(!foundBss ? \"cdb.entry.lzma\" : \"bss.cdb.entry.lzma\");\n\n            linker->defineSymbol(\"lzma_cpr\", getLoaderSectionStart(\"lzma.exec\") - entry_lzma);\n        }\n    }\n\n    relocateLoader();\n    // linker->dumpSymbols();\n    MemBuffer loader(lsize);\n    assert(lsize == getLoaderSize());\n    memcpy(loader, getLoader(), lsize);\n    patchPackHeader(loader, lsize);\n\n    if (!isCon && M_IS_LZMA(ph.method) && (HD_CODE_OFS + d_len + h_len) > CD_SEC)\n        throwInternalError(\"lzma --boot-only loader > 2048\");\n\n    // ps1_exe_t structure\n    fo->write(&oh, sizeof(oh));\n    fo->write(&bh, sz_cbh);\n    // decompressor\n    fo->write(loader + e_len, isCon ? h_len : (d_len + h_len));\n\n    // header size is 2048 bytes + sector alignment\n    fo->write(paddata, (pad + PS_HDR_SIZE) - fo->getBytesWritten());\n    // entry\n    fo->write(loader, e_len);\n    // compressed body\n    fo->write(obuf, ph.c_len);\n\n    verifyOverlappingDecompression();\n    if (!checkFinalCompressionRatio(fo))\n        throwNotCompressible();\n\n#if 0\n    printf(\"%-13s: uncompressed  : %8d bytes\\n\", getName(), (int) ph.u_len);\n    printf(\"%-13s: compressed    : %8d bytes\\n\", getName(), (int) ph.c_len);\n    printf(\"%-13s: decompressor  : %8d bytes\\n\", getName(), (int) lsize - h_len - pad_code);\n    printf(\"%-13s: header comp   : %8d bytes\\n\", getName(), (int) sz_cbh);\n    printf(\"%-13s: overlap       : %8d bytes\\n\", getName(), (int) overlap);\n    printf(\"%-13s: load address  : %08X bytes\\n\", getName(), (unsigned) oh.tx_ptr);\n    printf(\"%-13s: code entry    : %08X bytes\\n\", getName(), (unsigned) oh.epc);\n    printf(\"%-13s: bbs start     : %08X bytes\\n\", getName(), (unsigned) bss_start);\n    printf(\"%-13s: bbs end       : %08X bytes\\n\", getName(), (unsigned) bss_end);\n    printf(\"%-13s: eof in mem IF : %08X bytes\\n\", getName(), (unsigned) ih.tx_ptr + ih.tx_len);\n    printf(\"%-13s: eof in mem OF : %08X bytes\\n\", getName(), (unsigned) oh.tx_ptr + oh.tx_len);\n    byte i = 0;\n    if (isCon) {\n        if (foundBss)\n            i = 1;\n    } else {\n        i = 2;\n        if (M_IS_LZMA(ph.method)) {\n            if (!foundBss)\n                i = 3;\n            else\n                i = 4;\n        }\n    }\n    const char *loader_method[] = {\"con/stack\", \"con/bss\", \"cdb\", \"cdb/stack\", \"cdb/bss\"};\n    char method_name[32 + 1];\n    set_method_name(method_name, sizeof(method_name), ph.method, ph.level);\n    printf(\"%-13s: methods       : %s, %s\\n\", getName(), method_name, loader_method[i]);\n#endif\n}\n\n/*************************************************************************\n//\n**************************************************************************/\n\ntribool PackPs1::canUnpack() {\n    if (!readFileHeader())\n        return false;\n    if (!readPackHeader(CD_SEC))\n        return false;\n    // check header as set by packer\n    if (!readBkupHeader() || ph.c_len >= fdata_size)\n        throwCantUnpack(\"header damaged\");\n    // generic check\n    if (!checkFileHeader())\n        throwCantUnpack(\"unsupported header flags\");\n    return true;\n}\n\n/*************************************************************************\n//\n**************************************************************************/\n\nvoid PackPs1::unpack(OutputFile *fo) {\n    // restore orig exec hdr\n    memcpy(&oh, &ih, sizeof(ih));\n    memcpy((void *) &oh.epc, &bh, SZ_IH_BKUP);\n\n    // check for removed sector alignment\n    assert(oh.tx_len >= ph.u_len);\n    const unsigned pad = oh.tx_len - ph.u_len;\n\n    ibuf.alloc(fdata_size > PS_HDR_SIZE ? fdata_size : PS_HDR_SIZE);\n    obuf.allocForDecompression(ph.u_len, pad);\n\n    fi->seek(PS_HDR_SIZE, SEEK_SET);\n    fi->readx(ibuf, fdata_size);\n\n    // decompress\n    decompress(ibuf + (fdata_size - ph.c_len), obuf);\n\n    // write decompressed file\n    if (fo) {\n        // write header\n        fo->write(&oh, sizeof(oh));\n        // align the ps exe header (mode 2 sector data size)\n        ibuf.clear();\n        fo->write(ibuf, PS_HDR_SIZE - fo->getBytesWritten());\n        // write uncompressed data + pad\n        obuf.clear(ph.u_len, pad);\n        fo->write(obuf, ph.u_len + pad);\n    }\n}\n\n/* vim:set ts=4 sw=4 et: */\n","size_bytes":24550},"src/p_sys.cpp":{"content":"/* p_sys.cpp -- dos/sys executable format\n\n   This file is part of the Resize executable compressor.\n\n   Copyright (C) 2025 WHO-AM-I-404\n   Based on UPX - Ultimate Packer for eXecutables\n   Copyright (C) 1996-2025 Markus Franz Xaver Johannes Oberhumer\n   Copyright (C) 1996-2025 Laszlo Molnar\n   All Rights Reserved.\n\n   Resize and the UCL library are free software; you can redistribute them\n   and/or modify them under the terms of the GNU General Public License as\n   published by the Free Software Foundation; either version 2 of\n   the License, or (at your option) any later version.\n\n   This program is distributed in the hope that it will be useful,\n   but WITHOUT ANY WARRANTY; without even the implied warranty of\n   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n   GNU General Public License for more details.\n\n   You should have received a copy of the GNU General Public License\n   along with this program; see the file COPYING.\n   If not, write to the Free Software Foundation, Inc.,\n   59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.\n\n   WHO-AM-I-404 <who-am-i-404@proton.me>\n   Based on original work by:\n   Markus F.X.J. Oberhumer <markus@oberhumer.com>\n   Laszlo Molnar <ezerotven+github@gmail.com>\n */\n\n#include \"conf.h\"\n#include \"file.h\"\n#include \"filter.h\"\n#include \"packer.h\"\n#include \"p_com.h\"\n#include \"p_sys.h\"\n#include \"linker.h\"\n\nstatic const CLANG_FORMAT_DUMMY_STATEMENT\n#include \"stub/i086-dos16.sys.h\"\n\n/*************************************************************************\n//\n**************************************************************************/\n\ntribool PackSys::canPack() {\n    byte buf[128];\n\n    fi->readx(buf, sizeof(buf));\n    if (memcmp(buf, \"\\xff\\xff\\xff\\xff\", 4) != 0)\n        return false;\n    if (!fn_has_ext(fi->getName(), \"sys\")) // query file name\n        return false;\n    checkAlreadyPacked(buf, sizeof(buf));\n    if (file_size < 1024)\n        throwCantPack(\"file is too small for dos/sys\");\n    if (file_size > 0x10000)\n        throwCantPack(\"file is too large for dos/sys\");\n    return true;\n}\n\n/*************************************************************************\n//\n**************************************************************************/\n\nvoid PackSys::buildLoader(const Filter *ft) {\n    initLoader(stub_i086_dos16_sys, sizeof(stub_i086_dos16_sys));\n    // clang-format off\n    addLoader(\"SYSMAIN1\",\n              opt->cpu_x86 == opt->CPU_8086 ? \"SYSI0861\" : \"SYSI2861\",\n              \"SYSMAIN2\",\n              ph.first_offset_found == 1 ? \"SYSSBBBP\" : \"\",\n              ft->id ? \"SYSCALLT\" : \"\",\n              \"SYSMAIN3,UPX1HEAD,SYSCUTPO,NRV2B160,NRVDDONE,NRVDECO1\",\n              ph.max_offset_found <= 0xd00 ? \"NRVLED00\" : \"NRVGTD00\",\n              \"NRVDECO2\");\n    // clang-format on\n    if (ft->id) {\n        assert(ft->calls > 0);\n        addFilter16(ft->id);\n    }\n    // clang-format off\n    addLoader(\"SYSMAIN5\",\n              opt->cpu_x86 == opt->CPU_8086 ? \"SYSI0862\" : \"SYSI2862\",\n              \"SYSJUMP1\");\n    // clang-format on\n}\n\nvoid PackSys::patchLoader(OutputFile *fo, byte *loader, int lsize, unsigned calls) {\n    const int e_len = getLoaderSectionStart(\"SYSCUTPO\");\n    const int d_len = lsize - e_len;\n    assert(e_len > 0 && e_len < 128);\n    assert(d_len > 0 && d_len < 256);\n\n    if (ph.u_len + d_len + ph.overlap_overhead > 0xfffe)\n        throwNotCompressible();\n\n    // use some fields of the original file\n    linker->defineSymbol(\"attribute\", get_le16(ibuf + 4));\n    linker->defineSymbol(\"interrupt\", get_le16(ibuf + 8));\n\n    unsigned copy_to = ph.u_len + d_len + ph.overlap_overhead;\n\n    linker->defineSymbol(\"calltrick_calls\", calls);\n    linker->defineSymbol(\"copy_source\", ph.c_len + lsize - 1);\n    linker->defineSymbol(\"copy_destination\", copy_to);\n    linker->defineSymbol(\"neg_e_len\", 0 - e_len);\n    linker->defineSymbol(\"NRV2B160\", ph.u_len + ph.overlap_overhead + 1);\n    linker->defineSymbol(\"original_strategy\", get_le16(ibuf + 6));\n\n    relocateLoader();\n    loader = getLoader();\n\n    // some day we could use the relocation stuff for patchPackHeader too..\n    patchPackHeader(loader, e_len);\n    // write loader + compressed file\n    fo->write(loader, e_len);         // entry\n    fo->write(obuf, ph.c_len);        // compressed\n    fo->write(loader + e_len, d_len); // decompressor\n    NO_printf(\"%-13s: entry        : %8u bytes\\n\", getName(), e_len);\n    NO_printf(\"%-13s: compressed   : %8u bytes\\n\", getName(), ph.c_len);\n    NO_printf(\"%-13s: decompressor : %8u bytes\\n\", getName(), d_len);\n}\n\n/* vim:set ts=4 sw=4 et: */\n","size_bytes":4571},"src/p_tmt.cpp":{"content":"/* p_tmt.cpp --\n\n   This file is part of the Resize executable compressor.\n\n   Copyright (C) 2025 WHO-AM-I-404\n   Based on UPX - Ultimate Packer for eXecutables\n   Copyright (C) 1996-2025 Markus Franz Xaver Johannes Oberhumer\n   Copyright (C) 1996-2025 Laszlo Molnar\n   All Rights Reserved.\n\n   Resize and the UCL library are free software; you can redistribute them\n   and/or modify them under the terms of the GNU General Public License as\n   published by the Free Software Foundation; either version 2 of\n   the License, or (at your option) any later version.\n\n   This program is distributed in the hope that it will be useful,\n   but WITHOUT ANY WARRANTY; without even the implied warranty of\n   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n   GNU General Public License for more details.\n\n   You should have received a copy of the GNU General Public License\n   along with this program; see the file COPYING.\n   If not, write to the Free Software Foundation, Inc.,\n   59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.\n\n   WHO-AM-I-404 <who-am-i-404@proton.me>\n   Based on original work by:\n   Markus F.X.J. Oberhumer <markus@oberhumer.com>\n   Laszlo Molnar <ezerotven+github@gmail.com>\n */\n\n#include \"conf.h\"\n#include \"file.h\"\n#include \"filter.h\"\n#include \"packer.h\"\n#include \"p_tmt.h\"\n#include \"linker.h\"\n\nstatic const CLANG_FORMAT_DUMMY_STATEMENT\n#include \"stub/i386-dos32.tmt.h\"\n\n/*************************************************************************\n//\n**************************************************************************/\n\nPackTmt::PackTmt(InputFile *f) : super(f) {\n    bele = &N_BELE_RTP::le_policy;\n    COMPILE_TIME_ASSERT(sizeof(tmt_header_t) == 44)\n}\n\nLinker *PackTmt::newLinker() const { return new ElfLinkerX86; }\n\nconst int *PackTmt::getCompressionMethods(int method, int level) const {\n    return Packer::getDefaultCompressionMethods_le32(method, level);\n}\n\nconst int *PackTmt::getFilters() const {\n    static const int filters[] = {0x26, 0x24,           0x49, 0x46, 0x16, 0x13,  0x14,\n                                  0x11, FT_ULTRA_BRUTE, 0x25, 0x15, 0x12, FT_END};\n    return filters;\n}\n\nunsigned PackTmt::findOverlapOverhead(const byte *buf, const byte *tbuf, unsigned range,\n                                      unsigned upper_limit) const {\n    // make sure the decompressor will be paragraph aligned\n    unsigned o = super::findOverlapOverhead(buf, tbuf, range, upper_limit);\n    o = ((o + 0x20) & ~0xf) - (ph.u_len & 0xf);\n    return o;\n}\n\nvoid PackTmt::buildLoader(const Filter *ft) {\n    // prepare loader\n    initLoader(stub_i386_dos32_tmt, sizeof(stub_i386_dos32_tmt));\n    addLoader(\"IDENTSTR,TMTMAIN1\", ph.first_offset_found == 1 ? \"TMTMAIN1A\" : \"\", \"TMTMAIN1B\",\n              ft->id ? \"TMTCALT1\" : \"\", \"TMTMAIN2,UPX1HEAD,TMTCUTPO\");\n\n    // fake alignment for the start of the decompressor\n    linker->defineSymbol(\"TMTCUTPO\", 0x1000);\n\n    addLoader(getDecompressorSections(), \"TMTMAIN5\");\n    if (ft->id) {\n        assert(ft->calls > 0);\n        addLoader(\"TMTCALT2\");\n        addFilter32(ft->id);\n    }\n    addLoader(\"TMTRELOC,RELOC320\", big_relocs ? \"REL32BIG\" : \"\", \"RELOC32J,TMTJUMP1\");\n}\n\n/*************************************************************************\n//\n**************************************************************************/\n\nint PackTmt::readFileHeader() {\n#define H(x)  get_le16(h + 2 * (x))\n#define H4(x) get_le32(h + (x))\n    byte h[0x40];\n    int ic;\n    unsigned exe_offset = 0;\n    adam_offset = 0;\n\n    for (ic = 0; ic < 20; ic++) {\n        fi->seek(adam_offset, SEEK_SET);\n        fi->readx(h, sizeof(h));\n\n        if (memcmp(h, \"MZ\", 2) == 0) // dos/exe\n        {\n            exe_offset = adam_offset;\n            adam_offset += H(2) * 512 + H(1);\n            if (H(1))\n                adam_offset -= 512;\n            if (H(0x18 / 2) == 0x40 && H4(0x3c))\n                adam_offset = H4(0x3c);\n        } else if (memcmp(h, \"BW\", 2) == 0) {\n            adam_offset += H(2) * 512 + H(1);\n        } else if (memcmp(h, \"PMW1\", 4) == 0) {\n            fi->seek(adam_offset + H4(0x18), SEEK_SET);\n            adam_offset += H4(0x24);\n            unsigned objs = H4(0x1c);\n            while (objs--) {\n                fi->readx(h, 0x18);\n                adam_offset += H4(4);\n            }\n        } else if (memcmp(h, \"LE\", 2) == 0) {\n            // + (memory_pages-1)*memory_page_size+bytes_on_last_page\n            unsigned offs = exe_offset + (H4(0x14) - 1) * H4(0x28) + H4(0x2c);\n            fi->seek(adam_offset + 0x80, SEEK_SET);\n            fi->readx(h, 4);\n            // + data_pages_offset\n            adam_offset = offs + H4(0);\n        } else if (memcmp(h, \"Adam\", 4) == 0) {\n            break;\n        } else\n            return 0;\n    }\n    if (ic == 20)\n        return 0;\n\n    fi->seek(adam_offset, SEEK_SET);\n    fi->readx(&ih, sizeof(ih));\n\n    // TODO: could add more checks for the values in 'ih'\n    const unsigned imagesize = ih.imagesize;\n    const unsigned entry = ih.entry;\n    const unsigned rsize = ih.relocsize;\n    if (imagesize < sizeof(ih) || imagesize >= file_size_u || entry >= file_size_u ||\n        rsize >= file_size_u) {\n        throwCantPack(\"%s: bad header: imagesize=%#x entry=%#x relocsize=%#x\", getName(), imagesize,\n                      entry, rsize);\n        return 0;\n    }\n\n    return UPX_F_TMT_ADAM;\n#undef H4\n#undef H\n}\n\ntribool PackTmt::canPack() {\n    if (!readFileHeader())\n        return false;\n    return true;\n}\n\n/*************************************************************************\n//\n**************************************************************************/\n\nvoid PackTmt::pack(OutputFile *fo) {\n    big_relocs = 0;\n\n    Packer::handleStub(fi, fo, adam_offset);\n\n    const unsigned usize = ih.imagesize;\n    const unsigned rsize = ih.relocsize;\n    const unsigned relocnum = rsize / 4;\n\n    ibuf.alloc(usize + rsize + 128);\n    obuf.allocForCompression(usize + rsize + 128);\n\n    fi->seek(adam_offset + sizeof(ih), SEEK_SET);\n    fi->readx(ibuf, usize);\n\n    if (find_le32(ibuf, UPX_MIN(128u, usize), get_le32(\"UPX \")) >= 0)\n        throwAlreadyPacked();\n    if (rsize == 0)\n        throwCantPack(\"file is already compressed with another packer\");\n\n    MemBuffer mb_relocs(rsize);\n    SPAN_S_VAR(byte, relocs, mb_relocs);\n    fi->readx(relocs, rsize);\n\n    const unsigned overlay = file_size - fi->tell();\n    checkOverlay(overlay);\n\n    for (unsigned ic = 0; ic < relocnum; ic++)\n        set_le32(relocs + 4 * ic, get_le32(relocs + 4 * ic) - 4);\n\n    MemBuffer mb_orelocs(4 * relocnum + 8192); // relocations + extra_info\n    SPAN_S_VAR(byte, orelocs, mb_orelocs);\n    unsigned orelocsize =\n        optimizeReloc(relocnum, relocs, orelocs, ibuf, usize, 32, true, &big_relocs);\n    mb_relocs.dealloc(); // done\n#if 1\n    // write duplicate end marker; why is this here - historical oversight ???\n    orelocs[orelocsize++] = 0;\n#endif\n    // extra_info\n    set_le32(orelocs + orelocsize, ih.entry); // save original entry point\n    orelocsize += 4;\n    set_le32(orelocs + orelocsize, orelocsize + 4); // save orelocsize\n    orelocsize += 4;\n    memcpy(raw_index_bytes(ibuf, usize, orelocsize), orelocs, orelocsize);\n    mb_orelocs.dealloc(); // done\n\n    // prepare packheader\n    ph.u_len = usize + orelocsize;\n    // prepare filter\n    Filter ft(ph.level);\n    ft.buf_len = usize;\n    // compress\n    upx_compress_config_t cconf;\n    cconf.reset();\n    // limit stack size needed for runtime decompression\n    cconf.conf_lzma.max_num_probs = 1846 + (768 << 4); // ushort: ~28 KiB stack\n    compressWithFilters(&ft, 512, &cconf);\n\n    const unsigned lsize = getLoaderSize();\n    const unsigned s_point = getLoaderSection(\"TMTMAIN1\");\n    int e_len = getLoaderSectionStart(\"TMTCUTPO\");\n    const unsigned d_len = lsize - e_len;\n    assert(e_len > 0 && s_point > 0);\n\n    // patch loader\n    linker->defineSymbol(\"original_entry\", ih.entry);\n    defineDecompressorSymbols();\n    defineFilterSymbols(&ft);\n\n    linker->defineSymbol(\"bytes_to_copy\", ph.c_len + d_len);\n    linker->defineSymbol(\"copy_dest\", 0u - (ph.u_len + ph.overlap_overhead + d_len - 1));\n    linker->defineSymbol(\"copy_source\", ph.c_len + lsize - 1);\n    linker->defineSymbol(\"TMTCUTPO\", ph.u_len + ph.overlap_overhead);\n    relocateLoader();\n\n    MemBuffer loader(lsize);\n    memcpy(loader, getLoader(), lsize);\n    patchPackHeader(loader, e_len);\n\n    memcpy(&oh, &ih, sizeof(oh));\n    oh.imagesize = ph.c_len + lsize; // new size\n    oh.entry = s_point;              // new entry point\n    oh.relocsize = 4;\n\n    // write loader + compressed file\n    fo->write(&oh, sizeof(oh));\n    fo->write(loader, e_len);\n    fo->write(obuf, ph.c_len);\n    fo->write(loader + lsize - d_len, d_len); // decompressor\n    byte rel_entry[4];\n    set_le32(rel_entry, 5 + s_point);\n    fo->write(rel_entry, sizeof(rel_entry));\n\n    // verify\n    verifyOverlappingDecompression();\n\n    // copy the overlay\n    copyOverlay(fo, overlay, obuf);\n\n    // finally check the compression ratio\n    if (!checkFinalCompressionRatio(fo))\n        throwNotCompressible();\n}\n\ntribool PackTmt::canUnpack() {\n    if (!readFileHeader())\n        return false;\n    fi->seek(adam_offset, SEEK_SET);\n    return readPackHeader(512) ? 1 : -1;\n}\n\nvoid PackTmt::unpack(OutputFile *fo) {\n    Packer::handleStub(fi, fo, adam_offset);\n\n    ibuf.alloc(ph.c_len);\n    obuf.allocForDecompression(ph.u_len);\n\n    fi->seek(adam_offset + ph.buf_offset + ph.getPackHeaderSize(), SEEK_SET);\n    fi->readx(ibuf, ph.c_len);\n\n    // decompress\n    decompress(ibuf, obuf);\n\n    // read extra_info\n    const unsigned orig_entry = mem_size(1, get_le32(obuf + ph.u_len - 8));\n    const unsigned orelocsize = mem_size(1, get_le32(obuf + ph.u_len - 4));\n    const unsigned osize = mem_size(1, ph.u_len - orelocsize);\n\n    // unfilter\n    if (ph.filter) {\n        Filter ft(ph.level);\n        ft.init(ph.filter, 0);\n        ft.cto = (byte) ph.filter_cto;\n        if (ph.version < 11)\n            ft.cto = (byte) (get_le32(obuf + ph.u_len - 12) >> 24);\n        ft.unfilter(obuf, osize);\n    }\n\n    // decode relocations\n    SPAN_S_VAR(const byte, orelocs, raw_index_bytes(obuf, osize, orelocsize), orelocsize);\n    SPAN_S_VAR(byte, reloc_image, raw_index_bytes(obuf, 0, osize), osize);\n    MemBuffer mb_relocs;\n    const unsigned relocnum = unoptimizeReloc(orelocs, mb_relocs, reloc_image, osize, 32, true);\n    SPAN_S_VAR(byte, relocs, mb_relocs);\n    for (unsigned ic = 0; ic < relocnum; ic++)\n        set_le32(relocs + 4 * ic, get_le32(relocs + 4 * ic) + 4);\n\n    memcpy(&oh, &ih, sizeof(oh));\n    oh.imagesize = osize;\n    oh.entry = orig_entry;\n    oh.relocsize = relocnum * 4;\n\n    const unsigned overlay = file_size - adam_offset - ih.imagesize - ih.relocsize - sizeof(ih);\n    checkOverlay(overlay);\n\n    // write decompressed file\n    if (fo) {\n        fo->write(&oh, sizeof(oh));\n        fo->write(obuf, osize);\n        fo->write(relocs, relocnum * 4);\n    }\n\n    // copy the overlay\n    copyOverlay(fo, overlay, obuf);\n}\n\n/* vim:set ts=4 sw=4 et: */\n","size_bytes":11024},"src/p_tos.cpp":{"content":"/* p_tos.cpp -- atari/tos executable format\n\n   This file is part of the Resize executable compressor.\n\n   Copyright (C) 2025 WHO-AM-I-404\n   Based on UPX - Ultimate Packer for eXecutables\n   Copyright (C) 1996-2025 Markus Franz Xaver Johannes Oberhumer\n   Copyright (C) 1996-2025 Laszlo Molnar\n   All Rights Reserved.\n\n   Resize and the UCL library are free software; you can redistribute them\n   and/or modify them under the terms of the GNU General Public License as\n   published by the Free Software Foundation; either version 2 of\n   the License, or (at your option) any later version.\n\n   This program is distributed in the hope that it will be useful,\n   but WITHOUT ANY WARRANTY; without even the implied warranty of\n   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n   GNU General Public License for more details.\n\n   You should have received a copy of the GNU General Public License\n   along with this program; see the file COPYING.\n   If not, write to the Free Software Foundation, Inc.,\n   59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.\n\n   WHO-AM-I-404 <who-am-i-404@proton.me>\n   Based on original work by:\n   Markus F.X.J. Oberhumer <markus@oberhumer.com>\n   Laszlo Molnar <ezerotven+github@gmail.com>\n */\n\n// atari/tos: lots of micro-optimizations because this was written at a time\n//   where bytes and CPU cycles really mattered\n\n#include \"conf.h\"\n#include \"file.h\"\n#include \"filter.h\"\n#include \"packer.h\"\n#include \"p_tos.h\"\n#include \"linker.h\"\n\nstatic const CLANG_FORMAT_DUMMY_STATEMENT\n#include \"stub/m68k-atari.tos.h\"\n\n// #define TESTING 1\n\n/*************************************************************************\n//\n**************************************************************************/\n\n#define FH_SIZE sizeof(tos_header_t)\n\nPackTos::PackTos(InputFile *f) : super(f) {\n    bele = &N_BELE_RTP::be_policy;\n    COMPILE_TIME_ASSERT(FH_SIZE == 28)\n    COMPILE_TIME_ASSERT_ALIGNED1(tos_header_t)\n}\n\nLinker *PackTos::newLinker() const { return new ElfLinkerM68k; }\n\nconst int *PackTos::getCompressionMethods(int method, int level) const {\n    bool small = ih.fh_text + ih.fh_data <= 256 * 1024;\n    return Packer::getDefaultCompressionMethods_8(method, level, small);\n}\n\nconst int *PackTos::getFilters() const { return nullptr; }\n\nvoid PackTos::LinkerSymbols::LoopInfo::init(unsigned count_, bool allow_dbra) {\n    count = value = count_;\n    if (count == 0)\n        mode = LOOP_NONE;\n    else if (count <= 65536 && allow_dbra) {\n        mode = LOOP_DBRA;\n        value -= 1;\n        value &= 0xffff;\n    } else if (count <= 65536) {\n        mode = LOOP_SUBQ_W;\n        value &= 0xffff;\n    } else\n        mode = LOOP_SUBQ_L;\n}\n\nunsigned PackTos::getDecomprOffset(int method, int small) const {\n    UNUSED(small);\n    if (M_IS_NRV2B(method))\n        return 2; // FIXME: do not hardcode this value\n    else if (M_IS_NRV2D(method))\n        return 2; // FIXME: do not hardcode this value\n    else if (M_IS_NRV2E(method))\n        return 2; // FIXME: do not hardcode this value\n    else if (M_IS_LZMA(method))\n        return linker->getSectionSize(\"__mulsi3\");\n    else\n        throwBadLoader();\n    return 0;\n}\n\nvoid PackTos::buildLoader(const Filter *ft) {\n    assert(ft->id == 0);\n\n    initLoader(stub_m68k_atari_tos, sizeof(stub_m68k_atari_tos));\n    // linker->dumpSymbols();\n\n    //\n    // part 1a\n    //\n\n    addLoader(\"entry\");\n\n    if (symbols.up21_a6 <= 32767)\n        addLoader(\"set_up21_a6.w\");\n    else if (symbols.up21_d4 <= 32767)\n        addLoader(\"set_up21_d4.w\");\n    else\n        addLoader(\"set_up21_d4.l\");\n\n    assert(symbols.loop1.count || symbols.loop2.count);\n    if (symbols.loop1.count) {\n        if (symbols.loop1.value <= 127)\n            addLoader(\"loop1_set_count.b\");\n        else if (symbols.loop1.value <= 65535)\n            addLoader(\"loop1_set_count.w\");\n        else\n            addLoader(\"loop1_set_count.l\");\n        addLoader(\"loop1_label\");\n        addLoader(opt->small ? \"loop1.small\" : \"loop1.fast\");\n        if (symbols.loop1.mode == symbols.LOOP_SUBQ_L)\n            addLoader(\"loop1_subql\");\n        else if (symbols.loop1.mode == symbols.LOOP_SUBQ_W)\n            addLoader(\"loop1_subqw\");\n        else if (symbols.loop1.mode == symbols.LOOP_DBRA)\n            addLoader(\"loop1_dbra\");\n        else\n            throwBadLoader();\n    }\n    if (symbols.loop2.count) {\n        assert(symbols.loop2.mode == symbols.LOOP_DBRA);\n        addLoader(opt->small ? \"loop2.small\" : \"loop2.fast\");\n    }\n\n    addLoader(\"copy_to_stack\");\n\n    if (M_IS_NRV2B(ph.method))\n        addLoader(\"nrv2b.init\");\n    else if (M_IS_NRV2D(ph.method))\n        addLoader(\"nrv2d.init\");\n    else if (M_IS_NRV2E(ph.method))\n        addLoader(\"nrv2e.init\");\n    else if (M_IS_LZMA(ph.method))\n        addLoader(\"lzma.init\");\n    else\n        throwBadLoader();\n\n    symbols.up31_d4 = symbols.up31_base_d4 + getDecomprOffset(ph.method, opt->small);\n    symbols.up31_a6 = symbols.up31_base_a6 + getDecomprOffset(ph.method, opt->small);\n    if (symbols.up31_a6 <= 32767)\n        addLoader(\"jmp_decompressor_a6.w\");\n    else if (symbols.up31_d4 <= 32767)\n        addLoader(\"jmp_decompressor_d4.w\");\n    else if (symbols.up31_a6 <= 65534)\n        addLoader(\"jmp_decompressor_a6.w2\");\n    else\n        addLoader(\"jmp_decompressor_d4.l\");\n\n    //\n    // part 1b\n    //\n\n    addLoader(\"code_on_stack\");\n\n    addLoader(\"clear_dirty_bss\");\n    addLoader(\"loop3_label\");\n    addLoader(opt->small ? \"loop3.small\" : \"loop3.fast\");\n    if (symbols.loop3.mode == symbols.LOOP_SUBQ_L)\n        addLoader(\"loop3_subql\");\n    else if (symbols.loop3.mode == symbols.LOOP_SUBQ_W)\n        addLoader(\"loop3_subqw\");\n    else if (symbols.loop3.mode == symbols.LOOP_DBRA)\n        addLoader(\"loop3_dbra\");\n    else\n        throwBadLoader();\n\n    addLoader(\"flush_cache\");\n    addLoader(\"restore_stack\");\n#if 0\n    addLoader(\"clear_dirty_stack\");\n#endif\n    addLoader(\"start_program\");\n\n    addLoader(\"IDENTSTR,+40D,UPX1HEAD,CUTPOINT\");\n\n    //\n    // part 2\n    //\n\n    if (M_IS_NRV2B(ph.method)) {\n        addLoader(opt->small ? \"nrv2b_8.small\" : \"nrv2b_8.fast\");\n    } else if (M_IS_NRV2D(ph.method)) {\n        addLoader(opt->small ? \"nrv2d_8.small\" : \"nrv2d_8.fast\");\n    } else if (M_IS_NRV2E(ph.method)) {\n        addLoader(opt->small ? \"nrv2e_8.small\" : \"nrv2e_8.fast\");\n    } else if (M_IS_LZMA(ph.method)) {\n        addLoader(\"__mulsi3\");\n        addLoader(opt->small ? \"lzma.small\" : \"lzma.fast\");\n        addLoader(\"lzma.finish\");\n    } else\n        throwBadLoader();\n\n    if (symbols.need_reloc)\n        addLoader(\"reloc\");\n\n    assert(symbols.loop3.count);\n    if (symbols.loop3.value <= 127)\n        addLoader(\"loop3_set_count.b\");\n    else if (symbols.loop3.value <= 65535)\n        addLoader(\"loop3_set_count.w\");\n    else\n        addLoader(\"loop3_set_count.l\");\n\n    addLoader(\"jmp_stack\");\n}\n\n/*************************************************************************\n//\n**************************************************************************/\n\n/* flags for curproc->memflags */\n/* also used for program headers fh_flag */\n#define F_FASTLOAD 0x01 // don't zero heap\n#define F_ALTLOAD  0x02 // OK to load in alternate ram\n#define F_ALTALLOC 0x04 // OK to malloc from alt. ram\n#define F_SMALLTPA 0x08\n// used in MagiC: TPA can be allocated as specified in the program header\n// rather than the biggest free memory block\n#define F_MEMFLAGS 0xf0  // reserved for future use\n#define F_SHTEXT   0x800 // program's text may be shared\n\n#define F_MINALT 0xf0000000 // used to decide which type of RAM to load in\n\n#define F_ALLOCZERO 0x2000 // zero mem, for bugged (GEM...) programs\n\n/* Bit in Mxalloc's arg for \"don't auto-free this memory\" */\n#define F_KEEP 0x4000\n\n#define F_OS_SPECIAL 0x8000 // mark as a special process\n\n/* flags for curproc->memflags (that is, fh_flag) and also Mxalloc mode.  */\n/* (Actually, when users call Mxalloc, they add 0x10 to what you see here) */\n#define F_PROTMODE 0xf0 // protection mode bits\n#define F_PROT_P   0x00 // no read or write\n#define F_PROT_G   0x10 // any access OK\n#define F_PROT_S   0x20 // any super access OK\n#define F_PROT_PR  0x30 // any read OK, no write\n#define F_PROT_I   0x40 // invalid page\n\n/*************************************************************************\n// util\n//   readFileHeader() reads ih and checks for illegal values\n//   checkFileHeader() checks ih for legal but unsupported values\n**************************************************************************/\n\nint PackTos::readFileHeader() {\n    fi->seek(0, SEEK_SET);\n    fi->readx(&ih, FH_SIZE);\n    if (ih.fh_magic != 0x601a)\n        return 0;\n    if (0ull + FH_SIZE + ih.fh_text + ih.fh_data + ih.fh_sym > file_size_u)\n        return 0;\n    return UPX_F_ATARI_TOS;\n}\n\nbool PackTos::checkFileHeader() {\n    const unsigned f = ih.fh_flag;\n    // printf(\"flags: 0x%x, text: %d, data: %d, bss: %d, sym: %d\\n\", f, (int) ih.fh_text,\n    //        (int) ih.fh_data, (int) ih.fh_bss, (int) ih.fh_sym);\n    if ((ih.fh_text & 1) || (ih.fh_data & 1))\n        throwCantPack(\"odd size values in text/data\");\n    if (f & F_OS_SPECIAL)\n        throwCantPack(\"I won't pack F_OS_SPECIAL programs\");\n    if ((f & F_PROTMODE) > F_PROT_I)\n        throwCantPack(\"invalid protection mode\");\n    if ((f & F_PROTMODE) != F_PROT_P) {\n        if (opt->force < 1)\n            throwCantPack(\"no private memory protection; use option '-f' to force packing\");\n    }\n    if (f & F_SHTEXT) {\n        if (opt->force < 1)\n            throwCantPack(\"shared text segment; use option '-f' to force packing\");\n    }\n#if 0\n    // fh_reserved seems to be unused\n    if (ih.fh_reserved != 0) {\n        if (opt->force < 1)\n            throwCantPack(\"reserved header field set; use option '-f' to force packing\");\n    }\n#endif\n    return true;\n}\n\n/*************************************************************************\n// relocs\n**************************************************************************/\n\n// Check relocations for errors to make sure our loader can handle them\nstatic bool check_relocs(const byte *relocs, unsigned rsize, unsigned image_size,\n                         unsigned *relocnum, unsigned *relocsize, unsigned *overlay) {\n    assert(rsize >= 4);\n    assert(image_size >= 4);\n    unsigned fixup = get_be32(relocs);\n    if (fixup == 0 || fixup >= image_size)\n        return false;\n    unsigned last_fixup = fixup;\n    unsigned i = 4;\n\n    *relocnum = 1;\n    for (;;) {\n        if (fixup & 1) // must be word-aligned\n            return false;\n        if (fixup + 4 > image_size) // out of bounds\n            return false;\n        if (i >= rsize) // premature EOF in relocs\n            return false;\n        unsigned c = relocs[i++];\n        if (c == 0) // EOF end marker\n            break;\n        else if (c == 1) // increase fixup, no reloc\n            fixup += 254;\n        else if (c & 1) // must be word-aligned\n            return false;\n        else // next reloc is here\n        {\n            fixup += c;\n            if (fixup - last_fixup < 4) // overlapping relocation\n                return false;\n            last_fixup = fixup;\n            *relocnum += 1;\n        }\n    }\n\n    *relocsize = i;\n    *overlay = rsize - i;\n    return true;\n}\n\n/*************************************************************************\n//\n**************************************************************************/\n\ntribool PackTos::canPack() {\n    if (!readFileHeader())\n        return false;\n\n    byte buf[768];\n    fi->readx(buf, sizeof(buf));\n    checkAlreadyPacked(buf, sizeof(buf));\n\n    if (!checkFileHeader())\n        throwCantPack(\"unsupported header flags\");\n    if (file_size < 1024)\n        throwCantPack(\"program is too small for atari/tos\");\n\n    return true;\n}\n\nvoid PackTos::fileInfo() {\n    if (!readFileHeader())\n        return;\n    con_fprintf(stdout, \"    text: %d, data: %d, sym: %d, bss: %d, flags=0x%x\\n\", (int) ih.fh_text,\n                (int) ih.fh_data, (int) ih.fh_sym, (int) ih.fh_bss, (int) ih.fh_flag);\n}\n\n/*************************************************************************\n//\n**************************************************************************/\n\nvoid PackTos::pack(OutputFile *fo) {\n    unsigned t;\n    unsigned relocnum = 0;\n    unsigned relocsize = 0;\n    unsigned overlay = 0;\n\n    const unsigned i_text = ih.fh_text;\n    const unsigned i_data = ih.fh_data;\n    const unsigned i_sym = ih.fh_sym;\n    const unsigned i_bss = ih.fh_bss;\n\n    symbols.reset();\n    symbols.need_reloc = false;\n    // prepare symbols for buildLoader() - worst case\n    symbols.loop1.init(65536 + 1);\n    symbols.loop2.init((160 - 1) / 4);\n    symbols.loop3.init(65536 + 1);\n    symbols.up21_d4 = 65536 + 1;\n    symbols.up21_a6 = 65536 + 1;\n    symbols.up31_base_d4 = 65536 + 1;\n    symbols.up31_base_a6 = 65536 + 1;\n\n    // read file\n    const unsigned isize = file_size_u - i_sym;\n    ibuf.alloc(isize);\n    fi->seek(FH_SIZE, SEEK_SET);\n    // read text + data\n    t = i_text + i_data;\n    fi->readx(ibuf, t);\n    // skip symbols\n    if (i_sym && opt->exact)\n        throwCantPackExact();\n    fi->seek(i_sym, SEEK_CUR);\n    // read relocations + overlay\n    overlay = file_size_u - (FH_SIZE + i_text + i_data + i_sym);\n    fi->readx(ibuf + t, overlay);\n\n#if TESTING\n    printf(\"text: %d, data: %d, sym: %d, bss: %d, flags=0x%x\\n\", i_text, i_data, i_sym, i_bss,\n           (int) ih.fh_flag);\n    printf(\"xx1 reloc: %d, overlay: %d, fixup: %d\\n\", relocsize, overlay,\n           overlay >= 4 ? (int) get_be32(ibuf + t) : -1);\n#endif\n\n    // Check relocs (see load_and_reloc() in freemint/sys/memory.c).\n    // Must work around TOS bugs and lots of broken programs.\n    if (overlay < 4) {\n        // Bug workaround: Whatever this is, silently keep it in\n        // the (unused) relocations for byte-identical unpacking.\n        relocsize = overlay;\n        overlay = 0;\n    } else if (get_be32(ibuf + t) == 0) {\n        // Bug workaround - check the empty fixup before testing fh_reloc.\n        relocsize = 4;\n        overlay -= 4;\n    } else if (ih.fh_reloc != 0)\n        relocsize = 0;\n    else {\n        if (!check_relocs(ibuf + t, overlay, t, &relocnum, &relocsize, &overlay))\n            throwCantPack(\"bad relocation table\");\n        symbols.need_reloc = true;\n    }\n\n#if TESTING\n    printf(\"xx2: %d relocs: %d, overlay: %d, t: %d\\n\", relocnum, relocsize, overlay, t);\n#endif\n\n    checkOverlay(overlay);\n\n    // Append original fileheader.\n    t += relocsize;\n    ih.fh_sym = 0; // we stripped all symbols\n    memcpy(ibuf + t, &ih, FH_SIZE);\n    t += FH_SIZE;\n#if TESTING\n    printf(\"xx3 reloc: %d, overlay: %d, t: %d\\n\", relocsize, overlay, t);\n#endif\n    assert(t <= isize);\n\n    // Now the data in ibuf[0..t] looks like this:\n    //   text + data + relocs + original file header\n    // After compression this will become the first part of the\n    // data segment. The second part will be the decompressor.\n\n    // alloc buffer (4096 is for decompressor and the various alignments)\n    obuf.allocForCompression(t, 4096);\n\n    // prepare packheader\n    ph.u_len = t;\n    // prepare filter\n    Filter ft(ph.level);\n    // compress (max_match = 65535)\n    upx_compress_config_t cconf;\n    cconf.reset();\n    cconf.conf_ucl.max_match = 65535;\n    cconf.conf_lzma.max_num_probs = 1846 + (768 << 4); // ushort: ~28 KiB stack\n    compressWithFilters(&ft, 512, &cconf);\n\n    //\n    // multipass buildLoader()\n    //\n\n    // save initial loader\n    const unsigned initial_lsize = getLoaderSize();\n    unsigned last_lsize = initial_lsize;\n    MemBuffer last_loader(last_lsize);\n    memcpy(last_loader, getLoader(), last_lsize);\n\n    unsigned o_text, o_data, o_bss;\n    unsigned e_len, d_len, d_off;\n    for (;;) {\n        // The decompressed data will now get placed at this offset:\n        unsigned offset = (ph.u_len + ph.overlap_overhead) - ph.c_len;\n\n        // get loader\n        const unsigned lsize = getLoaderSize();\n        e_len = getLoaderSectionStart(\"CUTPOINT\");\n        d_len = lsize - e_len;\n        assert((e_len & 3) == 0 && (d_len & 1) == 0);\n\n        // compute section sizes\n        o_text = e_len;\n        o_data = ph.c_len;\n        o_bss = i_bss;\n\n        // word align len of compressed data\n        while (o_data & 1) {\n            obuf[o_data++] = 0;\n            offset++;\n        }\n\n        // append decompressor (part 2 of loader)\n        d_off = o_data;\n        ////memcpy(obuf + d_off, getLoader() + e_len, d_len); // must be done after relocation\n        o_data += d_len;\n\n        // dword align the len of the final data segment\n        while (o_data & 3) {\n            obuf[o_data++] = 0;\n            offset++;\n        }\n        // dword align offset\n        while (offset & 3)\n            offset++;\n\n        // new bss\n        if (i_text + i_data + i_bss > o_text + o_data + o_bss)\n            o_bss = (i_text + i_data + i_bss) - (o_text + o_data);\n\n        // dirty bss\n        unsigned dirty_bss = (o_data + offset) - (i_text + i_data);\n        // printf(\"real dirty_bss: %d\\n\", dirty_bss);\n        // dword align (or 16 - for speedup when clearing the dirty bss)\n        const unsigned dirty_bss_align = opt->small ? 4 : 16;\n        while (dirty_bss & (dirty_bss_align - 1))\n            dirty_bss++;\n        // adjust bss, assert room for some stack\n        unsigned stack = 512 + getDecompressorWrkmemSize();\n        if (dirty_bss + stack > o_bss)\n            o_bss = dirty_bss + stack;\n\n        // dword align the len of the final bss segment\n        while (o_bss & 3)\n            o_bss++;\n\n        // update symbols for buildLoader()\n        if (opt->small) {\n            symbols.loop1.init(o_data / 4);\n            symbols.loop2.init(0);\n        } else {\n            symbols.loop1.init(o_data / 160);\n            symbols.loop2.init((o_data % 160) / 4);\n        }\n        symbols.loop3.init(dirty_bss / dirty_bss_align);\n\n        symbols.up21_d4 = o_data + offset;\n        symbols.up31_base_d4 = d_off + offset;\n        symbols.up21_a6 = symbols.up21_d4 - (i_text + i_data);\n        symbols.up31_base_a6 = symbols.up31_base_d4 - (i_text + i_data);\n        assert((int) symbols.up21_a6 > 0);\n        assert((int) symbols.up31_base_a6 > 0);\n\n        const unsigned c = linker->getSymbolOffset(\"code_on_stack\");\n        unsigned d;\n        d = linker->getSymbolOffset(\"flush_cache_rts\") - c;\n        symbols.flush_cache_rts_offset = d;\n        d = linker->getSymbolOffset(\"clear_dirty_stack_loop\") - c;\n        symbols.clear_dirty_stack_len = (d + 3) / 4 + 32 - 1;\n        d = linker->getSymbolOffset(\"code_on_stack_end\") - c;\n        symbols.copy_to_stack_len = d / 2 - 1;\n\n        // now re-build loader\n        buildLoader(&ft);\n        unsigned new_lsize = getLoaderSize();\n        // printf(\"buildLoader %d %d\\n\", new_lsize, initial_lsize);\n        assert(new_lsize <= initial_lsize);\n        if (new_lsize == last_lsize && memcmp(getLoader(), last_loader, last_lsize) == 0)\n            break;\n        last_lsize = new_lsize;\n        memcpy(last_loader, getLoader(), last_lsize);\n    }\n\n    //\n    // define symbols and reloc\n    //\n\n    defineDecompressorSymbols();\n\n    linker->defineSymbol(\"loop1_count\", symbols.loop1.value);\n    linker->defineSymbol(\"loop2_count\", symbols.loop2.value);\n    linker->defineSymbol(\"loop3_count\", symbols.loop3.value);\n\n    linker->defineSymbol(\"orig_p_tlen\", i_text);\n    linker->defineSymbol(\"orig_p_dlen\", i_data);\n    linker->defineSymbol(\"orig_p_blen\", i_bss);\n\n    if (symbols.up21_a6 <= 32767)\n        linker->defineSymbol(\"up21_a6\", symbols.up21_a6);\n    else\n        linker->defineSymbol(\"up21_d4\", symbols.up21_d4);\n\n    if (symbols.up31_a6 <= 32767)\n        linker->defineSymbol(\"up31_a6\", symbols.up31_a6);\n    else if (symbols.up31_d4 <= 32767)\n        linker->defineSymbol(\"up31_d4\", symbols.up31_d4);\n    else if (symbols.up31_a6 <= 65534)\n        linker->defineSymbol(\"up31_a6\", symbols.up31_a6 - 32767);\n    else\n        linker->defineSymbol(\"up31_d4\", symbols.up31_d4);\n#if 0\n    printf(\"relocsize = %d\\n\", relocsize);\n    printf(\"upx21(d4) = %d\\n\", symbols.up21_d4);\n    printf(\"upx21(a6) = %d\\n\", symbols.up21_a6);\n    printf(\"upx31(d4) = %d\\n\", symbols.up31_d4);\n    printf(\"upx31(a6) = %d\\n\", symbols.up31_a6);\n#endif\n\n    linker->defineSymbol(\"flush_cache_rts_offset\", symbols.flush_cache_rts_offset);\n    linker->defineSymbol(\"copy_to_stack_len\", symbols.copy_to_stack_len);\n    linker->defineSymbol(\"clear_dirty_stack_len\", symbols.clear_dirty_stack_len);\n\n    relocateLoader();\n\n    //\n    // write\n    //\n\n    // set new file_hdr\n    memcpy(&oh, &ih, FH_SIZE);\n    if (opt->atari_tos.split_segments) {\n        oh.fh_text = o_text;\n        oh.fh_data = o_data;\n    } else {\n        // put everything into the text segment\n        oh.fh_text = o_text + o_data;\n        oh.fh_data = 0;\n    }\n    oh.fh_bss = o_bss;\n    oh.fh_sym = 0;\n    oh.fh_reserved = 0;\n    // only keep the following flags:\n    oh.fh_flag = ih.fh_flag & (F_FASTLOAD | F_ALTALLOC | F_SMALLTPA | F_ALLOCZERO | F_KEEP);\n    // add an empty relocation fixup to workaround a bug in some TOS versions\n    oh.fh_reloc = 0;\n\n#if TESTING\n    printf(\"old text: %6d, data: %6d, bss: %6d, reloc: %d, overlay: %d\\n\", i_text, i_data, i_bss,\n           relocsize, overlay);\n    printf(\"new text: %6d, data: %6d, bss: %6d, flag=0x%x\\n\", o_text, o_data, o_bss,\n           (int) oh.fh_flag);\n    linker->dumpSymbols();\n#endif\n\n    // prepare loader\n    MemBuffer loader(o_text);\n    memcpy(loader, getLoader(), o_text);\n    patchPackHeader(loader, o_text);\n\n    // write new file header, loader and compressed file\n    fo->write(&oh, FH_SIZE);\n    fo->write(loader, o_text); // entry\n    if (opt->debug.dump_stub_loader)\n        OutputFile::dump(opt->debug.dump_stub_loader, loader, o_text);\n    memcpy(obuf + d_off, getLoader() + e_len, d_len); // copy decompressor\n    fo->write(obuf, o_data);                          // compressed + decompressor\n\n    // write empty relocation fixup\n    fo->write(\"\\x00\\x00\\x00\\x00\", 4);\n\n    // verify\n    verifyOverlappingDecompression();\n\n    // copy the overlay\n    copyOverlay(fo, overlay, obuf);\n\n    // finally check the compression ratio\n    if (!checkFinalCompressionRatio(fo))\n        throwNotCompressible();\n}\n\n/*************************************************************************\n//\n**************************************************************************/\n\ntribool PackTos::canUnpack() {\n    if (!readFileHeader())\n        return false;\n    if (!readPackHeader(768))\n        return false;\n    // check header as set by packer\n    if ((ih.fh_text & 3) != 0 || (ih.fh_data & 3) != 0 || (ih.fh_bss & 3) != 0 || ih.fh_sym != 0 ||\n        ih.fh_reserved != 0 || ih.fh_reloc > 1)\n        throwCantUnpack(\"program header damaged\");\n    // generic check\n    if (!checkFileHeader())\n        throwCantUnpack(\"unsupported header flags\");\n    return true;\n}\n\n/*************************************************************************\n//\n**************************************************************************/\n\nvoid PackTos::unpack(OutputFile *fo) {\n    ibuf.alloc(ph.c_len);\n    obuf.allocForDecompression(ph.u_len);\n\n    fi->seek(FH_SIZE + ph.buf_offset + ph.getPackHeaderSize(), SEEK_SET);\n    fi->readx(ibuf, ph.c_len);\n\n    // decompress\n    decompress(ibuf, obuf);\n\n    // write original header & decompressed file\n    if (fo) {\n        unsigned overlay = file_size_u - (FH_SIZE + ih.fh_text + ih.fh_data);\n        if (ih.fh_reloc == 0 && overlay >= 4)\n            overlay -= 4; // this is our empty fixup\n        checkOverlay(overlay);\n\n        fo->write(obuf + ph.u_len - FH_SIZE, FH_SIZE); // orig. file_hdr\n        fo->write(obuf, ph.u_len - FH_SIZE);           // orig. text+data+relocs\n\n        // copy any overlay\n        copyOverlay(fo, overlay, obuf);\n    }\n}\n\n/* vim:set ts=4 sw=4 et: */\n","size_bytes":23769},"src/p_unix.cpp":{"content":"/* p_unix.cpp --\n\n   This file is part of the Resize executable compressor.\n\n   Copyright (C) 2025 WHO-AM-I-404\n   Based on UPX - Ultimate Packer for eXecutables\n   Copyright (C) 1996-2025 Markus Franz Xaver Johannes Oberhumer\n   Copyright (C) 1996-2025 Laszlo Molnar\n   Copyright (C) 2000-2025 John F. Reiser\n   All Rights Reserved.\n\n   Resize and the UCL library are free software; you can redistribute them\n   and/or modify them under the terms of the GNU General Public License as\n   published by the Free Software Foundation; either version 2 of\n   the License, or (at your option) any later version.\n\n   This program is distributed in the hope that it will be useful,\n   but WITHOUT ANY WARRANTY; without even the implied warranty of\n   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n   GNU General Public License for more details.\n\n   You should have received a copy of the GNU General Public License\n   along with this program; see the file COPYING.\n   If not, write to the Free Software Foundation, Inc.,\n   59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.\n\n   WHO-AM-I-404 <who-am-i-404@proton.me>\n   Based on original work by:\n   Markus F.X.J. Oberhumer <markus@oberhumer.com>\n   Laszlo Molnar <ezerotven+github@gmail.com>\n\n   John F. Reiser\n   <jreiser@users.sourceforge.net>\n */\n\n\n#include \"conf.h\"\n\n#include \"file.h\"\n#include \"filter.h\"\n#include \"packer.h\"\n#include \"p_unix.h\"\n#include \"p_elf.h\"\n\n// do not change\n#define BLOCKSIZE       (512*1024)\n\n\n/*************************************************************************\n//\n**************************************************************************/\n\nPackUnix::PackUnix(InputFile *f) :\n    super(f), exetype(0), blocksize(0), overlay_offset(0), lsize(0),\n    methods_used(0), szb_info(sizeof(b_info))\n{\n    COMPILE_TIME_ASSERT(sizeof(Elf32_Ehdr) == 52)\n    COMPILE_TIME_ASSERT(sizeof(Elf32_Phdr) == 32)\n    COMPILE_TIME_ASSERT(sizeof(b_info) == 12)\n    COMPILE_TIME_ASSERT(sizeof(l_info) == 12)\n    COMPILE_TIME_ASSERT(sizeof(p_info) == 12)\n\n    // opt->o_unix.android_shlib is global, but must be hint\n    // that applies only when an actual ET_DYN on EM_ARM (only!).\n    // User might say \"--android-shlib\" but give mulitple files\n    // where some are ET_EXEC.\n    saved_opt_android_shlib = opt->o_unix.android_shlib;\n    opt->o_unix.android_shlib = 0;  // Must apply selectively\n    // Besides, cannot figure out why asl_slide_Shdrs does not work.\n}\n\nPackUnix::~PackUnix()\n{\n    opt->o_unix.android_shlib = saved_opt_android_shlib;\n}\n\n// common part of canPack(), enhanced by subclasses\ntribool PackUnix::canPack()\n{\n    if (exetype == 0)\n        return false;\n\n#if defined(__unix__)\n    // must be executable by owner\n    if ((fi->st.st_mode & S_IXUSR) == 0)\n        throwCantPack(\"file not executable; try 'chmod +x'\");\n#endif\n    if (file_size < 4096)\n        throwCantPack(\"file is too small\");\n\n    // info: currently the header is 36 (32+4) bytes before EOF\n    unsigned char buf[256];\n    fi->seek(-(off_t)sizeof(buf), SEEK_END);\n    fi->readx(buf, sizeof(buf));\n    checkAlreadyPacked(buf, sizeof(buf));\n\n    return true;\n}\n\n\nvoid PackUnix::writePackHeader(OutputFile *fo)\n{\n    unsigned char buf[32];\n    memset(buf, 0, sizeof(buf));\n\n    const int hsize = ph.getPackHeaderSize();\n    assert((unsigned)hsize <= sizeof(buf));\n\n    // note: magic constants are always le32\n    set_le32(buf+0, UPX_MAGIC_LE32);\n    set_le32(buf+4, UPX_MAGIC2_LE32);\n\n    checkPatch(nullptr, 0, 0, 0);  // reset\n    patchPackHeader(buf, hsize);\n    checkPatch(nullptr, 0, 0, 0);  // reset\n\n    fo->write(buf, hsize);\n}\n\n\n/*************************************************************************\n// Generic Unix pack(). Subclasses must provide patchLoader().\n//\n// A typical compressed Unix executable looks like this:\n//   - loader stub\n//   - 12 bytes header info\n//   - the compressed blocks, each with a 8 byte header for block sizes\n//   - 4 bytes block end marker (uncompressed size 0)\n//   - 32 bytes UPX packheader\n//   - 4 bytes overlay offset (needed for decompression)\n**************************************************************************/\n\n// see note below and Packer::compress()\nbool PackUnix::checkCompressionRatio(unsigned, unsigned) const\n{\n    return true;\n}\n\nvoid PackUnix::pack1(OutputFile * /*fo*/, Filter & /*ft*/)\n{\n    // derived class usually provides this\n}\n\nint PackUnix::getStrategy(Filter &/*ft*/)\n{\n    // Called just before reading and compressing each block.\n    // Might want to adjust blocksize, etc.\n\n    // If user specified the filter, then use it (-2==filter_strategy).\n    // Else try the first two filters, and pick the better (2==filter_strategy).\n    return (opt->no_filter ? -3 : ((opt->filter > 0) ? -2 : 2));\n}\n\nint PackUnix::pack2(OutputFile *fo, Filter &ft)\n{\n    // compress blocks\n    total_in = 0;\n    total_out = 0;\n\n// FIXME: ui_total_passes is not correct with multiple blocks...\n//    ui_total_passes = (file_size + blocksize - 1) / blocksize;\n//    if (ui_total_passes == 1)\n//        ui_total_passes = 0;\n\n    unsigned remaining = file_size;\n    unsigned n_block = 0;\n    while (remaining > 0)\n    {\n        // FIXME: disable filters if we have more than one block.\n        // FIXME: There is only 1 un-filter in the stub [as of 2002-11-10].\n        // So the next block really has no choice!\n        // This merely prevents an assert() in compressWithFilters(),\n        // which assumes it has free choice on each call [block].\n        // And if the choices aren't the same on each block,\n        // then un-filtering will give incorrect results.\n        int filter_strategy = getStrategy(ft);\n        if (file_size > (off_t)blocksize)\n            filter_strategy = -3;      // no filters\n\n        int l = fi->readx(ibuf, UPX_MIN(blocksize, remaining));\n        remaining -= l;\n\n        // Note: compression for a block can fail if the\n        //       file is e.g. blocksize + 1 bytes long\n\n        // compress\n        ph.overlap_overhead = 0;\n        ph.c_len = ph.u_len = l;\n        ft.buf_len = l;\n\n        // compressWithFilters() updates u_adler _inside_ compress();\n        // that is, AFTER filtering.  We want BEFORE filtering,\n        // so that decompression checks the end-to-end checksum.\n        unsigned const end_u_adler = upx_adler32(ibuf, ph.u_len, ph.u_adler);\n        compressWithFilters(&ft, OVERHEAD, NULL_cconf, filter_strategy,\n            !!n_block++);  // check compression ratio only on first block\n\n        if (ph.c_len < ph.u_len) {\n            const upx_bytep tbuf = nullptr;\n            if (ft.id == 0) tbuf = ibuf;\n            ph.overlap_overhead = OVERHEAD;\n            if (!testOverlappingDecompression(obuf, tbuf, ph.overlap_overhead)) {\n                // not in-place compressible\n                ph.c_len = ph.u_len;\n            }\n        }\n        if (ph.c_len >= ph.u_len) {\n            // block is not compressible\n            ph.c_len = ph.u_len;\n            // must manually update checksum of compressed data\n            ph.c_adler = upx_adler32(ibuf, ph.u_len, ph.saved_c_adler);\n        }\n\n        // write block header\n        b_info blk_info;\n        memset(&blk_info, 0, sizeof(blk_info));\n        set_te32(&blk_info.sz_unc, ph.u_len);\n        set_te32(&blk_info.sz_cpr, ph.c_len);\n        if (ph.c_len < ph.u_len) {\n            blk_info.b_method = (unsigned char) ph.method;\n            blk_info.b_ftid = (unsigned char) ph.filter;\n            blk_info.b_cto8 = (unsigned char) ph.filter_cto;\n        }\n        fo->write(&blk_info, sizeof(blk_info));\n        b_len += sizeof(b_info);\n\n        // write compressed data\n        if (ph.c_len < ph.u_len) {\n            fo->write(obuf, ph.c_len);\n            verifyOverlappingDecompression();  // uses ph.u_adler\n        }\n        else {\n            fo->write(ibuf, ph.u_len);\n        }\n        ph.u_adler = end_u_adler;\n\n        total_in += ph.u_len;\n        total_out += ph.c_len;\n    }\n\n    // update header with totals\n    ph.u_len = total_in;\n    ph.c_len = total_out;\n\n    if ((off_t)total_in != file_size) {\n        throwEOFException();\n    }\n\n    return 1;  // default: write end-of-compression bhdr next\n}\n\nvoid\nPackUnix::patchLoaderChecksum()\n{\n    unsigned char *const ptr = getLoader();\n    l_info *const lp = &linfo;\n    // checksum for loader; also some PackHeader info\n    lp->l_magic = UPX_MAGIC_LE32;  // LE32 always\n    set_te16(&lp->l_lsize, (upx_uint16_t) lsize);\n    lp->l_version = (unsigned char) ph.version;\n    lp->l_format  = (unsigned char) ph.format;\n    // INFO: lp->l_checksum is currently unused\n    set_te32(&lp->l_checksum, upx_adler32(ptr, lsize));\n}\n\noff_t PackUnix::pack3(OutputFile *fo, Filter &ft)\n{\n    if (nullptr==linker) {\n        // If no filter, then linker is not constructed by side effect\n        // of packExtent calling compressWithFilters.\n        // This is typical after \"/usr/bin/patchelf --set-rpath\".\n        buildLoader(&ft);\n    }\n    upx_byte *p = getLoader();\n    lsize = getLoaderSize();\n    updateLoader(fo);\n    patchLoaderChecksum();\n    fo->write(p, lsize);\n    return fo->getBytesWritten();\n}\n\nvoid PackUnix::pack4(OutputFile *fo, Filter &)\n{\n    writePackHeader(fo);\n\n    unsigned tmp;\n    set_te32(&tmp, overlay_offset);\n    fo->write(&tmp, sizeof(tmp));\n}\n\nvoid PackUnix::pack(OutputFile *fo)\n{\n    Filter ft(ph.level);\n    ft.addvalue = 0;\n    b_len = 0;\n    progid = 0;\n\n    // set options\n    blocksize = opt->o_unix.blocksize;\n    if (blocksize <= 0)\n        blocksize = BLOCKSIZE;\n    if ((off_t)blocksize > file_size)\n        blocksize = file_size;\n\n    // init compression buffers\n    ibuf.alloc(blocksize);\n    obuf.allocForCompression(blocksize);\n\n    fi->seek(0, SEEK_SET);\n    pack1(fo, ft);  // generate Elf header, etc.\n\n    // Shlib probably did not generate Elf header yet.\n    if (fo->st_size()) { // Only append if pack1 actually wrote something.\n        p_info hbuf;\n        set_te32(&hbuf.p_progid, progid);\n        set_te32(&hbuf.p_filesize, file_size);\n        set_te32(&hbuf.p_blocksize, blocksize);\n        fo->write(&hbuf, sizeof(hbuf));\n    }\n\n    // append the compressed body\n    if (pack2(fo, ft)) {\n        // write block end marker (uncompressed size 0)\n        b_info hdr; memset(&hdr, 0, sizeof(hdr));\n        set_le32(&hdr.sz_cpr, UPX_MAGIC_LE32);\n        fo->write(&hdr, sizeof(hdr));\n    }\n\n    pack3(fo, ft);  // append loader\n\n    pack4(fo, ft);  // append PackHeader and overlay_offset; update Elf header\n\n    // finally check the compression ratio\n    if (!checkFinalCompressionRatio(fo))\n        throwNotCompressible();\n}\n\n\nvoid PackUnix::packExtent(\n    const Extent &x,\n    Filter *ft,\n    OutputFile *fo,\n    unsigned hdr_u_len,\n    unsigned b_extra,\n    bool inhibit_compression_check\n)\n{\n    unsigned const init_u_adler = ph.u_adler;\n    unsigned const init_c_adler = ph.c_adler;\n    MemBuffer hdr_ibuf;\n    if (hdr_u_len) {\n        hdr_ibuf.alloc(hdr_u_len);\n        fi->seek(0, SEEK_SET);\n        int l = fi->readx(hdr_ibuf, hdr_u_len);\n        (void)l;\n    }\n    fi->seek(x.offset, SEEK_SET);\n    for (off_t rest = x.size; 0 != rest; ) {\n        int const filter_strategy = ft ? getStrategy(*ft) : 0;\n        int l = fi->readx(ibuf, UPX_MIN(rest, (off_t)blocksize));\n        if (l == 0) {\n            break;\n        }\n        rest -= l;\n\n        // Note: compression for a block can fail if the\n        //       file is e.g. blocksize + 1 bytes long\n\n        // compress\n        ph.c_len = ph.u_len = l;\n        ph.overlap_overhead = 0;\n        unsigned end_u_adler = 0;\n        if (ft) {\n            // compressWithFilters() updates u_adler _inside_ compress();\n            // that is, AFTER filtering.  We want BEFORE filtering,\n            // so that decompression checks the end-to-end checksum.\n            end_u_adler = upx_adler32(ibuf, ph.u_len, ph.u_adler);\n            ft->buf_len = l;\n\n                // compressWithFilters() requirements?\n            ph.filter = 0;\n            ph.filter_cto = 0;\n            ft->id = 0;\n            ft->cto = 0;\n\n            compressWithFilters(ft, OVERHEAD, NULL_cconf, filter_strategy,\n                                0, 0, 0, hdr_ibuf, hdr_u_len, inhibit_compression_check);\n        }\n        else {\n            (void) compress(ibuf, ph.u_len, obuf);    // ignore return value\n        }\n\n        if (ph.c_len < ph.u_len) {\n            const upx_bytep tbuf = nullptr;\n            if (ft == nullptr || ft->id == 0) tbuf = ibuf;\n            ph.overlap_overhead = OVERHEAD;\n            if (!testOverlappingDecompression(obuf, tbuf, ph.overlap_overhead)) {\n                // not in-place compressible\n                ph.c_len = ph.u_len;\n            }\n        }\n        if (ph.c_len >= ph.u_len) {\n            // block is not compressible\n            ph.c_len = ph.u_len;\n            memcpy(obuf, ibuf, ph.c_len);\n            // must update checksum of compressed data\n            ph.c_adler = upx_adler32(ibuf, ph.u_len, ph.c_adler);\n        }\n\n        // write block sizes\n        b_info tmp;\n        if (hdr_u_len) {\n            unsigned hdr_c_len = 0;\n            MemBuffer hdr_obuf;\n            hdr_obuf.allocForCompression(hdr_u_len);\n            int r = upx_compress(hdr_ibuf, hdr_u_len, hdr_obuf, &hdr_c_len,\n                /* &progress callback */ nullptr,\n                ph_forced_method(ph.method), 10,\n                /* &config_t */ nullptr, /* &result_t */ nullptr);\n            if (r != UPX_E_OK)\n                throwInternalError(\"header compression failed\");\n            if (hdr_c_len >= hdr_u_len)\n                throwInternalError(\"header compression size increase\");\n            ph.saved_u_adler = upx_adler32(hdr_ibuf, hdr_u_len, init_u_adler);\n            ph.saved_c_adler = upx_adler32(hdr_obuf, hdr_c_len, init_c_adler);\n            ph.u_adler = upx_adler32(ibuf, ph.u_len, ph.saved_u_adler);\n            ph.c_adler = upx_adler32(obuf, ph.c_len, ph.saved_c_adler);\n            end_u_adler = ph.u_adler;\n            memset(&tmp, 0, sizeof(tmp));\n            set_te32(&tmp.sz_unc, hdr_u_len);\n            set_te32(&tmp.sz_cpr, hdr_c_len);\n            tmp.b_method = (unsigned char) ph_forced_method(ph.method);\n            tmp.b_extra = b_extra;\n            fo->write(&tmp, sizeof(tmp));\n            total_out += sizeof(tmp);\n            b_len += sizeof(b_info);\n            fo->write(hdr_obuf, hdr_c_len);\n            total_out += hdr_c_len;\n            total_in  += hdr_u_len;\n            hdr_u_len = 0;  // compress hdr one time only\n        }\n        memset(&tmp, 0, sizeof(tmp));\n        set_te32(&tmp.sz_unc, ph.u_len);\n        set_te32(&tmp.sz_cpr, ph.c_len);\n        if (ph.c_len < ph.u_len) {\n            tmp.b_method = (unsigned char) ph.method;\n            if (ft) {\n                tmp.b_ftid = (unsigned char) ft->id;\n                tmp.b_cto8 = ft->cto;\n            }\n        }\n        tmp.b_extra = b_extra;\n        fo->write(&tmp, sizeof(tmp));\n        total_out += sizeof(tmp);\n        b_len += sizeof(b_info);\n\n        if (ft) {\n            ph.u_adler = end_u_adler;\n        }\n        // write compressed data\n        if (ph.c_len < ph.u_len) {\n            fo->write(obuf, ph.c_len);\n            total_out += ph.c_len;\n            // Checks ph.u_adler after decompression, after unfiltering\n            verifyOverlappingDecompression(ft);\n        }\n        else {\n            fo->write(ibuf, ph.u_len);\n            total_out += ph.u_len;\n        }\n\n        total_in += ph.u_len;\n    }\n}\n\n// Consumes b_info header block and sz_cpr data block from input file 'fi'.\n// De-compresses; appends to output file 'fo' unless rewrite or peeking.\n// For \"peeking\" without writing: set (fo = nullptr), (is_rewrite = -1)\n// Return actual length when peeking; else 0.\nunsigned PackUnix::unpackExtent(unsigned wanted, OutputFile *fo,\n    unsigned &c_adler, unsigned &u_adler,\n    bool first_PF_X,\n    int is_rewrite // 0(false): write; 1(true): rewrite; -1: no write\n)\n{\n    b_info hdr; memset(&hdr, 0, sizeof(hdr));\n    unsigned inlen = 0; // output index (if-and-only-if peeking)\n    while (wanted) {\n        fi->readx(&hdr, szb_info);\n        int const sz_unc = ph.u_len = get_te32(&hdr.sz_unc);\n        int const sz_cpr = ph.c_len = get_te32(&hdr.sz_cpr);\n        ph.filter_cto = hdr.b_cto8;\n\n        if (sz_unc == 0 || M_LZMA < hdr.b_method) {\n            throwCantUnpack(\"corrupt b_info\");\n            break;\n        }\n        if (sz_unc <= 0 || sz_cpr <= 0)\n            throwCantUnpack(\"corrupt b_info\");\n        if (sz_cpr > sz_unc || sz_unc > (int)blocksize)\n            throwCantUnpack(\"corrupt b_info\");\n\n        // place the input for overlapping de-compression\n        int j = inlen + sz_unc + OVERHEAD - sz_cpr;\n        if (ibuf.getSize() < (unsigned)(j + sz_cpr)) {\n            throwCantUnpack(\"corrupt b_info\");\n        }\n        fi->readx(ibuf+j, sz_cpr);\n        total_in += sz_cpr;\n        // update checksum of compressed data\n        c_adler = upx_adler32(ibuf + j, sz_cpr, c_adler);\n\n        if (sz_cpr < sz_unc) { // block was compressed\n            ph.set_method(hdr.b_method);\n            decompress(ibuf+j, ibuf+inlen, false);\n            if (12==szb_info) { // modern per-block filter\n                if (hdr.b_ftid) {\n                    Filter ft(ph.level);  // FIXME: ph.level for b_info?\n                    ft.init(hdr.b_ftid, 0);\n                    ft.cto = hdr.b_cto8;\n                    ft.unfilter(ibuf+inlen, sz_unc);\n                }\n            }\n            else { // ancient per-file filter\n                if (first_PF_X) { // Elf32_Ehdr is never filtered\n                    first_PF_X = false;  // but everything else might be\n                }\n                else if (ph.filter) {\n                    Filter ft(ph.level);\n                    ft.init(ph.filter, 0);\n                    ft.cto = (unsigned char) ph.filter_cto;\n                    ft.unfilter(ibuf+inlen, sz_unc);\n                }\n            }\n        }\n        else if (sz_cpr == sz_unc) { // slide literal (non-compressible) block\n            memmove(&ibuf[inlen], &ibuf[j], sz_unc);\n        }\n        // update checksum of uncompressed data\n        u_adler = upx_adler32(ibuf + inlen, sz_unc, u_adler);\n        // write block\n        if (fo) {\n            if (is_rewrite) {\n                fo->rewrite(ibuf, sz_unc);\n            }\n            else {\n                fo->write(ibuf, sz_unc);\n                total_out += sz_unc;\n            }\n        }\n        else if (is_rewrite < 0) { // append to &ibuf[inlen]\n            inlen += sz_unc;  // accounting; data is already there\n            if (wanted <= (unsigned)sz_unc)  // done\n                break;\n        }\n        else if (wanted < (unsigned)sz_unc) // mismatched end-of-block\n            throwCantUnpack(\"corrupt b_info\");\n        else { // \"upx -t\": (!fo && !(is_rewrite < 0))\n            // No output.\n        }\n        wanted -= sz_unc;\n    }\n    return inlen;\n}\n\n/*************************************************************************\n// Generic Unix canUnpack().\n**************************************************************************/\n\n// The prize is the value of overlay_offset: the offset of compressed data\ntribool PackUnix::canUnpack()\n{\n    int const small = 32 + sizeof(overlay_offset);\n    // Allow zero-filled last page, for Mac OS X code signing.\n    int bufsize = 2*4096 + 2*small +1;\n    if (bufsize > fi->st_size())\n        bufsize = fi->st_size();\n    MemBuffer buf(bufsize);\n\n    fi->seek(-(off_t)bufsize, SEEK_END);\n    fi->readx(buf, bufsize);\n    return find_overlay_offset(buf);\n}\n\nint PackUnix::find_overlay_offset(MemBuffer const &buf)\n{\n    int const small = 32 + sizeof(overlay_offset);\n    int const bufsize = buf.getSize();\n    int i = bufsize;\n    while (i > small && 0 == buf[--i]) { }\n    i -= small;\n    // allow incompressible extents\n    if (i < 0 || !getPackHeader(buf + i, bufsize - i, true))\n        return false;\n\n    int l = ph.buf_offset + ph.getPackHeaderSize();\n    if (l < 0 || i + l + 4 > bufsize)\n        throwCantUnpack(\"file corrupted\");\n    overlay_offset = get_te32(buf + i + l);\n    if ((off_t)overlay_offset >= file_size)\n        throwCantUnpack(\"file corrupted\");\n\n    return true;\n}\n\n/*************************************************************************\n// Generic Unix unpack().\n//\n// This code looks much like the one in stub/l_linux.c\n// See notes there.\n**************************************************************************/\n\nvoid PackUnix::unpack(OutputFile *fo)\n{\n    b_info bhdr;\n    unsigned c_adler = upx_adler32(nullptr, 0);\n    unsigned u_adler = upx_adler32(nullptr, 0);\n\n    if (ph.version <= 11) {\n        szb_info = sizeof(bhdr.sz_unc) + sizeof(bhdr.sz_cpr);  // old style\n    }\n    // defaults for ph.version == 8\n    unsigned orig_file_size = 0;\n    blocksize = 512 * 1024;\n\n    fi->seek(overlay_offset, SEEK_SET);\n    if (ph.version > 8)\n    {\n        p_info hbuf;\n        fi->readx(&hbuf, sizeof(hbuf));\n        orig_file_size = get_te32(&hbuf.p_filesize);\n        blocksize = get_te32(&hbuf.p_blocksize);\n        off_t max_inflated = file_size * 273;  // zlib limit (256 + 16 + 1)\n\n        if (max_inflated < orig_file_size\n        ||  max_inflated < blocksize\n        ||  file_size > (off_t)orig_file_size\n        ||  blocksize > orig_file_size) {\n            throwCantUnpack(\"file header corrupted\");\n        }\n    }\n    else\n    {\n        // skip 4 bytes (program id)\n        fi->seek(4, SEEK_CUR);\n    }\n\n    if ((int)(blocksize + OVERHEAD) < 0)\n        throwCantUnpack(\"blocksize corrupted\");\n    ibuf.alloc(blocksize + OVERHEAD);\n\n    // decompress blocks\n    total_in = 0;\n    total_out = 0;\n    memset(&bhdr, 0, sizeof(bhdr));\n    for (;;)\n    {\n#define buf ibuf\n        int i;\n        unsigned sz_unc, sz_cpr;\n\n        fi->readx(&bhdr, szb_info);\n        ph.u_len = sz_unc = get_te32(&bhdr.sz_unc);\n        ph.c_len = sz_cpr = get_te32(&bhdr.sz_cpr);\n        ph.set_method(bhdr.b_method);\n\n        if (sz_unc == 0)                   // uncompressed size 0 -> EOF\n        {\n            // note: must reload sz_cpr as magic is always stored le32\n            sz_cpr = get_le32(&bhdr.sz_cpr);\n            if (sz_cpr != UPX_MAGIC_LE32)  // sz_cpr must be h->magic\n                throwCompressedDataViolation();\n            break;\n        }\n        // Minimum compressed length: LZMA has 5-byte info header.\n        // NRV_d8 has 1-byte initial 8 flag bits, plus end-of-block marker\n        // (32 bit look-back offset of all 1s: encoded as 24 pairs of bits\n        // {not last, 1} then low 8-bits of 0xff; total: 8 + 2*24 + 8 bits\n        // ==> 8 bytes)\n        if (sz_unc <= 0 || sz_cpr <= 5u\n        ||  sz_cpr > sz_unc || sz_unc > blocksize)\n            throwCantUnpack(\"corrupt b_info %#x %#x\", sz_unc, sz_cpr);\n\n        // Compressed output has control bytes such as the 32-bit\n        // first flag bits of NRV_d32, the 5-byte info of LZMA, etc.\n        // Fuzzers may try sz_cpr shorter than possible.\n        // Use some OVERHEAD for safety.\n        i = blocksize + OVERHEAD - upx::umax(12u, sz_cpr);\n        if (i < 0)\n            throwCantUnpack(\"corrupt b_info %#x %#x\", sz_cpr, blocksize);\n        fi->readx(buf+i, sz_cpr);\n        // update checksum of compressed data\n        c_adler = upx_adler32(buf + i, sz_cpr, c_adler);\n        // decompress\n        if (sz_cpr < sz_unc) {\n            decompress(buf+i, buf, false);\n            if (0!=bhdr.b_ftid) {\n                Filter ft(ph.level);\n                ft.init(bhdr.b_ftid);\n                ft.cto = bhdr.b_cto8;\n                ft.unfilter(buf, sz_unc);\n            }\n            i = 0;\n        }\n        // update checksum of uncompressed data\n        u_adler = upx_adler32(buf + i, sz_unc, u_adler);\n        total_in  += sz_cpr;\n        total_out += sz_unc;\n        // write block\n        if (fo)\n            fo->write(buf + i, sz_unc);\n#undef buf\n    }\n\n    // update header with totals\n    ph.c_len = total_in;\n    ph.u_len = total_out;\n\n    // all bytes must be written\n    if (ph.version > 8 && total_out != orig_file_size)\n        throwEOFException();\n\n    // finally test the checksums\n    if (ph.c_adler != c_adler || ph.u_adler != u_adler)\n        throwChecksumError();\n}\n\n/* vim:set ts=4 sw=4 et: */\n","size_bytes":24193},"src/p_vmlinx.cpp":{"content":"/* p_vmlinx.cpp -- pack vmlinux ET_EXEC file (before bootsect or setup)\n\n   This file is part of the Resize executable compressor.\n\n   Copyright (C) 2004-2025 John Reiser\n   Copyright (C) 2025 WHO-AM-I-404\n   Based on UPX - Ultimate Packer for eXecutables\n   Copyright (C) 1996-2025 Markus Franz Xaver Johannes Oberhumer\n   Copyright (C) 1996-2025 Laszlo Molnar\n   All Rights Reserved.\n\n   Resize and the UCL library are free software; you can redistribute them\n   and/or modify them under the terms of the GNU General Public License as\n   published by the Free Software Foundation; either version 2 of\n   the License, or (at your option) any later version.\n\n   This program is distributed in the hope that it will be useful,\n   but WITHOUT ANY WARRANTY; without even the implied warranty of\n   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n   GNU General Public License for more details.\n\n   You should have received a copy of the GNU General Public License\n   along with this program; see the file COPYING.\n   If not, write to the Free Software Foundation, Inc.,\n   59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.\n\n   WHO-AM-I-404 <who-am-i-404@proton.me>\n   Based on original work by:\n   Markus F.X.J. Oberhumer <markus@oberhumer.com>\n   Laszlo Molnar <ezerotven+github@gmail.com>\n\n   John Reiser\n   <jreiser@users.sourceforge.net>\n */\n\n\n#define ALLOW_INT_PLUS_MEMBUFFER 1\n#include \"conf.h\"\n\n#include \"file.h\"\n#include \"filter.h\"\n#include \"packer.h\"\n#include \"p_vmlinx.h\"\n#include \"linker.h\"\n\nstatic const CLANG_FORMAT_DUMMY_STATEMENT\n#include \"stub/i386-linux.kernel.vmlinux.h\"\nstatic const CLANG_FORMAT_DUMMY_STATEMENT\n#include \"stub/amd64-linux.kernel.vmlinux.h\"\nstatic const CLANG_FORMAT_DUMMY_STATEMENT\n#include \"stub/arm.v5a-linux.kernel.vmlinux.h\"\nstatic const CLANG_FORMAT_DUMMY_STATEMENT\n#include \"stub/armeb.v5a-linux.kernel.vmlinux.h\"\nstatic const CLANG_FORMAT_DUMMY_STATEMENT\n#include \"stub/powerpc-linux.kernel.vmlinux.h\"\n\n\n/*************************************************************************\n//\n**************************************************************************/\n\ntemplate <class T>\nPackVmlinuxBase<T>::PackVmlinuxBase(InputFile *f,\n                                    unsigned e_machine, unsigned elfclass, unsigned elfdata,\n                                    char const *const boot_label) :\n    super(f),\n    my_e_machine(e_machine), my_elfclass(elfclass), my_elfdata(elfdata),\n    my_boot_label(boot_label),\n    n_ptload(0), phdri(nullptr), shdri(nullptr), shstrtab(nullptr)\n{\n    ElfClass::compileTimeAssertions();\n    bele = N_BELE_CTP::getRTP((const BeLePolicy*) nullptr);\n}\n\ntemplate <class T>\nPackVmlinuxBase<T>::~PackVmlinuxBase()\n{\n    delete [] phdri;\n    delete [] shdri;\n    delete [] shstrtab;\n}\n\ntemplate <class T>\nint PackVmlinuxBase<T>::getStrategy(Filter &/*ft*/)\n{\n    // Called just before reading and compressing each block.\n    // Might want to adjust blocksize, etc.\n\n    // If user specified the filter, then use it (-2==strategy).\n    // Else try the first two filters, and pick the better (2==strategy).\n    return (opt->no_filter ? -3 : ((opt->filter > 0) ? -2 : 2));\n}\n\ntemplate <class T>\nint __acc_cdecl_qsort\nPackVmlinuxBase<T>::compare_Phdr(void const *aa, void const *bb)\n{\n    Phdr const *const a = (Phdr const *)aa;\n    Phdr const *const b = (Phdr const *)bb;\n    unsigned const xa = a->p_type - Phdr::PT_LOAD;\n    unsigned const xb = b->p_type - Phdr::PT_LOAD;\n            if (xa < xb)         return -1;  // PT_LOAD first\n            if (xa > xb)         return  1;\n    if (a->p_paddr < b->p_paddr) return -1;  // ascending by .p_paddr\n    if (a->p_paddr > b->p_paddr) return  1;\n    // What could remain?\n    // try to make sort order deterministic and just compare more fields\n#define CMP(field) \\\n    if (a->field != b->field) return a->field < b->field ? -1 : 1\n    CMP(p_offset);\n    CMP(p_vaddr);\n    CMP(p_filesz);\n    CMP(p_memsz);\n    CMP(p_flags);\n    CMP(p_align);\n#undef CMP\n    return 0;\n}\n\ntemplate <class T>\ntypename T::Shdr const *PackVmlinuxBase<T>::getElfSections()\n{\n    unsigned const e_shnum = ehdri.e_shnum;\n    if (ehdri.e_shentsize != sizeof(*shdri)\n    ||  file_size_u < ehdri.e_shoff\n    ||  file_size_u < ehdri.e_shoff + mem_size(ehdri.e_shentsize, e_shnum)) {\n        infoWarning(\"bad ElfXX_Shdrs\");\n        return nullptr;\n    }\n    shdri = new Shdr[(unsigned) e_shnum];\n    fi->seek(ehdri.e_shoff, SEEK_SET);\n    fi->readx(shdri, e_shnum * sizeof(*shdri));\n    unsigned const e_shstrndx = ehdri.e_shstrndx;\n    if (e_shnum <= e_shstrndx) {\n        infoWarning(\"bad .e_shstrndx %#x\", e_shstrndx);\n        return nullptr;\n    }\n    Shdr const *p = &shdri[e_shstrndx];\n    if (Shdr::SHT_STRTAB==p->sh_type\n    &&  p->sh_offset  <= (file_size_u - sizeof(*shdri))\n    &&  p->sh_size    <= (file_size_u - p->sh_offset)\n    &&  p->sh_name    <= (file_size_u - p->sh_offset)\n    &&  10            <= (file_size_u - p->sh_name)\n        // 10 == (1+ strlen(\".shstrtab\"))\n    ) {\n        if (p->sh_size <= p->sh_name) {\n            infoWarning(\"bad .shstrtab _Shdr[%u]\", (unsigned)ehdri.e_shstrndx);\n            return nullptr;\n        }\n        shstrtab = new char[1+ p->sh_size];\n        fi->seek(p->sh_offset, SEEK_SET);\n        fi->readx(shstrtab, p->sh_size);\n        shstrtab[p->sh_size] = '\\0';\n        if (0==strcmp(\".shstrtab\", shstrtab + p->sh_name)) {\n            return p;\n        }\n    }\n    return nullptr;\n}\n\ntemplate <class T>\ntribool PackVmlinuxBase<T>::canPack()\n{\n    fi->seek(0, SEEK_SET);\n    fi->readx(&ehdri, sizeof(ehdri));\n\n    // now check the ELF header\n    if (memcmp(&ehdri, \"\\x7f\\x45\\x4c\\x46\", 4)\n    ||  ehdri.e_ident[Ehdr::EI_CLASS] != my_elfclass\n    ||  ehdri.e_ident[Ehdr::EI_DATA] != my_elfdata\n    ||  ehdri.e_ident[Ehdr::EI_VERSION] != Ehdr::EV_CURRENT\n    ||  !memcmp(&ehdri.e_ident[8], \"FreeBSD\", 7)  // branded\n    ||  ehdri.e_machine != my_e_machine\n    ||  ehdri.e_version != 1  // version\n    ||  ehdri.e_ehsize != sizeof(ehdri)  // different <elf.h> ?\n    ) {\n        return false;\n    }\n\n    // additional requirements for vmlinux\n    if (ehdri.e_type != Ehdr::ET_EXEC\n    ||  ehdri.e_phoff != sizeof(ehdri)  // Phdr not contiguous with Ehdr\n    ||  ehdri.e_phentsize!=sizeof(Phdr)\n    ||  !is_valid_e_entry(ehdri.e_entry)\n    ) {\n        return false;\n    }\n\n    // A Linux kernel must have a __ksymtab section. [??]\n    Shdr const *p, *const shstrsec = getElfSections();\n    if (nullptr==shstrsec) {\n        return false;\n    }\n    {\n        int j;\n        for (p = shdri, j= ehdri.e_shnum; --j>=0; ++p) {\n            if (Shdr::SHT_PROGBITS==p->sh_type\n            && p->sh_name < shstrsec->sh_size\n            && 0==strcmp(\"__ksymtab\", p->sh_name + shstrtab)) {\n                break;\n            }\n        }\n        if (j < 0) {\n            return false;\n        }\n    }\n\n    phdri = new Phdr[(unsigned) ehdri.e_phnum];\n    fi->seek(ehdri.e_phoff, SEEK_SET);\n    fi->readx(phdri, ehdri.e_phnum * sizeof(*phdri));\n\n    // Put PT_LOAD together at the beginning, ascending by .p_paddr.\n    upx_qsort(phdri, ehdri.e_phnum, sizeof(*phdri), compare_Phdr);\n\n    // Find convex hull of physical addresses, and count the PT_LOAD.\n    // Ignore \".bss\": .p_filesz < .p_memsz\n    unsigned phys_lo= ~0u, phys_hi= 0u;\n    for (unsigned j = 0; j < ehdri.e_phnum; ++j) {\n        if (Phdr::PT_LOAD==phdri[j].p_type) {\n            // Check for general sanity (not necessarily required.)\n            if (0xfff & (phdri[j].p_offset | phdri[j].p_paddr\n                       | phdri[j].p_align  | phdri[j].p_vaddr) ) {\n                return false;\n            }\n            if (phys_lo > phdri[j].p_paddr) {\n                phys_lo = phdri[j].p_paddr;\n            }\n            if (phys_hi < (phdri[j].p_filesz + phdri[j].p_paddr)) {\n                phys_hi = (phdri[j].p_filesz + phdri[j].p_paddr);\n            }\n            ++n_ptload;\n        }\n    }\n    paddr_min = phys_lo;\n    sz_ptload = phys_hi - phys_lo;\n    return 0 < n_ptload;\n}\n\n#include \"p_elf.h\"\n\ntemplate <class T>\nvoid PackVmlinuxBase<T>::pack(OutputFile *fo)\n{\n    unsigned fo_off = 0;\n    Ehdr ehdro;\n    TE32 tmp_u32;\n\n    // nullptr\n    // .text(PT_LOADs) .note(1st page) .note(rest)\n    // .shstrtab .symtab .strtab\n    Shdr shdro[1+3+3];\n    memset(shdro, 0, sizeof(shdro));\n\n    ibuf.alloc(file_size);\n    obuf.allocForCompression(file_size);\n\n    // .e_ident, .e_machine, .e_version, .e_flags\n    memcpy(&ehdro, &ehdri, sizeof(ehdro));\n    ehdro.e_type = Ehdr::ET_REL;\n    ehdro.e_entry = 0;\n    ehdro.e_phoff = 0;\n    ehdro.e_shoff = sizeof(ehdro);\n    ehdro.e_phentsize = 0;\n    ehdro.e_phnum = 0;\n    ehdro.e_shnum = 1+3+3;\n    ehdro.e_shstrndx = 4;\n    fo->write(&ehdro, sizeof(ehdro)); fo_off+= sizeof(ehdro);\n    fo->write(shdro, sizeof(shdro)); fo_off+= sizeof(shdro);\n\n// Notice overlap [containment] of physical PT_LOAD[2] into PTLOAD[1]\n// in this vmlinux for x86_64 from Fedora Core 6 on 2007-01-07:\n//Program Headers:\n//  Type           Offset             VirtAddr           PhysAddr\n//                 FileSiz            MemSiz              Flags  Align\n//  LOAD           0x0000000000200000 0xffffffff80200000 0x0000000000200000\n//                 0x000000000034bce8 0x000000000034bce8  R E    200000\n//  LOAD           0x000000000054c000 0xffffffff8054c000 0x000000000054c000\n//                 0x00000000000ed004 0x00000000001702a4  RWE    200000\n//  LOAD           0x0000000000800000 0xffffffffff600000 0x00000000005f5000\n//                 0x0000000000000c08 0x0000000000000c08  RWE    200000\n//  NOTE           0x0000000000000000 0x0000000000000000 0x0000000000000000\n//                 0x0000000000000000 0x0000000000000000  R      8\n// Therefore we must \"compose\" the convex hull to be loaded.\n\n    ph.u_len = sz_ptload;\n    memset(ibuf, 0, sz_ptload);\n    for (unsigned j = 0; j < ehdri.e_phnum; ++j) {\n        if (Phdr::PT_LOAD==phdri[j].p_type) {\n            fi->seek(phdri[j].p_offset, SEEK_SET);\n            fi->readx(ibuf + ((unsigned) phdri[j].p_paddr - paddr_min), phdri[j].p_filesz);\n        }\n    }\n    checkAlreadyPacked(ibuf + (ph.u_len - 1024), 1024);\n\n    // prepare filter\n    ph.filter = 0;\n    Filter ft(ph.level);\n    ft.buf_len = ph.u_len;\n    ft.addvalue = 0;  // we are independent of actual runtime address; see ckt32\n\n    upx_compress_config_t cconf; cconf.reset();\n    // limit stack size needed for runtime decompression\n    cconf.conf_lzma.max_num_probs = 1846 + (768 << 4); // ushort: ~28 KiB stack\n\n    unsigned ppc32_extra = 0;\n    if (Ehdr::EM_PPC==my_e_machine) {\n        // output layout:\n        //      .long UPX_MAGIC_LE32\n        //      .long L20 - L10\n        // L10:\n        //      b_info for Ehdr; compressed Ehdr; .balign 4  // one block only\n        //      b_info for LOAD; compressed LOAD; .balign 4  // possibly many blocks\n        //          // This allows per-block filters!\n        // L20:\n        //      b f_decompress\n        // +4:  f_unfilter(char *buf, unsigned len, unsigned cto8, unsigned ftid)\n        //          // Code for multiple filters can \"daisy chain\" on ftid.\n        //      f_decompress(char const *src, unsigned  src_len,\n        //                   char       *dst, unsigned *dst_len, int method)\n        unsigned tmp;\n        tmp = UPX_MAGIC_LE32; fo->write(&tmp, sizeof(tmp)); fo_off += sizeof(tmp);\n        tmp = 0;              fo->write(&tmp, sizeof(tmp)); fo_off += sizeof(tmp);\n        ppc32_extra += 2*sizeof(tmp);\n        unsigned const len_unc = sizeof(ehdri) + sizeof(Phdr) * ehdri.e_phnum;\n        MemBuffer unc_hdr(len_unc);\n        MemBuffer cpr_hdr; cpr_hdr.allocForCompression(len_unc);\n        memcpy(&unc_hdr[0],             &ehdri, sizeof(ehdri));\n        memcpy(&unc_hdr[sizeof(ehdri)],  phdri, sizeof(Phdr) * ehdri.e_phnum);\n        unsigned len_cpr = 0;\n        int const r = upx_compress(unc_hdr, len_unc, cpr_hdr, &len_cpr,\n            nullptr, ph.method, 10, nullptr, nullptr );\n        if (UPX_E_OK!=r || len_unc<=len_cpr)  // FIXME: allow no compression\n            throwInternalError(\"Ehdr compression failed\");\n\n        packed_struct(b_info) { // 12-byte header before each compressed block\n            NE32 sz_unc;  // uncompressed_size\n            NE32 sz_cpr;  //   compressed_size\n            unsigned char b_method;  // compression algorithm\n            unsigned char b_ftid;  // filter id\n            unsigned char b_cto8;  // filter parameter\n            unsigned char b_unused;  // FIXME: !=0  for partial-block unfilter\n            // NE32 f_offset, f_len;  // only if    partial-block unfilter\n        };\n\n        struct b_info hdr_info;\n        set_be32(&hdr_info.sz_unc, len_unc);\n        set_be32(&hdr_info.sz_cpr, len_cpr);\n        hdr_info.b_method = ph.method;\n        hdr_info.b_ftid = 0;\n        hdr_info.b_cto8 = 0;\n        hdr_info.b_unused = 0;\n        fo->write(&hdr_info, sizeof(hdr_info)); fo_off += sizeof(hdr_info);\n        unsigned const frag = (3& (0u-len_cpr));\n        ppc32_extra += sizeof(hdr_info) + len_cpr + frag;\n        fo_off += len_cpr + frag;\n        memset(&cpr_hdr[len_cpr], 0, frag);  // valgrind only\n        fo->write(cpr_hdr, len_cpr + frag);\n\n        // Partial filter: .text and following contiguous SHF_EXECINSTR\n        upx_bytep f_ptr = ibuf;\n        unsigned  f_len = 0;\n        Shdr const *shdr = 1+ shdri;  // skip empty shdr[0]\n        if (ft.buf_len==0  // not specified yet  FIXME: was set near construction\n        && (Shdr::SHF_ALLOC     & shdr->sh_flags)\n        && (Shdr::SHF_EXECINSTR & shdr->sh_flags)) {\n            // shdr[1] is instructions (probably .text)\n            f_ptr = ibuf + (unsigned) (shdr->sh_offset - phdri[0].p_offset);\n            f_len = shdr->sh_size;\n            ++shdr;\n            for (int j= ehdri.e_shnum - 2; --j>=0; ++shdr) {\n                unsigned prev_end = shdr[-1].sh_size + shdr[-1].sh_offset;\n                prev_end += ~(0u-shdr[0].sh_addralign) & (0u-prev_end);  // align_up\n                if ((Shdr::SHF_ALLOC     & shdr->sh_flags)\n                &&  (Shdr::SHF_EXECINSTR & shdr->sh_flags)\n                &&  shdr[0].sh_offset==prev_end) {\n                    f_len += shdr->sh_size;\n                }\n                else {\n                    break;\n                }\n            }\n        }\n        else { // ft.buf_len already specified, or Shdr[1] not instructions\n            f_ptr = ibuf;\n            f_len = ph.u_len;\n        }\n        compressWithFilters(ibuf, ph.u_len, obuf,\n            f_ptr, f_len,  // filter range\n            nullptr, 0,  // hdr_ptr, hdr_len\n            &ft, 512, &cconf, getStrategy(ft));\n\n        set_be32(&hdr_info.sz_unc, ph.u_len);\n        set_be32(&hdr_info.sz_cpr, ph.c_len);\n        hdr_info.b_ftid = ft.id;\n        hdr_info.b_cto8 = ft.cto;\n        if (ph.u_len!=f_len) {\n            hdr_info.b_unused = 1;  // flag for partial filter\n        }\n        fo->write(&hdr_info, sizeof(hdr_info)); fo_off += sizeof(hdr_info);\n        ppc32_extra += sizeof(hdr_info);\n        if (ph.u_len!=f_len) {\n            set_be32(&hdr_info.sz_unc, f_ptr - (upx_bytep) ibuf);\n            set_be32(&hdr_info.sz_cpr, f_len);\n            fo->write(&hdr_info, 2*sizeof(unsigned)); fo_off += 2*sizeof(unsigned);\n            ppc32_extra += 2*sizeof(unsigned);\n        }\n    }\n    else {\n        compressWithFilters(&ft, 512, &cconf, getStrategy(ft));\n    }\n    unsigned const txt_c_len = ph.c_len;\n\n    const unsigned lsize = getLoaderSize();\n\n    defineDecompressorSymbols();\n    defineFilterSymbols(&ft);\n    relocateLoader();\n\n    MemBuffer loader(lsize);\n    memcpy(loader, getLoader(), lsize);\n    patchPackHeader(loader, lsize);\n\n#define shstrtab local_shstrtab // avoid -Wshadow warning\n    char const shstrtab[]= \"\\0.text\\0.note\\0.shstrtab\\0.symtab\\0.strtab\";\n    char const *p = shstrtab;\n    while (0!=*p++) ;\n    shdro[1].sh_name = ptr_diff(p, shstrtab);\n    shdro[1].sh_type = Shdr::SHT_PROGBITS;\n    shdro[1].sh_flags = Shdr::SHF_ALLOC | Shdr::SHF_EXECINSTR;\n    shdro[1].sh_offset = fo_off - ppc32_extra;\n    shdro[1].sh_size = ppc32_extra + txt_c_len + lsize;  // plus more ...\n    shdro[1].sh_addralign = 1;  // default\n\n    fo_off += write_vmlinux_head(fo, &shdro[1]);\n    fo->write(obuf, txt_c_len); fo_off += txt_c_len;\n    unsigned const a = (shdro[1].sh_addralign -1) & (0u-(ppc32_extra + txt_c_len));\n    if (0!=a) { // align\n        fo_off += a;\n        shdro[1].sh_size += a;\n        fo->seek(a, SEEK_CUR);\n    }\n    fo->write(loader, lsize); fo_off += lsize;\n\n#if 0\n    printf(\"%-13s: compressed   : %8u bytes\\n\", getName(), txt_c_len);\n    printf(\"%-13s: decompressor : %8u bytes\\n\", getName(), lsize);\n#endif\n    verifyOverlappingDecompression();\n\n    // .note with 1st page --------------------------------\n    ph.u_len = phdri[0].p_offset;\n    fi->seek(0, SEEK_SET);\n    fi->readx(ibuf, ph.u_len);\n    compress(ibuf, ph.u_len, obuf, &cconf);\n\n    while (0!=*p++) ;\n    shdro[2].sh_name = ptr_diff(p, shstrtab);\n    shdro[2].sh_type = Shdr::SHT_NOTE;\n    shdro[2].sh_offset = fo_off;\n    shdro[2].sh_size = sizeof(ph.u_len) + ph.c_len;\n    shdro[2].sh_addralign = 1;\n    tmp_u32 = ph.u_len; fo->write(&tmp_u32, 4);\n    fo->write(obuf, ph.c_len); fo_off += shdro[2].sh_size;\n\n    // .note with rest     --------------------------------\n    ph.u_len = file_size - (sz_ptload + phdri[0].p_offset);\n    fi->seek(sz_ptload + phdri[0].p_offset, SEEK_SET);\n    fi->readx(ibuf, ph.u_len);\n\n    // Temporarily decrease ph.level by about (1+ log2(sz_rest / sz_ptload))\n    // to avoid spending unreasonable effort compressing large symbol tables\n    // that are discarded 99.9% of the time anyway.\n    int const old_level = ph.level;\n    for (unsigned v = ((ph.u_len>>3) + ph.u_len) / sz_ptload; 0 < v; v>>=1) {\n        if (0== --ph.level) {\n            ph.level = 1;\n        }\n    }\n    compress(ibuf, ph.u_len, obuf, &cconf);\n    ph.level = old_level;\n\n    // while (0!=*p++) ;  // name is the same\n    shdro[3].sh_name = ptr_diff(p, shstrtab);\n    shdro[3].sh_type = Shdr::SHT_NOTE;\n    shdro[3].sh_offset = fo_off;\n    shdro[3].sh_size = sizeof(ph.u_len) + ph.c_len;\n    shdro[3].sh_addralign = 1;\n    tmp_u32 = ph.u_len; fo->write(&tmp_u32, 4);\n    fo->write(obuf, ph.c_len); fo_off += shdro[3].sh_size;\n\n    while (0!=*p++) ;\n    shdro[4].sh_name = ptr_diff(p, shstrtab);\n    shdro[4].sh_type = Shdr::SHT_STRTAB;\n    shdro[4].sh_offset = fo_off;\n    shdro[4].sh_size = sizeof(shstrtab);  // already includes terminating '\\0'\n    shdro[4].sh_addralign = 1;\n    fo->write(shstrtab, shdro[4].sh_size); fo_off += shdro[4].sh_size;\n\n    fo_off = ~3 & (3+ fo_off); fo->seek(fo_off, SEEK_SET);\n    while (0!=*p++) ;\n    shdro[5].sh_name = ptr_diff(p, shstrtab);\n    shdro[5].sh_type = Shdr::SHT_SYMTAB;\n    shdro[5].sh_offset = fo_off;\n    shdro[5].sh_size = ((Ehdr::EM_PPC==my_e_machine) + 5)*sizeof(Sym);\n    //shdro[5].sh_flags = Shdr::SHF_INFO_LINK;\n    shdro[5].sh_link = 6;  // to .strtab for symbols\n    shdro[5].sh_info = 1+3;  // number of non-global symbols [binutils/bfd/elf.c]\n    shdro[5].sh_addralign = 4;\n    shdro[5].sh_entsize = sizeof(Sym);\n\n    Sym sec_sym;\n\n    // Symbol 0; no references, but bfd demands it.\n    memset(&sec_sym, 0, sizeof(sec_sym));\n    fo->write(&sec_sym, sizeof(sec_sym)); fo_off += sizeof(sec_sym);\n\n    // Each section before .shstrtab needs a symbol.\n    sec_sym.st_info = sec_sym.make_st_info(Sym::STB_LOCAL, Sym::STT_SECTION);\n    sec_sym.st_other = Sym::STV_DEFAULT;\n    sec_sym.st_shndx = 1;  // .text\n    fo->write(&sec_sym, sizeof(sec_sym)); fo_off += sizeof(sec_sym);\n    sec_sym.st_shndx = 2;  // .note\n    fo->write(&sec_sym, sizeof(sec_sym)); fo_off += sizeof(sec_sym);\n    sec_sym.st_shndx = 3;  // .note\n    fo->write(&sec_sym, sizeof(sec_sym)); fo_off += sizeof(sec_sym);\n\n    // the symbol we care about\n    Sym unc_ker;\n    unc_ker.st_name = 1;  // 1 byte into strtab\n    unc_ker.st_value = 0;\n    unc_ker.st_size = ppc32_extra + txt_c_len;\n    unc_ker.st_info = unc_ker.make_st_info(Sym::STB_GLOBAL, Sym::STT_FUNC);\n    unc_ker.st_other = Sym::STV_DEFAULT;\n    unc_ker.st_shndx = 1;  // .text\n    fo->write(&unc_ker, sizeof(unc_ker)); fo_off += sizeof(unc_ker);\n\n    unsigned const lablen = strlen(my_boot_label);\n    if (Ehdr::EM_PPC==my_e_machine) {\n        unc_ker.st_name += 1+ lablen;\n        unc_ker.st_value = unc_ker.st_size;\n        unc_ker.st_size = 0;\n        fo->write(&unc_ker, sizeof(unc_ker)); fo_off += sizeof(unc_ker);\n    }\n    while (0!=*p++) ;\n    shdro[6].sh_name = ptr_diff(p, shstrtab);\n    shdro[6].sh_type = Shdr::SHT_STRTAB;\n    shdro[6].sh_offset = fo_off;\n    shdro[6].sh_size = 2+ lablen + (Ehdr::EM_PPC==my_e_machine)*(1+ 12);  // '\\0' before and after\n    shdro[6].sh_addralign = 1;\n    fo->seek(1, SEEK_CUR);  // the '\\0' before\n    fo->write(my_boot_label, 1+ lablen);  // include the '\\0' terminator\n    if (Ehdr::EM_PPC==my_e_machine) {\n        fo->write(\"_vmlinux_end\", 1+ 12); fo_off += 1+ 12;\n    }\n    fo_off += 2+ lablen;\n\n    fo->seek(0, SEEK_SET);\n    fo->write(&ehdro, sizeof(ehdro));\n    fo->write(&shdro[0], sizeof(shdro));\n    if (Ehdr::EM_PPC==my_e_machine) {\n        fo->seek(sizeof(unsigned), SEEK_CUR);\n        set_be32(&ppc32_extra, ppc32_extra - 2*sizeof(unsigned) + txt_c_len);\n        fo->write(&ppc32_extra, sizeof(ppc32_extra));\n    }\n\n    if (!checkFinalCompressionRatio(fo))\n        throwNotCompressible();\n#undef shstrtab\n}\n\ntemplate <class T>\ntribool PackVmlinuxBase<T>::canUnpack()\n{\n    fi->seek(0, SEEK_SET);\n    fi->readx(&ehdri, sizeof(ehdri));\n\n    // now check the ELF header\n    if (memcmp(&ehdri, \"\\x7f\\x45\\x4c\\x46\", 4)\n    ||  ehdri.e_ident[Ehdr::EI_CLASS] != my_elfclass\n    ||  ehdri.e_ident[Ehdr::EI_DATA] != my_elfdata\n    ||  ehdri.e_ident[Ehdr::EI_VERSION] != Ehdr::EV_CURRENT\n    ||  !memcmp(&ehdri.e_ident[8], \"FreeBSD\", 7)  // branded\n    ||  ehdri.e_machine != my_e_machine\n    ||  ehdri.e_version != 1  // version\n    ||  ehdri.e_ehsize != sizeof(ehdri)  // different <elf.h> ?\n    )\n        return false;\n\n    if (ehdri.e_type != Ehdr::ET_REL\n    //i386 fails  ||  ehdri.e_shoff != sizeof(ehdri)  // Shdr not contiguous with Ehdr\n    ||  ehdri.e_shentsize!=sizeof(Shdr)\n    ||  ehdri.e_shnum < 4\n    ||  (unsigned)file_size < (ehdri.e_shnum * sizeof(Shdr) + ehdri.e_shoff)\n    )\n        return false;\n\n    // find the .shstrtab section\n    Shdr const *const shstrsec = getElfSections();\n    if (nullptr==shstrsec) {\n        return false;\n    }\n\n    // check for .text .note .note  and sane (.sh_size + .sh_offset)\n    p_note0 = p_note1 = p_text = nullptr;\n    int j;\n    Shdr *p;\n    for (p= shdri, j= ehdri.e_shnum; --j>=0; ++p) {\n        if ((unsigned)file_size < (p->sh_size + p->sh_offset)\n        || (5+ p->sh_name) < p->sh_name  // wrap: ignore malformed\n        ||  shstrsec->sh_size < (5+ p->sh_name) ) {\n            continue;\n        }\n        if (0==strcmp(\".text\", shstrtab + p->sh_name)) {\n            p_text = p;\n        }\n        if (0==strcmp(\".note\", shstrtab + p->sh_name)) {\n            if (nullptr==p_note0) {\n                p_note0 = p;\n            } else\n            if (nullptr==p_note1) {\n                p_note1 = p;\n            }\n        }\n    }\n    if (nullptr==p_text || nullptr==p_note0 || nullptr==p_note1) {\n        return false;\n    }\n\n    char buf[1024];\n    fi->seek(p_text->sh_offset + p_text->sh_size - sizeof(buf), SEEK_SET);\n    fi->readx(buf, sizeof(buf));\n    if (!getPackHeader(buf, sizeof(buf)))\n        return -1; // format is known, but definitely is not packed\n\n    return true;\n}\n\ntemplate <class T>\nvoid PackVmlinuxBase<T>::unpack(OutputFile *fo)\n{\n    TE32 word;\n    PackHeader const ph_tmp(ph);\n\n    fi->seek(p_note0->sh_offset, SEEK_SET);\n    fi->readx(&word, sizeof(word));\n    ph.u_len = word;\n    ph.c_len = p_note0->sh_size - sizeof(word);\n    ibuf.alloc(ph.c_len);\n    fi->readx(ibuf, ph.c_len);\n    obuf.allocForDecompression(ph.u_len);\n    decompress(ibuf, obuf, false);\n    fo->write(obuf, ph.u_len);\n    obuf.dealloc();\n    ibuf.dealloc();\n\n    ph = ph_tmp;\n    if (!has_valid_vmlinux_head()) {\n        throwCantUnpack(\".text corrupted\");\n    }\n    ibuf.alloc(ph.c_len);\n    fi->readx(ibuf, ph.c_len);\n    obuf.allocForDecompression(ph.u_len);\n    decompress(ibuf, obuf);\n\n    Filter ft(ph.level);\n    ft.init(ph.filter, 0);\n    ft.cto = (unsigned char) ph.filter_cto;\n    ft.unfilter(obuf, ph.u_len);\n    fo->write(obuf, ph.u_len);\n    obuf.dealloc();\n    ibuf.dealloc();\n\n    fi->seek(p_note1->sh_offset, SEEK_SET);\n    fi->readx(&word, sizeof(word));\n    ph.u_len = word;\n    ph.c_len = p_note1->sh_size - sizeof(word);\n    ibuf.alloc(ph.c_len);\n    fi->readx(ibuf, p_note1->sh_size - sizeof(ph.u_len));\n    obuf.allocForDecompression(ph.u_len);\n    decompress(ibuf, obuf, false);\n    fo->write(obuf, ph.u_len);\n    obuf.dealloc();\n    ibuf.dealloc();\n\n    ph = ph_tmp;\n}\n\n\n/*************************************************************************\n//\n**************************************************************************/\n\nconst int *PackVmlinuxI386::getCompressionMethods(int method, int level) const\n{\n    return Packer::getDefaultCompressionMethods_le32(method, level);\n}\n\n\nconst int *PackVmlinuxI386::getFilters() const\n{\n    static const int filters[] = {\n        0x49, 0x46,\n    FT_END };\n    return filters;\n}\n\nconst int *PackVmlinuxARMEL::getCompressionMethods(int method, int level) const\n{\n    return Packer::getDefaultCompressionMethods_8(method, level);\n}\n\nconst int *PackVmlinuxARMEB::getCompressionMethods(int method, int level) const\n{\n    return Packer::getDefaultCompressionMethods_8(method, level);\n}\n\nconst int *PackVmlinuxPPC32::getCompressionMethods(int method, int level) const\n{\n    // No real dependency on LE32.\n    return Packer::getDefaultCompressionMethods_le32(method, level);\n}\n\nconst int *PackVmlinuxPPC64LE::getCompressionMethods(int method, int level) const\n{\n    // No real dependency on LE32.\n    return Packer::getDefaultCompressionMethods_le32(method, level);\n}\n\n\nconst int *PackVmlinuxARMEL::getFilters() const\n{\n    static const int f50[] = { 0x50, FT_END };\n    return f50;\n}\n\nconst int *PackVmlinuxARMEB::getFilters() const\n{\n    static const int f51[] = { 0x51, FT_END };\n    return f51;\n}\n\nconst int *PackVmlinuxPPC32::getFilters() const\n{\n    static const int fd0[] = { 0xd0, FT_END };\n    return fd0;\n}\n\nconst int *PackVmlinuxPPC64LE::getFilters() const\n{\n    static const int fd0[] = { 0xd0, FT_END };\n    return fd0;\n}\n\n//\n// Examples as of 2004-07-16 [readelf --segments vmlinux  # before fiddling]:\n//\n//----- kernel-2.6.7 plain [defconfig?]\n//Program Headers(2):\n//  Type           Offset   VirtAddr   PhysAddr   FileSiz MemSiz  Flg Align\n//  LOAD           0x001000 0x00100000 0x00100000 0x1c7e61 0x1c7e61 R E 0x1000\n//  LOAD           0x1c8e64 0x002c8e64 0x002c8e64 0x00000 0x00000 RW  0x1000\n//\n//----- kernel-2.6.7-1.488 Fedora Core 3 test 1\n//Program Headers(5):\n//  Type           Offset   VirtAddr   PhysAddr   FileSiz MemSiz  Flg Align\n//  LOAD           0x001000 0x02100000 0x02100000 0x202246 0x202246 R E 0x1000\n//  LOAD           0x204000 0xffff3000 0x02303000 0x00664 0x00664 R E 0x1000\n//  LOAD           0x205000 0x02304000 0x02304000 0x43562 0x43562 R   0x1000\n//  LOAD           0x249000 0x02348000 0x02348000 0x81800 0xcb0fc RWE 0x1000\n//  STACK          0x000000 0x00000000 0x00000000 0x00000 0x00000 RWE 0x4\n//\n//----- kernel-2.6.18-1.2778 Fedora Core 6 test 3\n//Program Headers(3)\n//  Type           Offset   VirtAddr   PhysAddr   FileSiz MemSiz  Flg Align\n//  LOAD           0x001000 0xc0400000 0x00400000 0x279820 0x279820 R E 0x1000\n//  LOAD           0x27b000 0xc067a000 0x0067a000 0x10ee64 0x1b07e8 RWE 0x1000\n//  NOTE           0x000000 0x00000000 0x00000000 0x00000 0x00000 R   0x4\n\nbool PackVmlinuxI386::is_valid_e_entry(Addr e_entry)\n{\n    return 0==(0x000fffff & e_entry); // entry on whole 1 MiB\n}\n\n\nLinker* PackVmlinuxI386::newLinker() const\n{\n    return new ElfLinkerX86;\n}\n\n\nvoid PackVmlinuxI386::buildLoader(const Filter *ft)\n{\n    // prepare loader\n    initLoader(stub_i386_linux_kernel_vmlinux, sizeof(stub_i386_linux_kernel_vmlinux));\n    addLoader(\"LINUX000\",\n              (0x40==(0xf0 & ft->id)) ? \"LXCKLLT1\" : (ft->id ? \"LXCALLT1\" : \"\"),\n              \"LXMOVEUP\",\n              getDecompressorSections(),\n              nullptr\n             );\n    if (ft->id) {\n        assert(ft->calls > 0);\n        if (0x40==(0xf0 & ft->id)) {\n            addLoader(\"LXCKLLT9\", nullptr);\n        }\n        else {\n            addLoader(\"LXCALLT9\", nullptr);\n        }\n        addFilter32(ft->id);\n    }\n    addLoader(\"LINUX990\",\n              ((ph.first_offset_found == 1) ? \"LINUX991\" : \"\"),\n              \"LINUX992,IDENTSTR,UPX1HEAD\", nullptr);\n}\n\nvoid PackVmlinuxAMD64::buildLoader(const Filter *ft)\n{\n    // prepare loader\n    initLoader(stub_amd64_linux_kernel_vmlinux, sizeof(stub_amd64_linux_kernel_vmlinux));\n    addLoader(\"LINUX000\",\n              (0x40==(0xf0 & ft->id)) ? \"LXCKLLT1\" : (ft->id ? \"LXCALLT1\" : \"\"),\n              \"LXMOVEUP\",\n              getDecompressorSections(),\n              nullptr\n             );\n    if (ft->id) {\n        assert(ft->calls > 0);\n        if (0x40==(0xf0 & ft->id)) {\n            addLoader(\"LXCKLLT9\", nullptr);\n        }\n        else {\n            addLoader(\"LXCALLT9\", nullptr);\n        }\n        addFilter32(ft->id);\n    }\n    addLoader(\"LINUX990\",\n              ((ph.first_offset_found == 1) ? \"LINUX991\" : \"\"),\n              \"LINUX992,IDENTSTR,UPX1HEAD\", nullptr);\n}\n\nbool PackVmlinuxARMEL::is_valid_e_entry(Addr e_entry)\n{\n    return 0xc0008000==e_entry;\n}\n\nbool PackVmlinuxARMEB::is_valid_e_entry(Addr e_entry)\n{\n    return 0xc0008000==e_entry;\n}\n\nbool PackVmlinuxPPC32::is_valid_e_entry(Addr e_entry)\n{\n    return 0xc0000000==e_entry;\n}\n\nbool PackVmlinuxPPC64LE::is_valid_e_entry(Addr e_entry)\n{\n    return 0xc0000000==e_entry;\n}\n\nLinker* PackVmlinuxARMEL::newLinker() const\n{\n    return new ElfLinkerArmLE;\n}\n\nLinker* PackVmlinuxARMEB::newLinker() const\n{\n    return new ElfLinkerArmBE;\n}\n\nLinker* PackVmlinuxPPC32::newLinker() const\n{\n    return new ElfLinkerPpc32;\n}\n\nLinker* PackVmlinuxPPC64LE::newLinker() const\n{\n    return new ElfLinkerPpc64le;\n}\n\n\nvoid PackVmlinuxARMEL::buildLoader(const Filter *ft)\n{\n    // prepare loader\n    initLoader(stub_arm_v5a_linux_kernel_vmlinux, sizeof(stub_arm_v5a_linux_kernel_vmlinux));\n    addLoader(\"LINUX000\", nullptr);\n    if (ft->id) {\n        assert(ft->calls > 0);\n        addLoader(\"LINUX010\", nullptr);\n    }\n    addLoader(\"LINUX020\", nullptr);\n    if (ft->id) {\n        addFilter32(ft->id);\n    }\n    addLoader(\"LINUX030\", nullptr);\n         if (ph.method == M_NRV2E_8) addLoader(\"NRV2E\", nullptr);\n    else if (ph.method == M_NRV2B_8) addLoader(\"NRV2B\", nullptr);\n    else if (ph.method == M_NRV2D_8) addLoader(\"NRV2D\", nullptr);\n    else if (M_IS_LZMA(ph.method))   addLoader(\"LZMA_ELF00,LZMA_DEC10,LZMA_DEC30\", nullptr);\n    else throwBadLoader();\n    addLoader(\"IDENTSTR,UPX1HEAD\", nullptr);\n}\n\nvoid PackVmlinuxARMEB::buildLoader(const Filter *ft)\n{\n    // prepare loader\n    initLoader(stub_armeb_v5a_linux_kernel_vmlinux, sizeof(stub_armeb_v5a_linux_kernel_vmlinux));\n    addLoader(\"LINUX000\", nullptr);\n    if (ft->id) {\n        assert(ft->calls > 0);\n        addLoader(\"LINUX010\", nullptr);\n    }\n    addLoader(\"LINUX020\", nullptr);\n    if (ft->id) {\n        addFilter32(ft->id);\n    }\n    addLoader(\"LINUX030\", nullptr);\n         if (ph.method == M_NRV2E_8) addLoader(\"NRV2E\", nullptr);\n    else if (ph.method == M_NRV2B_8) addLoader(\"NRV2B\", nullptr);\n    else if (ph.method == M_NRV2D_8) addLoader(\"NRV2D\", nullptr);\n    else if (M_IS_LZMA(ph.method))   addLoader(\"LZMA_ELF00,LZMA_DEC10,LZMA_DEC30\", nullptr);\n    else throwBadLoader();\n    addLoader(\"IDENTSTR,UPX1HEAD\", nullptr);\n}\n\nvoid PackVmlinuxPPC32::buildLoader(const Filter *ft)\n{\n    // prepare loader\n    initLoader(stub_powerpc_linux_kernel_vmlinux, sizeof(stub_powerpc_linux_kernel_vmlinux));\n    addLoader(\"LINUX000\", nullptr);\n    if (ft->id) {\n        assert(ft->calls > 0);\n        addLoader(\"LINUX010\", nullptr);\n    }\n    addLoader(\"LINUX020\", nullptr);\n    if (ft->id) {\n        addFilter32(ft->id);\n    }\n    addLoader(\"LINUX030\", nullptr);\n         if (ph.method == M_NRV2E_LE32) addLoader(\"NRV2E,NRV_TAIL\", nullptr);\n    else if (ph.method == M_NRV2B_LE32) addLoader(\"NRV2B,NRV_TAIL\", nullptr);\n    else if (ph.method == M_NRV2D_LE32) addLoader(\"NRV2D,NRV_TAIL\", nullptr);\n    else if (M_IS_LZMA(ph.method))   addLoader(\"LZMA_ELF00,LZMA_DEC10,LZMA_DEC30\", nullptr);\n    else throwBadLoader();\n    if (hasLoaderSection(\"CFLUSH\"))\n        addLoader(\"CFLUSH\");\n\n    addLoader(\"IDENTSTR,UPX1HEAD\", nullptr);\n}\n\nstatic const CLANG_FORMAT_DUMMY_STATEMENT\n#include \"stub/powerpc64le-linux.kernel.vmlinux.h\"\nvoid PackVmlinuxPPC64LE::buildLoader(const Filter *ft)\n{\n    // prepare loader\n    initLoader(stub_powerpc64le_linux_kernel_vmlinux, sizeof(stub_powerpc64le_linux_kernel_vmlinux));\n    addLoader(\"LINUX000\", nullptr);\n    if (ft->id) {\n        assert(ft->calls > 0);\n        addLoader(\"LINUX010\", nullptr);\n    }\n    addLoader(\"LINUX020\", nullptr);\n    if (ft->id) {\n        addFilter32(ft->id);\n    }\n    addLoader(\"LINUX030\", nullptr);\n         if (ph.method == M_NRV2E_LE32) addLoader(\"NRV2E,NRV_TAIL\", nullptr);\n    else if (ph.method == M_NRV2B_LE32) addLoader(\"NRV2B,NRV_TAIL\", nullptr);\n    else if (ph.method == M_NRV2D_LE32) addLoader(\"NRV2D,NRV_TAIL\", nullptr);\n    else if (M_IS_LZMA(ph.method))   addLoader(\"LZMA_ELF00,LZMA_DEC10,LZMA_DEC30\", nullptr);\n    else throwBadLoader();\n    if (hasLoaderSection(\"CFLUSH\"))\n        addLoader(\"CFLUSH\");\n\n    addLoader(\"IDENTSTR,UPX1HEAD\", nullptr);\n}\n\n\nstatic const CLANG_FORMAT_DUMMY_STATEMENT\n#include \"stub/i386-linux.kernel.vmlinux-head.h\"\nstatic const CLANG_FORMAT_DUMMY_STATEMENT\n#include \"stub/amd64-linux.kernel.vmlinux-head.h\"\nstatic const CLANG_FORMAT_DUMMY_STATEMENT\n#include \"stub/arm.v5a-linux.kernel.vmlinux-head.h\"\nstatic const CLANG_FORMAT_DUMMY_STATEMENT\n#include \"stub/armeb.v5a-linux.kernel.vmlinux-head.h\"\nstatic const CLANG_FORMAT_DUMMY_STATEMENT\n#include \"stub/powerpc-linux.kernel.vmlinux-head.h\"\n\nunsigned PackVmlinuxI386::write_vmlinux_head(\n    OutputFile *fo,\n    Shdr *stxt\n)\n{\n    // COMPRESSED_LENGTH\n    fo->write(&stub_i386_linux_kernel_vmlinux_head[0],\n        sizeof(stub_i386_linux_kernel_vmlinux_head)-(1+ 4) +1);\n    TE32 tmp_u32; tmp_u32 = ph.c_len; fo->write(&tmp_u32, 4);\n\n    stxt->sh_size += sizeof(stub_i386_linux_kernel_vmlinux_head);\n\n    return sizeof(stub_i386_linux_kernel_vmlinux_head);\n}\n\nunsigned PackVmlinuxAMD64::write_vmlinux_head(\n    OutputFile *fo,\n    Shdr *stxt\n)\n{\n    // COMPRESSED_LENGTH\n    fo->write(&stub_amd64_linux_kernel_vmlinux_head[0],\n        sizeof(stub_amd64_linux_kernel_vmlinux_head)-(1+ 4) +1);\n    TE32 tmp_u32; tmp_u32 = ph.c_len; fo->write(&tmp_u32, 4);\nprintf(\"  Compressed length=0x%x\\n\", ph.c_len);\nprintf(\"UnCompressed length=0x%x\\n\", ph.u_len);\n\n    stxt->sh_size += sizeof(stub_amd64_linux_kernel_vmlinux_head);\n\n    return sizeof(stub_amd64_linux_kernel_vmlinux_head);\n}\n\nvoid PackVmlinuxARMEL::defineDecompressorSymbols()\n{\n    super::defineDecompressorSymbols();\n    linker->defineSymbol(  \"COMPRESSED_LENGTH\", ph.c_len);\n    linker->defineSymbol(\"UNCOMPRESSED_LENGTH\", ph.u_len);\n    linker->defineSymbol(\"METHOD\", ph.method);\n}\n\nvoid PackVmlinuxARMEB::defineDecompressorSymbols()\n{\n    super::defineDecompressorSymbols();\n    linker->defineSymbol(  \"COMPRESSED_LENGTH\", ph.c_len);\n    linker->defineSymbol(\"UNCOMPRESSED_LENGTH\", ph.u_len);\n    linker->defineSymbol(\"METHOD\", ph.method);\n}\n\nvoid PackVmlinuxPPC32::defineDecompressorSymbols()\n{\n    super::defineDecompressorSymbols();\n    // linker->defineSymbol(  \"COMPRESSED_LENGTH\", ph.c_len);\n    // linker->defineSymbol(\"UNCOMPRESSED_LENGTH\", ph.u_len);\n    // linker->defineSymbol(\"METHOD\", ph.method);\n}\n\nvoid PackVmlinuxPPC64LE::defineDecompressorSymbols()\n{\n    super::defineDecompressorSymbols();\n    // linker->defineSymbol(  \"COMPRESSED_LENGTH\", ph.c_len);\n    // linker->defineSymbol(\"UNCOMPRESSED_LENGTH\", ph.u_len);\n    // linker->defineSymbol(\"METHOD\", ph.method);\n}\n\nvoid PackVmlinuxI386::defineDecompressorSymbols()\n{\n    super::defineDecompressorSymbols();\n    linker->defineSymbol(\"ENTRY_POINT\", phdri[0].p_paddr);\n    linker->defineSymbol(\"PHYSICAL_START\", phdri[0].p_paddr);\n}\n\nvoid PackVmlinuxAMD64::defineDecompressorSymbols()\n{\n    super::defineDecompressorSymbols();\n    // We assume a 32-bit boot loader, so we use the 32-bit convention\n    // of \"enter at the beginning\" (startup_32).  The 64-bit convention\n    // would be to use ehdri.e_entry (startup_64).\n    linker->defineSymbol(\"ENTRY_POINT\", (unsigned) phdri[0].p_paddr);\n    linker->defineSymbol(\"PHYSICAL_START\", (unsigned) phdri[0].p_paddr);\n}\n\nunsigned PackVmlinuxARMEL::write_vmlinux_head(\n    OutputFile *fo,\n    Shdr *stxt\n)\n{\n    // First word from vmlinux-head.S\n    fo->write(&stub_arm_v5a_linux_kernel_vmlinux_head[0], 4);\n\n    // Second word\n    TE32 tmp_u32;\n    unsigned const t = (0xff000000 &\n            BeLePolicy::get32(&stub_arm_v5a_linux_kernel_vmlinux_head[4]))\n        | (0x00ffffff & (0u - 1 + ((3+ ph.c_len)>>2)));\n    tmp_u32 = t;\n    fo->write(&tmp_u32, 4);\n\n    stxt->sh_addralign = 4;\n    stxt->sh_size += sizeof(stub_arm_v5a_linux_kernel_vmlinux_head);\n\n    return sizeof(stub_arm_v5a_linux_kernel_vmlinux_head);\n}\n\nunsigned PackVmlinuxARMEB::write_vmlinux_head(\n    OutputFile *fo,\n    Shdr *stxt\n)\n{\n    // First word from vmlinux-head.S\n    fo->write(&stub_armeb_v5a_linux_kernel_vmlinux_head[0], 4);\n\n    // Second word\n    TE32 tmp_u32;\n    unsigned const t = (0xff000000 &\n            BeLePolicy::get32(&stub_armeb_v5a_linux_kernel_vmlinux_head[4]))\n        | (0x00ffffff & (0u - 1 + ((3+ ph.c_len)>>2)));\n    tmp_u32 = t;\n    fo->write(&tmp_u32, 4);\n\n    stxt->sh_addralign = 4;\n    stxt->sh_size += sizeof(stub_armeb_v5a_linux_kernel_vmlinux_head);\n\n    return sizeof(stub_armeb_v5a_linux_kernel_vmlinux_head);\n}\n\nunsigned PackVmlinuxPPC32::write_vmlinux_head(\n    OutputFile * /*fo*/,\n    Shdr * /*stxt*/\n)\n{\n    return 0;\n}\n\nunsigned PackVmlinuxPPC64LE::write_vmlinux_head(\n    OutputFile * /*const fo*/,\n    Shdr * /*const stxt*/\n)\n{\n    return 0;\n}\n\n\nbool PackVmlinuxARMEL::has_valid_vmlinux_head()\n{\n    TE32 buf[2];\n    fi->seek(p_text->sh_offset + sizeof(stub_arm_v5a_linux_kernel_vmlinux_head) -8, SEEK_SET);\n    fi->readx(buf, sizeof(buf));\n    //unsigned const word0 = buf[0];\n    unsigned const word1 = buf[1];\n    if (0xeb==(word1>>24)\n    &&  (0x00ffffff& word1)==(0u - 1 + ((3+ ph.c_len)>>2))) {\n        return true;\n    }\n    return false;\n}\n\nbool PackVmlinuxARMEB::has_valid_vmlinux_head()\n{\n    TE32 buf[2];\n    fi->seek(p_text->sh_offset + sizeof(stub_armeb_v5a_linux_kernel_vmlinux_head) -8, SEEK_SET);\n    fi->readx(buf, sizeof(buf));\n    //unsigned const word0 = buf[0];\n    unsigned const word1 = buf[1];\n    if (0xeb==(word1>>24)\n    &&  (0x00ffffff& word1)==(0u - 1 + ((3+ ph.c_len)>>2))) {\n        return true;\n    }\n    return false;\n}\n\nbool PackVmlinuxPPC32::has_valid_vmlinux_head()\n{\n    TE32 buf[2];\n    fi->seek(p_text->sh_offset + sizeof(stub_powerpc_linux_kernel_vmlinux_head) -8, SEEK_SET);\n    fi->readx(buf, sizeof(buf));\n    //unsigned const word0 = buf[0];\n    unsigned const word1 = buf[1];\n    if (0xeb==(word1>>24)\n    &&  (0x00ffffff& word1)==(0u - 1 + ((3+ ph.c_len)>>2))) {\n        return true;\n    }\n    return false;\n}\n\nstatic const CLANG_FORMAT_DUMMY_STATEMENT\n#include \"stub/powerpc64le-linux.kernel.vmlinux-head.h\"\nbool PackVmlinuxPPC64LE::has_valid_vmlinux_head()\n{\n    TE64 buf[2];\n    fi->seek(p_text->sh_offset + sizeof(stub_powerpc64le_linux_kernel_vmlinux_head) -8, SEEK_SET);\n    fi->readx(buf, sizeof(buf));\n    //unsigned const word0 = buf[0];\n    unsigned const word1 = buf[1];\n    if (0xeb==(word1>>24)\n    &&  (0x00ffffff& word1)==(0u - 1 + ((3+ ph.c_len)>>2))) {\n        return true;\n    }\n    return false;\n}\n\nbool PackVmlinuxI386::has_valid_vmlinux_head()\n{\n    unsigned char buf[5];\n    fi->seek(p_text->sh_offset + sizeof(stub_i386_linux_kernel_vmlinux_head) -5, SEEK_SET);\n    fi->readx(&buf[0], 5);\n    if (0xE8!=buf[0] ||  BeLePolicy::get32(&buf[1]) != ph.c_len)\n    {\n        return false;\n    }\n    return true;\n}\n\nbool PackVmlinuxAMD64::has_valid_vmlinux_head()\n{\n    unsigned char buf[5];\n    fi->seek(p_text->sh_offset + sizeof(stub_amd64_linux_kernel_vmlinux_head) -5, SEEK_SET);\n    fi->readx(&buf[0], 5);\n    if (0xE8!=buf[0] ||  BeLePolicy::get32(&buf[1]) != ph.c_len)\n    {\n        return false;\n    }\n    return true;\n}\n\n\n/*************************************************************************\n//\n**************************************************************************/\n\nconst int *PackVmlinuxAMD64::getCompressionMethods(int method, int level) const\n{\n    return Packer::getDefaultCompressionMethods_le32(method, level);\n}\n\n\nconst int *PackVmlinuxAMD64::getFilters() const\n{\n    static const int filters[] = {\n        0x49, 0x46,\n    -1 };\n    return filters;\n}\n\nbool PackVmlinuxAMD64::is_valid_e_entry(Addr e_entry)\n{\n    return 0x200000<=e_entry; // 2 MiB\n}\n\nLinker* PackVmlinuxAMD64::newLinker() const\n{\n    return new ElfLinkerX86;\n}\n\n\n\n// instantiate instances\ntemplate class PackVmlinuxBase<ElfClass_BE32>;\n// template class PackVmlinuxBase<ElfClass_BE64>; // currently not used\ntemplate class PackVmlinuxBase<ElfClass_LE32>;\ntemplate class PackVmlinuxBase<ElfClass_LE64>;\n\n/* vim:set ts=4 sw=4 et: */\n","size_bytes":41367},"src/p_vmlinz.cpp":{"content":"/* p_vmlinz.cpp --\n\n   This file is part of the Resize executable compressor.\n\n   Copyright (C) 2025 WHO-AM-I-404\n   Based on UPX - Ultimate Packer for eXecutables\n   Copyright (C) 1996-2025 Markus Franz Xaver Johannes Oberhumer\n   Copyright (C) 1996-2025 Laszlo Molnar\n   All Rights Reserved.\n\n   Resize and the UCL library are free software; you can redistribute them\n   and/or modify them under the terms of the GNU General Public License as\n   published by the Free Software Foundation; either version 2 of\n   the License, or (at your option) any later version.\n\n   This program is distributed in the hope that it will be useful,\n   but WITHOUT ANY WARRANTY; without even the implied warranty of\n   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n   GNU General Public License for more details.\n\n   You should have received a copy of the GNU General Public License\n   along with this program; see the file COPYING.\n   If not, write to the Free Software Foundation, Inc.,\n   59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.\n\n   WHO-AM-I-404 <who-am-i-404@proton.me>\n   Based on original work by:\n   Markus F.X.J. Oberhumer <markus@oberhumer.com>\n   Laszlo Molnar <ezerotven+github@gmail.com>\n */\n\n\n#define ALLOW_INT_PLUS_MEMBUFFER 1\n#include \"conf.h\"\n\n#if (WITH_ZLIB)\n#include \"p_elf.h\"\n#include \"file.h\"\n#include \"filter.h\"\n#include \"packer.h\"\n#include \"p_vmlinz.h\"\n#include \"linker.h\"\n#include <zlib/zlib.h>\n\nstatic const CLANG_FORMAT_DUMMY_STATEMENT\n#include \"stub/i386-linux.kernel.vmlinuz.h\"\n\nstatic const unsigned stack_offset_during_uncompression = 0x9000;\n// add to \"real mode pointer\" in %esi; total 0x99000 is typical\n\n// from /usr/src/linux/arch/i386/boot/compressed/Makefile\nstatic const unsigned zimage_offset = 0x1000;\nstatic const unsigned bzimage_offset = 0x100000;\n\n\n/*************************************************************************\n//\n**************************************************************************/\n\nPackVmlinuzI386::PackVmlinuzI386(InputFile *f) :\n    super(f), physical_start(0x100000), page_offset(0), config_physical_align(0)\n    , filter_len(0)\n{\n    bele = &N_BELE_RTP::le_policy;\n    COMPILE_TIME_ASSERT(sizeof(boot_sect_t) == 0x250)\n}\n\n\nconst int *PackVmlinuzI386::getCompressionMethods(int method, int level) const\n{\n    return Packer::getDefaultCompressionMethods_le32(method, level);\n}\n\n\nconst int *PackVmlinuzI386::getFilters() const\n{\n    static const int filters[] = {\n        0x26, 0x24, 0x49, 0x46, 0x16, 0x13, 0x14, 0x11,\n        FT_ULTRA_BRUTE, 0x25, 0x15, 0x12,\n    FT_END };\n    return filters;\n}\n\nconst int *PackBvmlinuzI386::getFilters() const\n{\n    // The destination buffer might be relocated at runtime.\n    static const int filters[] = {\n        0x49, 0x46,\n    FT_END };\n    return filters;\n}\n\nint PackVmlinuzI386::getStrategy(Filter &/*ft*/)\n{\n    // If user specified the filter, then use it (-2==filter_strategy).\n    // Else try the first two filters, and pick the better (2==filter_strategy).\n    return (opt->no_filter ? -3 : ((opt->filter > 0) ? -2 : 2));\n}\n\n\ntribool PackVmlinuzI386::canPack()\n{\n    return readFileHeader() == getFormat();\n}\n\n\n/*************************************************************************\n// common util routines\n**************************************************************************/\n\nint PackVmlinuzI386::readFileHeader()\n{\n    setup_size = 0;\n\n    fi->readx(&h, sizeof(h));\n    if (h.boot_flag != 0xAA55)\n        return 0;\n    const bool hdrs = (memcmp(h.hdrs, \"HdrS\", 4) == 0);\n\n    setup_size = (1 + (h.setup_sects ? h.setup_sects : 4)) * 0x200;\n    if (setup_size <= 0 || setup_size >= file_size)\n        return 0;\n\n    int format = UPX_F_VMLINUZ_i386;\n    unsigned sys_size = ALIGN_UP((unsigned) file_size_u, 16u) - setup_size;\n\n    const unsigned char *p = (const unsigned char *) &h + 0x1e3;\n\n    if (hdrs && memcmp(p, \"\\x0d\\x0a\\x07\"\"ELKS\", 7) == 0)\n    {\n        format = UPX_F_ELKS_8086;\n    }\n    else if (hdrs && (h.load_flags & 1) != 0)\n    {\n        format = UPX_F_BVMLINUZ_i386;\n    }\n\n    if (0x204<=h.version) {\n        if ((16u * h.sys_size) != sys_size)\n            return 0;\n    }\n    else { // h.sys_size is only 2 bytes\n        if ((16u * (0xffff & h.sys_size)) != (~(~0u<<20) & sys_size))\n            return 0;\n    }\n\n    // FIXME: add more checks for a valid kernel\n\n    return format;\n}\n\n\nstatic int is_pow2(unsigned const x)\n{\n    return !(x & (x - 1));\n}\n\n// read full kernel into obuf[], gzip-decompress into ibuf[],\n// return decompressed size\nint PackVmlinuzI386::decompressKernel()\n{\n    // read whole kernel image\n    obuf.alloc(file_size);\n    fi->seek(0, SEEK_SET);\n    fi->readx(obuf, file_size);\n\n    {\n    const upx_byte *base = nullptr;\n    unsigned relocated = 0;\n\n    // See startup_32: in linux/arch/i386/boot/compressed/head.S\n    const upx_byte *p;\n    unsigned cpa_0 = 0;\n    unsigned cpa_1 = 0;\n    int j;\n    if (0x205<=h.version) {\n        cpa_0 = h.kernel_alignment;\n        cpa_1 = 0u - cpa_0;\n    } else\n    for ((p = &obuf[setup_size]), (j= 0); j < 0x200; ++j, ++p) {\n        if (0==memcmp(\"\\x89\\xeb\\x81\\xc3\", p, 4)\n        &&  0==memcmp(\"\\x81\\xe3\",      8+ p, 2)) {\n            // movl %ebp,%ebx\n            // addl $imm.w,%ebx\n            // andl $imm.w,%ebx\n            cpa_0 = 1+ get_te32( 4+ p);\n            cpa_1 =    get_te32(10+ p);\n            break;\n        }\n    }\n    for ((p = &obuf[setup_size]), (j= 0); j < 0x200; ++j, ++p) {\n        if (0==memcmp(\"\\x8d\\x83\",    p, 2)  // leal d32(%ebx),%eax\n        &&  0==memcmp(\"\\xff\\xe0\", 6+ p, 2)  // jmp *%eax\n        ) {\n            relocated = get_te32(2+ p);\n        }\n        if (0==memcmp(\"\\xE8\\x00\\x00\\x00\\x00\\x5D\", p, 6)) {\n            // \"call 1f; 1f: pop %ebp\"  determines actual execution address.\n            // linux-2.6.21 (spring 2007) and later; upx stub needs work\n            // unless LOAD_PHYSICAL_ADDR is known.\n            // Allowed code is:  linux-2.6.23/arch/x86/head_32.S  2008-01-01\n            //      call 1f\n            //  1:  popl %ebp\n            //      subl $1b, %ebp  # 32-bit immediate\n            //      movl $LOAD_PHYSICAL_ADDR, %ebx\n            //\n            if (0==memcmp(\"\\x81\\xed\", 6+  p, 2)      // subl $imm.w,%ebp\n            &&  0==memcmp(\"\\xbb\",     12+ p, 1) ) {  // movl $imm.w,%ebx\n                physical_start = get_te32(13+ p);\n            } else\n            if (0==memcmp(\"\\x81\\xed\", 6+  p, 2)  // subl $imm.w,%ebp\n            &&  is_pow2(cpa_0) && (0u-cpa_0)==cpa_1) {\n                base = (5+ p) - get_te32(8+ p);\n                config_physical_align = cpa_0;\n            }\n            else {\n                throwCantPack(\"Unrecognized relocatable kernel\");\n            }\n        }\n        // Find \"ljmp $__BOOT_CS,$__PHYSICAL_START\" if any.\n        if (0==memcmp(\"\\xEA\\x00\\x00\", p, 3) && 0==(0xf & p[3]) && 0==p[4]) {\n            /* whole megabyte < 16 MiB */\n            physical_start = get_te32(1+ p);\n            break;\n        }\n    }\n    if (base && relocated) {\n        p = base + relocated;\n        for (j = 0; j < 0x200; ++j, ++p) {\n            if (0==memcmp(\"\\x01\\x9c\\x0b\", p, 3)  // addl %ebx,d32(%ebx,%ecx)\n            ) {\n                page_offset = 0u - get_te32(3+ p);\n            }\n            if (0==memcmp(\"\\x89\\xeb\",    p, 2)  // movl %ebp,%ebx\n            &&  0==memcmp(\"\\x81\\xeb\", 2+ p, 2)  // subl $imm32,%ebx\n            ) {\n                physical_start = get_te32(4+ p);\n            }\n        }\n    }\n    }\n\n    checkAlreadyPacked(obuf + setup_size, UPX_MIN(file_size - setup_size, 1024LL));\n\n    int gzoff = setup_size;\n    if (0x208<=h.version) {\n        gzoff += h.payload_offset;\n    }\n    for (; gzoff < file_size; gzoff++)\n    {\n        // find gzip header (2 bytes magic + 1 byte method \"deflated\")\n        int off = find(obuf + gzoff, file_size - gzoff, \"\\x1F\\x8B\\x08\", 3);\n        if (off < 0)\n            break;\n        gzoff += off;\n        const int gzlen = (h.version < 0x208) ? (file_size - gzoff) : h.payload_length;\n        if (gzlen < 256)\n            break;\n        // check gzip flag byte\n        unsigned char flags = obuf[gzoff + 3];\n        if ((flags & 0xe0) != 0)        // reserved bits set\n            continue;\n        //printf(\"found gzip header at offset %d\\n\", gzoff);\n\n        // try to decompress\n        int klen;\n        int fd;\n        upx_off_t fd_pos;\n        for (;;)\n        {\n            klen = -1;\n            fd_pos = -1;\n            // open\n            fi->seek(gzoff, SEEK_SET);\n            fd = fi->dupFd();\n            if (fd < 0)\n                break;\n            gzFile zf = gzdopen(fd, \"rb\");\n            if (zf == nullptr)\n                break;\n            // estimate gzip-decompressed kernel size & alloc buffer\n            if (ibuf.getSize() == 0)\n                ibuf.alloc(gzlen * 3);\n            // decompress\n            klen = gzread(zf, ibuf, ibuf.getSize());\n            fd_pos = lseek(fd, 0, SEEK_CUR);\n            gzclose(zf);\n            fd = -1;\n            if (klen != (int)ibuf.getSize())\n                break;\n            // realloc and try again\n            unsigned s = ibuf.getSize();\n            ibuf.dealloc();\n            ibuf.alloc(3 * s / 2);\n        }\n        if (fd >= 0)\n            (void) close(fd);\n        if (klen <= 0)\n            continue;\n\n        if (klen <= gzlen)\n            continue;\n\n        if (0x208<=h.version && 0==memcmp(\"\\177ELF\", ibuf, 4)) {\n            // Full ELF in theory; for now, try to handle as .bin at physical_start.\n            // Check for PT_LOAD.p_paddr being ascending and adjacent.\n            Elf_LE32_Ehdr const *const ehdr = (Elf_LE32_Ehdr const *)(void const *)ibuf;\n            Elf_LE32_Phdr const *phdr = (Elf_LE32_Phdr const *)(ehdr->e_phoff + (char const *)ehdr);\n            Elf_LE32_Shdr const *shdr = (Elf_LE32_Shdr const *)(ehdr->e_shoff + (char const *)ehdr);\n            unsigned hi_paddr = 0, lo_paddr = 0;\n            unsigned delta_off = 0;\n            for (unsigned j=0; j < ehdr->e_phnum; ++j, ++phdr) {\n                if (phdr->PT_LOAD==phdr->p_type) {\n                    unsigned step = (hi_paddr + phdr->p_align - 1) & ~(phdr->p_align - 1);\n                    if (0==hi_paddr) { // first PT_LOAD\n                        if (physical_start!=phdr->p_paddr) {\n                            return 0;\n                        }\n                        delta_off = phdr->p_paddr - phdr->p_offset;\n                        lo_paddr = phdr->p_paddr;\n                        hi_paddr = phdr->p_filesz + phdr->p_paddr;\n                    }\n                    else if (step==phdr->p_paddr\n                        && delta_off==(phdr->p_paddr - phdr->p_offset)) {\n                        hi_paddr = phdr->p_filesz + phdr->p_paddr;\n                    }\n                    else {\n                        return 0;  // Not equivalent to a .bin.  Too complex for now.\n                    }\n                }\n            }\n            // FIXME: ascending order is only a convention; might need sorting.\n            for (unsigned j=1; j < ehdr->e_shnum; ++j) {\n                if (shdr->SHT_PROGBITS==shdr->sh_type) { // SHT_REL might be intermixed\n                    if (shdr->SHF_EXECINSTR & shdr[j].sh_flags) {\n                        filter_len += shdr[j].sh_size;  // FIXME: include sh_addralign\n                    }\n                    else {\n                        break;\n                    }\n                }\n            }\n            memmove(ibuf, (lo_paddr - delta_off) + ibuf, hi_paddr - lo_paddr);  // FIXME: set_size\n            // FIXME: .bss ?  Apparently handled by head.S\n        }\n\n        if (opt->force > 0)\n            return klen;\n\n        // some checks\n        if (fd_pos != file_size)\n        {\n            NO_printf(\"fd_pos: %jd, file_size: %lld\\n\", (intmax_t) fd_pos, file_size);\n\n            // linux-2.6.21.5/arch/i386/boot/compressed/vmlinux.lds\n            // puts .data.compressed ahead of .text, .rodata, etc;\n            // so piggy.o need not be last in bzImage.  Alas.\n            //throwCantPack(\"trailing bytes after kernel image; use option '-f' to force packing\");\n        }\n\n\n        // see /usr/src/linux/arch/i386/kernel/head.S\n        // 2.4.x: [cli;] cld; mov $...,%eax\n        if (memcmp(ibuf,     \"\\xFC\\xB8\", 2) == 0) goto head_ok;\n        if (memcmp(ibuf, \"\\xFA\\xFC\\xB8\", 3) == 0) goto head_ok;\n        // 2.6.21.5 CONFIG_PARAVIRT  mov %cs,%eax; test $3,%eax; jne ...;\n        if (memcmp(ibuf, \"\\x8c\\xc8\\xa9\\x03\\x00\\x00\\x00\\x0f\\x85\", 9) == 0) goto head_ok;\n        if (memcmp(ibuf, \"\\x8c\\xc8\\xa8\\x03\\x0f\\x85\", 6) == 0) goto head_ok;\n        // 2.6.x: [cli;] cld; lgdt ...\n        if (memcmp(ibuf,     \"\\xFC\\x0F\\x01\", 3) == 0) goto head_ok;\n        if (memcmp(ibuf, \"\\xFA\\xFC\\x0F\\x01\", 4) == 0) goto head_ok;\n        // 2.6.x+grsecurity+strongswan+openwall+trustix: ljmp $0x10,...\n        if (ibuf[0] == 0xEA && memcmp(ibuf+5, \"\\x10\\x00\", 2) == 0) goto head_ok;\n        // x86_64 2.6.x\n        if (0xB8==ibuf[0]  // mov $...,%eax\n        &&  0x8E==ibuf[5] && 0xD8==ibuf[6]  // mov %eax,%ds\n        &&  0x0F==ibuf[7] && 0x01==ibuf[8] && 020==(070 & ibuf[9]) // lgdtl\n        &&  0xB8==ibuf[14]  // mov $...,%eax\n        &&  0x0F==ibuf[19] && 0xA2==ibuf[20]  // cpuid\n        ) goto head_ok;\n\n        // cmpw   $0x207,0x206(%esi)  Debian vmlinuz-2.6.24-12-generic\n        if (0==memcmp(\"\\x66\\x81\\xbe\\x06\\x02\\x00\\x00\\x07\\x02\", ibuf, 9)) goto head_ok;\n\n        // testb  $0x40,0x211(%esi)  Fedora vmlinuz-2.6.25-0.218.rc8.git7.fc9.i686\n        if (0==memcmp(\"\\xf6\\x86\\x11\\x02\\x00\\x00\\x40\", ibuf, 7)) goto head_ok;\n\n        // rex.W prefix for x86_64\n        if (0x48==ibuf[0]) throwCantPack(\"x86_64 bzImage is not yet supported\");\n\n        throwCantPack(\"unrecognized kernel architecture; use option '-f' to force packing\");\n    head_ok:\n\n        // FIXME: more checks for special magic bytes in ibuf ???\n        // FIXME: more checks for kernel architecture ???\n\n        return klen;\n    }\n\n    return 0;\n}\n\n\nvoid PackVmlinuzI386::readKernel()\n{\n    int klen = decompressKernel();\n    if (klen <= 0)\n        throwCantPack(\"kernel decompression failed\");\n    //OutputFile::dump(\"kernel.img\", ibuf, klen);\n\n    // copy the setup boot code\n    setup_buf.alloc(setup_size);\n    memcpy(setup_buf, obuf, setup_size);\n    //OutputFile::dump(\"setup.img\", setup_buf, setup_size);\n\n    obuf.dealloc();\n    obuf.allocForCompression(klen);\n\n    ph.u_len = klen;\n    ph.filter = 0;\n}\n\n\nLinker* PackVmlinuzI386::newLinker() const\n{\n    return new ElfLinkerX86;\n}\n\n\n/*************************************************************************\n// vmlinuz specific\n**************************************************************************/\n\nvoid PackVmlinuzI386::buildLoader(const Filter *ft)\n{\n    // prepare loader\n    initLoader(stub_i386_linux_kernel_vmlinuz, sizeof(stub_i386_linux_kernel_vmlinuz));\n    addLoader(\"LINUZ000\",\n              ph.first_offset_found == 1 ? \"LINUZ010\" : \"\",\n              ft->id ? \"LZCALLT1\" : \"\",\n              \"LZIMAGE0\",\n              getDecompressorSections(),\n              nullptr\n             );\n    if (ft->id)\n    {\n        assert(ft->calls > 0);\n        addLoader(\"LZCALLT9\", nullptr);\n        addFilter32(ft->id);\n    }\n    addLoader(\"LINUZ990,IDENTSTR,UPX1HEAD\", nullptr);\n}\n\n\nvoid PackVmlinuzI386::pack(OutputFile *fo)\n{\n    readKernel();\n\n    // prepare filter\n    Filter ft(ph.level);\n    ft.buf_len = ph.u_len;\n    ft.addvalue = physical_start;  // saves 4 bytes in unfilter code\n\n    // compress\n    upx_compress_config_t cconf; cconf.reset();\n    // limit stack size needed for runtime decompression\n    cconf.conf_lzma.max_num_probs = 1846 + (768 << 4); // ushort: ~28 KiB stack\n    compressWithFilters(&ft, 512, &cconf, getStrategy(ft));\n\n    const unsigned lsize = getLoaderSize();\n\n    defineDecompressorSymbols();\n    defineFilterSymbols(&ft);\n    linker->defineSymbol(\"src_for_decompressor\", zimage_offset + lsize);\n    linker->defineSymbol(\"original_entry\", physical_start);\n    linker->defineSymbol(\"stack_offset\", stack_offset_during_uncompression);\n    relocateLoader();\n\n    MemBuffer loader(lsize);\n    memcpy(loader, getLoader(), lsize);\n    patchPackHeader(loader, lsize);\n\n    boot_sect_t * const bs = (boot_sect_t *) ((unsigned char *) setup_buf);\n    bs->sys_size = ALIGN_UP(lsize + ph.c_len, 16u) / 16;\n    bs->payload_length = ph.c_len;\n\n    fo->write(setup_buf, setup_buf.getSize());\n    fo->write(loader, lsize);\n    fo->write(obuf, ph.c_len);\n#if 0\n    printf(\"%-13s: setup        : %8ld bytes\\n\", getName(), (long) setup_buf.getSize());\n    printf(\"%-13s: loader       : %8ld bytes\\n\", getName(), (long) lsize);\n    printf(\"%-13s: compressed   : %8ld bytes\\n\", getName(), (long) ph.c_len);\n#endif\n\n    // verify\n    verifyOverlappingDecompression();\n\n    // finally check the compression ratio\n    if (!checkFinalCompressionRatio(fo))\n        throwNotCompressible();\n}\n\n\n/*************************************************************************\n// bvmlinuz specific\n**************************************************************************/\n\nvoid PackBvmlinuzI386::buildLoader(const Filter *ft)\n{\n    // prepare loader\n    initLoader(stub_i386_linux_kernel_vmlinuz, sizeof(stub_i386_linux_kernel_vmlinuz));\n    if (0!=page_offset) { // relocatable kernel\n        assert(0==ft->id || 0x40==(0xf0 & ft->id));  // others assume fixed buffer address\n        addLoader(\"LINUZ000,LINUZ001,LINUZVGA,LINUZ101,LINUZ110\",\n            ((0!=config_physical_align) ? \"LINUZ120\" : \"LINUZ130\"),\n            \"LINUZ140,LZCUTPOI,LINUZ141\",\n            (ft->id ? \"LINUZ145\" : \"\"),\n            (ph.first_offset_found == 1 ? \"LINUZ010\" : \"\"),\n            nullptr);\n    }\n    else {\n        addLoader(\"LINUZ000,LINUZ001,LINUZVGA,LINUZ005\",\n              ph.first_offset_found == 1 ? \"LINUZ010\" : \"\",\n              (0x40==(0xf0 & ft->id)) ? \"LZCKLLT1\" : (ft->id ? \"LZCALLT1\" : \"\"),\n              \"LBZIMAGE,IDENTSTR\",\n              \"+40\", // align the stuff to 4 byte boundary\n              \"UPX1HEAD\", // 32 byte\n              \"LZCUTPOI\",\n              nullptr);\n        // fake alignment for the start of the decompressor\n        //linker->defineSymbol(\"LZCUTPOI\", 0x1000);\n    }\n\n    addLoader(getDecompressorSections(), nullptr);\n\n    if (ft->id)\n    {\n            assert(ft->calls > 0);\n        if (0x40==(0xf0 & ft->id)) {\n            addLoader(\"LZCKLLT9\", nullptr);\n        }\n        else {\n            addLoader(\"LZCALLT9\", nullptr);\n        }\n        addFilter32(ft->id);\n    }\n    if (0!=page_offset) {\n        addLoader(\"LINUZ150,IDENTSTR,+40,UPX1HEAD\", nullptr);\n        unsigned const l_len = getLoaderSize();\n        unsigned const c_len = ALIGN_UP(ph.c_len, 4u);\n        unsigned const e_len = getLoaderSectionStart(\"LINUZ141\") -\n                               getLoaderSectionStart(\"LINUZ110\");\n        linker->defineSymbol(\"compressed_length\", c_len);\n        linker->defineSymbol(\"load_physical_address\", physical_start);  // FIXME\n        if (0!=config_physical_align) {\n            linker->defineSymbol(\"neg_config_physical_align\", 0u - config_physical_align);\n        }\n        linker->defineSymbol(\"neg_length_mov\", 0u - ALIGN_UP(c_len + l_len, 4u));\n        linker->defineSymbol(\"neg_page_offset\", 0u - page_offset);\n        //linker->defineSymbol(\"physical_start\", physical_start);\n        linker->defineSymbol(\"unc_length\", ph.u_len);\n        linker->defineSymbol(\"dec_offset\", ph.overlap_overhead + e_len);\n        linker->defineSymbol(\"unc_offset\", ph.overlap_overhead + ph.u_len - c_len);\n    }\n    else {\n        addLoader(\"LINUZ990\", nullptr);\n    }\n}\n\n\nvoid PackBvmlinuzI386::pack(OutputFile *fo)\n{\n    readKernel();\n\n    // prepare filter\n    Filter ft(ph.level);\n    ft.buf_len = (filter_len ? filter_len : (ph.u_len * 3)/5);\n    // May 2008: 3/5 is heuristic to cover most .text but avoid non-instructions.\n    // Otherwise \"call trick\" filter cannot find a free marker byte,\n    // especially when it searches over tables of data.\n    ft.addvalue = 0;  // The destination buffer might be relocated at runtime.\n\n    upx_compress_config_t cconf; cconf.reset();\n    // LINUZ001 allows most of low memory as stack for Bvmlinuz\n    cconf.conf_lzma.max_num_probs = (0x90000 - 0x10000)>>1; // ushort: 512 KiB stack\n\n    compressWithFilters(&ft, 512, &cconf, getStrategy(ft));\n\n    // align everything to dword boundary - it is easier to handle\n    unsigned c_len = ph.c_len;\n    memset(obuf + c_len, 0, 4);\n    c_len = ALIGN_UP(c_len, 4u);\n\n    const unsigned lsize = getLoaderSize();\n\n    if (M_IS_LZMA(ph.method)) {\n        const lzma_compress_result_t *res = &ph.compress_result.result_lzma;\n        upx_uint32_t properties = // lc, lp, pb, dummy\n            (res->lit_context_bits << 0) |\n            (res->lit_pos_bits << 8) |\n            (res->pos_bits << 16);\n        if (bele->isBE()) // big endian - bswap32\n            properties = bswap32(properties);\n        linker->defineSymbol(\"lzma_properties\", properties);\n        // -2 for properties\n        if (linker->findSymbol(\"lzma_c_len\", false)) {\n            linker->defineSymbol(\"lzma_c_len\", ph.c_len - 2);\n        }\n        if (linker->findSymbol(\"lzma_u_len\", false)) {\n            linker->defineSymbol(\"lzma_u_len\", ph.u_len);\n        }\n        unsigned const stack = getDecompressorWrkmemSize();\n        linker->defineSymbol(\"lzma_stack_adjust\", 0u - stack);\n    }\n\n    const int e_len = getLoaderSectionStart(\"LZCUTPOI\");\n    assert(e_len > 0);\n\n    if (0==page_offset) {  // not relocatable kernel\n        const unsigned d_len4 = ALIGN_UP(lsize - e_len, 4u);\n        const unsigned decompr_pos = ALIGN_UP(ph.u_len + ph.overlap_overhead, 16u);\n        const unsigned copy_size = c_len + d_len4;\n        const unsigned edi = decompr_pos + d_len4 - 4;          // copy to\n        const unsigned esi = ALIGN_UP(c_len + lsize, 4u) - 4;   // copy from\n\n        linker->defineSymbol(\"decompressor\", decompr_pos - bzimage_offset + physical_start);\n        linker->defineSymbol(\"src_for_decompressor\", physical_start + decompr_pos - c_len);\n        linker->defineSymbol(\"words_to_copy\", copy_size / 4);\n        linker->defineSymbol(\"copy_dest\", physical_start + edi);\n        linker->defineSymbol(\"copy_source\", bzimage_offset + esi);\n    }\n\n    defineFilterSymbols(&ft);\n    defineDecompressorSymbols();\n    if (0==page_offset) {\n        linker->defineSymbol(\"original_entry\", physical_start);\n    }\n    linker->defineSymbol(\"stack_offset\", stack_offset_during_uncompression);\n    relocateLoader();\n\n    MemBuffer loader(lsize);\n    memcpy(loader, getLoader(), lsize);\n    patchPackHeader(loader, lsize);\n\n    boot_sect_t * const bs = (boot_sect_t *) ((unsigned char *) setup_buf);\n    bs->sys_size = (ALIGN_UP(lsize + c_len, 16u) / 16);\n\n    fo->write(setup_buf, setup_buf.getSize());\n\n    unsigned const e_pfx = (0==page_offset) ? 0 : getLoaderSectionStart(\"LINUZ110\");\n    if (0!=page_offset) {\n        fo->write(loader, e_pfx);\n    }\n    else {\n        fo->write(loader, e_len);\n    }\n    fo->write(obuf, c_len);\n    if (0!=page_offset) {\n        fo->write(loader + e_pfx, e_len - e_pfx);\n    }\n    fo->write(loader + e_len, lsize - e_len);\n#if 0\n    printf(\"%-13s: setup        : %8ld bytes\\n\", getName(), (long) setup_buf.getSize());\n    printf(\"%-13s: entry        : %8ld bytes\\n\", getName(), (long) e_len);\n    printf(\"%-13s: compressed   : %8ld bytes\\n\", getName(), (long) c_len);\n    printf(\"%-13s: decompressor : %8ld bytes\\n\", getName(), (long) (lsize - e_len));\n#endif\n\n    // verify\n    verifyOverlappingDecompression();\n\n    // finally check the compression ratio\n    if (!checkFinalCompressionRatio(fo))\n        throwNotCompressible();\n}\n\n\n/*************************************************************************\n// unpack\n**************************************************************************/\n\ntribool PackVmlinuzI386::canUnpack()\n{\n    if (readFileHeader() != getFormat())\n        return false;\n    fi->seek(setup_size, SEEK_SET);\n    return readPackHeader(1024) ? 1 : -1;\n}\n\n\nvoid PackVmlinuzI386::unpack(OutputFile *fo)\n{\n    // no uncompression support for this format, so that\n    // it is possible to remove the original deflate code (>10 KiB)\n\n    // FIXME: but we could write the uncompressed \"vmlinux\" image\n\n    ibuf.alloc(ph.c_len);\n    obuf.allocForDecompression(ph.u_len);\n\n    fi->seek(setup_size + ph.buf_offset + ph.getPackHeaderSize(), SEEK_SET);\n    fi->readx(ibuf, ph.c_len);\n\n    // decompress\n    decompress(ibuf, obuf);\n\n    // unfilter\n    Filter ft(ph.level);\n    ft.init(ph.filter, physical_start);\n    ft.cto = (unsigned char) ph.filter_cto;\n    ft.unfilter(obuf, ph.u_len);\n\n    // write decompressed file\n    if (fo)\n    {\n        throwCantUnpack(\"build a new kernel instead :-)\");\n        //fo->write(obuf, ph.u_len);\n    }\n}\n\n\nPackVmlinuzARMEL::PackVmlinuzARMEL(InputFile *f) :\n    super(f), setup_size(0), filter_len(0)\n{\n    bele = &N_BELE_RTP::le_policy;\n}\n\nconst int *PackVmlinuzARMEL::getCompressionMethods(int method, int level) const\n{\n    return Packer::getDefaultCompressionMethods_8(method, level);\n}\n\nconst int *PackVmlinuzARMEL::getFilters() const\n{\n    static const int f50[] = { 0x50, FT_END };\n    return f50;\n}\n\nint PackVmlinuzARMEL::getStrategy(Filter &/*ft*/)\n{\n    // If user specified the filter, then use it (-2==filter_strategy).\n    // Else try the first two filters, and pick the better (2==filter_strategy).\n    return (opt->no_filter ? -3 : ((opt->filter > 0) ? -2 : 2));\n}\n\ntribool PackVmlinuzARMEL::canPack()\n{\n    return readFileHeader() == getFormat();\n}\n\nint PackVmlinuzARMEL::readFileHeader()\n{\n    unsigned int hdr[8];\n\n    fi->readx(hdr, sizeof(hdr));\n    for (int j=0; j < 8; ++j) {\n        if (0xe1a00000!=get_te32(&hdr[j])) {\n            return 0;\n        }\n    }\n    return UPX_F_VMLINUZ_ARM;\n}\n\nint PackVmlinuzARMEL::decompressKernel()\n{\n    // read whole kernel image\n    obuf.alloc(file_size);\n    fi->seek(0, SEEK_SET);\n    fi->readx(obuf, file_size);\n\n    //checkAlreadyPacked(obuf + setup_size, UPX_MIN(file_size - setup_size, 1024LL));\n\n    // Find head.S:\n    //      bl decompress_kernel  # 0xeb......\n    //      b call_kernel         # 0xea......\n    //LC0: .word LC0              # self!\n    unsigned decompress_kernel = 0;\n    unsigned caller1 = 0;\n    unsigned caller2 = 0;\n    unsigned got_start = 0;\n    unsigned got_end = 0;\n    for (unsigned j = 0; j < 0x400; j+=4) {\n        unsigned w;\n        if (j!=get_te32(j + obuf)) {\n            continue;\n        }\n        if (0xea000000!=(0xff000000&    get_te32(j - 4 + obuf))\n        ||  0xeb000000!=(0xff000000&(w= get_te32(j - 8 + obuf))) ) {\n            continue;\n        }\n        caller1 = j - 8;\n        decompress_kernel = ((0x00ffffff & w)<<2) + 8+ caller1;\n        for (unsigned k = 12; k<=128; k+=4) {\n            w = get_te32(j - k + obuf);\n            if (0xeb000000==(0xff000000 & w)\n            &&  decompress_kernel==(((0x00ffffff & w)<<2) + 8+ j - k) ) {\n                caller2 = j - k;\n                break;\n            }\n        }\n        got_start = get_te32(5*4 + j + obuf);\n        got_end   = get_te32(6*4 + j + obuf);\n#if 0  /*{*/\n        printf(\"decompress_kernel=0x%x  got_start=0x%x  got_end=0x%x\\n\",\n            decompress_kernel, got_start, got_end);\n#endif  /*}*/\n        break;\n    }\n    if (0==decompress_kernel) {\n        return 0;\n    }\n\n    // Find first subroutine that is called by decompress_kernel,\n    // which we will consider to be the start of the gunzip module\n    // and the end of the non-gunzip modules.\n    for (unsigned j = decompress_kernel; j < (unsigned)file_size; j+=4) {\n        unsigned w = get_te32(j + obuf);\n        if (0xeb800000==(0xff800000 & w)) {\n            setup_size = 8+ ((0xff000000 | w)<<2) + j;\n            // Move the GlobalOffsetTable.\n            for (unsigned k = got_start; k < got_end; k+=4) {\n                w = get_te32(k + obuf);\n                // FIXME: must relocate w\n                set_te32(k - got_start + setup_size + obuf, w);\n            }\n            setup_size += got_end - got_start;\n            set_te32(&obuf[caller1], 0xeb000000 |\n                (0x00ffffff & ((setup_size - (8+ caller1))>>2)) );\n            set_te32(&obuf[caller2], 0xeb000000 |\n                (0x00ffffff & ((setup_size - (8+ caller2))>>2)) );\n            break;\n        }\n    }\n\n    for (int gzoff = 0; gzoff < 0x4000; gzoff+=4) {\n        // find gzip header (2 bytes magic + 1 byte method \"deflated\")\n        int off = find(obuf + gzoff, file_size - gzoff, \"\\x1F\\x8B\\x08\", 3);\n        if (off < 0 || 0!=(3u & off))\n            break;  // not found, or not word-aligned\n        gzoff += off;\n        const int gzlen = file_size - gzoff;\n        if (gzlen < 256)\n            break;\n        // check gzip flag byte\n        unsigned char flags = obuf[gzoff + 3];\n        if ((flags & 0xe0) != 0)        // reserved bits set\n            continue;\n        //printf(\"found gzip header at offset %d\\n\", gzoff);\n\n        // try to decompress\n        int klen;\n        int fd;\n        upx_off_t fd_pos;\n        for (;;)\n        {\n            klen = -1;\n            fd_pos = -1;\n            // open\n            fi->seek(gzoff, SEEK_SET);\n            fd = fi->dupFd();\n            if (fd < 0)\n                break;\n            gzFile zf = gzdopen(fd, \"rb\");\n            if (zf == nullptr)\n                break;\n            // estimate gzip-decompressed kernel size & alloc buffer\n            if (ibuf.getSize() == 0)\n                ibuf.alloc(gzlen * 3);\n            // decompress\n            klen = gzread(zf, ibuf, ibuf.getSize());\n            fd_pos = lseek(fd, 0, SEEK_CUR);\n            gzclose(zf);\n            fd = -1;\n            if (klen != (int)ibuf.getSize())\n                break;\n            // realloc and try again\n            unsigned const s = ibuf.getSize();\n            ibuf.dealloc();\n            ibuf.alloc(3 * s / 2);\n        }\n        if (fd >= 0)\n            (void) close(fd);\n        if (klen <= 0)\n            continue;\n\n        if (klen <= gzlen)\n            continue;\n\n        if (opt->force > 0)\n            return klen;\n\n        // some checks\n        if (fd_pos != file_size) {\n            //printf(\"fd_pos: %ld, file_size: %ld\\n\", (long)fd_pos, (long)file_size);\n        }\n\n    //head_ok:\n\n        // FIXME: more checks for special magic bytes in ibuf ???\n        // FIXME: more checks for kernel architecture ???\n\n        return klen;\n    }\n\n    return 0;\n}\n\nvoid PackVmlinuzARMEL::readKernel()\n{\n    int klen = decompressKernel();\n    if (klen <= 0)\n        throwCantPack(\"kernel decompression failed\");\n    //OutputFile::dump(\"kernel.img\", ibuf, klen);\n\n    // copy the setup boot code\n    setup_buf.alloc(setup_size);\n    memcpy(setup_buf, obuf, setup_size);\n    //OutputFile::dump(\"setup.img\", setup_buf, setup_size);\n\n    obuf.dealloc();\n    obuf.allocForCompression(klen);\n\n    ph.u_len = klen;\n    ph.filter = 0;\n}\n\nLinker* PackVmlinuzARMEL::newLinker() const\n{\n    return new ElfLinkerArmLE;\n}\n\nstatic const CLANG_FORMAT_DUMMY_STATEMENT\n#include \"stub/arm.v5a-linux.kernel.vmlinux.h\"\nstatic const CLANG_FORMAT_DUMMY_STATEMENT\n#include \"stub/arm.v5a-linux.kernel.vmlinuz-head.h\"\n\nvoid PackVmlinuzARMEL::buildLoader(const Filter *ft)\n{\n    // prepare loader; same as vmlinux (with 'x')\n    initLoader(stub_arm_v5a_linux_kernel_vmlinux, sizeof(stub_arm_v5a_linux_kernel_vmlinux));\n    addLoader(\"LINUX000\", nullptr);\n    if (ft->id) {\n        assert(ft->calls > 0);\n        addLoader(\"LINUX010\", nullptr);\n    }\n    addLoader(\"LINUX020\", nullptr);\n    if (ft->id) {\n        addFilter32(ft->id);\n    }\n    addLoader(\"LINUX030\", nullptr);\n         if (ph.method == M_NRV2E_8) addLoader(\"NRV2E\", nullptr);\n    else if (ph.method == M_NRV2B_8) addLoader(\"NRV2B\", nullptr);\n    else if (ph.method == M_NRV2D_8) addLoader(\"NRV2D\", nullptr);\n    else if (M_IS_LZMA(ph.method))   addLoader(\"LZMA_ELF00\",\n        (opt->small ? \"LZMA_DEC10\" : \"LZMA_DEC20\"), \"LZMA_DEC30\", nullptr);\n    else throwBadLoader();\n    addLoader(\"IDENTSTR,UPX1HEAD\", nullptr);\n\n    // To debug (2008-09-14):\n    //   Build gdb-6.8-21.fc9.src.rpm; ./configure --target=arm-none-elf; make\n    //     Contains the fix for http://bugzilla.redhat.com/show_bug.cgi?id=436037\n    //   Install qemu-0.9.1-6.fc9.i386.rpm\n    //   qemu-system-arm -s -S -kernel <file> -nographic\n    //   (gdb) target remote localhost:1234\n    //   A very small boot loader runs at pc=0x0; the kernel is at 0x10000 (64KiB).\n}\n\nvoid PackVmlinuzARMEL::defineDecompressorSymbols()\n{\n    super::defineDecompressorSymbols();\n    linker->defineSymbol(  \"COMPRESSED_LENGTH\", ph.c_len);\n    linker->defineSymbol(\"UNCOMPRESSED_LENGTH\", ph.u_len);\n    linker->defineSymbol(\"METHOD\", ph.method);\n}\n\nunsigned PackVmlinuzARMEL::write_vmlinuz_head(OutputFile *fo)\n{ // First word from vmlinuz-head.S\n    fo->write(&stub_arm_v5a_linux_kernel_vmlinuz_head[0], 4);\n\n    // Second word\n    upx_uint32_t tmp_u32;\n    unsigned const t = (0xff000000 &\n            get_te32(&stub_arm_v5a_linux_kernel_vmlinuz_head[4]))\n        | (0x00ffffff & (0u - 1 + ((3+ ph.c_len)>>2)));\n    set_te32(&tmp_u32, t);\n    fo->write(&tmp_u32, 4);\n\n    return sizeof(stub_arm_v5a_linux_kernel_vmlinuz_head);\n}\n\nvoid PackVmlinuzARMEL::pack(OutputFile *fo)\n{\n    readKernel();\n\n    // prepare filter\n    Filter ft(ph.level);\n    ft.buf_len = ph.u_len;\n    ft.addvalue = 0;\n\n    // compress\n    upx_compress_config_t cconf; cconf.reset();\n    // limit stack size needed for runtime decompression\n    cconf.conf_lzma.max_num_probs = 1846 + (768 << 5); // ushort: 52,844 byte stack\n    compressWithFilters(&ft, 512, &cconf, getStrategy(ft));\n\n    const unsigned lsize = getLoaderSize();\n\n    defineDecompressorSymbols();\n    defineFilterSymbols(&ft);\n    relocateLoader();\n\n    MemBuffer loader(lsize);\n    memcpy(loader, getLoader(), lsize);\n    patchPackHeader(loader, lsize);\n\n//    boot_sect_t * const bs = (boot_sect_t *) ((unsigned char *) setup_buf);\n//    bs->sys_size = ALIGN_UP(lsize + ph.c_len, 16u) / 16;\n//    bs->payload_length = ph.c_len;\n\n    fo->write(setup_buf, setup_buf.getSize());\n    write_vmlinuz_head(fo);\n    fo->write(obuf, ph.c_len);\n    unsigned const zero = 0;\n    fo->write((void const *)&zero, 3u & (0u - ph.c_len));\n    fo->write(loader, lsize);\n#if 0\n    printf(\"%-13s: setup        : %8ld bytes\\n\", getName(), (long) setup_buf.getSize());\n    printf(\"%-13s: loader       : %8ld bytes\\n\", getName(), (long) lsize);\n    printf(\"%-13s: compressed   : %8ld bytes\\n\", getName(), (long) ph.c_len);\n#endif\n\n    // verify\n    verifyOverlappingDecompression();\n\n    // finally check the compression ratio\n    if (!checkFinalCompressionRatio(fo))\n        throwNotCompressible();\n}\n\ntribool PackVmlinuzARMEL::canUnpack()\n{\n    if (readFileHeader() != getFormat())\n        return false;\n    fi->seek(setup_size, SEEK_SET);\n    return readPackHeader(1024) ? 1 : -1;\n}\n\nvoid PackVmlinuzARMEL::unpack(OutputFile *fo)\n{\n    // no uncompression support for this format, so that\n    // it is possible to remove the original deflate code (>10 KiB)\n\n    // FIXME: but we could write the uncompressed \"vmlinux\" image\n\n    ibuf.alloc(ph.c_len);\n    obuf.allocForDecompression(ph.u_len);\n\n    fi->seek(setup_size + ph.buf_offset + ph.getPackHeaderSize(), SEEK_SET);\n    fi->readx(ibuf, ph.c_len);\n\n    // decompress\n    decompress(ibuf, obuf);\n\n    // unfilter\n    Filter ft(ph.level);\n    ft.init(ph.filter, 0);\n    ft.cto = (unsigned char) ph.filter_cto;\n    ft.unfilter(obuf, ph.u_len);\n\n    // write decompressed file\n    if (fo)\n    {\n        throwCantUnpack(\"build a new kernel instead :-)\");\n        //fo->write(obuf, ph.u_len);\n    }\n}\n\n#endif // WITH_ZLIB\n\n/* vim:set ts=4 sw=4 et: */\n","size_bytes":35583},"src/p_w32pe_i386.cpp":{"content":"/* p_w32pe_i386.cpp --\n\n   This file is part of the Resize executable compressor.\n\n   Copyright (C) 2025 WHO-AM-I-404\n   Based on UPX - Ultimate Packer for eXecutables\n   Copyright (C) 1996-2025 Markus Franz Xaver Johannes Oberhumer\n   Copyright (C) 1996-2025 Laszlo Molnar\n   All Rights Reserved.\n\n   Resize and the UCL library are free software; you can redistribute them\n   and/or modify them under the terms of the GNU General Public License as\n   published by the Free Software Foundation; either version 2 of\n   the License, or (at your option) any later version.\n\n   This program is distributed in the hope that it will be useful,\n   but WITHOUT ANY WARRANTY; without even the implied warranty of\n   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n   GNU General Public License for more details.\n\n   You should have received a copy of the GNU General Public License\n   along with this program; see the file COPYING.\n   If not, write to the Free Software Foundation, Inc.,\n   59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.\n\n   WHO-AM-I-404 <who-am-i-404@proton.me>\n   Based on original work by:\n   Markus F.X.J. Oberhumer <markus@oberhumer.com>\n   Laszlo Molnar <ezerotven+github@gmail.com>\n */\n\n#include \"conf.h\"\n#include \"file.h\"\n#include \"filter.h\"\n#include \"packer.h\"\n#include \"pefile.h\"\n#include \"p_w32pe_i386.h\"\n#include \"linker.h\"\n\nstatic const CLANG_FORMAT_DUMMY_STATEMENT\n#include \"stub/i386-win32.pe.h\"\n\n/*************************************************************************\n//\n**************************************************************************/\n\nPackW32PeI386::PackW32PeI386(InputFile *f) : super(f) {}\n\nPackW32PeI386::~PackW32PeI386() noexcept {}\n\nconst int *PackW32PeI386::getCompressionMethods(int method, int level) const {\n    bool small = ih.codesize + ih.datasize <= 256 * 1024;\n    return Packer::getDefaultCompressionMethods_le32(method, level, small);\n}\n\nconst int *PackW32PeI386::getFilters() const {\n    static const int filters[] = {0x26, 0x24,           0x49, 0x46, 0x16, 0x13,  0x14,\n                                  0x11, FT_ULTRA_BRUTE, 0x25, 0x15, 0x12, FT_END};\n    return filters;\n}\n\nLinker *PackW32PeI386::newLinker() const { return new ElfLinkerX86; }\n\n/*************************************************************************\n// util\n**************************************************************************/\n\nint PackW32PeI386::readFileHeader() {\n    if (file_size >= 0x206) {\n        byte buf[6];\n        fi->seek(0x200, SEEK_SET);\n        fi->readx(buf, 6);\n        isrtm = memcmp(buf, \"32STUB\", 6) == 0;\n    }\n    return super::readFileHeader();\n}\n\n/*************************************************************************\n// pack\n**************************************************************************/\n\ntribool PackW32PeI386::canPack() {\n    if (!readFileHeader())\n        return false;\n    checkMachine(ih.cpu);\n    if (ih.cpu < IMAGE_FILE_MACHINE_I386 || ih.cpu > 0x150)\n        return false;\n    return true;\n}\n\nvoid PackW32PeI386::buildLoader(const Filter *ft) {\n    // recompute tlsindex (see pack() below)\n    unsigned tmp_tlsindex = tlsindex;\n    const unsigned oam1 = ih.objectalign - 1;\n    const unsigned newvsize = (ph.u_len + rvamin + ph.overlap_overhead + oam1) & ~oam1;\n    if (tlsindex && ((newvsize - ph.c_len - 1024 + oam1) & ~oam1) > tlsindex + 4)\n        tmp_tlsindex = 0;\n\n    // prepare loader\n    initLoader(stub_i386_win32_pe, sizeof(stub_i386_win32_pe), 2);\n    if (isdll)\n        addLoader(\"PEISDLL1\");\n    addLoader(\"PEMAIN01\", use_stub_relocs ? \"PESOCREL\" : \"PESOCPIC\", \"PESOUNC0\",\n              icondir_count > 1 ? (icondir_count == 2 ? \"PEICONS1\" : \"PEICONS2\") : \"\",\n              tmp_tlsindex ? \"PETLSHAK\" : \"\", \"PEMAIN02\",\n              ph.first_offset_found == 1 ? \"PEMAIN03\" : \"\", getDecompressorSections(),\n              // multipass ? \"PEMULTIP\" : \"\",\n              \"PEMAIN10\");\n    addLoader(tmp_tlsindex ? \"PETLSHAK2\" : \"\");\n    if (ft->id) {\n        const unsigned texv = ih.codebase - rvamin;\n        assert(ft->calls > 0);\n        addLoader(texv ? \"PECTTPOS\" : \"PECTTNUL\");\n        addFilter32(ft->id);\n    }\n    if (soimport)\n        addLoader(\"PEIMPORT\", importbyordinal ? \"PEIBYORD\" : \"\", kernel32ordinal ? \"PEK32ORD\" : \"\",\n                  importbyordinal ? \"PEIMORD1\" : \"\", \"PEIMPOR2\", isdll ? \"PEIERDLL\" : \"PEIEREXE\",\n                  \"PEIMDONE\");\n    if (sorelocs) {\n        addLoader(soimport == 0 || soimport + cimports != crelocs ? \"PERELOC1\" : \"PERELOC2\",\n                  \"PERELOC3,RELOC320\", big_relocs ? \"REL32BIG\" : \"\", \"RELOC32J\");\n        // FIXME: the following should be moved out of the above if\n        addLoader(big_relocs & 6 ? \"PERLOHI0\" : \"\", big_relocs & 4 ? \"PERELLO0\" : \"\",\n                  big_relocs & 2 ? \"PERELHI0\" : \"\");\n    }\n    if (use_dep_hack)\n        addLoader(\"PEDEPHAK\");\n\n    // NEW: TLS callback support PART 1, the callback handler installation - Stefan Widmann\n    if (use_tls_callbacks)\n        addLoader(\"PETLSC\");\n\n    addLoader(\"PEMAIN20\");\n    if (use_clear_dirty_stack)\n        addLoader(\"CLEARSTACK\");\n    addLoader(\"PEMAIN21\");\n    // NEW: last loader sections split up to insert TLS callback handler - Stefan Widmann\n    addLoader(ih.entry || !ilinker ? \"PEDOJUMP\" : \"PERETURN\");\n\n    // NEW: TLS callback support PART 2, the callback handler - Stefan Widmann\n    if (use_tls_callbacks)\n        addLoader(\"PETLSC2\");\n\n    addLoader(\"IDENTSTR,UPX1HEAD\");\n}\n\nbool PackW32PeI386::needForceOption() const {\n    // return true if we need `--force` to pack this file\n    bool r = false;\n    r |= (ih.opthdrsize != 0xe0);\n    r |= ((ih.flags & IMAGE_FILE_EXECUTABLE_IMAGE) == 0);\n    r |= ((ih.flags & IMAGE_FILE_32BIT_MACHINE) == 0); // 32 bit machine flag must be set\n    r |= (ih.coffmagic != 0x10b);                      // COFF magic is 0x10B in PE files\n    r |= (ih.entry == 0 && !isdll);\n    r |= (ih.ddirsentries != 16);\n    r |= (IDSIZE(PEDIR_EXCEPTION) != 0); // is this used on i386?\n    //// r |= (IDSIZE(PEDIR_COPYRIGHT) != 0);\n    return r;\n}\n\nvoid PackW32PeI386::defineSymbols(unsigned ncsection, unsigned upxsection, unsigned sizeof_oh,\n                                  unsigned ic, unsigned s1addr) {\n    const unsigned myimport = ncsection + soresources - rvamin;\n\n    // patch loader\n    linker->defineSymbol(\"original_entry\", ih.entry);\n    if (use_dep_hack) {\n        // This works around a \"protection\" introduced in MSVCRT80, which\n        // works like this:\n        // When the compiler detects that it would link in some code from its\n        // C runtime library which references some data in a read only\n        // section then it compiles in a runtime check whether that data is\n        // still in a read only section by looking at the pe header of the\n        // file. If this check fails the runtime does \"interesting\" things\n        // like not running the floating point initialization code - the result\n        // is a R6002 runtime error.\n        // These supposed to be read only addresses are covered by the sections\n        // UPX0 & UPX1 in the compressed files, so we have to patch the PE header\n        // in the memory. And the page on which the PE header is stored is read\n        // only so we must make it rw, fix the flags (i.e. clear\n        // IMAGE_SCN_MEM_WRITE of osection[x].flags), and make it ro again.\n\n        // rva of the most significant byte of member \"flags\" in section \"UPX0\"\n        const unsigned swri = pe_offset + sizeof_oh + sizeof(pe_section_t) - 1;\n        // make sure we only touch the minimum number of pages\n        const unsigned addr = 0u - rvamin + swri;\n        linker->defineSymbol(\"swri\", addr & 0xfff); // page offset\n        // check whether osection[0].flags and osection[1].flags\n        // are on the same page\n        linker->defineSymbol(\n            \"vp_size\", ((addr & 0xfff) + 0x28 >= 0x1000) ? 0x2000 : 0x1000); // 2 pages or 1 page\n        linker->defineSymbol(\"vp_base\", addr & ~0xfff);                      // page mask\n        linker->defineSymbol(\"VirtualProtect\",\n                             0u - rvamin + ilinkerGetAddress(\"kernel32.dll\", \"VirtualProtect\"));\n    }\n    linker->defineSymbol(\"reloc_delt\", 0u - (unsigned) ih.imagebase - rvamin);\n    linker->defineSymbol(\"start_of_relocs\", crelocs);\n\n    if (ilinker) {\n        if (!isdll)\n            linker->defineSymbol(\"ExitProcess\",\n                                 0u - rvamin + ilinkerGetAddress(\"kernel32.dll\", \"ExitProcess\"));\n        linker->defineSymbol(\"GetProcAddress\",\n                             0u - rvamin + ilinkerGetAddress(\"kernel32.dll\", \"GetProcAddress\"));\n        linker->defineSymbol(\"kernel32_ordinals\", myimport);\n        linker->defineSymbol(\"LoadLibraryA\",\n                             0u - rvamin + ilinkerGetAddress(\"kernel32.dll\", \"LoadLibraryA\"));\n        linker->defineSymbol(\"start_of_imports\", myimport);\n        linker->defineSymbol(\"compressed_imports\", cimports);\n    }\n\n    defineDecompressorSymbols();\n    linker->defineSymbol(\"filter_buffer_start\", ih.codebase - rvamin);\n\n    // in case of overlapping decompression, this hack is needed,\n    // because windoze zeroes the word pointed by tlsindex before\n    // it starts programs\n    linker->defineSymbol(\"tls_value\",\n                         (tlsindex + 4 > s1addr) ? get_le32(obuf + tlsindex - s1addr - ic) : 0);\n    linker->defineSymbol(\"tls_address\", tlsindex - rvamin);\n\n    linker->defineSymbol(\"icon_delta\", icondir_count - 1);\n    linker->defineSymbol(\"icon_offset\", ncsection + icondir_offset - rvamin);\n\n    const unsigned esi0 = s1addr + ic;\n    linker->defineSymbol(\"start_of_uncompressed\", 0u - esi0 + rvamin);\n    linker->defineSymbol(\"start_of_compressed\", use_stub_relocs ? esi0 + ih.imagebase : esi0);\n\n    if (use_tls_callbacks) {\n        // esi is ih.imagebase + rvamin\n        linker->defineSymbol(\"tls_callbacks_ptr\", tlscb_ptr);\n        linker->defineSymbol(\"tls_module_base\", 0u - rvamin);\n    }\n\n    linker->defineSymbol(isdll ? \"PEISDLL1\" : \"PEMAIN01\", upxsection);\n    // linker->dumpSymbols();\n}\n\nvoid PackW32PeI386::addNewRelocations(Reloc &rel, unsigned upxsection) {\n    if (use_stub_relocs)\n        rel.add_reloc(upxsection + linker->getSymbolOffset(\"PESOCREL\") + 1,\n                      IMAGE_REL_BASED_HIGHLOW);\n}\n\nvoid PackW32PeI386::setOhDataBase(const pe_section_t *osection) { oh.database = osection[2].vaddr; }\n\nvoid PackW32PeI386::setOhHeaderSize(const pe_section_t *osection) {\n    // SizeOfHeaders\n    oh.headersize =\n        ALIGN_UP(pe_offset + usizeof(oh) + usizeof(*osection) * oh.objects, oh.filealign);\n}\n\nvoid PackW32PeI386::pack(OutputFile *fo) {\n    unsigned mask = (1u << IMAGE_SUBSYSTEM_WINDOWS_GUI) | (1u << IMAGE_SUBSYSTEM_WINDOWS_CUI) |\n                    (1u << IMAGE_SUBSYSTEM_EFI_APPLICATION) |\n                    (1u << IMAGE_SUBSYSTEM_EFI_BOOT_SERVICE_DRIVER) |\n                    (1u << IMAGE_SUBSYSTEM_EFI_RUNTIME_DRIVER) | (1u << IMAGE_SUBSYSTEM_EFI_ROM);\n    super::pack0(fo, mask, 0x400000, false);\n}\n\n/* vim:set ts=4 sw=4 et: */\n","size_bytes":11021},"src/p_w64pe_amd64.cpp":{"content":"/* p_w64pe_amd64.cpp --\n\n   This file is part of the Resize executable compressor.\n\n   Copyright (C) 2025 WHO-AM-I-404\n   Based on UPX - Ultimate Packer for eXecutables\n   Copyright (C) 1996-2025 Markus Franz Xaver Johannes Oberhumer\n   Copyright (C) 1996-2025 Laszlo Molnar\n   All Rights Reserved.\n\n   Resize and the UCL library are free software; you can redistribute them\n   and/or modify them under the terms of the GNU General Public License as\n   published by the Free Software Foundation; either version 2 of\n   the License, or (at your option) any later version.\n\n   This program is distributed in the hope that it will be useful,\n   but WITHOUT ANY WARRANTY; without even the implied warranty of\n   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n   GNU General Public License for more details.\n\n   You should have received a copy of the GNU General Public License\n   along with this program; see the file COPYING.\n   If not, write to the Free Software Foundation, Inc.,\n   59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.\n\n   WHO-AM-I-404 <who-am-i-404@proton.me>\n   Based on original work by:\n   Markus F.X.J. Oberhumer <markus@oberhumer.com>\n   Laszlo Molnar <ezerotven+github@gmail.com>\n\n   -------------------------------------------------------------------\n\n   PE+ format extension changes         (C) 2010 Stefan Widmann\n\n */\n\n#include \"conf.h\"\n#include \"file.h\"\n#include \"filter.h\"\n#include \"packer.h\"\n#include \"pefile.h\"\n#include \"p_w64pe_amd64.h\"\n#include \"linker.h\"\n\nstatic const CLANG_FORMAT_DUMMY_STATEMENT\n#include \"stub/amd64-win64.pe.h\"\n\n/*************************************************************************\n//\n**************************************************************************/\n\nPackW64PeAmd64::PackW64PeAmd64(InputFile *f) : super(f) { use_stub_relocs = false; }\n\nPackW64PeAmd64::~PackW64PeAmd64() noexcept {}\n\nconst int *PackW64PeAmd64::getCompressionMethods(int method, int level) const {\n    bool small = ih.codesize + ih.datasize <= 256 * 1024;\n    return Packer::getDefaultCompressionMethods_le32(method, level, small);\n}\n\nconst int *PackW64PeAmd64::getFilters() const {\n    static const int filters[] = {0x49, FT_END};\n    return filters;\n}\n\nLinker *PackW64PeAmd64::newLinker() const { return new ElfLinkerAMD64; }\n\n/*************************************************************************\n// pack\n**************************************************************************/\n\ntribool PackW64PeAmd64::canPack() {\n    if (!readFileHeader())\n        return false;\n    checkMachine(ih.cpu);\n    if (ih.cpu != IMAGE_FILE_MACHINE_AMD64)\n        return false;\n    return true;\n}\n\nvoid PackW64PeAmd64::buildLoader(const Filter *ft) {\n    // recompute tlsindex (see pack() below)\n    unsigned tmp_tlsindex = tlsindex;\n    const unsigned oam1 = ih.objectalign - 1;\n    const unsigned newvsize = (ph.u_len + rvamin + ph.overlap_overhead + oam1) & ~oam1;\n    if (tlsindex && ((newvsize - ph.c_len - 1024 + oam1) & ~oam1) > tlsindex + 4)\n        tmp_tlsindex = 0;\n\n    // prepare loader\n    initLoader(stub_amd64_win64_pe, sizeof(stub_amd64_win64_pe), 2);\n    addLoader(\"START\");\n    if (ih.entry && isdll)\n        addLoader(\"PEISDLL0\");\n    if (isefi)\n        addLoader(\"PEISEFI0\");\n    addLoader(isdll ? \"PEISDLL1\" : \"\", \"PEMAIN01\", // outer \"enter\" (push rbp; mov rsp,rbp)\n              icondir_count > 1 ? (icondir_count == 2 ? \"PEICONS1\" : \"PEICONS2\") : \"\",\n              tmp_tlsindex ? \"PETLSHAK\" : \"\", \"PEMAIN02\",\n              // ph.first_offset_found == 1 ? \"PEMAIN03\" : \"\",\n\n              // LZMA_ELF00 has inner \"enter\" (push rbp; mov rsp,rbp)\n              // LZMA_TAIL  has inner 'leave' (mov rbp,rsp; pop rbp)\n              M_IS_LZMA(ph.method) ? \"LZMA_HEAD,LZMA_ELF00,LZMA_DEC20,LZMA_TAIL\"\n\n              : M_IS_NRV2B(ph.method) ? \"NRV_HEAD,NRV2B\"\n              : M_IS_NRV2D(ph.method) ? \"NRV_HEAD,NRV2D\"\n              : M_IS_NRV2E(ph.method) ? \"NRV_HEAD,NRV2E\"\n                                      : \"UNKNOWN_COMPRESSION_METHOD\",\n              // getDecompressorSections(),\n              /*multipass ? \"PEMULTIP\" :  */ \"\", \"PEMAIN10\");\n    addLoader(tmp_tlsindex ? \"PETLSHAK2\" : \"\");\n    if (ft->id) {\n        const unsigned texv = ih.codebase - rvamin;\n        assert(ft->calls > 0);\n        addLoader(texv ? \"PECTTPOS\" : \"PECTTNUL\");\n        addLoader(\"PEFILTER49\");\n    }\n    if (soimport)\n        addLoader(\"PEIMPORT\", importbyordinal ? \"PEIBYORD\" : \"\", kernel32ordinal ? \"PEK32ORD\" : \"\",\n                  importbyordinal ? \"PEIMORD1\" : \"\", \"PEIMPOR2\", isdll ? \"PEIERDLL\" : \"PEIEREXE\",\n                  \"PEIMDONE\");\n    if (sorelocs) {\n        addLoader(soimport == 0 || soimport + cimports != crelocs ? \"PERELOC1\" : \"PERELOC2\",\n                  \"PERELOC3\", big_relocs ? \"REL64BIG\" : \"\", \"RELOC64J\");\n        if (0) {\n            addLoader(big_relocs & 6 ? \"PERLOHI0\" : \"\", big_relocs & 4 ? \"PERELLO0\" : \"\",\n                      big_relocs & 2 ? \"PERELHI0\" : \"\");\n        }\n    }\n    if (use_dep_hack)\n        addLoader(\"PEDEPHAK\");\n\n    // NEW: TLS callback support PART 1, the callback handler installation - Stefan Widmann\n    if (use_tls_callbacks)\n        addLoader(\"PETLSC\");\n\n    addLoader(\"PEMAIN20\"); // outer \"leave\" (mov rbp,rsp; pop rbp)\n    if (use_clear_dirty_stack)\n        addLoader(\"CLEARSTACK\");\n    addLoader(\"PEMAIN21\");\n\n    if (ih.entry && isdll)\n        addLoader(\"PEISDLL9\");\n    if (isefi)\n        addLoader(\"PEISEFI9\");\n    addLoader(ih.entry || !ilinker ? \"PEDOJUMP\" : \"PERETURN\");\n\n    // NEW: TLS callback support PART 2, the callback handler - Stefan Widmann\n    if (use_tls_callbacks)\n        addLoader(\"PETLSC2\");\n\n    addLoader(\"IDENTSTR,UPX1HEAD\");\n}\n\nbool PackW64PeAmd64::needForceOption() const {\n    // return true if we need `--force` to pack this file\n    bool r = false;\n    r |= (ih.opthdrsize != 0xf0); // optional header size is 0xF0 in PE32+ files\n    r |= ((ih.flags & IMAGE_FILE_EXECUTABLE_IMAGE) == 0);\n    r |= ((ih.flags & IMAGE_FILE_32BIT_MACHINE) != 0); // 32 bit machine flag may not be set\n    r |= (ih.coffmagic != 0x20b);                      // COFF magic is 0x20B in PE32+ files\n    r |= (ih.entry == 0 && !isdll);\n    r |= (ih.ddirsentries != 16);\n    return r;\n}\n\nvoid PackW64PeAmd64::defineSymbols(unsigned ncsection, unsigned upxsection, unsigned sizeof_oh,\n                                   unsigned ic, unsigned s1addr) {\n    const unsigned myimport = ncsection + soresources - rvamin;\n\n    // patch loader\n    linker->defineSymbol(\"original_entry\", ih.entry);\n    if (use_dep_hack) {\n        // This works around a \"protection\" introduced in MSVCRT80, which\n        // works like this:\n        // When the compiler detects that it would link in some code from its\n        // C runtime library which references some data in a read only\n        // section then it compiles in a runtime check whether that data is\n        // still in a read only section by looking at the pe header of the\n        // file. If this check fails the runtime does \"interesting\" things\n        // like not running the floating point initialization code - the result\n        // is a R6002 runtime error.\n        // These supposed to be read only addresses are covered by the sections\n        // UPX0 & UPX1 in the compressed files, so we have to patch the PE header\n        // in the memory. And the page on which the PE header is stored is read\n        // only so we must make it rw, fix the flags (i.e. clear\n        // IMAGE_SCN_MEM_WRITE of osection[x].flags), and make it ro again.\n\n        // rva of the most significant byte of member \"flags\" in section \"UPX0\"\n        const unsigned swri = pe_offset + sizeof_oh + sizeof(pe_section_t) - 1;\n        // make sure we only touch the minimum number of pages\n        const unsigned addr = 0u - rvamin + swri;\n        linker->defineSymbol(\"swri\", addr & 0xfff); // page offset\n        // check whether osection[0].flags and osection[1].flags\n        // are on the same page\n        linker->defineSymbol(\n            \"vp_size\", ((addr & 0xfff) + 0x28 >= 0x1000) ? 0x2000 : 0x1000); // 2 pages or 1 page\n        linker->defineSymbol(\"vp_base\", addr & ~0xfff);                      // page mask\n        linker->defineSymbol(\"VirtualProtect\", ilinkerGetAddress(\"kernel32.dll\", \"VirtualProtect\"));\n    }\n    linker->defineSymbol(\"start_of_relocs\", crelocs);\n\n    if (ilinker) {\n        if (!isdll)\n            linker->defineSymbol(\"ExitProcess\", ilinkerGetAddress(\"kernel32.dll\", \"ExitProcess\"));\n        linker->defineSymbol(\"GetProcAddress\", ilinkerGetAddress(\"kernel32.dll\", \"GetProcAddress\"));\n        linker->defineSymbol(\"kernel32_ordinals\", myimport);\n        linker->defineSymbol(\"LoadLibraryA\", ilinkerGetAddress(\"kernel32.dll\", \"LoadLibraryA\"));\n        linker->defineSymbol(\"start_of_imports\", myimport);\n        linker->defineSymbol(\"compressed_imports\", cimports);\n    }\n\n    if (M_IS_LZMA(ph.method)) {\n        if (linker->findSymbol(\"lzma_c_len\", false)) {\n            linker->defineSymbol(\"lzma_c_len\", ph.c_len - 2);\n        }\n        if (linker->findSymbol(\"lzma_u_len\", false)) {\n            linker->defineSymbol(\"lzma_u_len\", ph.u_len);\n        }\n    }\n    linker->defineSymbol(\"filter_buffer_start\", ih.codebase - rvamin);\n\n    // in case of overlapping decompression, this hack is needed,\n    // because windoze zeroes the word pointed by tlsindex before\n    // it starts programs\n    linker->defineSymbol(\"tls_value\",\n                         (tlsindex + 4 > s1addr) ? get_le32(obuf + tlsindex - s1addr - ic) : 0);\n    linker->defineSymbol(\"tls_address\", tlsindex - rvamin);\n\n    linker->defineSymbol(\"icon_delta\", icondir_count - 1);\n    linker->defineSymbol(\"icon_offset\", ncsection + icondir_offset - rvamin);\n\n    const unsigned esi0 = s1addr + ic;\n    linker->defineSymbol(\"start_of_uncompressed\", 0u - esi0 + rvamin);\n    linker->defineSymbol(\"start_of_compressed\", esi0);\n\n    if (use_tls_callbacks) {\n        linker->defineSymbol(\"tls_callbacks_ptr\", tlscb_ptr - ih.imagebase);\n        linker->defineSymbol(\"tls_module_base\", 0u - rvamin);\n    }\n\n    linker->defineSymbol(\"START\", upxsection);\n}\n\nvoid PackW64PeAmd64::setOhHeaderSize(const pe_section_t *osection) {\n    // SizeOfHeaders\n    oh.headersize =\n        ALIGN_UP(pe_offset + usizeof(oh) + usizeof(*osection) * oh.objects, oh.filealign);\n}\n\nvoid PackW64PeAmd64::pack(OutputFile *fo) {\n    unsigned mask = (1u << IMAGE_SUBSYSTEM_WINDOWS_GUI) | (1u << IMAGE_SUBSYSTEM_WINDOWS_CUI) |\n                    (1u << IMAGE_SUBSYSTEM_EFI_APPLICATION) |\n                    (1u << IMAGE_SUBSYSTEM_EFI_BOOT_SERVICE_DRIVER) |\n                    (1u << IMAGE_SUBSYSTEM_EFI_RUNTIME_DRIVER) | (1u << IMAGE_SUBSYSTEM_EFI_ROM);\n    super::pack0(fo, mask, 0x0000000140000000ULL);\n}\n\n/* vim:set ts=4 sw=4 et: */\n","size_bytes":10749},"src/p_w64pe_arm64.cpp":{"content":"/* p_w64pe_arm64.cpp --\n\n   This file is part of the Resize executable compressor.\n\n   Copyright (C) 2025 WHO-AM-I-404\n   Based on UPX - Ultimate Packer for eXecutables\n   Copyright (C) 1996-2025 Markus Franz Xaver Johannes Oberhumer\n   Copyright (C) 1996-2025 Laszlo Molnar\n   All Rights Reserved.\n\n   Resize and the UCL library are free software; you can redistribute them\n   and/or modify them under the terms of the GNU General Public License as\n   published by the Free Software Foundation; either version 2 of\n   the License, or (at your option) any later version.\n\n   This program is distributed in the hope that it will be useful,\n   but WITHOUT ANY WARRANTY; without even the implied warranty of\n   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n   GNU General Public License for more details.\n\n   You should have received a copy of the GNU General Public License\n   along with this program; see the file COPYING.\n   If not, write to the Free Software Foundation, Inc.,\n   59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.\n\n   WHO-AM-I-404 <who-am-i-404@proton.me>\n   Based on original work by:\n   Markus F.X.J. Oberhumer <markus@oberhumer.com>\n   Laszlo Molnar <ezerotven+github@gmail.com>\n */\n\n// TODO: implement this; see p_w64pe_amd64.cpp\n\n#include \"conf.h\"\n#include \"file.h\"\n#include \"filter.h\"\n#include \"packer.h\"\n#include \"pefile.h\"\n#include \"p_w64pe_arm64.h\"\n#include \"linker.h\"\n\n// static const CLANG_FORMAT_DUMMY_STATEMENT\n// #include \"stub/arm64-win64.pe.h\"\n\n/*************************************************************************\n//\n**************************************************************************/\n\nPackW64PeArm64::PackW64PeArm64(InputFile *f) : super(f) {\n    // use_stub_relocs = false;\n}\n\nLinker *PackW64PeArm64::newLinker() const { return new ElfLinkerArm64LE; }\n\nconst int *PackW64PeArm64::getCompressionMethods(int method, int level) const {\n    bool small = ih.codesize + ih.datasize <= 256 * 1024;\n    return Packer::getDefaultCompressionMethods_le32(method, level, small);\n}\n\nconst int *PackW64PeArm64::getFilters() const { return nullptr; }\n\n/*************************************************************************\n// pack\n**************************************************************************/\n\ntribool PackW64PeArm64::canPack() {\n    if (!readFileHeader())\n        return false;\n    checkMachine(ih.cpu);\n    if (ih.cpu != IMAGE_FILE_MACHINE_ARM64)\n        return false;\n    throwCantPack(\"win64/arm64 is not yet implemented\");\n    return true;\n}\n\nvoid PackW64PeArm64::buildLoader(const Filter *ft) {\n    UNUSED(ft);\n    throwCantPack(\"not yet implemented\");\n}\n\nbool PackW64PeArm64::needForceOption() const {\n    // return true if we need `--force` to pack this file\n    bool r = false;\n    throwCantPack(\"not yet implemented\");\n    return r;\n}\n\nvoid PackW64PeArm64::defineSymbols(unsigned ncsection, unsigned upxsection, unsigned sizeof_oh,\n                                   unsigned ic, unsigned s1addr) {\n    UNUSED(ncsection);\n    UNUSED(upxsection);\n    UNUSED(sizeof_oh);\n    UNUSED(ic);\n    UNUSED(s1addr);\n    throwCantPack(\"not yet implemented\");\n}\n\nvoid PackW64PeArm64::setOhHeaderSize(const pe_section_t *osection) {\n    // SizeOfHeaders\n    UNUSED(osection);\n    throwCantPack(\"not yet implemented\");\n}\n\nvoid PackW64PeArm64::pack(OutputFile *fo) {\n    UNUSED(fo);\n    throwCantPack(\"not yet implemented\");\n}\n\n/*************************************************************************\n// pack\n**************************************************************************/\n\ntribool PackW64PeArm64EC::canPack() {\n    if (!readFileHeader())\n        return false;\n    checkMachine(ih.cpu);\n    if (ih.cpu != IMAGE_FILE_MACHINE_ARM64EC)\n        return false;\n    throwCantPack(\"win64/arm64ec is not yet implemented\");\n    return true;\n}\n\n/* vim:set ts=4 sw=4 et: */\n","size_bytes":3845},"src/p_wcle.cpp":{"content":"/* p_wcle.cpp --\n\n   This file is part of the Resize executable compressor.\n\n   Copyright (C) 2025 WHO-AM-I-404\n   Based on UPX - Ultimate Packer for eXecutables\n   Copyright (C) 1996-2025 Markus Franz Xaver Johannes Oberhumer\n   Copyright (C) 1996-2025 Laszlo Molnar\n   All Rights Reserved.\n\n   Resize and the UCL library are free software; you can redistribute them\n   and/or modify them under the terms of the GNU General Public License as\n   published by the Free Software Foundation; either version 2 of\n   the License, or (at your option) any later version.\n\n   This program is distributed in the hope that it will be useful,\n   but WITHOUT ANY WARRANTY; without even the implied warranty of\n   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n   GNU General Public License for more details.\n\n   You should have received a copy of the GNU General Public License\n   along with this program; see the file COPYING.\n   If not, write to the Free Software Foundation, Inc.,\n   59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.\n\n   WHO-AM-I-404 <who-am-i-404@proton.me>\n   Based on original work by:\n   Markus F.X.J. Oberhumer <markus@oberhumer.com>\n   Laszlo Molnar <ezerotven+github@gmail.com>\n */\n\n#include \"conf.h\"\n#include \"file.h\"\n#include \"filter.h\"\n#include \"packer.h\"\n#include \"lefile.h\"\n#include \"p_wcle.h\"\n#include \"linker.h\"\n\nstatic const CLANG_FORMAT_DUMMY_STATEMENT\n#include \"stub/i386-dos32.watcom.le.h\"\n\n#define LEOF_READ    (1 << 0)\n#define LEOF_WRITE   (1 << 1)\n#define LEOF_EXEC    (1 << 2)\n#define LEOF_PRELOAD (1 << 6)\n#define LEOF_HUGE32  (1 << 13)\n\n#define IOT(x, y) iobject_table[x].y\n#define OOT(x, y) oobject_table[x].y\n\n#define LE_STUB_EDI (1)\n\n#ifdef TESTING\n#define dputc(x, y)                                                                                \\\n    do {                                                                                           \\\n        if (opt->debug.debug_level)                                                                \\\n            putc(x, y);                                                                            \\\n    } while (0)\n#define Opt_debug opt->debug.debug_level\n#else\n#define dputc(x, y) ((void) 0)\n#define Opt_debug   0\n#endif\n\n#define my_base_address reserved\n#define objects         ih.object_table_entries\n#define pages           ih.memory_pages\n#define mps             ih.memory_page_size\n#define opages          oh.memory_pages\n\n/*************************************************************************\n//\n**************************************************************************/\n\nconst int *PackWcle::getCompressionMethods(int method, int level) const {\n    return Packer::getDefaultCompressionMethods_le32(method, level);\n}\n\nconst int *PackWcle::getFilters() const {\n    static const int filters[] = {0x26, 0x24,           0x49, 0x46, 0x16, 0x13,  0x14,\n                                  0x11, FT_ULTRA_BRUTE, 0x25, 0x15, 0x12, FT_END};\n    return filters;\n}\n\nLinker *PackWcle::newLinker() const { return new ElfLinkerX86; }\n\nvoid PackWcle::buildLoader(const Filter *ft) {\n    // prepare loader\n    initLoader(stub_i386_dos32_watcom_le, sizeof(stub_i386_dos32_watcom_le));\n    addLoader(\"IDENTSTR,WCLEMAIN\", ph.first_offset_found == 1 ? \"WCLEMAIN02\" : \"\",\n              \"WCLEMAIN03,UPX1HEAD,WCLECUTP\");\n\n    // fake alignment for the start of the decompressor\n    linker->defineSymbol(\"WCLECUTP\", 0x1000);\n\n    addLoader(getDecompressorSections(), \"WCLEMAI2\");\n    if (ft->id) {\n        assert(ft->calls > 0);\n        addLoader(ft->addvalue ? \"WCCTTPOS\" : \"WCCTTNUL\");\n        addFilter32(ft->id);\n    }\n#if 1\n    // FIXME: if (has_relocation)\n    { addLoader(\"WCRELOC1,RELOC320\", big_relocs ? \"REL32BIG\" : \"\", \"RELOC32J\"); }\n#endif\n    addLoader(has_extra_code ? \"WCRELSEL\" : \"\", \"WCLEMAI4\");\n}\n\n/*************************************************************************\n// util\n**************************************************************************/\n\nvoid PackWcle::handleStub(OutputFile *fo) {\n    if (fo && !opt->watcom_le.le)\n        Packer::handleStub(fi, fo, le_offset);\n}\n\ntribool PackWcle::canPack() {\n    if (!LeFile::readFileHeader())\n        return false;\n    return true;\n}\n\n/*************************************************************************\n//\n**************************************************************************/\n\n// IDEA: as all the entries go into object #1, I could create bundles with 255\n// elements (of course I still have to handle empty bundles)\n\nvoid PackWcle::encodeEntryTable() {\n    unsigned count, object, n;\n    byte *p = ientries;\n    n = 0;\n    while (*p) {\n        count = *p;\n        n += count;\n        if (p[1] == 0) // unused bundle\n            p += 2;\n        else if (p[1] == 3) // 32-bit bundle\n        {\n            object = get_le16(p + 2) - 1;\n            set_le16(p + 2, 1);\n            p += 4;\n            for (; count; count--, p += 5)\n                set_le32(p + 1, IOT(object, my_base_address) + get_le32(p + 1));\n        } else\n            throwCantPack(\"unsupported bundle type in entry table\");\n    }\n\n    // if (Opt_debug) printf(\"%d entries encoded.\\n\",n);\n    UNUSED(n);\n\n    soentries = ptr_udiff_bytes(p, ientries) + 1;\n    oentries = ientries;\n    ientries = nullptr;\n}\n\nvoid PackWcle::readObjectTable() {\n    LeFile::readObjectTable();\n\n    // temporary copy of the object descriptors\n    if (!objects) // late detection, but protect against .alloc(0)\n        throwCantPack(\"no objects\");\n    iobject_desc.alloc(objects * sizeof(*iobject_table));\n    memcpy(iobject_desc, iobject_table, objects * sizeof(*iobject_table));\n\n    unsigned ic, jc, virtual_size;\n\n    for (ic = jc = virtual_size = 0; ic < objects; ic++) {\n        jc += IOT(ic, npages);\n        IOT(ic, my_base_address) = virtual_size;\n        virtual_size += (IOT(ic, virtual_size) + mps - 1) & ~(mps - 1);\n    }\n    if (pages != jc)\n        throwCantPack(\"bad page number\");\n}\n\nvoid PackWcle::encodeObjectTable() {\n    unsigned ic, jc;\n\n    soobject_table = 2;\n    oobject_table = New(le_object_table_entry_t, soobject_table);\n    memset(oobject_table, 0, mem_size(sizeof(*oobject_table), soobject_table));\n\n    // object #1:\n    OOT(0, base_address) = IOT(0, base_address);\n\n    ic = IOT(objects - 1, my_base_address) + IOT(objects - 1, virtual_size);\n    jc = mem_size(mps, pages, sofixups, 1024);\n    if (ic < jc)\n        ic = jc;\n\n    unsigned csection = (ic + ph.overlap_overhead + mps - 1) & ~(mps - 1);\n\n    OOT(0, virtual_size) = csection + mps;\n    OOT(0, flags) = LEOF_READ | LEOF_EXEC | LEOF_HUGE32 | LEOF_PRELOAD;\n    OOT(0, pagemap_index) = 1;\n    OOT(0, npages) = opages;\n\n    // object #2: stack\n    OOT(1, base_address) = (OOT(0, base_address) + OOT(0, virtual_size) + mps - 1) & ~(mps - 1);\n    OOT(1, virtual_size) = mps + getDecompressorWrkmemSize();\n    OOT(1, flags) = LEOF_READ | LEOF_HUGE32 | LEOF_WRITE;\n    OOT(1, pagemap_index) = 1;\n\n    oh.init_cs_object = 1;\n    oh.init_eip_offset = neweip;\n    oh.init_ss_object = 2;\n    oh.init_esp_offset = OOT(1, virtual_size);\n    oh.automatic_data_object = 2;\n}\n\nvoid PackWcle::encodePageMap() {\n    opm_entries = New(le_pagemap_entry_t, sopm_entries = opages);\n    for (unsigned ic = 0; ic < sopm_entries; ic++) {\n        opm_entries[ic].l = (byte) (ic + 1);\n        opm_entries[ic].m = (byte) ((ic + 1) >> 8);\n        opm_entries[ic].h = 0;\n        opm_entries[ic].type = 0;\n    }\n}\n\nvoid PackWcle::encodeFixupPageTable() {\n    unsigned ic;\n    ofpage_table = New(unsigned, sofpage_table = 1 + opages);\n    for (ofpage_table[0] = ic = 0; ic < opages; ic++)\n        set_le32(ofpage_table + ic + 1, sofixups - FIXUP_EXTRA);\n}\n\nvoid PackWcle::encodeFixups() {\n    sofixups = 1 * 7 + FIXUP_EXTRA;\n    ofixups = New(byte, sofixups);\n    memset(ofixups, 0, sofixups);\n    ofixups[0] = 7;\n    set_le16(ofixups + 2, (LE_STUB_EDI + neweip) & (mps - 1));\n    ofixups[4] = 1;\n}\n\nvoid PackWcle::preprocessFixups() {\n    big_relocs = 0;\n\n    unsigned ic, jc;\n\n    Array(unsigned, counts, objects + 2);\n    countFixups(counts);\n\n    for (ic = jc = 0; ic < objects; ic++)\n        jc += counts[ic];\n\n    if (jc == 0) {\n        // FIXME: implement this\n        throwCantPack(\"files without relocations are not supported\");\n    }\n\n    MemBuffer mb_relocs(jc);\n    ByteArray(srf, counts[objects + 0] + 1);\n    ByteArray(slf, counts[objects + 1] + 1);\n\n    SPAN_S_VAR(byte, relocs, mb_relocs);\n    SPAN_S_VAR(byte, selector_fixups, srf_membuf);\n    SPAN_S_VAR(byte, selfrel_fixups, slf_membuf);\n    unsigned relocnum = 0;\n\n    byte *fix = ifixups;\n    for (ic = jc = 0; ic < pages; ic++) {\n        while (ptr_udiff_bytes(fix, ifixups) < get_le32(ifpage_table + (ic + 1))) {\n            const int fixp2 = get_le16_signed(fix + 2);\n            unsigned value;\n\n            switch (*fix) {\n            case 2: // selector fixup\n                if (fixp2 < 0) {\n                    // cross page selector fixup\n                    dputc('S', stdout);\n                    fix += 5;\n                    break;\n                }\n                dputc('s', stdout);\n                memcpy(selector_fixups, \"\\x8C\\xCB\\x66\\x89\\x9D\",\n                       5); // mov bx, cs ; mov [xxx+ebp], bx\n                if (IOT(fix[4] - 1, flags) & LEOF_WRITE)\n                    selector_fixups[1] = 0xDB; // ds\n                set_le32(selector_fixups + 5, jc + fixp2);\n                selector_fixups += 9;\n                fix += 5;\n                break;\n            case 5: // 16-bit offset\n                if ((unsigned) fixp2 < 4096 && IOT(fix[4] - 1, my_base_address) == jc)\n                    dputc('6', stdout);\n                else\n                    throwCantPack(\"unsupported 16-bit offset relocation\");\n                fix += (fix[1] & 0x10) ? 9 : 7;\n                break;\n            case 6: // 16:32 pointer\n                if (fixp2 < 0) {\n                    // cross page pointer fixup\n                    dputc('P', stdout);\n                    fix += (fix[1] & 0x10) ? 9 : 7;\n                    break;\n                }\n                dputc('p', stdout);\n                memcpy(iimage + jc + fixp2, fix + 5, (fix[1] & 0x10) ? 4 : 2);\n                set_le32(relocs + 4 * relocnum++, jc + fixp2);\n                set_le32(iimage + jc + fixp2,\n                         get_le32(iimage + jc + fixp2) + IOT(fix[4] - 1, my_base_address));\n\n                memcpy(selector_fixups, \"\\x8C\\xCA\\x66\\x89\\x95\", 5);\n                if (IOT(fix[4] - 1, flags) & LEOF_WRITE)\n                    selector_fixups[1] = 0xDA; // ds\n                set_le32(selector_fixups + 5, jc + fixp2 + 4);\n                selector_fixups += 9;\n                fix += (fix[1] & 0x10) ? 9 : 7;\n                break;\n            case 7: // 32-bit offset\n                if (fixp2 < 0) {\n                    fix += (fix[1] & 0x10) ? 9 : 7;\n                    break;\n                }\n                // if (memcmp(iimage+jc+fixp2,fix+5,(fix[1] & 0x10) ? 4 : 2))\n                //    throwCantPack(\"illegal fixup offset\");\n\n                // work around a pmwunlite bug: remove duplicated fixups\n                // FIXME: fix the other cases too\n                if (relocnum == 0 || get_le32(relocs + 4 * relocnum - 4) != jc + fixp2) {\n                    set_le32(relocs + 4 * relocnum++, jc + fixp2);\n                    set_le32(iimage + jc + fixp2,\n                             get_le32(iimage + jc + fixp2) + IOT(fix[4] - 1, my_base_address));\n                }\n                fix += (fix[1] & 0x10) ? 9 : 7;\n                break;\n            case 8: // 32-bit self relative fixup\n                if (fixp2 < 0) {\n                    // cross page self relative fixup\n                    dputc('R', stdout);\n                    fix += (fix[1] & 0x10) ? 9 : 7;\n                    break;\n                }\n                value = get_le32(fix + 5);\n                if (fix[1] == 0)\n                    value &= 0xffff;\n                set_le32(iimage + jc + fixp2,\n                         (value + IOT(fix[4] - 1, my_base_address)) - jc - fixp2 - 4);\n                set_le32(selfrel_fixups, jc + fixp2);\n                selfrel_fixups += 4;\n                dputc('r', stdout);\n                fix += (fix[1] & 0x10) ? 9 : 7;\n                break;\n            default:\n                throwCantPack(\"unsupported fixup record\");\n            }\n        }\n        jc += mps;\n    }\n\n    // resize ifixups if it's too small\n    if (sofixups < 4 * relocnum + 8192) {\n        delete[] ifixups;\n        sofixups = 4 * relocnum + 8192;\n        ifixups = New(byte, sofixups);\n    }\n    SPAN_S_VAR(byte, orelocs, ifixups, sofixups);\n    fix =\n        ifixups + optimizeReloc(relocnum, relocs, orelocs, iimage, soimage, 32, true, &big_relocs);\n    has_extra_code = ptr_udiff_bytes(selector_fixups, srf) != 0;\n    // FIXME: this could be removed if has_extra_code = false\n    // but then we'll need a flag\n    *selector_fixups++ = 0xC3;                               // ret\n    memcpy(fix, srf, ptr_udiff_bytes(selector_fixups, srf)); // copy selector fixup code\n    fix += ptr_udiff_bytes(selector_fixups, srf);\n\n    memcpy(fix, slf, ptr_udiff_bytes(selfrel_fixups, slf)); // copy self-relative fixup positions\n    fix += ptr_udiff_bytes(selfrel_fixups, slf);\n    set_le32(fix, 0xFFFFFFFFUL);\n    fix += 4;\n\n    sofixups = ptr_udiff_bytes(fix, ifixups);\n}\n\n#define RESERVED 0x1000\nvoid PackWcle::encodeImage(Filter *ft) {\n    // concatenate image & preprocessed fixups\n    unsigned isize = soimage + sofixups;\n    ibuf.alloc(isize);\n    memcpy(ibuf, iimage, soimage);\n    memcpy(ibuf + soimage, ifixups, sofixups);\n\n    delete[] ifixups;\n    ifixups = nullptr;\n\n    mb_oimage.allocForCompression(isize, RESERVED + 512);\n    oimage = mb_oimage; // => now a SPAN_S\n    // prepare packheader\n    ph.u_len = isize;\n    // prepare filter [already done]\n    // compress\n    upx_compress_config_t cconf;\n    cconf.reset();\n    cconf.conf_lzma.max_num_probs = 1846 + (768 << 4); // ushort: ~28 KiB stack\n    compressWithFilters(ibuf, isize, raw_bytes(oimage + RESERVED, mb_oimage.getSize() - RESERVED),\n                        ibuf + ft->addvalue, ft->buf_len, nullptr, 0, ft, 512, &cconf, 0);\n\n    ibuf.dealloc();\n    soimage = ph.c_len;\n    while (soimage & 3)\n        oimage[RESERVED + soimage++] = 0;\n}\n\nvoid PackWcle::pack(OutputFile *fo) {\n    handleStub(fo);\n\n    if (ih.byte_order || ih.word_order || ih.exe_format_level || ih.cpu_type < 2 ||\n        ih.cpu_type > 5 || ih.target_os != 1 || ih.module_type != 0x200 ||\n        ih.object_iterate_data_map_offset || ih.resource_entries || ih.module_directives_entries ||\n        ih.imported_modules_count || ih.object_table_entries > 255)\n        throwCantPack(\"watcom/le: unexpected value in header\");\n\n    readObjectTable();\n    readPageMap();\n    readResidentNames();\n    readEntryTable();\n    readFixupPageTable();\n    readFixups();\n    readImage();\n    readNonResidentNames();\n\n    //    if (find_le32(iimage,20,get_le32(\"UPX \")) >= 0)\n    if (find_le32(raw_bytes(iimage, soimage), UPX_MIN(soimage, 256u), UPX_MAGIC_LE32) >= 0)\n        throwAlreadyPacked();\n\n    if (ih.init_ss_object != objects)\n        throwCantPack(\"the stack is not in the last object\");\n\n    preprocessFixups();\n\n    const unsigned text_size = mem_size(mps, IOT(ih.init_cs_object - 1, npages));\n    const unsigned text_vaddr = IOT(ih.init_cs_object - 1, my_base_address);\n\n    // attach some useful data at the end of preprocessed fixups\n    ifixups[sofixups++] = (byte) (ih.automatic_data_object & 0xff);\n    unsigned ic = objects * sizeof(*iobject_table);\n    memcpy(ifixups + sofixups, iobject_desc, ic);\n    iobject_desc.dealloc();\n\n    sofixups += ic;\n    set_le32(ifixups + sofixups,\n             ih.init_esp_offset + IOT(ih.init_ss_object - 1, my_base_address)); // old stack pointer\n    set_le32(ifixups + sofixups + 4, ih.init_eip_offset + text_vaddr);          // real entry point\n    set_le32(ifixups + sofixups + 8,\n             mem_size(mps, pages)); // virtual address of unpacked relocations\n    ifixups[sofixups + 12] = (byte) (unsigned) objects;\n    sofixups += 13;\n\n    // prepare filter\n    Filter ft(ph.level);\n    ft.buf_len = text_size;\n    ft.addvalue = text_vaddr;\n    // compress\n    encodeImage(&ft);\n\n    const unsigned lsize = getLoaderSize();\n    neweip = getLoaderSection(\"WCLEMAIN\");\n    int e_len = getLoaderSectionStart(\"WCLECUTP\");\n    const unsigned d_len = lsize - e_len;\n    assert(e_len > 0 && e_len < RESERVED);\n\n    memmove(oimage + e_len, oimage + RESERVED, soimage);\n    soimage += lsize;\n\n    opages = (soimage + mps - 1) / mps;\n    oh.bytes_on_last_page = soimage % mps;\n\n    encodeObjectTable();\n    encodeFixups();\n    encodeFixupPageTable();\n    encodePageMap();\n    encodeEntryTable();\n\n    encodeResidentNames();\n    encodeNonResidentNames();\n\n    // patch loader\n    ic = (OOT(0, virtual_size) - d_len) & ~15;\n    assert(ic > ((ph.u_len + ph.overlap_overhead + 31) & ~15));\n\n    linker->defineSymbol(\"WCLECUTP\", ic);\n\n    linker->defineSymbol(\"original_entry\", ih.init_eip_offset + text_vaddr);\n    linker->defineSymbol(\"original_stack\",\n                         ih.init_esp_offset + IOT(ih.init_ss_object - 1, my_base_address));\n    linker->defineSymbol(\"start_of_relocs\", mem_size(mps, pages));\n    defineDecompressorSymbols();\n    defineFilterSymbols(&ft);\n    linker->defineSymbol(\"filter_buffer_start\", text_vaddr);\n\n    unsigned jpos = (((ph.c_len + 3) & ~3) + d_len + 3) / 4;\n    linker->defineSymbol(\"words_to_copy\", jpos);\n    linker->defineSymbol(\"copy_dest\", ((ic + d_len + 3) & ~3) - 4);\n    linker->defineSymbol(\"copy_source\", e_len + jpos * 4 - 4);\n\n    relocateLoader();\n\n    MemBuffer loader(lsize);\n    memcpy(loader, getLoader(), lsize);\n    patchPackHeader(loader, lsize);\n\n    memcpy(oimage, loader, e_len);\n    memcpy(oimage + soimage - d_len, loader + e_len, d_len);\n\n    writeFile(fo, opt->watcom_le.le);\n\n    // verify\n    verifyOverlappingDecompression(mb_oimage + e_len, mb_oimage.getSize() - e_len);\n\n    // copy the overlay\n    const unsigned overlaystart = ih.data_pages_offset + exe_offset + getImageSize();\n    const unsigned overlay = file_size - overlaystart - ih.non_resident_name_table_length;\n    checkOverlay(overlay);\n    copyOverlay(fo, overlay, mb_oimage);\n\n    // finally check the compression ratio\n    if (!checkFinalCompressionRatio(fo))\n        throwNotCompressible();\n}\n\n/*************************************************************************\n//\n**************************************************************************/\n\nvoid PackWcle::decodeFixups() {\n    mb_iimage.dealloc();\n    iimage = nullptr;\n\n    SPAN_S_VAR(const byte, p, oimage + soimage);\n    MemBuffer mb_relocs;\n    const unsigned fixupn = unoptimizeReloc(p, mb_relocs, oimage, soimage, 32, true);\n\n    MemBuffer wrkmem(8 * fixupn + 8);\n    unsigned ic, jc, o, r;\n    for (ic = 0; ic < fixupn; ic++) {\n        jc = get_le32(mb_relocs + 4 * ic);\n        set_le32(wrkmem + ic * 8, jc);\n        o = soobject_table;\n        r = get_le32(oimage + jc);\n        virt2rela(oobject_table, &o, &r);\n        set_le32(wrkmem + ic * 8 + 4, OOT(o - 1, my_base_address));\n        set_le32(oimage + jc, r);\n    }\n    set_le32(wrkmem + ic * 8, 0xFFFFFFFF); // end of 32-bit offset fixups\n    mb_relocs.dealloc();                   // done\n\n    // selector fixups then self-relative fixups\n    SPAN_S_VAR(const byte, selector_fixups, p);\n\n    // Find selfrel_fixups by skipping over selector_fixups.\n    SPAN_S_VAR(const byte, q, selector_fixups);\n    // The code is a subroutine that ends in RET (0xC3).\n    while (*q != 0xC3) {\n        // Defend against tampered selector_fixups; see PackWcle::preprocessFixups().\n        // selector_fixups[] is x386 code with 9-byte blocks of 2 instructions each:\n        // \"\\x8C\\xCB\\x66\\x89\\x9D\"  // mov bx, cs ; mov [xxx+ebp], bx\n        // \"\\x8C\\xCA\\x66\\x89\\x95\"\n        // and where byte [+1] also can be '\\xDA' or '\\xDB'.\n        if (0x8C != q[0] || 0x66 != q[2] || 0x89 != q[3]) { // Unexpected; tampering?\n            // Try to recover by looking for the RET.\n            const byte *q2 = (const byte *) memchr(q, 0xC3, 9);\n            if (q2) { // Assume recovery\n                q = q2;\n                break;\n            }\n        }\n        // Guard against run-away.\n        static byte const blank[9] = {0};\n        // catastrophic worst case or no-good early warning\n        if (ptr_diff_bytes(oimage + ph.u_len - sizeof(blank), raw_bytes(q, 0)) < 0 ||\n            !memcmp(blank, q, sizeof(blank))) {\n            char msg[50];\n            snprintf(msg, sizeof(msg), \"bad selector_fixups %d\",\n                     ptr_diff_bytes(q, selector_fixups));\n            throwCantPack(msg);\n        }\n        q += 9;\n    }\n    unsigned selectlen = ptr_udiff_bytes(q, selector_fixups) / 9;\n    SPAN_S_VAR(const byte, selfrel_fixups, q + 1); // Skip the 0xC3\n\n    const unsigned fbytes = fixupn * 9 + 1000 + selectlen * 5;\n    ofixups = New(byte, fbytes);\n    SPAN_S_VAR(byte, fp, ofixups, fbytes, ofixups);\n\n    for (ic = 1, jc = 0; ic <= opages; ic++) {\n        // self relative fixups\n        while ((r = get_le32(selfrel_fixups)) / mps == ic - 1) {\n            fp[0] = 8;\n            set_le16(fp + 2, r & (mps - 1));\n            o = 4 + get_le32(oimage + r);\n            set_le32(oimage + r, 0);\n            r += o;\n            o = soobject_table;\n            virt2rela(oobject_table, &o, &r);\n            fp[4] = (byte) o;\n            set_le32(fp + 5, r);\n            fp[1] = (byte) (r > 0xFFFF ? 0x10 : 0);\n            fp += fp[1] ? 9 : 7;\n            selfrel_fixups += 4;\n            dputc('r', stdout);\n        }\n        // selector fixups\n        while (selectlen && (r = get_le32(selector_fixups + 5)) / mps == ic - 1) {\n            fp[0] = 2;\n            fp[1] = 0;\n            set_le16(fp + 2, r & (mps - 1));\n            unsigned x = selector_fixups[1] > 0xD0 ? oh.init_ss_object : oh.init_cs_object;\n            fp[4] = (byte) x;\n            fp += 5;\n            selector_fixups += 9;\n            selectlen--;\n            dputc('s', stdout);\n        }\n        // 32 bit offset fixups\n        while (get_le32(wrkmem + 4 * jc) < mem_size(mps, ic)) {\n            if (jc > 1 &&\n                ((get_le32(wrkmem + 4 * (jc - 2)) + 3) & (mps - 1)) < 3) // cross page fixup?\n            {\n                r = get_le32(oimage + get_le32(wrkmem + 4 * (jc - 2)));\n                fp[0] = 7;\n                fp[1] = (byte) (r > 0xFFFF ? 0x10 : 0);\n                set_le16(fp + 2, get_le32(wrkmem + 4 * (jc - 2)) | ~3);\n                set_le32(fp + 5, r);\n                o = soobject_table;\n                r = get_le32(wrkmem + 4 * (jc - 1));\n                virt2rela(oobject_table, &o, &r);\n                fp[4] = (byte) o;\n                fp += fp[1] ? 9 : 7;\n                dputc('0', stdout);\n            }\n            o = soobject_table;\n            r = get_le32(wrkmem + 4 * (jc + 1));\n            virt2rela(oobject_table, &o, &r);\n            r = get_le32(oimage + get_le32(wrkmem + 4 * jc));\n            fp[0] = 7;\n            fp[1] = (byte) (r > 0xFFFF ? 0x10 : 0);\n            set_le16(fp + 2, get_le32(wrkmem + 4 * jc) & (mps - 1));\n            fp[4] = (byte) o;\n            set_le32(fp + 5, r);\n            fp += fp[1] ? 9 : 7;\n            jc += 2;\n        }\n        set_le32(ofpage_table + ic, ptr_udiff_bytes(fp, ofixups));\n    }\n    for (ic = 0; ic < FIXUP_EXTRA; ic++)\n        *fp++ = 0;\n    sofixups = ptr_udiff_bytes(fp, ofixups);\n}\n\nvoid PackWcle::decodeFixupPageTable() {\n    ofpage_table = New(unsigned, sofpage_table = 1 + opages);\n    set_le32(ofpage_table, 0);\n    // the rest of ofpage_table is filled by decodeFixups()\n}\n\nvoid PackWcle::decodeObjectTable() {\n    soobject_table = oimage[ph.u_len - 1];\n    oobject_table = New(le_object_table_entry_t, soobject_table);\n    unsigned jc, ic = soobject_table * sizeof(*oobject_table);\n\n    const unsigned extradata = ph.version == 10 ? 17 : 13;\n    memcpy(oobject_table, oimage + ph.u_len - extradata - ic, ic);\n    if (ph.version >= 12)\n        oh.automatic_data_object = oimage[ph.u_len - ic - 14];\n\n    for (ic = jc = 0; ic < soobject_table; ic++) {\n        OOT(ic, my_base_address) = jc;\n        jc += (OOT(ic, virtual_size) + mps - 1) & ~(mps - 1);\n    }\n\n    // restore original cs:eip & ss:esp\n    ic = soobject_table;\n    jc = get_le32(oimage + ph.u_len - (ph.version < 11 ? 13 : 9));\n    virt2rela(oobject_table, &ic, &jc);\n    oh.init_cs_object = ic;\n    oh.init_eip_offset = jc;\n\n    ic = soobject_table;\n    if (ph.version < 10)\n        jc = ih.init_esp_offset;\n    else\n        jc = get_le32(oimage + ph.u_len - (ph.version == 10 ? 17 : 13));\n    virt2rela(oobject_table, &ic, &jc);\n    oh.init_ss_object = ic;\n    oh.init_esp_offset = jc;\n}\n\nvoid PackWcle::decodeImage() {\n    mb_oimage.allocForDecompression(ph.u_len);\n    oimage = mb_oimage; // => now a SPAN_S\n\n    decompress(iimage + ph.buf_offset + ph.getPackHeaderSize(), oimage);\n    soimage = get_le32(oimage + ph.u_len - 5);\n    opages = soimage / mps;\n    oh.memory_page_size = mps;\n}\n\nvoid PackWcle::decodeEntryTable() {\n    unsigned count, object, n, r;\n    SPAN_S_VAR(byte, p, ientries, soentries);\n    n = 0;\n    while (*p) {\n        count = *p;\n        n += count;\n        if (p[1] == 0) // unused bundle\n            p += 2;\n        else if (p[1] == 3) // 32-bit offset bundle\n        {\n            object = get_le16(p + 2);\n            if (object != 1)\n                throwCantUnpack(\"corrupted entry found\");\n            object = soobject_table;\n            r = get_le32(p + 5);\n            virt2rela(oobject_table, &object, &r);\n            set_le16(p + 2, object--);\n            p += 4;\n            for (; count; count--, p += 5)\n                set_le32(p + 1, get_le32(p + 1) - OOT(object, my_base_address));\n        } else\n            throwCantUnpack(\"unsupported bundle type in entry table\");\n    }\n\n    // if (Opt_debug) printf(\"\\n%d entries decoded.\\n\",n);\n    UNUSED(n);\n\n    soentries = ptr_udiff_bytes(p, ientries) + 1;\n    oentries = ientries;\n    ientries = nullptr;\n}\n\ntribool PackWcle::canUnpack() {\n    if (!LeFile::readFileHeader())\n        return false;\n    fi->seek(exe_offset + ih.data_pages_offset, SEEK_SET);\n    // FIXME: 1024 could be too large for some files\n    // int len = 1024;\n    int len = UPX_MIN(getImageSize(), 256u);\n    if (len == 0)\n        return false;\n    return readPackHeader(len) ? 1 : -1;\n}\n\n/*static*/\nvoid PackWcle::virt2rela(const le_object_table_entry_t *entr, unsigned *objn, unsigned *addr) {\n    for (; *objn > 1; objn[0]--) {\n        if (entr[*objn - 1].my_base_address > *addr)\n            continue;\n        *addr -= entr[*objn - 1].my_base_address;\n        break;\n    }\n}\n\n/*************************************************************************\n//\n**************************************************************************/\n\nvoid PackWcle::unpack(OutputFile *fo) {\n    handleStub(fo);\n\n    readObjectTable();\n    iobject_desc.dealloc();\n    readPageMap();\n    readResidentNames();\n    readEntryTable();\n    readFixupPageTable();\n    readFixups();\n    readImage();\n    readNonResidentNames();\n\n    decodeImage();\n    decodeObjectTable();\n\n    // unfilter\n    if (ph.filter) {\n        const unsigned text_size = mem_size(mps, OOT(oh.init_cs_object - 1, npages));\n        const unsigned text_vaddr = OOT(oh.init_cs_object - 1, my_base_address);\n\n        Filter ft(ph.level);\n        ft.init(ph.filter, text_vaddr);\n        ft.cto = (byte) ph.filter_cto;\n        if (ph.version < 11)\n            ft.cto = (byte) (get_le32(oimage + ph.u_len - 9) >> 24);\n        ft.unfilter(oimage + text_vaddr, text_size);\n    }\n\n    decodeFixupPageTable();\n    decodeFixups();\n    decodeEntryTable();\n    decodePageMap();\n    decodeResidentNames();\n    decodeNonResidentNames();\n\n    for (unsigned ic = 0; ic < soobject_table; ic++)\n        OOT(ic, my_base_address) = 0;\n\n    while (oimage[soimage - 1] == 0)\n        soimage--;\n    oh.bytes_on_last_page = soimage % mps;\n\n    // write decompressed file\n    if (fo)\n        writeFile(fo, opt->watcom_le.le);\n\n    // copy the overlay\n    const unsigned overlaystart = ih.data_pages_offset + exe_offset + getImageSize();\n    const unsigned overlay = file_size - overlaystart - ih.non_resident_name_table_length;\n    checkOverlay(overlay);\n    copyOverlay(fo, overlay, mb_oimage);\n}\n\n/* vim:set ts=4 sw=4 et: */\n","size_bytes":28345},"src/p_wince_arm.cpp":{"content":"/* p_wince_arm.cpp --\n\n   This file is part of the Resize executable compressor.\n\n   Copyright (C) 2025 WHO-AM-I-404\n   Based on UPX - Ultimate Packer for eXecutables\n   Copyright (C) 1996-2025 Markus Franz Xaver Johannes Oberhumer\n   Copyright (C) 1996-2025 Laszlo Molnar\n   All Rights Reserved.\n\n   Resize and the UCL library are free software; you can redistribute them\n   and/or modify them under the terms of the GNU General Public License as\n   published by the Free Software Foundation; either version 2 of\n   the License, or (at your option) any later version.\n\n   This program is distributed in the hope that it will be useful,\n   but WITHOUT ANY WARRANTY; without even the implied warranty of\n   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n   GNU General Public License for more details.\n\n   You should have received a copy of the GNU General Public License\n   along with this program; see the file COPYING.\n   If not, write to the Free Software Foundation, Inc.,\n   59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.\n\n   WHO-AM-I-404 <who-am-i-404@proton.me>\n   Based on original work by:\n   Markus F.X.J. Oberhumer <markus@oberhumer.com>\n   Laszlo Molnar <ezerotven+github@gmail.com>\n */\n\n#include \"conf.h\"\n#include \"file.h\"\n#include \"filter.h\"\n#include \"packer.h\"\n#include \"pefile.h\"\n#include \"p_wince_arm.h\"\n#include \"linker.h\"\n\nstatic const CLANG_FORMAT_DUMMY_STATEMENT\n#include \"stub/arm.v4a-wince.pe.h\"\nstatic const CLANG_FORMAT_DUMMY_STATEMENT\n#include \"stub/arm.v4t-wince.pe.h\"\n\n/*************************************************************************\n//\n**************************************************************************/\n\nPackWinCeArm::PackWinCeArm(InputFile *f) : super(f) {}\n\nPackWinCeArm::~PackWinCeArm() noexcept {}\n\nLinker *PackWinCeArm::newLinker() const { return new ElfLinkerArmLE; }\n\nconst int *PackWinCeArm::getCompressionMethods(int method, int level) const {\n    static const int m_all[] = {M_NRV2B_8, M_NRV2E_8, M_LZMA, M_END};\n    static const int m_lzma[] = {M_LZMA, M_END};\n    static const int m_nrv2b[] = {M_NRV2B_8, M_END};\n    static const int m_nrv2e[] = {M_NRV2E_8, M_END};\n\n    if (!use_thumb_stub)\n        return getDefaultCompressionMethods_8(method, level);\n\n    if (method == M_ALL)\n        return m_all;\n    if (M_IS_LZMA(method))\n        return m_lzma;\n    if (M_IS_NRV2B(method))\n        return m_nrv2b;\n    if (M_IS_NRV2E(method))\n        return m_nrv2e;\n    return m_nrv2e;\n}\n\nconst int *PackWinCeArm::getFilters() const {\n    static const int filters[] = {0x50, FT_END};\n    return filters;\n}\n\n/*************************************************************************\n// import handling\n**************************************************************************/\n\nvoid PackWinCeArm::processImports2(unsigned myimport, unsigned iat_off) // pass 2\n{\n    PeFile::processImports2(myimport, iat_off);\n\n    // adjust import data\n    for (import_desc *im = (import_desc *) oimpdlls; im->dllname; im++) {\n        im->oft = im->iat;\n        bool is_coredll = strcasecmp(kernelDll(), oimpdlls + (im->dllname - myimport)) == 0;\n        im->iat = is_coredll ? iat_off : iat_off + 12;\n    }\n}\n\nvoid PackWinCeArm::addStubImports() {\n    // the order of procedure names below should match the\n    // assumptions of the assembly stubs\n    // WARNING! these names are sorted alphanumerically by the ImportLinker\n    addKernelImport(\"CacheSync\");\n    addKernelImport(\"GetProcAddressA\");\n    addKernelImport(\"LoadLibraryW\");\n}\n\nvoid PackWinCeArm::processTls(Interval *) // pass 1\n{\n    if ((sotls = ALIGN_UP(IDSIZE(PEDIR_TLS), 4u)) == 0)\n        return;\n\n    // never should happen on wince/arm\n    throwCantPack(\"Static TLS entries found. Send a report please.\");\n}\n\n/*************************************************************************\n// pack\n**************************************************************************/\n\ntribool PackWinCeArm::canPack() {\n    if (!readFileHeader())\n        return false;\n    checkMachine(ih.cpu);\n    if (ih.cpu != IMAGE_FILE_MACHINE_ARM && ih.cpu != IMAGE_FILE_MACHINE_THUMB)\n        return false;\n    use_thumb_stub |= ih.cpu == IMAGE_FILE_MACHINE_THUMB || (ih.entry & 1) == 1;\n    // HACK FIXME later: don't misuse opt->cpu_x86, need an extra option to force thumb stub\n    use_thumb_stub |= (opt->cpu_x86 == opt->CPU_8086);\n    return true;\n}\n\nvoid PackWinCeArm::buildLoader(const Filter *ft) {\n    const byte *loader = use_thumb_stub ? stub_arm_v4t_wince_pe : stub_arm_v4a_wince_pe;\n    unsigned size = use_thumb_stub ? sizeof(stub_arm_v4t_wince_pe) : sizeof(stub_arm_v4a_wince_pe);\n\n    // prepare loader\n    initLoader(loader, size);\n\n    if (isdll)\n        addLoader(\"DllStart\");\n    addLoader(\"ExeStart\");\n\n    if (ph.method == M_NRV2E_8)\n        addLoader(\"Call2E\");\n    else if (ph.method == M_NRV2B_8)\n        addLoader(\"Call2B\");\n    else if (ph.method == M_NRV2D_8)\n        addLoader(\"Call2D\");\n    else if (M_IS_LZMA(ph.method))\n        addLoader(\"+40C,CallLZMA\");\n\n    if (ft->id == 0x50)\n        addLoader(\"+40C,Unfilter_0x50\");\n\n    if (sorelocs)\n        addLoader(\"+40C,Relocs\");\n\n    addLoader(\"+40C,Imports\");\n    addLoader(\"ProcessEnd\");\n\n    if (ph.method == M_NRV2E_8)\n        addLoader(\".ucl_nrv2e_decompress_8\");\n    else if (ph.method == M_NRV2B_8)\n        addLoader(\".ucl_nrv2b_decompress_8\");\n    else if (ph.method == M_NRV2D_8)\n        addLoader(\".ucl_nrv2d_decompress_8\");\n    else if (M_IS_LZMA(ph.method))\n        addLoader(\"+40C,LZMA_DECODE,LZMA_DEC10\");\n\n    addLoader(\"IDENTSTR,UPX1HEAD\");\n}\n\nbool PackWinCeArm::needForceOption() const {\n    // return true if we need `--force` to pack this file\n    bool r = false;\n    r |= (ih.opthdrsize != 0xe0);\n    r |= ((ih.flags & IMAGE_FILE_EXECUTABLE_IMAGE) == 0);\n    r |= (ih.entry == 0 /*&& !isdll*/);\n    r |= (ih.ddirsentries != 16);\n    //// r |= (IDSIZE(PEDIR_EXCEPTION) != 0); // is this used on arm?\n    //// r |= (IDSIZE(PEDIR_COPYRIGHT) != 0);\n    return r;\n}\n\nvoid PackWinCeArm::callCompressWithFilters(Filter &ft, int filter_strategy, unsigned ih_codebase) {\n    // limit stack size needed for runtime decompression\n    upx_compress_config_t cconf;\n    cconf.reset();\n    cconf.conf_lzma.max_num_probs = 1846 + (768 << 4); // ushort: ~28 KiB stack\n    compressWithFilters(&ft, 2048, &cconf, filter_strategy, ih_codebase, rvamin, 0, nullptr, 0);\n}\n\nvoid PackWinCeArm::addNewRelocations(Reloc &rel, unsigned upxsection) {\n    static const char *const symbols_to_relocate[] = {\"ONAM\", \"BIMP\", \"BREL\", \"FIBE\",\n                                                      \"FIBS\", \"ENTR\", \"DST0\", \"SRC0\"};\n    for (unsigned s2r = 0; s2r < TABLESIZE(symbols_to_relocate); s2r++) {\n        unsigned off = linker->getSymbolOffset(symbols_to_relocate[s2r]);\n        if (off != 0xdeaddead)\n            rel.add_reloc(off + upxsection, IMAGE_REL_BASED_HIGHLOW);\n    }\n}\n\nunsigned PackWinCeArm::getProcessImportParam(unsigned upxsection) {\n    return linker->getSymbolOffset(\"IATT\") + upxsection;\n}\n\nvoid PackWinCeArm::defineSymbols(unsigned ncsection, unsigned, unsigned, unsigned ic,\n                                 unsigned s1addr) {\n    const unsigned onam = ncsection + soxrelocs + ih.imagebase;\n    linker->defineSymbol(\"start_of_dll_names\", onam);\n    linker->defineSymbol(\"start_of_imports\", ih.imagebase + rvamin + cimports);\n    linker->defineSymbol(\"start_of_relocs\", crelocs + rvamin + ih.imagebase);\n    linker->defineSymbol(\"filter_buffer_end\", ih.imagebase + ih.codebase + ih.codesize);\n    linker->defineSymbol(\"filter_buffer_start\", ih.imagebase + ih.codebase);\n    linker->defineSymbol(\"original_entry\", ih.entry + ih.imagebase);\n    linker->defineSymbol(\"uncompressed_length\", ph.u_len);\n    linker->defineSymbol(\"start_of_uncompressed\", ih.imagebase + rvamin);\n    linker->defineSymbol(\"compressed_length\", ph.c_len);\n    linker->defineSymbol(\"start_of_compressed\", ih.imagebase + s1addr + ic);\n    defineDecompressorSymbols();\n}\n\nvoid PackWinCeArm::setOhDataBase(const pe_section_t *osection) { oh.database = osection[2].vaddr; }\n\nvoid PackWinCeArm::setOhHeaderSize(const pe_section_t *osection) {\n    // SizeOfHeaders\n    oh.headersize = osection[1].rawdataptr;\n}\n\nvoid PackWinCeArm::pack(OutputFile *fo) {\n    super::pack0(fo, (1u << IMAGE_SUBSYSTEM_WINDOWS_CE_GUI), 0x10000, true);\n}\n\n/* vim:set ts=4 sw=4 et: */\n","size_bytes":8320},"src/packer.cpp":{"content":"/* packer.cpp --\n\n   This file is part of the Resize executable compressor.\n\n   Copyright (C) 2025 WHO-AM-I-404\n   Based on UPX - Ultimate Packer for eXecutables\n   Copyright (C) 1996-2025 Markus Franz Xaver Johannes Oberhumer\n   Copyright (C) 1996-2025 Laszlo Molnar\n   All Rights Reserved.\n\n   Resize and the UCL library are free software; you can redistribute them\n   and/or modify them under the terms of the GNU General Public License as\n   published by the Free Software Foundation; either version 2 of\n   the License, or (at your option) any later version.\n\n   This program is distributed in the hope that it will be useful,\n   but WITHOUT ANY WARRANTY; without even the implied warranty of\n   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n   GNU General Public License for more details.\n\n   You should have received a copy of the GNU General Public License\n   along with this program; see the file COPYING.\n   If not, write to the Free Software Foundation, Inc.,\n   59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.\n\n   WHO-AM-I-404 <who-am-i-404@proton.me>\n   Based on original work by:\n   Markus F.X.J. Oberhumer <markus@oberhumer.com>\n   Laszlo Molnar <ezerotven+github@gmail.com>\n */\n\n#include \"conf.h\"\n#include \"file.h\"\n#include \"packer.h\"\n#include \"filter.h\"\n#include \"linker.h\"\n#include \"ui.h\"\n\n/*************************************************************************\n//\n**************************************************************************/\n\nPackerBase::PackerBase(InputFile *f)\n    : fi(f), file_size(f != nullptr ? f->st_size() : 0), file_size_i32(file_size) {\n    ph.reset();\n    mem_size_assert(1, file_size_u); // limited by UPX_RSIZE_MAX\n    assert_noexcept(file_size_i32 == file_size);\n    assert_noexcept(file_size_u32 == file_size_u);\n}\n\nPacker::Packer(InputFile *f) : PackerBase(f) { uip = new UiPacker(this); }\n\nPacker::~Packer() noexcept {\n    upx::owner_delete(uip);\n    upx::owner_delete(linker);\n    assert_noexcept(linker == nullptr);\n}\n\n// for PackMaster\nvoid Packer::assertPacker() const {\n#if DEBUG\n    assert(getFormat() > 0);\n    assert(getFormat() < 255);\n    assert(getVersion() >= 11);\n    assert(getVersion() <= 14);\n    assert(strlen(getName()) <= 15);\n    // info: 36 is the limit for show_all_packers() in help.cpp, but 32 should be enough for now\n    assert(strlen(getFullName(nullptr)) <= 32);\n    assert(strlen(getFullName(opt)) <= 32);\n    if (bele == nullptr)\n        fprintf(stderr, \"%s\\n\", getName());\n    assert(bele != nullptr);\n    if (getFormat() != UPX_F_MACH_FAT) // macho/fat is multiarch\n    {\n        const N_BELE_RTP::AbstractPolicy *format_bele;\n        if (getFormat() < 128)\n            format_bele = &N_BELE_RTP::le_policy;\n        else\n            format_bele = &N_BELE_RTP::be_policy;\n        if (bele != format_bele)\n            fprintf(stderr, \"%s\\n\", getName());\n        assert(bele == format_bele);\n    }\n    Linker *l = newLinker();\n    assert(l != nullptr);\n    if (bele != l->bele)\n        fprintf(stderr, \"%s\\n\", getName());\n    assert(bele == l->bele);\n    delete l;\n#endif\n}\n\n/*************************************************************************\n// public entries called from class PackMaster\n**************************************************************************/\n\nvoid Packer::doPack(OutputFile *fo) {\n    uip->uiPackStart(fo);\n    pack(fo);\n    uip->uiPackEnd(fo);\n}\n\nvoid Packer::doUnpack(OutputFile *fo) {\n    uip->uiUnpackStart(fo);\n    unpack(fo);\n    uip->uiUnpackEnd(fo);\n}\n\nvoid Packer::doTest() {\n    uip->uiTestStart();\n    test();\n    uip->uiTestEnd();\n}\n\nvoid Packer::doList() {\n    uip->uiListStart();\n    list();\n    uip->uiListEnd();\n}\n\nvoid Packer::doFileInfo() {\n    uip->uiFileInfoStart();\n    fileInfo();\n    uip->uiFileInfoEnd();\n}\n\n/*************************************************************************\n// default actions\n**************************************************************************/\n\nvoid Packer::test() { unpack(nullptr); }\n\nvoid Packer::list() { uip->uiList(); }\n\nvoid Packer::fileInfo() {\n    // FIXME: subclasses should list their sections here\n    // We also should try to get a nice layout...\n}\n\nbool Packer::testUnpackVersion(int version) const {\n    if (version != ph_version && ph_version != -1)\n        throwCantUnpack(\"program has been modified; run a virus checker!\");\n    if (!canUnpackVersion(version))\n        throwCantUnpack(\"I am not compatible with older versions of UPX\");\n    return true;\n}\n\nbool Packer::testUnpackFormat(int format) const {\n    if (format != ph_format && ph_format != -1)\n        throwCantUnpack(\"program has been modified; run a virus checker!\");\n    return canUnpackFormat(format);\n}\n\n/*************************************************************************\n// compress - wrap call to low-level upx_compress()\n**************************************************************************/\n\nbool Packer::compress(SPAN_P(byte) i_ptr, unsigned i_len, SPAN_P(byte) o_ptr,\n                      const upx_compress_config_t *cconf_parm) {\n    ph.u_len = i_len;\n    ph.c_len = 0;\n    assert(ph.level >= 1);\n    assert(ph.level <= 10);\n\n    // Avoid too many progress bar updates. 64 is s->bar_len in ui.cpp.\n    unsigned step = (ph.u_len < 64 * 1024) ? 0 : ph.u_len / 64;\n\n    // save current checksums\n    ph.saved_u_adler = ph.u_adler;\n    ph.saved_c_adler = ph.c_adler;\n    // update checksum of uncompressed data\n    ph.u_adler = upx_adler32(raw_bytes(i_ptr, ph.u_len), ph.u_len, ph.u_adler);\n\n    // set compression parameters\n    upx_compress_config_t cconf;\n    cconf.reset();\n    if (cconf_parm)\n        cconf = *cconf_parm;\n    // cconf options\n    int method = ph_forced_method(ph.method);\n    if (M_IS_NRV2B(method) || M_IS_NRV2D(method) || M_IS_NRV2E(method)) {\n        if (opt->crp.crp_ucl.c_flags != -1)\n            cconf.conf_ucl.c_flags = opt->crp.crp_ucl.c_flags;\n        if (opt->crp.crp_ucl.p_level != -1)\n            cconf.conf_ucl.p_level = opt->crp.crp_ucl.p_level;\n        if (opt->crp.crp_ucl.h_level != -1)\n            cconf.conf_ucl.h_level = opt->crp.crp_ucl.h_level;\n        if (opt->crp.crp_ucl.max_offset != UINT_MAX &&\n            opt->crp.crp_ucl.max_offset < cconf.conf_ucl.max_offset)\n            cconf.conf_ucl.max_offset = opt->crp.crp_ucl.max_offset;\n        if (opt->crp.crp_ucl.max_match != UINT_MAX &&\n            opt->crp.crp_ucl.max_match < cconf.conf_ucl.max_match)\n            cconf.conf_ucl.max_match = opt->crp.crp_ucl.max_match;\n#if (WITH_NRV)\n        if ((ph.level >= 7 || (ph.level >= 4 && ph.u_len >= 512 * 1024)) && !opt->prefer_ucl)\n            step = 0;\n#endif\n    }\n    if (M_IS_LZMA(method)) {\n        upx::oassign(cconf.conf_lzma.pos_bits, opt->crp.crp_lzma.pos_bits);\n        upx::oassign(cconf.conf_lzma.lit_pos_bits, opt->crp.crp_lzma.lit_pos_bits);\n        upx::oassign(cconf.conf_lzma.lit_context_bits, opt->crp.crp_lzma.lit_context_bits);\n        upx::oassign(cconf.conf_lzma.dict_size, opt->crp.crp_lzma.dict_size);\n        upx::oassign(cconf.conf_lzma.num_fast_bytes, opt->crp.crp_lzma.num_fast_bytes);\n    }\n    if (M_IS_DEFLATE(method)) {\n        upx::oassign(cconf.conf_zlib.mem_level, opt->crp.crp_zlib.mem_level);\n        upx::oassign(cconf.conf_zlib.window_bits, opt->crp.crp_zlib.window_bits);\n        upx::oassign(cconf.conf_zlib.strategy, opt->crp.crp_zlib.strategy);\n    }\n    if (uip->ui_pass >= 0)\n        uip->ui_pass++;\n    uip->startCallback(ph.u_len, step, uip->ui_pass, uip->ui_total_passes);\n    uip->firstCallback();\n\n    // OutputFile::dump(\"data.raw\", in, ph.u_len);\n\n    // compress\n    int r = upx_compress(raw_bytes(i_ptr, ph.u_len), ph.u_len, raw_bytes(o_ptr, 0), &ph.c_len,\n                         uip->getCallback(), method, ph.level, &cconf, &ph.compress_result);\n\n    // uip->finalCallback(ph.u_len, ph.c_len);\n    uip->endCallback();\n\n    if (r == UPX_E_OUT_OF_MEMORY)\n        throwOutOfMemoryException();\n    if (r != UPX_E_OK)\n        throwInternalError(\"compression failed\");\n\n    if (M_IS_NRV2B(method) || M_IS_NRV2D(method) || M_IS_NRV2E(method)) {\n        const ucl_uint *res = ph.compress_result.result_ucl.result;\n        // ph.min_offset_found = res[0];\n        ph.max_offset_found = res[1];\n        // ph.min_match_found = res[2];\n        ph.max_match_found = res[3];\n        // ph.min_run_found = res[4];\n        ph.max_run_found = res[5];\n        ph.first_offset_found = res[6];\n        // ph.same_match_offsets_found = res[7];\n        if (cconf_parm) {\n            assert(cconf.conf_ucl.max_offset == 0 ||\n                   cconf.conf_ucl.max_offset >= ph.max_offset_found);\n            assert(cconf.conf_ucl.max_match == 0 || cconf.conf_ucl.max_match >= ph.max_match_found);\n        }\n    }\n\n    NO_printf(\"\\nPacker::compress: %d/%d: %7d -> %7d\\n\", method, ph.level, ph.u_len, ph.c_len);\n    if (!checkCompressionRatio(ph.u_len, ph.c_len))\n        return false;\n    // return in any case if not compressible\n    if (ph.c_len >= ph.u_len)\n        return false;\n\n    // update checksum of compressed data\n    ph.c_adler = upx_adler32(raw_bytes(o_ptr, ph.c_len), ph.c_len, ph.c_adler);\n    // Decompress and verify. Skip this when using the fastest level.\n    if (!ph_skipVerify(ph)) {\n        // decompress\n        unsigned new_len = ph.u_len;\n        r = upx_decompress(raw_bytes(o_ptr, ph.c_len), ph.c_len, raw_bytes(i_ptr, ph.u_len),\n                           &new_len, method, &ph.compress_result);\n        if (r == UPX_E_OUT_OF_MEMORY)\n            throwOutOfMemoryException();\n        // printf(\"%d %d: %d %d %d\\n\", method, r, ph.c_len, ph.u_len, new_len);\n        if (r != UPX_E_OK)\n            throwInternalError(\"decompression failed\");\n        if (new_len != ph.u_len)\n            throwInternalError(\"decompression failed (size error)\");\n\n        // verify decompression\n        if (ph.u_adler != upx_adler32(raw_bytes(i_ptr, ph.u_len), ph.u_len, ph.saved_u_adler))\n            throwInternalError(\"decompression failed (checksum error)\");\n    }\n    return true;\n}\n\nbool Packer::checkDefaultCompressionRatio(unsigned u_len, unsigned c_len) const {\n    assert((int) u_len > 0);\n    assert((int) c_len > 0);\n    if (c_len >= u_len)\n        return false;\n    unsigned gain = u_len - c_len;\n\n    if (gain < 512) // need at least 512 bytes gain\n        return false;\n#if 1\n    if (gain >= 4096) // ok if we have at least 4096 bytes gain\n        return true;\n#endif\n    if (gain >= u_len / 16) // ok if we have at least 6.25% gain\n        return true;\n    return false;\n}\n\nbool Packer::checkCompressionRatio(unsigned u_len, unsigned c_len) const {\n    return checkDefaultCompressionRatio(u_len, c_len);\n}\n\nbool Packer::checkFinalCompressionRatio(const OutputFile *fo) const {\n    const unsigned u_len = file_size;\n    const unsigned c_len = fo->getBytesWritten();\n    return checkDefaultCompressionRatio(u_len, c_len);\n}\n\n/*************************************************************************\n// decompress\n**************************************************************************/\n\nvoid Packer::decompress(SPAN_P(const byte) in, SPAN_P(byte) out, bool verify_checksum, Filter *ft) {\n    ph_decompress(ph, in, out, verify_checksum, ft);\n}\n\n/*************************************************************************\n// overlapping decompression\n**************************************************************************/\n\nbool Packer::testOverlappingDecompression(const byte *buf, const byte *tbuf,\n                                          unsigned overlap_overhead) const {\n    return ph_testOverlappingDecompression(ph, buf, tbuf, overlap_overhead);\n}\n\nvoid Packer::verifyOverlappingDecompression(Filter *ft) {\n    assert(ph.c_len < ph.u_len);\n    assert((int) ph.overlap_overhead > 0);\n    // Idea:\n    //   obuf[] was allocated with MemBuffer::allocForCompression(), and\n    //   its contents are no longer needed, i.e. the compressed data\n    //   must have been already written.\n    //   We now can perform a real overlapping decompression and\n    //   verify the checksum.\n    //\n    // Note:\n    //   This verify is just because of complete paranoia that there\n    //   could be a hidden bug in the upx_test_overlap implementation,\n    //   and it should not be necessary at all.\n    //\n    // See also:\n    //   Filter::verifyUnfilter()\n\n    if (ph_skipVerify(ph))\n        return;\n    unsigned offset = (ph.u_len + ph.overlap_overhead) - ph.c_len;\n    if (offset + ph.c_len > obuf.getSize())\n        return;\n    memmove(obuf + offset, obuf, ph.c_len);\n    decompress(obuf + offset, obuf, true, ft);\n    obuf.checkState();\n}\n\nvoid Packer::verifyOverlappingDecompression(byte *o_ptr, unsigned o_size, Filter *ft) {\n    assert(ph.c_len < ph.u_len);\n    assert((int) ph.overlap_overhead > 0);\n    if (ph_skipVerify(ph))\n        return;\n    unsigned offset = (ph.u_len + ph.overlap_overhead) - ph.c_len;\n    if (offset + ph.c_len > o_size)\n        return;\n    memmove(o_ptr + offset, o_ptr, ph.c_len);\n    decompress(o_ptr + offset, o_ptr, true, ft);\n}\n\n/*************************************************************************\n// Find overhead for in-place decompression in a heuristic way\n// (using a binary search). Return 0 on error.\n//\n// To speed up things:\n//   - you can pass the range of an acceptable interval (so that\n//     we can succeed early)\n//   - you can enforce an upper_limit (so that we can fail early)\n**************************************************************************/\n\nunsigned Packer::findOverlapOverhead(const byte *buf, const byte *tbuf, unsigned range,\n                                     unsigned upper_limit) const {\n    assert((int) range >= 0);\n\n    // prepare to deal with very pessimistic values\n    unsigned low = 1;\n    unsigned high = UPX_MIN(ph.u_len + 512, upper_limit);\n    // but be optimistic for first try (speedup)\n    unsigned m = UPX_MIN(16u, high);\n    //\n    unsigned overhead = 0;\n    unsigned nr = 0; // statistics\n\n    while (high >= low) {\n        assert(m >= low);\n        assert(m <= high);\n        assert(m < overhead || overhead == 0);\n        nr++;\n        bool success = testOverlappingDecompression(buf, tbuf, m);\n        // printf(\"testOverlapOverhead(%d): %d %d: %d -> %d\\n\", nr, low, high, m, (int)success);\n        if (success) {\n            overhead = m;\n            // Succeed early if m lies in [low .. low+range-1], i.e. if\n            // if the range of the current interval is <= range.\n            //   if (m <= low + range - 1)\n            //   if (m <  low + range)\n            if (m - low < range) // avoid underflow\n                break;\n            high = m - 1;\n        } else\n            low = m + 1;\n        ////m = (low + high) / 2;\n        m = (low & high) + ((low ^ high) >> 1); // avoid overflow\n    }\n\n    // printf(\"findOverlapOverhead: %d (%d tries)\\n\", overhead, nr);\n    if (overhead == 0)\n        throwInternalError(\"this is an oo bug\");\n\n    UNUSED(nr);\n    return overhead;\n}\n\n/*************************************************************************\n// file i/o utils\n**************************************************************************/\n\n/*static*/ void Packer::handleStub(InputFile *fif, OutputFile *fo, unsigned size) {\n    if (fo) {\n        if (size > 0) {\n            // copy stub from exe\n            info(\"Copying original stub: %u bytes\", size);\n            ByteArray(stub, size);\n            fif->seek(0, SEEK_SET);\n            fif->readx(stub, size);\n            fo->write(stub, size);\n        } else {\n            // no stub\n        }\n    }\n}\n\nvoid Packer::checkOverlay(unsigned overlay) {\n    if ((int) overlay < 0 || overlay > file_size_u)\n        throw OverlayException(\"invalid overlay size; file is possibly corrupt\");\n    if (overlay == 0)\n        return;\n    info(\"Found overlay: %d bytes\", overlay);\n    if (opt->overlay == opt->SKIP_OVERLAY)\n        throw OverlayException(\"file has overlay -- skipped; try '--overlay=copy'\");\n}\n\nvoid Packer::copyOverlay(OutputFile *fo, unsigned overlay, MemBuffer &buf, bool do_seek) {\n    assert((int) overlay >= 0);\n    assert(overlay < file_size_u);\n    buf.checkState();\n    if (!fo || overlay == 0)\n        return;\n    if (opt->overlay != opt->COPY_OVERLAY) {\n        assert(opt->overlay == opt->STRIP_OVERLAY);\n        infoWarning(\"stripping overlay: %d bytes\", overlay);\n        return;\n    }\n    info(\"Copying overlay: %d bytes\", overlay);\n    if (do_seek)\n        fi->seek(-(upx_off_t) overlay, SEEK_END);\n\n    // get buffer size, align to improve i/o speed\n    unsigned buf_size = buf.getSize();\n    if (buf_size > 65536)\n        buf_size = ALIGN_DOWN(buf_size, 4096u);\n    assert((int) buf_size > 0);\n\n    do {\n        unsigned len = overlay < buf_size ? overlay : buf_size;\n        fi->readx(buf, len);\n        fo->write(buf, len);\n        overlay -= len;\n    } while (overlay > 0);\n    buf.checkState();\n}\n\n// Create a pseudo-unique program id.\nunsigned Packer::getRandomId() const {\n    if (opt->debug.disable_random_id)\n        return 0x01020304;\n    unsigned id = 0;\n    while (id == 0) {\n        id ^= (unsigned) fi->st.st_ino;\n        id ^= (unsigned) fi->st.st_atime;\n        id ^= (unsigned) upx_rand();\n    }\n    return id;\n}\n\n/*************************************************************************\n// packheader util\n**************************************************************************/\n\n// this is called directly after the constructor from class PackMaster\nvoid Packer::initPackHeader() {\n    ph.reset();\n    ph.version = getVersion();\n    ph.format = getFormat();\n    ph.method = M_NONE;\n    ph.level = -1;\n    ph.u_adler = ph.c_adler = ph.saved_u_adler = ph.saved_c_adler = upx_adler32(nullptr, 0);\n    ph.buf_offset = 0;\n    ph.u_file_size = file_size;\n}\n\n// this is called directly after canPack() from class PackMaster\nvoid Packer::updatePackHeader() {\n    assert(opt->cmd == CMD_COMPRESS);\n    //\n    const int *m = getCompressionMethods(opt->method, opt->level);\n    ph.method = m[0];\n    ph.level = opt->level;\n    if (ph.level < 0)\n        ph.level = file_size < 512 * 1024 ? 8 : 7;\n    //\n    assert(isValidCompressionMethod(ph.method));\n    assert(1 <= ph.level && ph.level <= 10);\n}\n\n// FIXME: remove patchPackHeader() and fold into relocateLoader();\n//   then make linker->relocate() private (friend Packer)\nint Packer::patchPackHeader(void *b, int blen) {\n    assert(isValidFilter(ph.filter));\n\n    const int size = ph.getPackHeaderSize();\n    if (linker->findSection(\"UPX1HEAD\", false))\n        assert(size == linker->getSectionSize(\"UPX1HEAD\"));\n    int boff = find_le32(b, blen, UPX_MAGIC_LE32);\n    checkPatch(b, blen, boff, size);\n\n    auto bb = (byte *) b;\n    ph.putPackHeader(SPAN_S_MAKE(byte, bb + boff, blen, bb));\n\n    return boff;\n}\n\nbool Packer::getPackHeader(const void *b, int blen, bool allow_incompressible) {\n    auto bb = (const byte *) b;\n    if (!ph.decodePackHeaderFromBuf(SPAN_S_MAKE(const byte, bb, blen), blen))\n        return false;\n\n    if (ph.version > getVersion())\n        throwCantUnpack(\"need a newer version of UPX\");\n    // Some formats might be able to unpack old versions because\n    // their implementation hasn't changed. Ask them.\n    if (opt->cmd != CMD_FILEINFO)\n        if (!testUnpackVersion(ph.version))\n            return false;\n\n    if (ph.c_len > ph.u_len || (ph.c_len == ph.u_len && !allow_incompressible) ||\n        ph.c_len >= file_size_u || ph.version <= 0 || ph.version >= 0xff)\n        throwCantUnpack(\"header corrupted\");\n    else if (ph.u_len > ph.u_file_size) {\n#if 0\n        // FIXME: does this check make sense w.r.t. overlays ???\n        if (ph.format == UPX_F_WIN32_PE || ph.format == UPX_F_DOS_EXE)\n            // may get longer\n            ((void)0);\n        else\n            throwCantUnpack(\"header size corrupted\");\n#endif\n    }\n    if (!isValidCompressionMethod(ph.method))\n        throwCantUnpack(\"unknown compression method (try a newer version of UPX)\");\n\n    // Some formats might be able to unpack \"subformats\". Ask them.\n    if (!testUnpackFormat(ph.format))\n        return false;\n\n    return true;\n}\n\nbool Packer::readPackHeader(int len, bool allow_incompressible) {\n    assert(len > 0);\n    MemBuffer buf(len);\n    len = fi->read(buf, len);\n    if (len <= 0)\n        return false;\n    return getPackHeader(buf, len, allow_incompressible);\n}\n\nvoid Packer::checkAlreadyPacked(const void *b, int blen) {\n    assert(blen >= 4);\n    int boff = find_le32(b, blen, UPX_MAGIC_LE32);\n    if (boff < 0)\n        return;\n\n    // FIXME: could add some more checks to verify that this\n    //   is a real PackHeader, e.g.\n    //\n    // PackHeader tmp;\n    // if (!tmp.decodePackHeaderFromBuf((byte *)b + boff, blen - boff))\n    //    return;\n    //\n    // This also would require that the buffer in 'b' holds\n    // the full PackHeader, and not only the 4 magic bytes.\n\n    throwAlreadyPacked();\n}\n\n/*************************************************************************\n// patch util for loader\n**************************************************************************/\n\nvoid Packer::checkPatch(void *b, int blen, int boff, int size) {\n    if (b == nullptr && blen == 0 && boff == 0 && size == 0) {\n        // reset\n        last_patch = nullptr;\n        last_patch_len = 0;\n        last_patch_off = 0;\n        return;\n    }\n    if (b == nullptr || blen <= 0 || boff < 0 || size <= 0)\n        throwBadLoader();\n    if (boff + size <= 0 || boff + size > blen)\n        throwBadLoader();\n    // printf(\"checkPatch: %p %5d %5d %2d\\n\", b, blen, boff, size);\n    if (b == last_patch) {\n        if (boff + size > last_patch_off)\n            throwInternalError(\"invalid patch order\");\n        // The next check is not strictly necessary, but the buffer\n        // length should better not increase...\n        if (blen > last_patch_len)\n            throwInternalError(\"invalid patch order (length)\");\n    } else\n        last_patch = b;\n    last_patch_len = blen;\n    last_patch_off = boff;\n}\n\nint Packer::patch_be16(void *b, int blen, unsigned old, unsigned new_) {\n    int boff = find_be16(b, blen, old);\n    checkPatch(b, blen, boff, 2);\n\n    byte *p = (byte *) b + boff;\n    set_be16(p, new_);\n\n    return boff;\n}\n\nint Packer::patch_be16(void *b, int blen, const void *old, unsigned new_) {\n    int boff = find(b, blen, old, 2);\n    checkPatch(b, blen, boff, 2);\n\n    byte *p = (byte *) b + boff;\n    set_be16(p, new_);\n\n    return boff;\n}\n\nint Packer::patch_be32(void *b, int blen, unsigned old, unsigned new_) {\n    int boff = find_be32(b, blen, old);\n    checkPatch(b, blen, boff, 4);\n\n    byte *p = (byte *) b + boff;\n    set_be32(p, new_);\n\n    return boff;\n}\n\nint Packer::patch_be32(void *b, int blen, const void *old, unsigned new_) {\n    int boff = find(b, blen, old, 4);\n    checkPatch(b, blen, boff, 4);\n\n    byte *p = (byte *) b + boff;\n    set_be32(p, new_);\n\n    return boff;\n}\n\nint Packer::patch_le16(void *b, int blen, unsigned old, unsigned new_) {\n    int boff = find_le16(b, blen, old);\n    checkPatch(b, blen, boff, 2);\n\n    byte *p = (byte *) b + boff;\n    set_le16(p, new_);\n\n    return boff;\n}\n\nint Packer::patch_le16(void *b, int blen, const void *old, unsigned new_) {\n    int boff = find(b, blen, old, 2);\n    checkPatch(b, blen, boff, 2);\n\n    byte *p = (byte *) b + boff;\n    set_le16(p, new_);\n\n    return boff;\n}\n\nint Packer::patch_le32(void *b, int blen, unsigned old, unsigned new_) {\n    int boff = find_le32(b, blen, old);\n    checkPatch(b, blen, boff, 4);\n\n    byte *p = (byte *) b + boff;\n    set_le32(p, new_);\n\n    return boff;\n}\n\nint Packer::patch_le32(void *b, int blen, const void *old, unsigned new_) {\n    int boff = find(b, blen, old, 4);\n    checkPatch(b, blen, boff, 4);\n\n    byte *p = (byte *) b + boff;\n    set_le32(p, new_);\n\n    return boff;\n}\n\n/*************************************************************************\n// loader util (interface to linker)\n**************************************************************************/\n\nstatic const char *getIdentstr(unsigned *size, int small) {\n    // IMPORTANT: we do NOT change \"http://upx.sf.net\"\n    static char identbig[] =\n        \"\\n\\0\"\n        \"$Info: \"\n        \"This file is packed with the UPX executable packer http://upx.sf.net $\"\n        \"\\n\\0\"\n        \"$Id: UPX \" UPX_VERSION_STRING4 \" Copyright (C) 1996-\" UPX_VERSION_YEAR\n        \" the UPX Team. All Rights Reserved. $\"\n        \"\\n\";\n    static char identsmall[] =\n        \"\\n\"\n        \"$Id: UPX \"\n        \"(C) 1996-\" UPX_VERSION_YEAR \" the UPX Team. All Rights Reserved. http://upx.sf.net $\"\n        \"\\n\";\n    static char identtiny[] = UPX_VERSION_STRING4;\n\n    static upx_std_once_flag init_done;\n    upx_std_call_once(init_done, []() noexcept {\n        if (opt->debug.fake_stub_version[0] || opt->debug.fake_stub_year[0]) {\n            struct Ident {\n                char *s;\n                int len;\n            };\n            static const Ident idents[] = {{identbig, (int) sizeof(identbig) - 1},\n                                           {identsmall, (int) sizeof(identsmall) - 1},\n                                           {identtiny, (int) sizeof(identtiny) - 1},\n                                           {nullptr, 0}};\n            for (const Ident *iter = idents; iter->s; ++iter) {\n                if (opt->debug.fake_stub_version[0])\n                    mem_replace(iter->s, iter->len, UPX_VERSION_STRING4, 4,\n                                opt->debug.fake_stub_version);\n                if (opt->debug.fake_stub_year[0])\n                    mem_replace(iter->s, iter->len, UPX_VERSION_YEAR, 4, opt->debug.fake_stub_year);\n            }\n        }\n    });\n\n    if (small < 0)\n        small = opt->small;\n    if (small >= 2) {\n        *size = sizeof(identtiny);\n        return identtiny;\n    } else if (small >= 1) {\n        *size = sizeof(identsmall);\n        return identsmall;\n    } else {\n        *size = sizeof(identbig);\n        return identbig;\n    }\n}\n\nvoid Packer::initLoader(const void *pdata, int plen, int small, int pextra) {\n    upx::owner_delete(linker);\n    linker = newLinker();\n    assert(bele == linker->bele);\n    linker->init(pdata, plen, pextra);\n\n    unsigned size;\n    char const *const ident = getIdentstr(&size, small);\n    linker->addSection(\"IDENTSTR\", ident, size, 0);\n}\n\n#define C const char *\n#define N ACC_STATIC_CAST(void *, nullptr)\nvoid Packer::addLoader(C a) { addLoaderVA(a, N); }\nvoid Packer::addLoader(C a, C b) { addLoaderVA(a, b, N); }\nvoid Packer::addLoader(C a, C b, C c) { addLoaderVA(a, b, c, N); }\nvoid Packer::addLoader(C a, C b, C c, C d) { addLoaderVA(a, b, c, d, N); }\nvoid Packer::addLoader(C a, C b, C c, C d, C e) { addLoaderVA(a, b, c, d, e, N); }\nvoid Packer::addLoader(C a, C b, C c, C d, C e, C f) { addLoaderVA(a, b, c, d, e, f, N); }\nvoid Packer::addLoader(C a, C b, C c, C d, C e, C f, C g) { addLoaderVA(a, b, c, d, e, f, g, N); }\nvoid Packer::addLoader(C a, C b, C c, C d, C e, C f, C g, C h) {\n    addLoaderVA(a, b, c, d, e, f, g, h, N);\n}\nvoid Packer::addLoader(C a, C b, C c, C d, C e, C f, C g, C h, C i) {\n    addLoaderVA(a, b, c, d, e, f, g, h, i, N);\n}\nvoid Packer::addLoader(C a, C b, C c, C d, C e, C f, C g, C h, C i, C j) {\n    addLoaderVA(a, b, c, d, e, f, g, h, i, j, N);\n}\n#undef C\n#undef N\n\nvoid Packer::addLoaderVA(const char *s, ...) {\n    va_list ap;\n    va_start(ap, s);\n    linker->addLoader(s, ap);\n    va_end(ap);\n}\n\nbyte *Packer::getLoader() const {\n    int size = -1;\n    byte *oloader = linker->getLoader(&size);\n    if (oloader == nullptr || size <= 0)\n        throwBadLoader();\n    return oloader;\n}\n\nint Packer::getLoaderSize() const {\n    int size = -1;\n    byte *oloader = linker->getLoader(&size);\n    if (oloader == nullptr || size <= 0)\n        throwBadLoader();\n    return size;\n}\n\nbool Packer::hasLoaderSection(const char *name) const {\n    void *section = linker->findSection(name, false);\n    return section != nullptr;\n}\n\nint Packer::getLoaderSection(const char *name, int *slen) const {\n    int size = -1;\n    int ostart = linker->getSection(name, &size);\n    if (ostart < 0 || size <= 0)\n        throwBadLoader();\n    if (slen)\n        *slen = size;\n    return ostart;\n}\n\n// same, but the size of the section may be == 0\nint Packer::getLoaderSectionStart(const char *name, int *slen) const {\n    int size = -1;\n    int ostart = linker->getSection(name, &size);\n    if (ostart < 0 || size < 0)\n        throwBadLoader();\n    if (slen)\n        *slen = size;\n    return ostart;\n}\n\nvoid Packer::relocateLoader() {\n    linker->relocate();\n\n#if 0\n    // \"relocate\" packheader\n    if (linker->findSection(\"UPX1HEAD\", false))\n    {\n        int lsize = -1;\n        int loff = getLoaderSectionStart(\"UPX1HEAD\", &lsize);\n        assert(lsize == ph.getPackHeaderSize());\n        byte *p = getLoader() + loff;\n        assert(get_le32(p) == UPX_MAGIC_LE32);\n        //patchPackHeader(p, lsize);\n        ph.putPackHeader(p);\n    }\n#endif\n}\n\n/*************************************************************************\n//      void Packer::compressWithFilters():\n// Try compression with several methods and filters, choose the best\n/  or first working one. Needs buildLoader().\n//\n// Required inputs:\n//   this->ph\n//     ulen\n//   parm_ft\n//     clevel\n//     addvalue\n//     buf_len (optional)\n//\n// - updates this->ph\n// - updates *ft\n// - i_ptr[] is restored to the original unfiltered version\n// - o_ptr[] contains the best compressed version\n//\n// filter_strategy:\n//   n:  try the first N filters, use best one\n//  -1:  try all filters, use first working one\n//  -2:  try only the opt->filter filter\n//  -3:  use no filter at all\n//  -4:  use no filter at all, and build no loader, either\n//\n// This has been prepared for generalization into class Packer so that\n// opt->all_methods and/or opt->all_filters are available for all\n// executable formats.\n//\n// It will replace the tryFilters() / compress() call sequence.\n//\n// 2006-02-15: hdr_buf and hdr_u_len are default empty input \"header\" array\n// to fix a 2-pass problem with Elf headers.  As of today there can be\n// only one decompression method per executable output file, and that method\n// is the one that gives best compression for .text and loader.  However,\n// the Elf headers precede .text in the output file, and are written first.\n// \"--brute\" compression often compressed the Elf headers using nrv2b\n// but the .text (and loader) with nrv2e.  This often resulted in SIGSEGV\n// during decompression.\n// The workaround is for hdr_buf and hdr_u_len to describe the Elf headers\n// (typically less than 512 bytes) when .text is passed in, and include\n// them in the calculation of shortest output.  Then the result\n// this->ph.method  will say which [single] method to use for everything.\n// The Elf headers are never filtered.  They are short enough (< 512 bytes)\n// that compressing them more than once per method (once here when choosing,\n// once again just before writing [because compressWithFilters discards])\n// is OK because of the simplicity of not having two output arrays.\n**************************************************************************/\n\nint Packer::prepareMethods(int *methods, int ph_method, const int *all_methods) const {\n    int nmethods = 0;\n    if (!opt->all_methods || all_methods == nullptr || (-0x80 == (ph_method >> 24))) {\n        methods[nmethods++] = ph_forced_method(ph_method);\n        return nmethods;\n    }\n    for (int mm = 0; all_methods[mm] != M_END; ++mm) {\n        int method = all_methods[mm];\n        if (method == M_ULTRA_BRUTE && !opt->ultra_brute)\n            break;\n        if (method == M_SKIP || method == M_ULTRA_BRUTE)\n            continue;\n        if (opt->all_methods && opt->all_methods_use_lzma != 1 && M_IS_LZMA(method))\n            continue;\n        // check duplicate\n        assert(Packer::isValidCompressionMethod(method));\n        for (int i = 0; i < nmethods; i++)\n            assert(method != methods[i]);\n        // use this method\n        methods[nmethods++] = method;\n    }\n    // debug\n    if (opt->debug.use_random_method && nmethods >= 2) {\n        int method = methods[upx_rand() % nmethods];\n        NO_printf(\"\\nuse_random_method = %#x (%d)\\n\", method, nmethods);\n        methods[0] = method;\n        nmethods = 1;\n    }\n    return nmethods;\n}\n\nstatic int prepareFilters(int *filters, int &filter_strategy, const int *all_filters) {\n    int nfilters = 0;\n\n    // setup filter filter_strategy\n    if (filter_strategy == 0) {\n        if (opt->all_filters)\n            // choose best from all available filters\n            filter_strategy = INT_MAX;\n        else if (opt->filter >= 0 && Filter::isValidFilter(opt->filter, all_filters))\n            // try opt->filter\n            filter_strategy = -2;\n        else\n            // try the first working filter\n            filter_strategy = -1;\n    }\n    assert(filter_strategy != 0);\n\n    if (filter_strategy <= -3)\n        goto done;\n    if (filter_strategy == -2) {\n        if (opt->filter >= 0 && Filter::isValidFilter(opt->filter, all_filters)) {\n            filters[nfilters++] = opt->filter;\n            goto done;\n        }\n        filter_strategy = -1;\n    }\n    assert(filter_strategy >= -1);\n\n    while (all_filters && *all_filters != FT_END) {\n        int filter_id = *all_filters++;\n        if (filter_id == FT_ULTRA_BRUTE && !opt->ultra_brute)\n            break;\n        if (filter_id == FT_SKIP || filter_id == FT_ULTRA_BRUTE)\n            continue;\n        if (filter_id == 0)\n            continue;\n        // check duplicate\n        assert(Filter::isValidFilter(filter_id));\n        for (int i = 0; i < nfilters; i++)\n            assert(filter_id != filters[i]);\n        // use this filter\n        filters[nfilters++] = filter_id;\n        if (filter_strategy >= 0 && nfilters >= filter_strategy)\n            break;\n    }\n\ndone:\n    // filter_strategy now only means \"stop after first successful filter\"\n    filter_strategy = (filter_strategy < 0) ? -1 : 0;\n    // make sure that we have a \"no filter\" fallback\n    bool have_filter0 = false;\n    for (int i = 0; i < nfilters; i++)\n        if (filters[i] == 0) {\n            have_filter0 = true;\n            break;\n        }\n    if (!have_filter0)\n        filters[nfilters++] = 0;\n    // debug\n    if (opt->debug.use_random_filter && nfilters >= 3 && filters[nfilters - 1] == 0) {\n        int filter_id = filters[upx_rand() % (nfilters - 1)];\n        if (filter_id > 0) {\n            NO_printf(\"\\nuse_random_filter = %#x (%d)\\n\", filter_id, nfilters - 1);\n            filters[0] = filter_id;\n            filters[1] = 0;\n            nfilters = 2;\n        }\n    }\n    return nfilters;\n}\n\nvoid Packer::compressWithFilters(byte *i_ptr,\n                                 const unsigned i_len, // written and restored by filters\n                                 byte *const o_ptr,    // where to put compressed output\n                                 byte *f_ptr,\n                                 const unsigned f_len, // subset of [*i_ptr, +i_len)\n                                 byte *const hdr_ptr, const unsigned hdr_len,\n                                 Filter *const parm_ft, // updated\n                                 const unsigned overlap_range,\n                                 upx_compress_config_t const *const cconf,\n                                 int filter_strategy, // in+out for prepareFilters\n                                 bool const inhibit_compression_check) {\n    parm_ft->buf_len = f_len;\n    // struct copies\n    const PackHeader orig_ph = this->ph;\n    PackHeader best_ph = this->ph;\n    const Filter orig_ft = *parm_ft;\n    Filter best_ft = *parm_ft;\n    //\n    best_ph.c_len = i_len;\n    best_ph.overlap_overhead = 0;\n    unsigned best_ph_lsize = 0;\n    unsigned best_hdr_c_len = 0;\n\n    // preconditions\n    assert(orig_ph.filter == 0);\n    assert(orig_ft.id == 0);\n\n    // prepare methods and filters\n    int methods[MAX_METHODS];\n    int nmethods = prepareMethods(methods, ph.method, getCompressionMethods(M_ALL, ph.level));\n    assert_noexcept(nmethods > 0);\n    assert_noexcept(nmethods < (int) MAX_METHODS);\n    int filters[MAX_FILTERS];\n    int nfilters = prepareFilters(filters, filter_strategy, getFilters());\n    assert_noexcept(nfilters > 0);\n    assert_noexcept(nfilters < (int) MAX_FILTERS);\n#if 0\n    printf(\"compressWithFilters: m(%d):\", nmethods);\n    for (int i = 0; i < nmethods; i++)\n        printf(\" %#x\", methods[i]);\n    printf(\" f(%d):\", nfilters);\n    for (int i = 0; i < nfilters; i++)\n        printf(\" %#x\", filters[i]);\n    printf(\"\\n\");\n#endif\n\n    // update total_passes; previous (ui_total_passes > 0) means incremental\n    if (!ph_is_forced_method(ph.method)) {\n        if (uip->ui_total_passes > 0)\n            uip->ui_total_passes -= 1;\n        if (filter_strategy < 0)\n            uip->ui_total_passes += nmethods;\n        else\n            uip->ui_total_passes += nfilters * nmethods;\n    }\n\n    // Working buffer for compressed data. Don't waste memory and allocate as needed.\n    byte *o_tmp = o_ptr;\n    MemBuffer o_tmp_buf;\n\n    // compress using all methods/filters\n    int nfilters_success_total = 0;\n    for (int mm = 0; mm < nmethods; mm++) // for all methods\n    {\n        NO_printf(\"\\nmethod %d (%d of %d)\\n\", methods[mm], 1 + mm, nmethods);\n        assert(isValidCompressionMethod(methods[mm]));\n        unsigned hdr_c_len = 0;\n        if (hdr_ptr != nullptr && hdr_len) {\n            if (nfilters_success_total != 0 && o_tmp == o_ptr) {\n                // do not overwrite o_ptr\n                o_tmp_buf.allocForCompression(UPX_MAX(hdr_len, i_len));\n                o_tmp = o_tmp_buf;\n            }\n            int r = upx_compress(hdr_ptr, hdr_len, o_tmp, &hdr_c_len, nullptr, methods[mm], 10,\n                                 nullptr, nullptr);\n            if (r != UPX_E_OK)\n                throwInternalError(\"header compression failed\");\n            if (hdr_c_len >= hdr_len)\n                throwInternalError(\"header compression size increase\");\n        }\n        int nfilters_success_mm = 0;\n        for (int ff = 0; ff < nfilters; ff++) // for all filters\n        {\n            assert(isValidFilter(filters[ff]));\n            // get fresh packheader\n            ph = orig_ph;\n            ph.method = methods[mm];\n            ph.filter = filters[ff];\n            ph.overlap_overhead = 0;\n            // get fresh filter\n            Filter ft = orig_ft;\n            ft.init(ph.filter, orig_ft.addvalue);\n            // filter\n            optimizeFilter(&ft, f_ptr, f_len);\n            bool success = ft.filter(f_ptr, f_len);\n            if (ft.id != 0 && ft.calls == 0) {\n                // filter did not do anything - no need to call ft.unfilter()\n                success = false;\n            }\n            if (!success) {\n                // filter failed or was useless\n                if (filter_strategy >= 0) {\n                    // adjust ui passes\n                    if (uip->ui_pass >= 0)\n                        uip->ui_pass++;\n                }\n                continue;\n            }\n            // filter success\n            NO_printf(\"\\nfilter: id 0x%02x size %6d, calls %5d/%5d/%3d/%5d/%5d, cto 0x%02x\\n\",\n                      ft.id, ft.buf_len, ft.calls, ft.noncalls, ft.wrongcalls, ft.firstcall,\n                      ft.lastcall, ft.cto);\n            if (nfilters_success_total != 0 && o_tmp == o_ptr) {\n                o_tmp_buf.allocForCompression(i_len);\n                o_tmp = o_tmp_buf;\n            }\n            nfilters_success_total++;\n            nfilters_success_mm++;\n            ph.filter_cto = ft.cto;\n            ph.n_mru = ft.n_mru;\n            // compress\n            if (compress(i_ptr, i_len, o_tmp, cconf)) {\n                unsigned lsize = 0;\n                // findOverlapOperhead() might be slow; omit if already too big.\n                if (ph.c_len + lsize + hdr_c_len <=\n                    best_ph.c_len + best_ph_lsize + best_hdr_c_len) {\n                    // get results\n                    ph.overlap_overhead = findOverlapOverhead(o_tmp, i_ptr, overlap_range);\n                    if (-4 < filter_strategy) {\n                        buildLoader(&ft);\n                        lsize = getLoaderSize();\n                        assert(lsize > 0);\n                    }\n                }\n                NO_printf(\"\\n%2d %02x: %d +%4d +%3d = %d  (best: %d +%4d +%3d = %d)\\n\", ph.method,\n                          ph.filter, ph.c_len, lsize, hdr_c_len, ph.c_len + lsize + hdr_c_len,\n                          best_ph.c_len, best_ph_lsize, best_hdr_c_len,\n                          best_ph.c_len + best_ph_lsize + best_hdr_c_len);\n                bool update = false;\n                if (ph.c_len + lsize + hdr_c_len < best_ph.c_len + best_ph_lsize + best_hdr_c_len)\n                    update = true;\n                else if (ph.c_len + lsize + hdr_c_len ==\n                         best_ph.c_len + best_ph_lsize + best_hdr_c_len) {\n                    // prefer smaller loaders\n                    if (lsize + hdr_c_len < best_ph_lsize + best_hdr_c_len)\n                        update = true;\n                    else if (lsize + hdr_c_len == best_ph_lsize + best_hdr_c_len) {\n                        // prefer less overlap_overhead\n                        if (ph.overlap_overhead < best_ph.overlap_overhead)\n                            update = true;\n                    }\n                }\n                if (update) {\n                    assert((int) ph.overlap_overhead > 0);\n                    // update o_ptr[] with best version\n                    if (o_tmp != o_ptr)\n                        memcpy(o_ptr, o_tmp, ph.c_len);\n                    // save compression results\n                    best_ph = ph;\n                    best_ph_lsize = lsize;\n                    best_hdr_c_len = hdr_c_len;\n                    best_ft = ft;\n                }\n            }\n            // restore - unfilter with verify\n            ft.unfilter(f_ptr, f_len, true);\n            if (filter_strategy < 0)\n                break;\n        }\n        assert(nfilters_success_mm > 0);\n    }\n\n    // postconditions 1)\n    assert(nfilters_success_total > 0);\n    assert(best_ph.u_len == orig_ph.u_len);\n    assert(best_ph.filter == best_ft.id);\n    assert(best_ph.filter_cto == best_ft.cto);\n    // FIXME  assert(best_ph.n_mru == best_ft.n_mru);\n\n    // copy back results\n    this->ph = best_ph;\n    *parm_ft = best_ft;\n\n    // Finally, check compression ratio.\n    // Might be inhibited when blocksize < file_size, for instance.\n    if (!inhibit_compression_check) {\n        if (best_ph.c_len + best_ph_lsize >= best_ph.u_len)\n            throwNotCompressible();\n        if (!checkCompressionRatio(best_ph.u_len, best_ph.c_len))\n            throwNotCompressible();\n\n        // postconditions 2)\n        assert(best_ph.overlap_overhead > 0);\n    }\n\n    // convenience\n    buildLoader(&best_ft);\n}\n\n/*************************************************************************\n//\n**************************************************************************/\n\nvoid Packer::compressWithFilters(Filter *ft, const unsigned overlap_range,\n                                 const upx_compress_config_t *cconf, int filter_strategy,\n                                 bool inhibit_compression_check) {\n    // call the subroutine immediately below\n    compressWithFilters(ft, overlap_range, cconf, filter_strategy, 0, 0, 0, nullptr, 0,\n                        inhibit_compression_check);\n}\n\nvoid Packer::compressWithFilters(Filter *ft, const unsigned overlap_range,\n                                 upx_compress_config_t const *cconf, int filter_strategy,\n                                 unsigned filter_off, unsigned ibuf_off, unsigned obuf_off,\n                                 byte *const hdr_ptr, unsigned hdr_len,\n                                 bool inhibit_compression_check) {\n    ibuf.checkState();\n    obuf.checkState();\n\n    byte *i_ptr = ibuf + ibuf_off;\n    unsigned i_len = ph.u_len;\n    byte *o_ptr = obuf + obuf_off;\n    unsigned f_len = ft->buf_len ? ft->buf_len : i_len;\n    if (filter_strategy <= -3) {\n        filter_off = 0;\n        f_len = 0;\n    }\n    byte *f_ptr = ibuf + filter_off;\n\n    assert(f_ptr + f_len <= i_ptr + i_len);\n\n    // call the first one in this file\n    compressWithFilters(i_ptr, i_len, o_ptr, f_ptr, f_len, hdr_ptr, hdr_len, ft, overlap_range,\n                        cconf, filter_strategy, inhibit_compression_check);\n\n    ibuf.checkState();\n    obuf.checkState();\n}\n\n/* vim:set ts=4 sw=4 et: */\n","size_bytes":44335},"src/packer_c.cpp":{"content":"/* packer_c.cpp -- Packer compression handling\n\n   This file is part of the Resize executable compressor.\n\n   Copyright (C) 2025 WHO-AM-I-404\n   Based on UPX - Ultimate Packer for eXecutables\n   Copyright (C) 1996-2025 Markus Franz Xaver Johannes Oberhumer\n   Copyright (C) 1996-2025 Laszlo Molnar\n   All Rights Reserved.\n\n   Resize and the UCL library are free software; you can redistribute them\n   and/or modify them under the terms of the GNU General Public License as\n   published by the Free Software Foundation; either version 2 of\n   the License, or (at your option) any later version.\n\n   This program is distributed in the hope that it will be useful,\n   but WITHOUT ANY WARRANTY; without even the implied warranty of\n   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n   GNU General Public License for more details.\n\n   You should have received a copy of the GNU General Public License\n   along with this program; see the file COPYING.\n   If not, write to the Free Software Foundation, Inc.,\n   59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.\n\n   WHO-AM-I-404 <who-am-i-404@proton.me>\n   Based on original work by:\n   Markus F.X.J. Oberhumer <markus@oberhumer.com>\n   Laszlo Molnar <ezerotven+github@gmail.com>\n */\n\n#include \"conf.h\"\n#include \"packer.h\"\n#include \"linker.h\"\n\n/*************************************************************************\n// compression method util\n**************************************************************************/\n\n/*static*/ bool Packer::isValidCompressionMethod(int m) {\n    return M_IS_LZMA(m) || M_IS_NRV2B(m) || M_IS_NRV2D(m) || M_IS_NRV2E(m);\n}\n\nconst int *Packer::getDefaultCompressionMethods_8(int method, int level, int small) const {\n#define M_LZMA_003 (M_LZMA | 0x00300)\n#define M_LZMA_407 (M_LZMA | 0x40700)\n    static const int m_all[] = {M_NRV2B_8,     M_NRV2D_8,  M_NRV2E_8,  M_LZMA,\n                                M_ULTRA_BRUTE, M_LZMA_003, M_LZMA_407, M_END};\n    // static const int m_cl1b[]  = { M_CL1B_8, M_END };\n    static const int m_lzma[] = {M_LZMA, M_END};\n    static const int m_nrv2b[] = {M_NRV2B_8, M_END};\n    static const int m_nrv2d[] = {M_NRV2D_8, M_END};\n    static const int m_nrv2e[] = {M_NRV2E_8, M_END};\n\n    if (method == M_ALL)\n        return m_all;\n    // if (M_IS_CL1B(method))  return m_cl1b;\n    if (M_IS_LZMA(method))\n        return m_lzma;\n    if (M_IS_NRV2B(method))\n        return m_nrv2b;\n    if (M_IS_NRV2D(method))\n        return m_nrv2d;\n    if (M_IS_NRV2E(method))\n        return m_nrv2e;\n    if (small < 0)\n        small = file_size <= 512 * 1024;\n    if (level == 1 || small)\n        return m_nrv2b;\n    return m_nrv2e;\n}\n\nconst int *Packer::getDefaultCompressionMethods_le32(int method, int level, int small) const {\n    static const int m_all[] = {M_NRV2B_LE32,  M_NRV2D_LE32, M_NRV2E_LE32, M_LZMA,\n                                M_ULTRA_BRUTE, M_LZMA_003,   M_LZMA_407,   M_END};\n    // static const int m_cl1b[]  = { M_CL1B_LE32, M_END };\n    static const int m_lzma[] = {M_LZMA, M_END};\n    static const int m_nrv2b[] = {M_NRV2B_LE32, M_END};\n    static const int m_nrv2d[] = {M_NRV2D_LE32, M_END};\n    static const int m_nrv2e[] = {M_NRV2E_LE32, M_END};\n\n    if (method == M_ALL)\n        return m_all;\n    // if (M_IS_CL1B(method))  return m_cl1b;\n    if (M_IS_LZMA(method))\n        return m_lzma;\n    if (M_IS_NRV2B(method))\n        return m_nrv2b;\n    if (M_IS_NRV2D(method))\n        return m_nrv2d;\n    if (M_IS_NRV2E(method))\n        return m_nrv2e;\n    if (small < 0)\n        small = file_size <= 512 * 1024;\n    if (level == 1 || small)\n        return m_nrv2b;\n    return m_nrv2e;\n}\n\n/*************************************************************************\n// loader util\n**************************************************************************/\n\nstatic bool callsManyTimes(int format) {\n    // clang-format off\n    return\n        UPX_F_LINUX_ELF_i386   ==format\n    ||  UPX_F_LINUX_ELFI_i386  ==format\n    ||  UPX_F_LINUX_ELF64_AMD64==format\n    ||  UPX_F_LINUX_ELF32_ARM  ==format\n    ||  UPX_F_LINUX_ELF32_PPC32   ==format\n    ||  UPX_F_LINUX_ELF64_PPC64LE ==format\n    ||  UPX_F_LINUX_ELF32_ARMEB==format\n    ||  UPX_F_BSD_ELF_i386     ==format\n    ||  UPX_F_VMLINUX_ARM      ==format\n    ||  UPX_F_VMLINUX_ARMEB    ==format\n    ||  UPX_F_VMLINUX_PPC32    ==format\n    ||  UPX_F_VMLINUX_PPC64LE  ==format\n    ||  UPX_F_VMLINUZ_ARM      ==format\n    ||  UPX_F_MACH_PPC32       ==format\n    ||  UPX_F_MACH_PPC64       ==format\n    ||  UPX_F_MACH_i386        ==format\n    ||  UPX_F_DYLIB_i386       ==format\n    ;\n    // clang-format on\n}\n\nconst char *Packer::getDecompressorSections() const {\n    // clang-format off\n    static const char nrv2b_le32_small[] =\n        \"N2BSMA10,N2BDEC10,N2BSMA20,N2BDEC20,N2BSMA30,\"\n        \"N2BDEC30,N2BSMA40,N2BSMA50,N2BDEC50,N2BSMA60,\"\n        \"N2BDEC60\";\n    static const char nrv2b_le32_fast[] =\n        \"N2BFAS10,+80CXXXX,N2BFAS11,N2BDEC10,N2BFAS20,\"\n        \"N2BDEC20,N2BFAS30,N2BDEC30,N2BFAS40,N2BFAS50,\"\n        \"N2BDEC50,N2BFAS60,+40CXXXX,N2BFAS61,N2BDEC60\";\n    static const char nrv2d_le32_small[] =\n        \"N2DSMA10,N2DDEC10,N2DSMA20,N2DDEC20,N2DSMA30,\"\n        \"N2DDEC30,N2DSMA40,N2DSMA50,N2DDEC50,N2DSMA60,\"\n        \"N2DDEC60\";\n    static const char nrv2d_le32_fast[] =\n        \"N2DFAS10,+80CXXXX,N2DFAS11,N2DDEC10,N2DFAS20,\"\n        \"N2DDEC20,N2DFAS30,N2DDEC30,N2DFAS40,N2DFAS50,\"\n        \"N2DDEC50,N2DFAS60,+40CXXXX,N2DFAS61,N2DDEC60\";\n    static const char nrv2e_le32_small[] =\n        \"N2ESMA10,N2EDEC10,N2ESMA20,N2EDEC20,N2ESMA30,\"\n        \"N2EDEC30,N2ESMA40,N2ESMA50,N2EDEC50,N2ESMA60,\"\n        \"N2EDEC60\";\n    static const char nrv2e_le32_fast[] =\n        \"N2EFAS10,+80CXXXX,N2EFAS11,N2EDEC10,N2EFAS20,\"\n        \"N2EDEC20,N2EFAS30,N2EDEC30,N2EFAS40,N2EFAS50,\"\n        \"N2EDEC50,N2EFAS60,+40CXXXX,N2EFAS61,N2EDEC60\";\n#if 0\n    static const char cl1b_le32_small[] =\n        \"CL1ENTER,CL1SMA10,CL1RLOAD,\"\n        \"CL1WID01,CL1SMA1B,\"\n        \"CL1WID02,CL1SMA1B,\"\n        \"CL1WID03,CL1SMA1B,\"\n        \"CL1WID04,CL1SMA1B,\"\n        \"CL1WID05,CL1SMA1B,\"\n        \"CL1WID06,CL1SMA1B,\"\n        \"CL1WID07,CL1SMA1B,\"\n        \"CL1WID08,CL1SMA1B,\"\n        \"CL1WID09,CL1SMA1B,\"\n        \"CL1WID10,\"\n        \"CL1START,\"\n        \"CL1TOP00,CL1SMA1B,\"\n        \"CL1TOP01,CL1SMA1B,\"\n        \"CL1TOP02,CL1SMA1B,\"\n        \"CL1TOP03,CL1SMA1B,\"\n        \"CL1TOP04,CL1SMA1B,\"\n        \"CL1TOP05,CL1SMA1B,\"\n        \"CL1TOP06,CL1SMA1B,\"\n        \"CL1TOP07,CL1SMA1B,\"\n        \"CL1OFF01,CL1SMA1B,\"\n        \"CL1OFF02,CL1SMA1B,\"\n        \"CL1OFF03,CL1SMA1B,\"\n        \"CL1OFF04,\"\n        \"CL1LEN00,CL1SMA1B,\"\n        \"CL1LEN01,CL1SMA1B,\"\n        \"CL1LEN02,\"\n        \"CL1COPY0\";\n    static const char cl1b_le32_fast[] =\n        \"CL1ENTER,\"          \"CL1RLOAD,\"\n        \"CL1WID01,CL1FAS1B,\"\n        \"CL1WID02,CL1FAS1B,\"\n        \"CL1WID03,CL1FAS1B,\"\n        \"CL1WID04,CL1FAS1B,\"\n        \"CL1WID05,CL1FAS1B,\"\n        \"CL1WID06,CL1FAS1B,\"\n        \"CL1WID07,CL1FAS1B,\"\n        \"CL1WID08,CL1FAS1B,\"\n        \"CL1WID09,CL1FAS1B,\"\n        \"CL1WID10,\"\n        \"CL1START,\"\n        \"CL1TOP00,CL1FAS1B,\"\n        \"CL1TOP01,CL1FAS1B,\"\n        \"CL1TOP02,CL1FAS1B,\"\n        \"CL1TOP03,CL1FAS1B,\"\n        \"CL1TOP04,CL1FAS1B,\"\n        \"CL1TOP05,CL1FAS1B,\"\n        \"CL1TOP06,CL1FAS1B,\"\n        \"CL1TOP07,CL1FAS1B,\"\n        \"CL1OFF01,CL1FAS1B,\"\n        \"CL1OFF02,CL1FAS1B,\"\n        \"CL1OFF03,CL1FAS1B,\"\n        \"CL1OFF04,\"\n        \"CL1LEN00,CL1FAS1B,\"\n        \"CL1LEN01,CL1FAS1B,\"\n        \"CL1LEN02,\"\n        \"CL1COPY0\";\n#endif\n    static const char lzma_small[] =\n        \"LZMA_DEC00,LZMA_DEC10,LZMA_DEC30\";\n    static const char lzma_fast[] =\n        \"LZMA_DEC00,LZMA_DEC20,LZMA_DEC30\";\n    static const char lzma_elf_small[] =\n        \"LZMA_ELF00,LZMA_DEC10,LZMA_DEC30\";\n    static const char lzma_elf_fast[] =\n        \"LZMA_ELF00,LZMA_DEC20,LZMA_DEC30\";\n    // clang-format on\n\n    const unsigned method = ph_forced_method(ph.method);\n    if (method == M_NRV2B_LE32)\n        return opt->small ? nrv2b_le32_small : nrv2b_le32_fast;\n    if (method == M_NRV2D_LE32)\n        return opt->small ? nrv2d_le32_small : nrv2d_le32_fast;\n    if (method == M_NRV2E_LE32)\n        return opt->small ? nrv2e_le32_small : nrv2e_le32_fast;\n    //    if (method == M_CL1B_LE32)\n    //        return opt->small ? cl1b_le32_small  : cl1b_le32_fast;\n    if (M_IS_LZMA(method)) {\n        if (callsManyTimes(ph.format)) {\n            return opt->small ? lzma_elf_small : lzma_elf_fast;\n        }\n        return opt->small ? lzma_small : lzma_fast;\n    }\n    throwInternalError(\"bad decompressor\");\n    return nullptr;\n}\n\nunsigned Packer::getDecompressorWrkmemSize() const {\n    unsigned size = 0;\n    if (M_IS_LZMA(ph.method)) {\n        const lzma_compress_result_t *res = &ph.compress_result.result_lzma;\n        // FIXME - this is for i386 only\n        size = 8 + 4 + ALIGN_UP(2 * res->num_probs, 4u);\n        size = ALIGN_UP(size, 16u);\n    }\n    assert((int) size >= 0);\n    return size;\n}\n\nvoid Packer::defineDecompressorSymbols() {\n    if (callsManyTimes(ph.format)) {\n        // ELF calls the decompressor many times; the parameters change!\n        return;\n    }\n    if (M_IS_LZMA(ph.method)) {\n        const lzma_compress_result_t *res = &ph.compress_result.result_lzma;\n        upx_uint32_t properties = // lc, lp, pb, dummy\n            (res->lit_context_bits << 0) | (res->lit_pos_bits << 8) | (res->pos_bits << 16);\n        if (bele->isBE()) // big endian - bswap32\n            properties = bswap32(properties);\n\n        linker->defineSymbol(\"lzma_properties\", properties);\n        // len - 2 because of properties\n        if (linker->findSymbol(\"lzma_c_len\", false)) {\n            linker->defineSymbol(\"lzma_c_len\", ph.c_len - 2);\n        }\n        if (linker->findSymbol(\"lzma_u_len\", false)) {\n            linker->defineSymbol(\"lzma_u_len\", ph.u_len);\n        }\n        unsigned stack = getDecompressorWrkmemSize();\n        linker->defineSymbol(\"lzma_stack_adjust\", 0u - stack);\n\n        if (ph.format == UPX_F_DOS_EXE) {\n            linker->defineSymbol(\"lzma_properties_hi\", properties >> 16); // pb\n            linker->defineSymbol(\"lzma_c_len_hi\", (ph.c_len - 2) >> 16);\n            linker->defineSymbol(\"lzma_u_len_hi\", ph.u_len >> 16);\n            linker->defineSymbol(\"lzma_u_len_segment\", (ph.u_len & 0xf0000) >> 4);\n        }\n    }\n}\n\n/* vim:set ts=4 sw=4 et: */\n","size_bytes":10310},"src/packer_f.cpp":{"content":"/* packer_f.cpp -- Packer filter handling\n\n   This file is part of the Resize executable compressor.\n\n   Copyright (C) 2025 WHO-AM-I-404\n   Based on UPX - Ultimate Packer for eXecutables\n   Copyright (C) 1996-2025 Markus Franz Xaver Johannes Oberhumer\n   Copyright (C) 1996-2025 Laszlo Molnar\n   All Rights Reserved.\n\n   Resize and the UCL library are free software; you can redistribute them\n   and/or modify them under the terms of the GNU General Public License as\n   published by the Free Software Foundation; either version 2 of\n   the License, or (at your option) any later version.\n\n   This program is distributed in the hope that it will be useful,\n   but WITHOUT ANY WARRANTY; without even the implied warranty of\n   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n   GNU General Public License for more details.\n\n   You should have received a copy of the GNU General Public License\n   along with this program; see the file COPYING.\n   If not, write to the Free Software Foundation, Inc.,\n   59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.\n\n   WHO-AM-I-404 <who-am-i-404@proton.me>\n   Based on original work by:\n   Markus F.X.J. Oberhumer <markus@oberhumer.com>\n   Laszlo Molnar <ezerotven+github@gmail.com>\n */\n\n#include \"conf.h\"\n#include \"packer.h\"\n#include \"filter.h\"\n#include \"linker.h\"\n\n/*************************************************************************\n// filter util; see class FilterImpl\n**************************************************************************/\n\nbool Packer::isValidFilter(int filter_id) const {\n    return Filter::isValidFilter(filter_id, getFilters());\n}\n\n/*************************************************************************\n// addFilter32\n**************************************************************************/\n\n#define NOFILT 0 // no filter\n#define FNOMRU 1 // filter, but not using mru\n#define MRUFLT 2 // mru filter\n\nstatic inline unsigned f80_call(int filter_id) { return (1 + (0x0f & filter_id)) % 3; }\n\nstatic inline unsigned f80_jmp1(int filter_id) { return ((1 + (0x0f & filter_id)) / 3) % 3; }\n\nstatic inline unsigned f80_jcc2(int filter_id) { return f80_jmp1(filter_id); }\n\nvoid Packer::addFilter32(int filter_id) {\n    assert(filter_id > 0);\n    assert(isValidFilter(filter_id));\n\n    if (filter_id < 0x80) {\n        if (0x50 == (0xF0 & filter_id)) {\n            addLoader(\"ctok32.00\",\n                      ((0x50 == filter_id)   ? \"ctok32.50\"\n                       : (0x51 == filter_id) ? \"ctok32.51\"\n                                             : \"\"),\n                      \"ctok32.10\");\n        } else if ((filter_id & 0xf) % 3 == 0) {\n            if (filter_id < 0x40) {\n                addLoader(\"CALLTR00\", (filter_id > 0x20) ? \"CTCLEVE1\" : \"\", \"CALLTR01\",\n                          (filter_id & 0xf) > 3\n                              ? (filter_id > 0x20 ? \"CTBSHR01,CTBSWA01\" : \"CTBROR01,CTBSWA01\")\n                              : \"\",\n                          \"CALLTR02\");\n            } else if (0x40 == (0xF0 & filter_id)) {\n                addLoader(\"ctok32.00\");\n                if (9 <= (0xf & filter_id)) {\n                    addLoader(\"ctok32.10\");\n                }\n                addLoader(\"ctok32.20\");\n                if (9 <= (0xf & filter_id)) {\n                    addLoader(\"ctok32.30\");\n                }\n                addLoader(\"ctok32.40\");\n            }\n        } else\n            addLoader(\"CALLTR10\", (filter_id & 0xf) % 3 == 1 ? \"CALLTRE8\" : \"CALLTRE9\", \"CALLTR11\",\n                      (filter_id > 0x20) ? \"CTCLEVE2\" : \"\", \"CALLTR12\",\n                      (filter_id & 0xf) > 3\n                          ? (filter_id > 0x20 ? \"CTBSHR11,CTBSWA11\" : \"CTBROR11,CTBSWA11\")\n                          : \"\",\n                      \"CALLTR13\");\n    }\n    if (0x80 == (filter_id & 0xF0)) {\n        const bool x386 = (opt->cpu_x86 <= opt->CPU_386);\n        const unsigned n_mru = ph.n_mru ? 1 + ph.n_mru : 0;\n        const bool mrupwr2 = (0 != n_mru) && 0 == ((n_mru - 1) & n_mru);\n        const unsigned f_call = f80_call(filter_id);\n        const unsigned f_jmp1 = f80_jmp1(filter_id);\n        const unsigned f_jcc2 = f80_jcc2(filter_id);\n\n        if (NOFILT != f_jcc2) {\n            addLoader(\"LXJCC010\");\n            if (n_mru) {\n                addLoader(\"LXMRU045\");\n            } else {\n                addLoader(\"LXMRU046\");\n            }\n            if (0 == n_mru || MRUFLT != f_jcc2) {\n                addLoader(\"LXJCC020\");\n            } else { // 0 != n_mru\n                addLoader(\"LXJCC021\");\n            }\n            if (NOFILT != f_jcc2) {\n                addLoader(\"LXJCC023\");\n            }\n        }\n        addLoader(\"LXUNF037\");\n        if (x386) {\n            if (n_mru) {\n                addLoader(\"LXUNF386\");\n            }\n            addLoader(\"LXUNF387\");\n            if (n_mru) {\n                addLoader(\"LXUNF388\");\n            }\n        } else {\n            addLoader(\"LXUNF486\");\n            if (n_mru) {\n                addLoader(\"LXUNF487\");\n            }\n        }\n        if (n_mru) {\n            addLoader(\"LXMRU065\");\n            if (256 == n_mru) {\n                addLoader(\"MRUBYTE3\");\n            } else {\n                addLoader(\"MRUARB30\");\n                if (mrupwr2) {\n                    addLoader(\"MRUBITS3\");\n                } else {\n                    addLoader(\"MRUARB40\");\n                }\n            }\n            addLoader(\"LXMRU070\");\n            if (256 == n_mru) {\n                addLoader(\"MRUBYTE4\");\n            } else if (mrupwr2) {\n                addLoader(\"MRUBITS4\");\n            } else {\n                addLoader(\"MRUARB50\");\n            }\n            addLoader(\"LXMRU080\");\n            if (256 == n_mru) {\n                addLoader(\"MRUBYTE5\");\n            } else {\n                addLoader(\"MRUARB60\");\n                if (mrupwr2) {\n                    addLoader(\"MRUBITS5\");\n                } else {\n                    addLoader(\"MRUARB70\");\n                }\n            }\n            addLoader(\"LXMRU090\");\n            if (256 == n_mru) {\n                addLoader(\"MRUBYTE6\");\n            } else {\n                addLoader(\"MRUARB80\");\n                if (mrupwr2) {\n                    addLoader(\"MRUBITS6\");\n                } else {\n                    addLoader(\"MRUARB90\");\n                }\n            }\n            addLoader(\"LXMRU100\");\n        }\n        addLoader(\"LXUNF040\");\n        if (n_mru) {\n            addLoader(\"LXMRU110\");\n        } else {\n            addLoader(\"LXMRU111\");\n        }\n        addLoader(\"LXUNF041\");\n        addLoader(\"LXUNF042\");\n        if (n_mru) {\n            addLoader(\"LXMRU010\");\n            if (NOFILT != f_jmp1 && NOFILT == f_call) {\n                addLoader(\"LXJMPA00\");\n            } else {\n                addLoader(\"LXCALLB0\");\n            }\n            addLoader(\"LXUNF021\");\n        } else {\n            addLoader(\"LXMRU022\");\n            if (NOFILT != f_jmp1 && NOFILT == f_call) {\n                addLoader(\"LXJMPA01\");\n            } else {\n                addLoader(\"LXCALLB1\");\n            }\n        }\n        if (n_mru) {\n            if (256 != n_mru && mrupwr2) {\n                addLoader(\"MRUBITS1\");\n            }\n            addLoader(\"LXMRU030\");\n            if (256 == n_mru) {\n                addLoader(\"MRUBYTE1\");\n            } else {\n                addLoader(\"MRUARB10\");\n            }\n            addLoader(\"LXMRU040\");\n        }\n\n        addLoader(\"LXUNF030\");\n        if (NOFILT != f_jcc2) {\n            addLoader(\"LXJCC000\");\n        }\n        if (NOFILT != f_call || NOFILT != f_jmp1) { // at least one is filtered\n            // shift opcode origin to zero\n            if (0 == n_mru) {\n                addLoader(\"LXCJ0MRU\");\n            } else {\n                addLoader(\"LXCJ1MRU\");\n            }\n\n            // determine if in range\n            if ((NOFILT != f_call) && (NOFILT != f_jmp1)) { // unfilter both\n                addLoader(\"LXCALJMP\");\n            }\n            if ((NOFILT == f_call) ^ (NOFILT == f_jmp1)) { // unfilter just one\n                if (0 == n_mru) {\n                    addLoader(\"LXCALL00\");\n                } else {\n                    addLoader(\"LXCALL01\");\n                }\n            }\n\n            // determine if mru applies\n            if (0 == n_mru || !((FNOMRU == f_call) || (FNOMRU == f_jmp1))) {\n                // no mru, or no exceptions\n                addLoader(\"LXCJ2MRU\");\n            } else {\n                // mru on one, but not the other\n                addLoader(\"LXCJ4MRU\");\n                if (MRUFLT == f_jmp1) { // JMP only\n                    addLoader(\"LXCJ6MRU\");\n                } else if (MRUFLT == f_call) { // CALL only\n                    addLoader(\"LXCJ7MRU\");\n                }\n                addLoader(\"LXCJ8MRU\");\n            }\n        }\n        addLoader(\"LXUNF034\");\n        if (n_mru) {\n            addLoader(\"LXMRU055\");\n            if (256 == n_mru) {\n                addLoader(\"MRUBYTE2\");\n            } else if (mrupwr2) {\n                addLoader(\"MRUBITS2\");\n            } else {\n                addLoader(\"MRUARB20\");\n            }\n            addLoader(\"LXMRU057\");\n        }\n    }\n}\n\n#undef NOFILT\n#undef FNOMRU\n#undef MRUFLT\n\n/*************************************************************************\n//\n**************************************************************************/\n\nvoid Packer::defineFilterSymbols(const Filter *ft) {\n    if (ft->id == 0) {\n        linker->defineSymbol(\"filter_length\", 0);\n        linker->defineSymbol(\"filter_cto\", 0);\n        return;\n    }\n    assert(ft->calls > 0);\n    assert(ft->buf_len > 0);\n\n    if (ft->id >= 0x40 && ft->id <= 0x4f) {\n        linker->defineSymbol(\"filter_length\", ft->buf_len);\n        linker->defineSymbol(\"filter_cto\", ft->cto);\n    } else if (ft->id >= 0x50 && ft->id <= 0x5f) {\n        linker->defineSymbol(\"filter_id\", ft->id);\n        linker->defineSymbol(\"filter_cto\", ft->cto);\n    } else if ((ft->id & 0xf) % 3 == 0) {\n        linker->defineSymbol(\"filter_length\", ft->calls);\n        linker->defineSymbol(\"filter_cto\", ft->cto);\n    } else {\n        linker->defineSymbol(\"filter_length\", ft->lastcall - ft->calls * 4);\n        linker->defineSymbol(\"filter_cto\", ft->cto);\n    }\n\n#if 0\n    if (0x80 == (ft->id & 0xF0)) {\n        const int mru = ph.n_mru ? 1 + ph.n_mru : 0;\n        if (mru && mru != 256) {\n            const unsigned is_pwr2 = (0 == ((mru - 1) & mru));\n            // patch_le32(0x80 + (char *) loader, lsize - 0x80, \"NMRU\", mru - is_pwr2);\n        }\n    }\n#endif\n}\n\n/* vim:set ts=4 sw=4 et: */\n","size_bytes":10552},"src/packer_r.cpp":{"content":"/* packer_r.cpp -- Packer relocation handling\n\n   This file is part of the Resize executable compressor.\n\n   Copyright (C) 2025 WHO-AM-I-404\n   Based on UPX - Ultimate Packer for eXecutables\n   Copyright (C) 1996-2025 Markus Franz Xaver Johannes Oberhumer\n   Copyright (C) 1996-2025 Laszlo Molnar\n   All Rights Reserved.\n\n   Resize and the UCL library are free software; you can redistribute them\n   and/or modify them under the terms of the GNU General Public License as\n   published by the Free Software Foundation; either version 2 of\n   the License, or (at your option) any later version.\n\n   This program is distributed in the hope that it will be useful,\n   but WITHOUT ANY WARRANTY; without even the implied warranty of\n   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n   GNU General Public License for more details.\n\n   You should have received a copy of the GNU General Public License\n   along with this program; see the file COPYING.\n   If not, write to the Free Software Foundation, Inc.,\n   59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.\n\n   WHO-AM-I-404 <who-am-i-404@proton.me>\n   Based on original work by:\n   Markus F.X.J. Oberhumer <markus@oberhumer.com>\n   Laszlo Molnar <ezerotven+github@gmail.com>\n */\n\n#include \"conf.h\"\n#include \"packer.h\"\n\n/*************************************************************************\n// sort and delta-compress relocations with optional bswap within image\n// returns number of **bytes** written to 'out'\n**************************************************************************/\n\n/*static*/\nunsigned Packer::optimizeReloc(unsigned relocnum, SPAN_P(byte) relocs, SPAN_S(byte) out,\n                               SPAN_P(byte) image, unsigned image_size, int bits, bool bswap,\n                               int *big) {\n    assert(bits == 32 || bits == 64);\n    mem_size_assert(1, image_size);\n#if WITH_XSPAN >= 2\n    ptr_check_no_overlap(relocs.data(), relocs.size_bytes(), image.data(image_size), image_size,\n                         out.data(), out.size_bytes());\n#endif\n    SPAN_S_VAR(byte, fix, out);\n\n    *big = 0;\n    if (opt->exact)\n        throwCantPackExact();\n    if (relocnum == 0)\n        return 0;\n    upx_qsort(raw_bytes(relocs, 4 * relocnum), relocnum, 4, le32_compare);\n    if (0) {\n        printf(\"optimizeReloc: u_reloc %9u checksum=0x%08x\\n\", 4 * relocnum,\n               upx_adler32(relocs, 4 * relocnum));\n        printf(\"optimizeReloc: u_image %9u checksum=0x%08x\\n\", image_size,\n               upx_adler32(image, image_size));\n    }\n\n    unsigned pc = (unsigned) -4;\n    for (unsigned i = 0; i < relocnum; i++) {\n        unsigned delta = get_le32(relocs + i * 4) - pc;\n        if (delta == 0)\n            continue;\n        else if ((int) delta < 4)\n            throwCantPack(\"overlapping fixups\");\n        else if (delta < 0xf0)\n            *fix++ = (byte) delta;\n        else if (delta < 0x100000) {\n            *fix++ = (byte) (0xf0 + (delta >> 16));\n            *fix++ = (byte) delta;\n            *fix++ = (byte) (delta >> 8);\n        } else {\n            *big = 1;\n            *fix++ = 0xf0;\n            *fix++ = 0;\n            *fix++ = 0;\n            set_le32(fix, delta);\n            fix += 4;\n        }\n        pc += delta;\n        if (pc + 4 > image_size)\n            throwCantPack(\"bad reloc[%#x] = %#x\", i, pc);\n        if (bswap) {\n            if (bits == 32)\n                set_be32(image + pc, get_le32(image + pc));\n            else\n                set_be64(image + pc, get_le64(image + pc));\n        }\n    }\n    *fix++ = 0; // end marker\n    const unsigned bytes = ptr_udiff_bytes(fix, out);\n    if (0) {\n        printf(\"optimizeReloc: c_reloc %9u checksum=0x%08x\\n\", bytes, upx_adler32(out, bytes));\n        printf(\"optimizeReloc: c_image %9u checksum=0x%08x\\n\", image_size,\n               upx_adler32(image, image_size));\n    }\n    return bytes;\n}\n\n/*************************************************************************\n// delta-decompress relocations\n// advances 'in'\n// allocates 'out' and returns number of **relocs** written to 'out'\n**************************************************************************/\n\n/*static*/\nunsigned Packer::unoptimizeReloc(SPAN_S(const byte) & in, MemBuffer &out, SPAN_P(byte) image,\n                                 unsigned image_size, int bits, bool bswap) {\n    assert(bits == 32 || bits == 64);\n    mem_size_assert(1, image_size);\n#if WITH_XSPAN >= 2\n    ptr_check_no_overlap(in.data(), in.size_bytes(), image.data(image_size), image_size);\n#endif\n    SPAN_S_VAR(const byte, fix, in);\n\n    // count\n    unsigned relocnum = 0;\n    for (fix = in; *fix; fix++, relocnum++) {\n        if (*fix >= 0xf0) {\n            if (*fix == 0xf0 && get_le16(fix + 1) == 0)\n                fix += 4;\n            fix += 2;\n        }\n    }\n    NO_fprintf(stderr, \"relocnum=%x\\n\", relocnum);\n    if (0) {\n        const unsigned bytes = ptr_udiff_bytes(fix + 1, in);\n        printf(\"unoptimizeReloc: c_reloc %9u checksum=0x%08x\\n\", bytes, upx_adler32(in, bytes));\n        printf(\"unoptimizeReloc: c_image %9u checksum=0x%08x\\n\", image_size,\n               upx_adler32(image, image_size));\n    }\n\n    out.alloc(mem_size(4, relocnum + 1)); // one extra entry\n    SPAN_S_VAR(LE32, relocs, out);\n\n    fix = in;\n    unsigned pc = (unsigned) -4;\n    for (unsigned i = 0; i < relocnum; i++) {\n        unsigned delta;\n        if (*fix < 0xf0)\n            delta = *fix++;\n        else {\n            delta = (*fix & 0x0f) * 0x10000 + get_le16(fix + 1);\n            fix += 3;\n            if (delta == 0) {\n                delta = get_le32(fix);\n                fix += 4;\n            }\n        }\n        if ((int) delta < 4)\n            throwCantUnpack(\"overlapping fixups\");\n        pc += delta;\n        if (pc + 4 > image_size)\n            throwCantUnpack(\"bad reloc[%#x] = %#x\", i, pc);\n        *relocs++ = pc;\n        if (bswap) {\n            if (bits == 32)\n                set_be32(image + pc, get_le32(image + pc));\n            else\n                set_be64(image + pc, get_le64(image + pc));\n        }\n    }\n    in = fix + 1; // advance\n    assert(relocnum == ptr_udiff_bytes(relocs, raw_bytes(out, 0)) / 4);\n    if (0) {\n        printf(\"unoptimizeReloc: u_reloc %9u checksum=0x%08x\\n\", 4 * relocnum,\n               upx_adler32(out, 4 * relocnum));\n        printf(\"unoptimizeReloc: u_image %9u checksum=0x%08x\\n\", image_size,\n               upx_adler32(image, image_size));\n    }\n    return relocnum;\n}\n\n/* vim:set ts=4 sw=4 et: */\n","size_bytes":6470},"src/packhead.cpp":{"content":"/* packhead.cpp --\n\n   This file is part of the Resize executable compressor.\n\n   Copyright (C) 2025 WHO-AM-I-404\n   Based on UPX - Ultimate Packer for eXecutables\n   Copyright (C) 1996-2025 Markus Franz Xaver Johannes Oberhumer\n   Copyright (C) 1996-2025 Laszlo Molnar\n   All Rights Reserved.\n\n   Resize and the UCL library are free software; you can redistribute them\n   and/or modify them under the terms of the GNU General Public License as\n   published by the Free Software Foundation; either version 2 of\n   the License, or (at your option) any later version.\n\n   This program is distributed in the hope that it will be useful,\n   but WITHOUT ANY WARRANTY; without even the implied warranty of\n   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n   GNU General Public License for more details.\n\n   You should have received a copy of the GNU General Public License\n   along with this program; see the file COPYING.\n   If not, write to the Free Software Foundation, Inc.,\n   59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.\n\n   WHO-AM-I-404 <who-am-i-404@proton.me>\n   Based on original work by:\n   Markus F.X.J. Oberhumer <markus@oberhumer.com>\n   Laszlo Molnar <ezerotven+github@gmail.com>\n */\n\n#include \"conf.h\"\n#include \"packhead.h\"\n#include \"filter.h\" // for ft->unfilter()\n\n/*************************************************************************\n// PackHeader\n//\n// We try to be able to unpack UPX 0.7x (versions 8 & 9) and at\n// least to detect older versions, so this is a little bit messy.\n**************************************************************************/\n\nPackHeader::PackHeader() noexcept { reset(); }\n\nvoid PackHeader::reset() noexcept {\n    mem_clear(this);\n    version = -1;\n    format = -1;\n    compress_result.reset();\n}\n\nint PackHeader::set_method(int m, unsigned offset) {\n    unsigned mc = ~(0x80u << 24) & m; // see ph_forced_method\n    unsigned lo = 0xFF & m;\n    // See packer_c.cpp for \"hi bytes\" in M_LZMA_003 and M_LZMA_407.\n    // \"hi bytes\" are not allowed unless M_LZMA.\n    if ((lo < M_NRV2B_LE32 || M_LZMA < lo || (M_LZMA != lo && mc != lo)) && ~0u != offset)\n        throwCantPack(\"bad method %#x at %#x\", (unsigned) m, offset);\n    return method = m;\n}\n\n/*************************************************************************\n// extremely simple checksum for the header itself (since version 10)\n**************************************************************************/\n\nstatic upx_uint8_t get_packheader_checksum(SPAN_S(const byte) buf, int blen) {\n    assert(blen >= 4);\n    assert(get_le32(buf) == UPX_MAGIC_LE32);\n    buf += 4;\n    blen -= 4;\n    unsigned c = 0;\n    while (blen-- > 0)\n        c += *buf++;\n    c %= 251;\n    return (upx_uint8_t) c;\n}\n\n/*************************************************************************\n//\n**************************************************************************/\n\n// Returns the size that will be generated based on version and format,\n// not necessarily the size that actually is present in spoofed input.\nint PackHeader::getPackHeaderSize() const {\n    if (format < 0 || version < 0)\n        throwInternalError(\"getPackHeaderSize\");\n\n    int n = 0;\n    if (version <= 3) // Note: covers (version <= 0)\n        n = 24;\n    else if (version <= 9) {\n        if (format == UPX_F_DOS_COM || format == UPX_F_DOS_SYS)\n            n = 20;\n        else if (format == UPX_F_DOS_EXE || format == UPX_F_DOS_EXEH)\n            n = 25;\n        else\n            n = 28;\n    } else {\n        if (format == UPX_F_DOS_COM || format == UPX_F_DOS_SYS)\n            n = 22;\n        else if (format == UPX_F_DOS_EXE || format == UPX_F_DOS_EXEH)\n            n = 27;\n        else\n            n = 32;\n    }\n    if (n < 20)\n        throwCantUnpack(\"unknown header version\");\n    return n;\n}\n\n/*************************************************************************\n// see stub/src/include/header.S\n**************************************************************************/\n\nvoid PackHeader::putPackHeader(SPAN_S(byte) p) const {\n    // NOTE: It is the caller's responsibility to ensure the buffer p has\n    // sufficient space for the header.\n    assert(get_le32(p) == UPX_MAGIC_LE32);\n    if (get_le32(p + 4) != UPX_MAGIC2_LE32) {\n        NO_fprintf(stderr, \"MAGIC2_LE32: %x %x\\n\", get_le32(p + 4), UPX_MAGIC2_LE32);\n        throwBadLoader();\n    }\n\n    int size = 0;\n    upx_uint8_t old_chksum = 0;\n\n    // the new variable length header\n    if (format < 128) { // little endian\n        if (format == UPX_F_DOS_COM || format == UPX_F_DOS_SYS) {\n            size = 22;\n            old_chksum = get_packheader_checksum(p, size - 1);\n            set_le16(p + 16, u_len);\n            set_le16(p + 18, c_len);\n            p[20] = (byte) filter;\n        } else if (format == UPX_F_DOS_EXE) {\n            size = 27;\n            old_chksum = get_packheader_checksum(p, size - 1);\n            set_le24(p + 16, u_len);\n            set_le24(p + 19, c_len);\n            set_le24(p + 22, u_file_size);\n            p[25] = (byte) filter;\n        } else if (format == UPX_F_DOS_EXEH) {\n            throwInternalError(\"invalid format\");\n        } else {\n            size = 32;\n            old_chksum = get_packheader_checksum(p, size - 1);\n            set_le32(p + 16, u_len);\n            set_le32(p + 20, c_len);\n            set_le32(p + 24, u_file_size);\n            p[28] = (byte) filter;\n            p[29] = (byte) filter_cto;\n            assert(n_mru == 0 || (n_mru >= 2 && n_mru <= 256));\n            p[30] = (byte) (n_mru ? n_mru - 1 : 0);\n        }\n        set_le32(p + 8, u_adler);\n        set_le32(p + 12, c_adler);\n    } else { // big endian\n        size = 32;\n        old_chksum = get_packheader_checksum(p, size - 1);\n        set_be32(p + 8, u_len);\n        set_be32(p + 12, c_len);\n        set_be32(p + 16, u_adler);\n        set_be32(p + 20, c_adler);\n        set_be32(p + 24, u_file_size);\n        p[28] = (byte) filter;\n        p[29] = (byte) filter_cto;\n        assert(n_mru == 0 || (n_mru >= 2 && n_mru <= 256));\n        p[30] = (byte) (n_mru ? n_mru - 1 : 0);\n    }\n\n    p[4] = (byte) version;\n    p[5] = (byte) format;\n    p[6] = (byte) method;\n    p[7] = (byte) level;\n\n    // header_checksum\n    assert(size == getPackHeaderSize());\n    // check old header_checksum\n    if (p[size - 1] != 0) {\n        if (p[size - 1] != old_chksum) {\n            // printf(\"old_checksum: %d %d\\n\", p[size - 1], old_chksum);\n            throwBadLoader();\n        }\n    }\n    // store new header_checksum\n    p[size - 1] = get_packheader_checksum(p, size - 1);\n}\n\n/*************************************************************************\n//\n**************************************************************************/\n\nbool PackHeader::decodePackHeaderFromBuf(SPAN_S(const byte) buf, int blen) {\n    int boff = find_le32(raw_bytes(buf, blen), blen, UPX_MAGIC_LE32);\n    if (boff < 0)\n        return false;\n    blen -= boff; // bytes remaining in buf\n    if (blen < 20)\n        throwCantUnpack(\"header corrupted 1\");\n\n    SPAN_S_VAR(const byte, const p, buf + boff);\n\n    version = p[4];\n    format = p[5];\n    method = p[6];\n    level = p[7];\n    filter_cto = 0;\n\n    if (opt->debug.debug_level) {\n        fprintf(stderr, \"  decodePackHeaderFromBuf  version=%d  format=%d  method=%d  level=%d\\n\",\n                version, format, method, level);\n    }\n    if (!((format >= 1 && format <= UPX_F_W64PE_ARM64EC) ||\n          (format >= 129 && format <= UPX_F_DYLIB_PPC64))) {\n        throwCantUnpack(\"unknown format %d\", format);\n    }\n\n    //\n    // decode the new variable length header\n    //\n\n    int off_filter = 0;\n    if (format < 128) {\n        u_adler = get_le32(p + 8);\n        c_adler = get_le32(p + 12);\n        if (format == UPX_F_DOS_COM || format == UPX_F_DOS_SYS) {\n            u_len = get_le16(p + 16);\n            c_len = get_le16(p + 18);\n            u_file_size = u_len;\n            off_filter = 20;\n        } else if (format == UPX_F_DOS_EXE || format == UPX_F_DOS_EXEH) {\n            if (blen < 25)\n                throwCantUnpack(\"header corrupted 6\");\n            u_len = get_le24(p + 16);\n            c_len = get_le24(p + 19);\n            u_file_size = get_le24(p + 22);\n            off_filter = 25;\n        } else {\n            if (blen < 31)\n                throwCantUnpack(\"header corrupted 7\");\n            u_len = get_le32(p + 16);\n            c_len = get_le32(p + 20);\n            u_file_size = get_le32(p + 24);\n            off_filter = 28;\n            filter_cto = p[29];\n            n_mru = p[30] ? 1 + p[30] : 0;\n        }\n    } else {\n        if (blen < 31)\n            throwCantUnpack(\"header corrupted 8\");\n        u_len = get_be32(p + 8);\n        c_len = get_be32(p + 12);\n        u_adler = get_be32(p + 16);\n        c_adler = get_be32(p + 20);\n        u_file_size = get_be32(p + 24);\n        off_filter = 28;\n        filter_cto = p[29];\n        n_mru = p[30] ? 1 + p[30] : 0;\n    }\n\n    if (version >= 10) {\n        if (blen < off_filter + 1)\n            throwCantUnpack(\"header corrupted 9\");\n        filter = p[off_filter];\n    } else if ((level & 128) == 0)\n        filter = 0;\n    else {\n        // convert old flags to new filter id\n        level &= 127;\n        if (format == UPX_F_DOS_COM || format == UPX_F_DOS_SYS)\n            filter = 0x06;\n        else\n            filter = 0x26;\n    }\n    level &= 15;\n\n    //\n    // now some checks\n    //\n\n    if (version == 0xff)\n        throwCantUnpack(\"cannot unpack UPX ;-)\");\n    // check header_checksum\n    if (version >= 10) {\n        int size = getPackHeaderSize(); // expected; based on format and version\n        if (size > blen || p[size - 1] != get_packheader_checksum(p, size - 1))\n            throwCantUnpack(\"header corrupted 3\");\n    }\n    if (c_len < 2 || u_len < 2 || !mem_size_valid_bytes(c_len) || !mem_size_valid_bytes(u_len))\n        throwCantUnpack(\"header corrupted 4\");\n\n    //\n    // success\n    //\n\n    this->buf_offset = boff;\n    return true;\n}\n\n/*************************************************************************\n// ph method util\n**************************************************************************/\n\nbool ph_is_forced_method(int method) noexcept // predicate\n{\n    return (method >> 24) == -0x80;\n}\n\nint ph_force_method(int method) noexcept // mark as forced\n{\n    return method | (0x80u << 24);\n}\n\nint ph_forced_method(int method) noexcept // extract the forced method\n{\n    if (ph_is_forced_method(method))\n        method &= ~(0x80u << 24);\n    assert_noexcept(method > 0);\n    return method;\n}\n\nbool ph_skipVerify(const PackHeader &ph) noexcept {\n    if (M_IS_DEFLATE(ph.method))\n        return false;\n    if (M_IS_LZMA(ph.method))\n        return false;\n    if (ph.level > 1)\n        return false;\n    return true;\n}\n\n/*************************************************************************\n// ph decompress util\n**************************************************************************/\n\nvoid ph_decompress(PackHeader &ph, SPAN_P(const byte) in, SPAN_P(byte) out, bool verify_checksum,\n                   Filter *ft) {\n    // verify checksum of compressed data\n    if (verify_checksum) {\n        unsigned adler = upx_adler32(raw_bytes(in, ph.c_len), ph.c_len, ph.saved_c_adler);\n        if (adler != ph.c_adler)\n            throwChecksumError();\n    }\n\n    // decompress\n    if (ph.u_len < ph.c_len)\n        throwCantUnpack(\"header corrupted\");\n    unsigned new_len = ph.u_len;\n    int r = upx_decompress(raw_bytes(in, ph.c_len), ph.c_len, raw_bytes(out, ph.u_len), &new_len,\n                           ph_forced_method(ph.method), &ph.compress_result);\n    if (r == UPX_E_OUT_OF_MEMORY)\n        throwOutOfMemoryException();\n    if (r != UPX_E_OK || new_len != ph.u_len)\n        throwCompressedDataViolation();\n\n    // verify checksum of decompressed data\n    if (verify_checksum) {\n        if (ft)\n            ft->unfilter(out, ph.u_len);\n        unsigned adler = upx_adler32(raw_bytes(out, ph.u_len), ph.u_len, ph.saved_u_adler);\n        if (adler != ph.u_adler)\n            throwChecksumError();\n    }\n}\n\n/*************************************************************************\n// ph overlapping decompression util\n**************************************************************************/\n\nbool ph_testOverlappingDecompression(const PackHeader &ph, const byte *buf, const byte *tbuf,\n                                     unsigned overlap_overhead) {\n    if (ph.c_len >= ph.u_len)\n        return false;\n\n    assert((int) overlap_overhead >= 0);\n    assert((int) (ph.u_len + overlap_overhead) >= 0);\n    const int method = ph_forced_method(ph.method);\n\n    // Because upx_test_overlap() does not use the asm_fast decompressor\n    // we must account for extra 3 bytes that asm_fast does use,\n    // or else we may fail at runtime decompression.\n    unsigned extra = 0;\n    if (M_IS_NRV2B(method) || M_IS_NRV2D(method) || M_IS_NRV2E(method))\n        extra = 3;\n    if (overlap_overhead <= 4 + extra) // don't waste time here\n        return false;\n    overlap_overhead -= extra;\n\n    unsigned src_off = ph.u_len + overlap_overhead - ph.c_len;\n    unsigned new_len = ph.u_len;\n    int r = upx_test_overlap(buf - src_off, tbuf, src_off, ph.c_len, &new_len, method,\n                             &ph.compress_result);\n    if (r == UPX_E_OUT_OF_MEMORY)\n        throwOutOfMemoryException();\n    return (r == UPX_E_OK && new_len == ph.u_len);\n}\n\n/* vim:set ts=4 sw=4 et: */\n","size_bytes":13395},"src/packmast.cpp":{"content":"/* packmast.cpp --\n\n   This file is part of the Resize executable compressor.\n\n   Copyright (C) 2025 WHO-AM-I-404\n   Based on UPX - Ultimate Packer for eXecutables\n   Copyright (C) 1996-2025 Markus Franz Xaver Johannes Oberhumer\n   Copyright (C) 1996-2025 Laszlo Molnar\n   All Rights Reserved.\n\n   Resize and the UCL library are free software; you can redistribute them\n   and/or modify them under the terms of the GNU General Public License as\n   published by the Free Software Foundation; either version 2 of\n   the License, or (at your option) any later version.\n\n   This program is distributed in the hope that it will be useful,\n   but WITHOUT ANY WARRANTY; without even the implied warranty of\n   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n   GNU General Public License for more details.\n\n   You should have received a copy of the GNU General Public License\n   along with this program; see the file COPYING.\n   If not, write to the Free Software Foundation, Inc.,\n   59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.\n\n   WHO-AM-I-404 <who-am-i-404@proton.me>\n   Based on original work by:\n   Markus F.X.J. Oberhumer <markus@oberhumer.com>\n   Laszlo Molnar <ezerotven+github@gmail.com>\n */\n\n// dispatch to a concrete subclass of class PackerBase; see work.cpp\n\n#include \"conf.h\"\n#include \"file.h\"\n#include \"packmast.h\"\n#include \"packer.h\"\n\n#include \"lefile.h\"\n#include \"pefile.h\"\n#include \"p_elf.h\"\n#include \"p_unix.h\"\n\n#include \"p_com.h\"\n#include \"p_djgpp2.h\"\n#include \"p_exe.h\"\n#include \"p_lx_elf.h\"\n#include \"p_lx_exc.h\"\n#include \"p_lx_interp.h\"\n#include \"p_lx_sh.h\"\n#include \"p_mach.h\"\n#include \"p_ps1.h\"\n#include \"p_sys.h\"\n#include \"p_tmt.h\"\n#include \"p_tos.h\"\n#include \"p_vmlinx.h\"\n#include \"p_vmlinz.h\"\n#include \"p_w32pe_i386.h\"\n#include \"p_w64pe_amd64.h\"\n#include \"p_w64pe_arm64.h\"\n#include \"p_wcle.h\"\n#include \"p_wince_arm.h\"\n\n/*************************************************************************\n//\n**************************************************************************/\n\nPackMaster::PackMaster(InputFile *f, Options *o) noexcept : fi(f) {\n    // replace global options with local options\n    if (o != nullptr) {\n#if WITH_THREADS\n        // TODO later: check for possible \"noexcept\" violation here\n        std::lock_guard<std::mutex> lock(opt_lock_mutex);\n#endif\n        saved_opt = o;\n        memcpy(&this->local_options, o, sizeof(*o)); // struct copy\n        opt = &this->local_options;\n    }\n}\n\nPackMaster::~PackMaster() noexcept {\n    upx::owner_delete(packer);\n    // restore global options\n    if (saved_opt != nullptr) {\n#if WITH_THREADS\n        // TODO later: check for possible \"noexcept\" violation here\n        std::lock_guard<std::mutex> lock(opt_lock_mutex);\n#endif\n        opt = saved_opt;\n        saved_opt = nullptr;\n    }\n}\n\n/*************************************************************************\n//\n**************************************************************************/\n\nstatic noinline tribool try_can_pack(PackerBase *pb, void *user) may_throw {\n    InputFile *f = (InputFile *) user;\n    try {\n        pb->initPackHeader();\n        f->seek(0, SEEK_SET);\n        tribool r = pb->canPack();\n        if (r) {\n            if (opt->cmd == CMD_COMPRESS)\n                pb->updatePackHeader();\n            f->seek(0, SEEK_SET);\n            return true; // success\n        }\n        if (r.isThird()) // aka \"-1\"\n            return r;    // canPack() says the format is recognized and we should fail early\n    } catch (const IOException &) {\n        // ignored\n    }\n    return false;\n}\n\nstatic noinline tribool try_can_unpack(PackerBase *pb, void *user) may_throw {\n    InputFile *f = (InputFile *) user;\n    try {\n        pb->initPackHeader();\n        f->seek(0, SEEK_SET);\n        tribool r = pb->canUnpack();\n        if (r) {\n            f->seek(0, SEEK_SET);\n            return true; // success\n        }\n        if (r.isThird()) // aka \"-1\"\n            return r;    // canUnpack() says the format is recognized and we should fail early\n    } catch (const IOException &) {\n        // ignored\n    }\n    return false;\n}\n\n/*************************************************************************\n//\n**************************************************************************/\n\n/*static*/\nPackerBase *PackMaster::visitAllPackers(visit_func_t func, InputFile *f, const Options *o,\n                                        void *user) may_throw {\n#define VISIT(Klass)                                                                               \\\n    do {                                                                                           \\\n        static_assert(std::is_class_v<Klass>);                                                     \\\n        static_assert(std::is_nothrow_destructible_v<Klass>);                                      \\\n        auto pb = std::unique_ptr<PackerBase>(new Klass(f));                                       \\\n        if (o->debug.debug_level)                                                                  \\\n            fprintf(stderr, \"visitAllPackers: (ver=%d, fmt=%3d) %s\\n\", pb->getVersion(),           \\\n                    pb->getFormat(), #Klass);                                                      \\\n        pb->assertPacker();                                                                        \\\n        tribool r = func(pb.get(), user);                                                          \\\n        if (r)                                                                                     \\\n            return pb.release(); /* success */                                                     \\\n        if (r.isThird())                                                                           \\\n            return nullptr; /* stop and fail early */                                              \\\n    } while (0)\n\n    // NOTE: order of tries is important !!!\n\n    //\n    // .exe\n    //\n    if (!o->dos_exe.force_stub) {\n        // dos32\n        VISIT(PackDjgpp2);\n        VISIT(PackTmt);\n        VISIT(PackWcle);\n        // Windows\n        // VISIT(PackW64PeArm64EC); // NOT YET IMPLEMENTED\n        // VISIT(PackW64PeArm64); // NOT YET IMPLEMENTED\n        VISIT(PackW64PeAmd64);\n        VISIT(PackW32PeI386);\n        VISIT(PackWinCeArm);\n    }\n    VISIT(PackExe); // dos/exe\n\n    //\n    // linux kernel\n    //\n    VISIT(PackVmlinuxARMEL);\n    VISIT(PackVmlinuxARMEB);\n    VISIT(PackVmlinuxPPC32);\n    VISIT(PackVmlinuxPPC64LE);\n    VISIT(PackVmlinuxAMD64);\n    VISIT(PackVmlinuxI386);\n#if (WITH_ZLIB)\n    VISIT(PackVmlinuzI386);\n    VISIT(PackBvmlinuzI386);\n    VISIT(PackVmlinuzARMEL);\n#endif\n\n    //\n    // linux\n    //\n    if (!o->o_unix.force_execve) {\n        if (o->o_unix.use_ptinterp) {\n            VISIT(PackLinuxElf32x86interp);\n        }\n        VISIT(PackFreeBSDElf32x86);\n        VISIT(PackNetBSDElf32x86);\n        VISIT(PackOpenBSDElf32x86);\n        VISIT(PackLinuxElf32x86);\n        VISIT(PackLinuxElf64amd);\n        VISIT(PackLinuxElf32armLe);\n        VISIT(PackLinuxElf32armBe);\n        VISIT(PackLinuxElf64arm);\n        VISIT(PackLinuxElf32ppc);\n        VISIT(PackLinuxElf64ppc);\n        VISIT(PackLinuxElf64ppcle);\n        VISIT(PackLinuxElf32mipsel);\n        VISIT(PackLinuxElf32mipseb);\n        VISIT(PackLinuxI386sh);\n    }\n    VISIT(PackBSDI386);\n    VISIT(PackMachFat);   // cafebabe conflict\n    VISIT(PackLinuxI386); // cafebabe conflict\n\n    // Mach (Darwin / macOS)\n    VISIT(PackDylibAMD64);\n    VISIT(PackMachPPC32); // TODO: this works with upx 3.91..3.94 but got broken in 3.95; FIXME\n    VISIT(PackMachI386);\n    VISIT(PackMachAMD64);\n    VISIT(PackMachARMEL);\n    VISIT(PackMachARM64EL);\n\n    // 2010-03-12  omit these because PackMachBase<T>::pack4dylib (p_mach.cpp)\n    // does not understand what the Darwin (Apple Mac OS X) dynamic loader\n    // assumes about .dylib file structure.\n    //   VISIT(PackDylibI386);\n    //   VISIT(PackDylibPPC32);\n\n    //\n    // misc\n    //\n    VISIT(PackTos); // atari/tos\n    VISIT(PackPs1); // ps1/exe\n    VISIT(PackSys); // dos/sys\n    VISIT(PackCom); // dos/com\n\n    return nullptr;\n#undef VISIT\n}\n\n/*static*/ PackerBase *PackMaster::getPacker(InputFile *f) may_throw {\n    PackerBase *pb = visitAllPackers(try_can_pack, f, opt, f);\n    if (!pb)\n        throwUnknownExecutableFormat();\n    return pb;\n}\n\n/*static*/ PackerBase *PackMaster::getUnpacker(InputFile *f) may_throw {\n    PackerBase *pb = visitAllPackers(try_can_unpack, f, opt, f);\n    if (!pb)\n        throwNotPacked();\n    return pb;\n}\n\n/*************************************************************************\n// delegation from work.cpp\n**************************************************************************/\n\nvoid PackMaster::pack(OutputFile *fo) may_throw {\n    assert(packer == nullptr);\n    packer = getPacker(fi);\n    packer->doPack(fo);\n}\n\nvoid PackMaster::unpack(OutputFile *fo) may_throw {\n    assert(packer == nullptr);\n    packer = getUnpacker(fi);\n    packer->doUnpack(fo);\n}\n\nvoid PackMaster::test() may_throw {\n    assert(packer == nullptr);\n    packer = getUnpacker(fi);\n    packer->doTest();\n}\n\nvoid PackMaster::list() may_throw {\n    assert(packer == nullptr);\n    packer = getUnpacker(fi);\n    packer->doList();\n}\n\nvoid PackMaster::fileInfo() may_throw {\n    assert(packer == nullptr);\n    packer = visitAllPackers(try_can_unpack, fi, opt, fi);\n    if (!packer)\n        packer = visitAllPackers(try_can_pack, fi, opt, fi);\n    if (!packer)\n        throwUnknownExecutableFormat(nullptr, 1); // make a warning here\n    packer->doFileInfo();\n}\n\n/* vim:set ts=4 sw=4 et: */\n","size_bytes":9564},"src/pefile.cpp":{"content":"/* pefile.cpp --\n\n   This file is part of the Resize executable compressor.\n\n   Copyright (C) 2025 WHO-AM-I-404\n   Based on UPX - Ultimate Packer for eXecutables\n   Copyright (C) 1996-2025 Markus Franz Xaver Johannes Oberhumer\n   Copyright (C) 1996-2025 Laszlo Molnar\n   All Rights Reserved.\n\n   Resize and the UCL library are free software; you can redistribute them\n   and/or modify them under the terms of the GNU General Public License as\n   published by the Free Software Foundation; either version 2 of\n   the License, or (at your option) any later version.\n\n   This program is distributed in the hope that it will be useful,\n   but WITHOUT ANY WARRANTY; without even the implied warranty of\n   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n   GNU General Public License for more details.\n\n   You should have received a copy of the GNU General Public License\n   along with this program; see the file COPYING.\n   If not, write to the Free Software Foundation, Inc.,\n   59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.\n\n   WHO-AM-I-404 <who-am-i-404@proton.me>\n   Based on original work by:\n   Markus F.X.J. Oberhumer <markus@oberhumer.com>\n   Laszlo Molnar <ezerotven+github@gmail.com>\n */\n\n#include \"conf.h\"\n#include \"file.h\"\n#include \"filter.h\"\n#include \"packer.h\"\n#include \"pefile.h\"\n#include \"linker.h\"\n\n#define FILLVAL 0\n#define import  my_import // \"import\" is a keyword since C++20\n\n/*************************************************************************\n//\n**************************************************************************/\n\n#define IPTR_VAR(type, var, first) SPAN_S_VAR(type, var, first, ibuf)\n#define OPTR_VAR(type, var, first) SPAN_S_VAR(type, var, first, obuf)\n#define IPTR_VAR_OFFSET(type, var, offset)                                                         \\\n    SPAN_S_VAR(type, var, ibuf + (offset), ibuf.getSize() - (offset), ibuf + (offset))\n\nstatic void xcheck(const void *p) {\n    if very_unlikely (p == nullptr)\n        throwCantUnpack(\"xcheck unexpected nullptr pointer; take care!\");\n}\nstatic void xcheck(const void *p, size_t plen, const void *b, size_t blen) {\n    const charptr pp = (const charptr) p;\n    const charptr bb = (const charptr) b;\n    if very_unlikely (pp < bb || pp > bb + blen || pp + plen > bb + blen)\n        throwCantUnpack(\"xcheck pointer out of range; take care!\");\n}\n#define ICHECK(p, bytes) xcheck(raw_bytes(p, 0), bytes, ibuf, ibuf.getSize())\n#define OCHECK(p, bytes) xcheck(raw_bytes(p, 0), bytes, obuf, obuf.getSize())\n\n// #define imemset(a,b,c)      ICHECK(a,c), memset(a,b,c)\n// #define omemset(a,b,c)      OCHECK(a,c), memset(a,b,c)\n// #define imemcpy(a,b,c)      ICHECK(a,c), memcpy(a,b,c)\n#define omemcpy(a, b, c)  OCHECK(a, c), memcpy(a, b, c)\n#define omemmove(a, b, c) OCHECK(a, c), memmove(a, b, c)\n\n/*************************************************************************\n//\n**************************************************************************/\n\nPeFile::PeFile(InputFile *f) : super(f) {\n    bele = &N_BELE_RTP::le_policy;\n    COMPILE_TIME_ASSERT(sizeof(ddirs_t) == 8)\n    COMPILE_TIME_ASSERT(sizeof(pe_section_t) == 40)\n    COMPILE_TIME_ASSERT_ALIGNED1(ddirs_t)\n    COMPILE_TIME_ASSERT_ALIGNED1(pe_section_t)\n    COMPILE_TIME_ASSERT(RT_LAST == TABLESIZE(opt->win32_pe.compress_rt))\n\n    isection = nullptr;\n    oimport = nullptr;\n    oimpdlls = nullptr;\n    orelocs = nullptr;\n    oexport = nullptr;\n    otls = nullptr;\n    oresources = nullptr;\n    oxrelocs = nullptr;\n    icondir_offset = 0;\n    icondir_count = 0;\n    importbyordinal = false;\n    kernel32ordinal = false;\n    tlsindex = 0;\n    big_relocs = 0;\n    sorelocs = 0;\n    soxrelocs = 0;\n    sotls = 0;\n    ilinker = nullptr;\n    use_tls_callbacks = false;\n    oloadconf = nullptr;\n    soloadconf = 0;\n\n    isdll = false;\n    isrtm = false;\n    isefi = false;\n    use_dep_hack = true;\n    use_clear_dirty_stack = true;\n    use_stub_relocs = true;\n}\n\nbool PeFile::testUnpackVersion(int version) const {\n    if (version != ph_version && ph_version != -1)\n        throwCantUnpack(\"program has been modified; run a virus checker!\");\n    if (!canUnpackVersion(version))\n        throwCantUnpack(\"this program is packed with an obsolete version and cannot be unpacked\");\n    return true;\n}\n\n/*************************************************************************\n// util\n**************************************************************************/\n\n// early check of machine to generate a helpful error message\n// FIXME/TODO: proper check for ARM64EC\n// FIXME/TODO: proper check for ARM64X \"universal\" binary\n// CHPE   Compiled Hybrid PE: Microsoft internal only?\n// CHPEV2 Compiled Hybrid PE: ARM64EC, ARM64X\n/*static*/ int PeFile::checkMachine(unsigned cpu) {\n    // unsupported\n    if (cpu == IMAGE_FILE_MACHINE_IA64)\n        throwCantPack(\"win64/ia64 is not supported\");\n    if (cpu == IMAGE_FILE_MACHINE_LOONGARCH64)\n        throwCantPack(\"win64/loong64 is not supported\");\n    if (cpu == IMAGE_FILE_MACHINE_RISCV64)\n        throwCantPack(\"win64/riscv64 is not supported\");\n\n    // known but not (yet?) supported\n    if (cpu == IMAGE_FILE_MACHINE_ARMNT)\n        throwCantPack(\"win32/armnt is not supported\"); // obsolete\n    if (cpu == IMAGE_FILE_MACHINE_ARM64)\n        throwCantPack(\"win64/arm64 is not yet supported\");\n    // FIXME: it seems that arm64ec actually uses MACHINE_AMD64 ???\n    if (cpu == IMAGE_FILE_MACHINE_ARM64EC)\n        throwCantPack(\"win64/arm64ec is not yet supported\");\n\n    // supported\n    if (cpu == IMAGE_FILE_MACHINE_AMD64)\n        return UPX_F_W64PE_AMD64;\n    if (cpu == IMAGE_FILE_MACHINE_ARM || cpu == IMAGE_FILE_MACHINE_THUMB)\n        return UPX_F_WINCE_ARM;\n    if (cpu >= IMAGE_FILE_MACHINE_I386 && cpu <= 0x150) // what is this 0x150 ???\n        return UPX_F_W32PE_I386;\n\n    // other or unknown (alpha, mips, powerpc, sh, etc.)\n    throwCantPack(\"pefile: unsupported machine %#x\", cpu);\n    return 0; // pacify msvc\n}\n\nint PeFile::readFileHeader() {\n    struct alignas(1) ExeHeader final {\n        LE16 mz;\n        LE16 m512;\n        LE16 p512;\n        char _[18];\n        LE16 relocoffs;\n        char __[34];\n        LE32 nexepos;\n    };\n\n    COMPILE_TIME_ASSERT(sizeof(ExeHeader) == 64)\n    COMPILE_TIME_ASSERT_ALIGNED1(ExeHeader)\n    COMPILE_TIME_ASSERT(sizeof(((ExeHeader *) nullptr)->_) == 18)\n    COMPILE_TIME_ASSERT(sizeof(((ExeHeader *) nullptr)->__) == 34)\n\n    ExeHeader h;\n    int ic;\n    pe_offset = 0;\n\n    for (ic = 0; ic < 20; ic++) {\n        fi->seek(pe_offset, SEEK_SET);\n        fi->readx(&h, sizeof(h));\n\n        if (h.mz == 'M' + 'Z' * 256) // dos exe\n        {\n            if (h.nexepos && h.nexepos < sizeof(ExeHeader)) {\n                // Overlapping MZ and PE headers by 'leanify', etc.\n                char buf[64];\n                snprintf(buf, sizeof(buf), \"PE and MZ header overlap: %#x < %#x\",\n                         (unsigned) h.nexepos, (unsigned) sizeof(ExeHeader));\n                throwCantPack(buf);\n            }\n            const unsigned delta = (h.relocoffs >= 0x40)\n                                       ? h.nexepos // new format exe\n                                       : (h.p512 * 512 + h.m512 - h.m512 ? 512 : h.nexepos);\n\n            if ((pe_offset + delta) < delta // wrap-around\n                || (pe_offset + delta) > file_size_u) {\n                char buf[64];\n                snprintf(buf, sizeof(buf), \"bad PE delta %#x at offset %#x\", delta, pe_offset);\n                throwCantPack(buf);\n            }\n            pe_offset += delta;\n        } else if (get_le32((const byte *) &h) == 'P' + 'E' * 256)\n            break;\n        else\n            return 0;\n    }\n    if (ic == 20)\n        return 0;\n    fi->seek(pe_offset, SEEK_SET);\n    readPeHeader();\n    return getFormat();\n}\n\n/*************************************************************************\n// interval handling\n**************************************************************************/\n\nPeFile::Interval::Interval(SPAN_P(byte) b) : base(b) {}\n\nPeFile::Interval::~Interval() noexcept { ::free(ivarr); }\n\nint __acc_cdecl_qsort PeFile::Interval::compare(const void *p1, const void *p2) {\n    const interval *i1 = (const interval *) p1;\n    const interval *i2 = (const interval *) p2;\n    if (i1->start < i2->start)\n        return -1;\n    if (i1->start > i2->start)\n        return 1;\n    if (i1->len < i2->len)\n        return 1;\n    if (i1->len > i2->len)\n        return -1;\n    return 0;\n}\n\nvoid PeFile::Interval::add_interval(unsigned start, unsigned len) {\n    if (ivnum == ivcapacity) {\n        ivcapacity += 15;\n        ivarr = (interval *) realloc(ivarr, mem_size(sizeof(interval), ivcapacity));\n        assert(ivarr != nullptr);\n    }\n    ivarr[ivnum].start = start;\n    ivarr[ivnum].len = len;\n    ivnum += 1;\n}\n\nvoid PeFile::Interval::add_interval(const void *start, unsigned len) {\n    add_interval(ptr_udiff_bytes(start, base), len);\n}\n\nvoid PeFile::Interval::add_interval(const void *start, const void *end) {\n    add_interval(ptr_udiff_bytes(start, base), ptr_udiff_bytes(end, start));\n}\n\nvoid PeFile::Interval::add_interval(const Interval *other) {\n    for (unsigned ic = 0; ic < other->ivnum; ic++)\n        add_interval(other->ivarr[ic].start, other->ivarr[ic].len);\n}\n\nvoid PeFile::Interval::flatten() {\n    if (!ivnum)\n        return;\n    upx_qsort(ivarr, ivnum, sizeof(ivarr[0]), Interval::compare);\n    for (unsigned ic = 0; ic < ivnum - 1; ic++) {\n        unsigned jc;\n        for (jc = ic + 1; jc < ivnum && ivarr[ic].start + ivarr[ic].len >= ivarr[jc].start; jc++)\n            if (ivarr[ic].start + ivarr[ic].len < ivarr[jc].start + ivarr[jc].len)\n                ivarr[ic].len = ivarr[jc].start + ivarr[jc].len - ivarr[ic].start;\n        if (jc > ic + 1) {\n            memmove(ivarr + ic + 1, ivarr + jc, sizeof(interval) * (ivnum - jc));\n            ivnum -= jc - ic - 1;\n        }\n    }\n}\n\nvoid PeFile::Interval::clear() {\n    for (unsigned ic = 0; ic < ivnum; ic++)\n        memset(base + ivarr[ic].start, 0, ivarr[ic].len);\n}\n\nvoid PeFile::Interval::dump() const {\n    printf(\"%d intervals:\\n\", ivnum);\n    for (unsigned ic = 0; ic < ivnum; ic++)\n        printf(\"%x %x\\n\", ivarr[ic].start, ivarr[ic].len);\n}\n\n/*************************************************************************\n// relocation handling\n**************************************************************************/\n\n// do NOT allow --force to override reloc checks\nstatic constexpr bool ALWAYS_CHECK_STRICT_RELOCS = true;\n\nvoid PeFile::Reloc::RelocationBlock::reset() noexcept {\n    rel = nullptr;  // SPAN_0\n    rel1 = nullptr; // SPAN_0\n    count = 0;\n}\n\n// TODO later: remove this in-place memory optimization hack and use an extra array\nstatic constexpr size_t RELOC_INPLACE_OFFSET = 64 * 1024;\n\nstatic constexpr size_t RELOC_ENTRY_SIZE = 5; // encoded size in bytes; actual encoding is private\nstatic void reloc_entry_encode(SPAN_P(byte) buf, unsigned pos, unsigned reloc_type) {\n    if (reloc_type == 0 || reloc_type >= 16)\n        throwCantPack(\"bad reloc_type %#x %u\", pos, reloc_type);\n    set_ne32(buf, pos);\n    buf[4] = (upx_uint8_t) reloc_type;\n}\nstatic void reloc_entry_decode(SPAN_P(const byte) buf, unsigned *pos, unsigned *reloc_type) {\n    *pos = get_ne32(buf);\n    *reloc_type = buf[4];\n    assert(*reloc_type > 0 && *reloc_type < 16);\n}\nstatic int __acc_cdecl_qsort reloc_entry_compare(const void *a, const void *b) {\n    const unsigned pos1 = get_ne32(a);\n    const unsigned pos2 = get_ne32(b);\n    if (pos1 != pos2)\n        return pos1 < pos2 ? -1 : 1;\n    const unsigned reloc_type1 = ((const upx_uint8_t *) a)[4];\n    const unsigned reloc_type2 = ((const upx_uint8_t *) b)[4];\n    if (reloc_type1 != reloc_type2)\n        return reloc_type1 < reloc_type2 ? -1 : 1;\n    return 0;\n}\n\nPeFile::Reloc::~Reloc() noexcept {\n    COMPILE_TIME_ASSERT(sizeof(BaseReloc) == 8)\n    COMPILE_TIME_ASSERT_ALIGNED1(BaseReloc)\n    if (start_did_alloc) // don't leak memory on exceptions\n        delete[] start;\n}\n\n// constructor for compression only\nPeFile::Reloc::Reloc(byte *ptr, unsigned bytes) {\n    assert(opt->cmd == CMD_COMPRESS);\n    start_size_in_bytes = mem_size(1, bytes);\n    start = ptr;\n    initSpans();\n    // fill counts\n    unsigned pos, reloc_type;\n    while (next(pos, reloc_type))\n        counts[reloc_type]++;\n}\n\nPeFile::Reloc::Reloc(unsigned relocnum) {\n    start_size_in_bytes = mem_size(RELOC_ENTRY_SIZE, relocnum, RELOC_INPLACE_OFFSET, 8192);\n    start = new byte[start_size_in_bytes]; // => transfer ownership to oxrelocs[] in finish()\n    start_did_alloc = true;\n    initSpans();\n}\n\nvoid PeFile::Reloc::initSpans() {\n    start_buf = SPAN_0_MAKE(byte, start, start_size_in_bytes); // => now a SPAN_S\n    rb.rel = SPAN_TYPE_CAST(BaseReloc, start_buf);             // SPAN_0\n    rb.rel1 = SPAN_TYPE_CAST(LE16, start_buf);                 // SPAN_0\n    rb.reset();\n}\n\n// explicitly check values so that we get better error messages (instead of a cryptic SPAN failure)\nbool PeFile::Reloc::readFromRelocationBlock(byte *next_rb) { // set rb\n    assert(!start_did_alloc);\n    const unsigned off = ptr_udiff_bytes(next_rb, start);\n    assert((off & 1) == 0);\n    rb.reset();\n    if (off >= start_size_in_bytes) { // permissive: use \">=\" instead of strict \"==\"\n        if (off > start_size_in_bytes) {\n            // MAYBE TODO later: could add a warning here?\n        }\n        return false; // EOF\n    }\n    if (start_size_in_bytes - off < 8)\n        throwCantPack(\"relocs overflow\");\n    const unsigned sob = get_le32(start_buf + (off + 4)); // size_of_block\n#if 1\n    // ignore a dubious single empty relocation block with sob == 0\n    if (sob == 0 && (off == 0 && start_size_in_bytes == 8))\n        return false; // EOF\n#endif\n    if (ALWAYS_CHECK_STRICT_RELOCS) {\n        if (sob < 8)\n            throwCantPack(\"bad reloc size_of_block %u\", sob);\n        if (start_size_in_bytes - off < sob)\n            throwCantPack(\"overflow reloc size_of_block %u\", sob);\n        if ((sob & 1) != 0)\n            throwCantPack(\"odd reloc size_of_block %u\", sob);\n    } else if (!opt->force) {\n        if (sob < 8)\n            throwCantPack(\"bad reloc size_of_block %u (try --force)\", sob);\n        if (start_size_in_bytes - off < sob)\n            throwCantPack(\"overflow reloc size_of_block %u (try --force)\", sob);\n        if ((sob & 1) != 0)\n            throwCantPack(\"odd reloc size_of_block %u (try --force)\", sob);\n    }\n    // success\n    rb.rel = (BaseReloc *) next_rb;   // SPAN checked\n    rb.rel1 = (LE16 *) (next_rb + 8); // SPAN checked\n    rb.count = sob < 8 ? 0 : (sob - 8) / sizeof(LE16);\n    return true;\n}\n\nbool PeFile::Reloc::next(unsigned &result_pos, unsigned &result_reloc_type) {\n    assert(!start_did_alloc);\n    for (;;) {\n        // search current block\n        while (rb.count > 0) {\n            rb.count -= 1;\n            const unsigned value = *rb.rel1++;\n            result_pos = rb.rel->virtual_address + (value & 0xfff);\n            result_reloc_type = (value >> 12) & 0xf;\n            NO_printf(\"Reloc::next %#x %d\\n\", result_pos, result_reloc_type);\n            if (result_reloc_type != IMAGE_REL_BASED_IGNORE)\n                return true; // success\n        }\n        // advance to next block\n        byte *next_rb = (rb.rel == nullptr) ? start : (byte *) raw_bytes(rb.rel1, 0);\n        if (!readFromRelocationBlock(next_rb)) {\n            rb.reset();   // rewind\n            return false; // EOF\n        }\n    }\n}\n\nvoid PeFile::Reloc::add_reloc(unsigned pos, unsigned reloc_type) {\n    assert(start_did_alloc);\n    // assert(reloc_type != IMAGE_REL_BASED_IGNORE);\n    if (reloc_type == IMAGE_REL_BASED_IGNORE)\n        return;\n    auto entry_ptr = start_buf + mem_size(RELOC_ENTRY_SIZE, counts[0], RELOC_INPLACE_OFFSET);\n    reloc_entry_encode(entry_ptr, pos, reloc_type);\n    counts[0] += 1;\n}\n\nvoid PeFile::Reloc::finish(byte *(&result_ptr), unsigned &result_size) {\n    assert(start_did_alloc);\n    // sort in-place relocs\n    upx_qsort(\n        raw_index_bytes(start_buf, RELOC_INPLACE_OFFSET, mem_size(RELOC_ENTRY_SIZE, counts[0])),\n        counts[0], RELOC_ENTRY_SIZE, reloc_entry_compare);\n\n    auto finish_block = [](SPAN_S(BaseReloc) rel) -> byte * {\n        unsigned sob = rel->size_of_block;\n        assert(sob >= 10 && (sob & 1) == 0);\n        auto end = SPAN_TYPE_CAST(byte, rel) + sob;\n        while ((sob & 3) != 0) { // UPX: we want align by 4 here\n            *end++ = 0;          // clear byte (i.e. write IMAGE_REL_BASED_IGNORE)\n            sob += 1;\n        }\n        rel->size_of_block = sob;\n        return raw_bytes(end, 0);\n    };\n\n    rb.reset();\n    unsigned prev_pos = 0;\n    unsigned current_page = 0;\n    for (unsigned ic = 0; ic < counts[0]; ic++) {\n        const auto entry_ptr = start_buf + mem_size(RELOC_ENTRY_SIZE, ic, RELOC_INPLACE_OFFSET);\n        unsigned pos, reloc_type;\n        reloc_entry_decode(entry_ptr, &pos, &reloc_type);\n        if (ic > 0 && pos == prev_pos) {\n            if (ALWAYS_CHECK_STRICT_RELOCS)\n                throwCantPack(\"duplicate relocs\");\n            else if (!opt->force)\n                throwCantPack(\"duplicate relocs (try --force)\");\n        }\n        prev_pos = pos;\n        if (ic == 0 || pos - current_page >= 0x1000) {\n            current_page = pos & ~0xfff; // page start\n            // prepare next block for writing\n            byte *next_rb = (rb.rel == nullptr) ? start : finish_block(rb.rel);\n            rb.rel = (BaseReloc *) next_rb;\n            rb.rel1 = (LE16 *) (next_rb + 8);\n            rb.rel->virtual_address = current_page;\n            rb.rel->size_of_block = 8;\n        }\n        // check for in-place overflow\n        if (ptr_diff_bytes(rb.rel1, entry_ptr) >= 0) {\n            // info: if this is indeed a valid file we must increase RELOC_INPLACE_OFFSET\n            throwCantPack(\"too many inplace relocs\");\n        }\n        // write LE16 IMAGE_BASE_RELOCATION relocation\n        *rb.rel1++ = (reloc_type << 12) | (pos & 0xfff);\n        rb.rel->size_of_block += 2;\n    }\n    result_size = 0; // result_size can be 0 in 64-bit mode\n    if (rb.rel != nullptr)\n        result_size = ptr_udiff_bytes(finish_block(rb.rel), start);\n    assert((result_size & 3) == 0);\n    // transfer ownership\n    assert(start_did_alloc);\n    result_ptr = start;\n    start_did_alloc = false;\n#if DEBUG || 1 // safety, as we are really finished\n    ptr_invalidate_and_poison(start);\n    start_size_in_bytes = 0;\n    SPAN_INVALIDATE(start_buf);\n    SPAN_INVALIDATE(rb.rel);\n    SPAN_INVALIDATE(rb.rel1);\n    rb.count = 0xdeaddead;\n#endif\n}\n\nvoid PeFile32::processRelocs() // pass1\n{\n    big_relocs = 0;\n\n    const unsigned skip1 = IDADDR(PEDIR_BASERELOC);\n    const unsigned take1 = IDSIZE(PEDIR_BASERELOC);\n    Reloc rel(ibuf.subref(\"bad reloc %#x\", skip1, take1), take1);\n    const unsigned *const counts = rel.getcounts();\n    unsigned relocnum = 0;\n\n    for (unsigned ic = 1; ic < 16; ic++)\n        relocnum += counts[ic];\n    for (unsigned ic = 0; ic < 16; ic++)\n        NO_printf(\"reloc counts[%u] %u\\n\", ic, counts[ic]);\n\n    if (opt->win32_pe.strip_relocs || relocnum == 0) {\n        if (IDSIZE(PEDIR_BASERELOC)) {\n            ibuf.fill(IDADDR(PEDIR_BASERELOC), IDSIZE(PEDIR_BASERELOC), FILLVAL);\n            ih.objects = tryremove(IDADDR(PEDIR_BASERELOC), ih.objects);\n        }\n        mb_orelocs.alloc(1);\n        mb_orelocs.clear();\n        orelocs = mb_orelocs; // => orelocs now is a SPAN_S\n        sorelocs = 0;\n        return;\n    }\n\n    for (unsigned ic = IMAGE_REL_BASED_HIGHADJ; ic < 16; ic++)\n        if (counts[ic])\n            infoWarning(\"skipping unsupported relocation type %d (%d)\", ic, counts[ic]);\n\n    LE32 *fix[4];\n    auto fix_deleter = upx::ArrayDeleter(fix, 0); // don't leak memory\n    for (unsigned ic = 0; ic <= IMAGE_REL_BASED_HIGHLOW; ic++) {\n        fix[ic] = New(LE32, counts[ic]);\n        fix_deleter.count += 1;\n    }\n\n    unsigned xcounts[4];\n    memset(xcounts, 0, sizeof(xcounts));\n\n    // prepare sorting\n    unsigned pos, reloc_type;\n    while (rel.next(pos, reloc_type)) {\n        // FIXME add check for relocations which try to modify the\n        // PE header or other relocation records\n        if (pos >= ih.imagesize)\n            continue; // skip out-of-bounds record\n        if (reloc_type <= IMAGE_REL_BASED_HIGHLOW)\n            fix[reloc_type][xcounts[reloc_type]++] = pos - rvamin;\n    }\n\n    // remove duplicated records\n    for (unsigned ic = 1; ic <= IMAGE_REL_BASED_HIGHLOW; ic++) {\n        upx_qsort(fix[ic], xcounts[ic], 4, le32_compare);\n        unsigned prev = ~0u;\n        unsigned jc = 0;\n        for (unsigned kc = 0; kc < xcounts[ic]; kc++)\n            if (fix[ic][kc] != prev)\n                prev = fix[ic][jc++] = fix[ic][kc];\n\n        NO_printf(\"reloc xcounts[%u] %u->%u\\n\", ic, xcounts[ic], jc);\n        xcounts[ic] = jc;\n    }\n\n    // preprocess \"type 3\" relocation records\n    for (unsigned ic = 0; ic < xcounts[IMAGE_REL_BASED_HIGHLOW]; ic++) {\n        pos = fix[3][ic] + rvamin;\n        unsigned w = get_le32(ibuf.subref(\"bad reloc type 3 %#x\", pos, sizeof(LE32)));\n        set_le32(ibuf + pos, w - ih.imagebase - rvamin);\n    }\n\n    ibuf.fill(IDADDR(PEDIR_BASERELOC), IDSIZE(PEDIR_BASERELOC), FILLVAL);\n    mb_orelocs.alloc(mem_size(4, relocnum, 8192)); // 8192 - safety\n    orelocs = mb_orelocs;                          // => orelocs now is a SPAN_S\n    sorelocs = optimizeReloc(xcounts[3], (byte *) fix[3], orelocs, ibuf + rvamin, ibufgood - rvamin,\n                             32, true, &big_relocs);\n\n    // Malware that hides behind UPX often has PE header info that is\n    // deliberately corrupt.  Sometimes it is even tuned to cause us trouble!\n    // Use an extra check to avoid AccessViolation (SIGSEGV) when appending\n    // the relocs into one array.\n    if ((sizeof(LE32) * relocnum + 8192) <\n        (sorelocs +\n         sizeof(LE32) * (2 + xcounts[IMAGE_REL_BASED_LOW] + xcounts[IMAGE_REL_BASED_HIGH])))\n        throwCantUnpack(\"Invalid relocs\");\n\n    // append relocs type \"LOW\" then \"HIGH\"\n    for (unsigned ic = IMAGE_REL_BASED_LOW; ic >= IMAGE_REL_BASED_HIGH; ic--) {\n        memcpy(orelocs + sorelocs, fix[ic], sizeof(LE32) * xcounts[ic]);\n        sorelocs += sizeof(LE32) * xcounts[ic];\n        set_le32(orelocs + sorelocs, 0);\n        if (xcounts[ic]) {\n            sorelocs += 4;\n            big_relocs |= 2 * ic;\n        }\n    }\n\n    info(\"Relocations: original size: %u bytes, preprocessed size: %u bytes\",\n         (unsigned) IDSIZE(PEDIR_BASERELOC), sorelocs);\n}\n\n// FIXME - this is too similar to PeFile32::processRelocs\nvoid PeFile64::processRelocs() // pass1\n{\n    big_relocs = 0;\n\n    const unsigned skip1 = IDADDR(PEDIR_BASERELOC);\n    const unsigned take1 = IDSIZE(PEDIR_BASERELOC);\n    Reloc rel(ibuf.subref(\"bad reloc %#x\", skip1, take1), take1);\n    const unsigned *const counts = rel.getcounts();\n    unsigned relocnum = 0;\n\n    for (unsigned ic = 1; ic < 16; ic++)\n        relocnum += counts[ic];\n    for (unsigned ic = 0; ic < 16; ic++)\n        NO_printf(\"reloc counts[%u] %u\\n\", ic, counts[ic]);\n\n    if (opt->win32_pe.strip_relocs || relocnum == 0) {\n        if (IDSIZE(PEDIR_BASERELOC)) {\n            ibuf.fill(IDADDR(PEDIR_BASERELOC), IDSIZE(PEDIR_BASERELOC), FILLVAL);\n            ih.objects = tryremove(IDADDR(PEDIR_BASERELOC), ih.objects);\n        }\n        mb_orelocs.alloc(1);\n        mb_orelocs.clear();\n        orelocs = mb_orelocs; // => orelocs now is a SPAN_S\n        sorelocs = 0;\n        return;\n    }\n\n    for (unsigned ic = 0; ic < 16; ic++)\n        if (ic != IMAGE_REL_BASED_DIR64 && counts[ic])\n            infoWarning(\"skipping unsupported relocation type %d (%d)\", ic, counts[ic]);\n\n    LE32 *fix[16];\n    auto fix_deleter = upx::ArrayDeleter(fix, 0); // don't leak memory\n    for (unsigned ic = 0; ic < 16; ic++) {\n        fix[ic] = New(LE32, counts[ic]);\n        fix_deleter.count += 1;\n    }\n\n    unsigned xcounts[16];\n    memset(xcounts, 0, sizeof(xcounts));\n\n    // prepare sorting\n    unsigned pos, reloc_type;\n    while (rel.next(pos, reloc_type)) {\n        // FIXME add check for relocations which try to modify the\n        // PE header or other relocation records\n        if (pos >= ih.imagesize)\n            continue; // skip out-of-bounds record\n        if (reloc_type < 16)\n            fix[reloc_type][xcounts[reloc_type]++] = pos - rvamin;\n    }\n\n    // remove duplicated records\n    for (unsigned ic = 1; ic < 16; ic++) {\n        upx_qsort(fix[ic], xcounts[ic], 4, le32_compare);\n        unsigned prev = ~0u;\n        unsigned jc = 0;\n        for (unsigned kc = 0; kc < xcounts[ic]; kc++)\n            if (fix[ic][kc] != prev)\n                prev = fix[ic][jc++] = fix[ic][kc];\n\n        NO_printf(\"xcounts[%u] %u->%u\\n\", ic, xcounts[ic], jc);\n        xcounts[ic] = jc;\n    }\n\n    // preprocess \"type 10\" relocation records\n    for (unsigned ic = 0; ic < xcounts[IMAGE_REL_BASED_DIR64]; ic++) {\n        pos = fix[IMAGE_REL_BASED_DIR64][ic] + rvamin;\n        upx_uint64_t w = get_le64(ibuf.subref(\"bad reloc 10 %#x\", pos, sizeof(LE64)));\n        set_le64(ibuf + pos, w - ih.imagebase - rvamin);\n    }\n\n    ibuf.fill(IDADDR(PEDIR_BASERELOC), IDSIZE(PEDIR_BASERELOC), FILLVAL);\n    mb_orelocs.alloc(mem_size(4, relocnum, 8192)); // 8192 - safety\n    orelocs = mb_orelocs;                          // => orelocs now is a SPAN_S\n    sorelocs = optimizeReloc(xcounts[IMAGE_REL_BASED_DIR64], (byte *) fix[IMAGE_REL_BASED_DIR64],\n                             orelocs, ibuf + rvamin, ibufgood - rvamin, 64, true, &big_relocs);\n\n    info(\"Relocations: original size: %u bytes, preprocessed size: %u bytes\",\n         (unsigned) IDSIZE(PEDIR_BASERELOC), sorelocs);\n}\n\n/*************************************************************************\n// import handling\n**************************************************************************/\n\nLE32 &PeFile::IDSIZE(unsigned x) { return iddirs[x].size; }\nLE32 &PeFile::IDADDR(unsigned x) { return iddirs[x].vaddr; }\nLE32 &PeFile::ODSIZE(unsigned x) { return oddirs[x].size; }\nLE32 &PeFile::ODADDR(unsigned x) { return oddirs[x].vaddr; }\nconst LE32 &PeFile::IDSIZE(unsigned x) const { return iddirs[x].size; }\nconst LE32 &PeFile::IDADDR(unsigned x) const { return iddirs[x].vaddr; }\n\n/*\n ImportLinker: 32 and 64 bit import table building.\n Import entries (dll name + proc name/ordinal pairs) can be\n added in arbitrary order.\n\n Internally it works by creating sections with special names,\n and adding relocation entries between those sections. The special\n names ensure that when the import table is built in the memory\n from those sections, a correct table can be generated simply by\n sorting the sections by name, and adding all of them to the output\n in the sorted order.\n */\n\nclass PeFile::ImportLinker final : public ElfLinkerAMD64 {\n    // temporary string owner, deletes on destruction\n    struct TStr final : private upx::noncopyable {\n        explicit TStr(char *str) noexcept : s(str) {}\n        ~TStr() noexcept { delete[] s; } // delete!\n        operator char *() noexcept { return s; }\n        operator const char *() const noexcept { return s; }\n    private:\n        char *s;\n    };\n\n    // encoding of dll and proc names are required, so that our special\n    // control characters in the name of sections can work as intended\n    static void encode_name(SPAN_P(const char) name, SPAN_S(char) buf) {\n        while (*name) {\n            *buf++ = 'a' + ((*name >> 4) & 0xf);\n            *buf++ = 'a' + (*name & 0xf);\n            name++;\n        }\n        *buf = 0;\n    }\n\n    static char *name_for_dll(const char *dll, char first_char) {\n        assert(dll != nullptr);\n        const unsigned l = strlen(dll);\n        assert(l > 0);\n        const unsigned new_size = 1 + 3 * l + 1;\n        char *const new_name = New(char, new_size);\n        SPAN_S_VAR(char, const name, new_name, new_size);\n        name[0] = first_char;\n        SPAN_S_VAR(char, n, name + (1 + 2 * l));\n        do {\n            *n++ = tolower((uchar) *dll);\n        } while (*dll++);\n        encode_name(new_name + (1 + 2 * l), name + 1);\n        return new_name;\n    }\n\n    static char *name_for_proc(const char *dll, const char *proc, char first_char, char separator) {\n        const unsigned new_size = 1 + 2 * strlen(dll) + 1 + 2 * strlen(proc) + 1 + 1;\n        TStr dll_name(name_for_dll(dll, first_char));\n        char *const new_name = New(char, new_size);\n        SPAN_S_VAR(char, const name, new_name, new_size);\n        upx_safe_snprintf(new_name, new_size, \"%s%c\", (const char *) dll_name, separator);\n        encode_name(proc, name + strlen(name));\n        return new_name;\n    }\n\n    static const char zeros[sizeof(import_desc)];\n\n    enum {\n        // the order of identifiers is very important below!!\n        descriptor_id = 'D',\n        thunk_id,\n        dll_name_id,\n        proc_name_id,\n        ordinal_id,\n\n        thunk_separator_first,\n        thunk_separator,\n        thunk_separator_last,\n        procname_separator,\n    };\n\n    unsigned thunk_size; // 4 or 8 bytes\n\n    void add_import(const char *dll, const char *proc, unsigned ordinal) {\n        TStr sdll(name_for_dll(dll, dll_name_id));\n        TStr desc_name(name_for_dll(dll, descriptor_id));\n\n        char tsep = thunk_separator;\n        if (findSection(sdll, false) == nullptr) {\n            tsep = thunk_separator_first;\n            addSection(sdll, dll, strlen(dll) + 1, 0); // name of the dll\n            addSymbol(sdll, sdll, 0);\n\n            addSection(desc_name, zeros, sizeof(zeros), 0); // descriptor\n            addRelocation(desc_name, offsetof(import_desc, dllname), \"R_X86_64_32\", sdll, 0);\n        }\n        TStr thunk(proc == nullptr ? name_for_dll(dll, thunk_id)\n                                   : name_for_proc(dll, proc, thunk_id, tsep));\n\n        if (findSection(thunk, false) != nullptr)\n            return; // we already have this dll/proc\n        addSection(thunk, zeros, thunk_size, 0);\n        addSymbol(thunk, thunk, 0);\n        if (tsep == thunk_separator_first) {\n            addRelocation(desc_name, offsetof(import_desc, iat), \"R_X86_64_32\", thunk, 0);\n\n            TStr last_thunk(name_for_proc(dll, \"X\", thunk_id, thunk_separator_last));\n            addSection(last_thunk, zeros, thunk_size, 0);\n        }\n\n        const char *reltype = thunk_size == 4 ? \"R_X86_64_32\" : \"R_X86_64_64\";\n        if (ordinal != 0u) {\n            addRelocation(thunk, 0, reltype, \"*UND*\", ordinal | (1ull << (thunk_size * 8 - 1)));\n        } else if (proc != nullptr) {\n            TStr proc_name(name_for_proc(dll, proc, proc_name_id, procname_separator));\n            addSection(proc_name, zeros, 2, 1); // 2 bytes of word aligned \"hint\"\n            addSymbol(proc_name, proc_name, 0);\n            addRelocation(thunk, 0, reltype, proc_name, 0);\n\n            strcat(proc_name, \"X\");\n            addSection(proc_name, proc, strlen(proc), 0); // the name of the symbol\n        } else\n            infoWarning(\"empty import: %s\", dll);\n    }\n\n    static int __acc_cdecl_qsort compare(const void *aa, const void *bb) {\n        const Section *a = *(const Section *const *) aa;\n        const Section *b = *(const Section *const *) bb;\n        if (a->sort_id == b->sort_id) // identical object, poor qsort() implementation\n            return 0;\n        int rc = strcmp(a->name, b->name);\n        if (rc != 0)\n            return rc;\n        // What could remain?\n        // make sort order deterministic\n        return a->sort_id < b->sort_id ? -1 : 1;\n    }\n\n    virtual void alignCode(unsigned len) override { alignWithByte(len, 0); }\n\n    const Section *getThunk(const char *dll, const char *proc, char tsep) const {\n        assert(dll);\n        assert(proc);\n        TStr thunk(name_for_proc(dll, proc, thunk_id, tsep));\n        return findSection(thunk, false);\n    }\n\npublic:\n    explicit ImportLinker(unsigned thunk_size_) : thunk_size(thunk_size_) {\n        assert(thunk_size == 4 || thunk_size == 8);\n        addSection(\"*UND*\", nullptr, 0, 0);\n        addSymbol(\"*UND*\", \"*UND*\", 0);\n        addSection(\"*ZSTART\", nullptr, 0, 0);\n        addSymbol(\"*ZSTART\", \"*ZSTART\", 0);\n        Section *s = addSection(\"Dzero\", zeros, sizeof(import_desc), 0);\n        assert(s->name[0] == descriptor_id);\n\n        // one trailing 00 byte after the last proc name\n        addSection(\"Zzero\", zeros, 1, 0);\n    }\n\n    template <typename C>\n    void add_import(const C *dll, unsigned ordinal) {\n        ACC_COMPILE_TIME_ASSERT(sizeof(C) == 1) // \"char\" or \"byte\"\n        assert(ordinal < 0x10000);\n        char ord[1 + 5 + 1];\n        upx_safe_snprintf(ord, sizeof(ord), \"%c%05u\", ordinal_id, ordinal);\n        add_import((const char *) dll, ordinal ? ord : nullptr, ordinal);\n    }\n\n    template <typename C1, typename C2>\n    void add_import(const C1 *dll, const C2 *proc) {\n        ACC_COMPILE_TIME_ASSERT(sizeof(C1) == 1) // \"char\" or \"byte\"\n        ACC_COMPILE_TIME_ASSERT(sizeof(C2) == 1) // \"char\" or \"byte\"\n        assert(proc);\n        add_import((const char *) dll, (const char *) proc, 0);\n    }\n\n    unsigned build() {\n        assert(output == nullptr);\n        int osize = 4 + 2 * nsections; // upper limit for alignments\n        for (unsigned ic = 0; ic < nsections; ic++)\n            osize += sections[ic]->size;\n        output_capacity = osize;\n        output = New(byte, output_capacity);\n        outputlen = 0;\n\n        // sort the sections by name before adding them all\n        // NOLINTNEXTLINE(bugprone-multi-level-implicit-pointer-conversion)\n        upx_qsort(sections, nsections, sizeof(sections[0]), ImportLinker::compare);\n\n        for (unsigned ic = 0; ic < nsections; ic++)\n            addLoader(sections[ic]->name);\n        addLoader(\"+40D\");\n        assert(outputlen <= osize);\n\n        // OutputFile::dump(\"il0.imp\", output, outputlen);\n        return outputlen;\n    }\n\n    void relocate_import(unsigned myimport) {\n        assert(nsections > 0);\n        assert(output);\n        defineSymbol(\"*ZSTART\", /*0xffffffffff1000ull + 0 * */ myimport);\n        ElfLinkerAMD64::relocate();\n        // OutputFile::dump(\"il1.imp\", output, outputlen);\n    }\n\n    template <typename C1, typename C2>\n    upx_uint64_t getAddress(const C1 *dll, const C2 *proc) const {\n        ACC_COMPILE_TIME_ASSERT(sizeof(C1) == 1) // \"char\" or \"byte\"\n        ACC_COMPILE_TIME_ASSERT(sizeof(C2) == 1) // \"char\" or \"byte\"\n        const Section *s = getThunk((const char *) dll, (const char *) proc, thunk_separator_first);\n        if (s == nullptr)\n            s = getThunk((const char *) dll, (const char *) proc, thunk_separator);\n        if (s == nullptr)\n            throwInternalError(\"entry not found\");\n        return s->offset;\n    }\n\n    template <typename C>\n    upx_uint64_t getAddress(const C *dll, unsigned ordinal) const {\n        ACC_COMPILE_TIME_ASSERT(sizeof(C) == 1) // \"char\" or \"byte\"\n        assert(ordinal > 0 && ordinal < 0x10000);\n        char ord[1 + 5 + 1];\n        upx_safe_snprintf(ord, sizeof(ord), \"%c%05u\", ordinal_id, ordinal);\n        const Section *s = getThunk((const char *) dll, ord, thunk_separator_first);\n        if (s == nullptr)\n            s = getThunk((const char *) dll, ord, thunk_separator);\n        if (s == nullptr)\n            throwInternalError(\"entry not found\");\n        return s->offset;\n    }\n\n    template <typename C>\n    upx_uint64_t getAddress(const C *dll) const {\n        ACC_COMPILE_TIME_ASSERT(sizeof(C) == 1) // \"char\" or \"byte\"\n        TStr sdll(name_for_dll((const char *) dll, dll_name_id));\n        return findSection(sdll, true)->offset;\n    }\n\n    template <typename C>\n    bool hasDll(const C *dll) const {\n        ACC_COMPILE_TIME_ASSERT(sizeof(C) == 1) // \"char\" or \"byte\"\n        TStr sdll(name_for_dll((const char *) dll, dll_name_id));\n        return findSection(sdll, false) != nullptr;\n    }\n}; // class PeFile::ImportLinker\n\n/*static*/ const char PeFile::ImportLinker::zeros[sizeof(import_desc)] = {0};\n\nvoid PeFile::addKernelImport(const char *name) { ilinker->add_import(kernelDll(), name); }\n\nvoid PeFile::addStubImports() {\n    addKernelImport(\"LoadLibraryA\");\n    addKernelImport(\"GetProcAddress\");\n    if (!isdll)\n        addKernelImport(\"ExitProcess\");\n    addKernelImport(\"VirtualProtect\");\n}\n\nvoid PeFile::processImports2(unsigned myimport, unsigned) { // pass 2\n    COMPILE_TIME_ASSERT(sizeof(import_desc) == 20)\n    if (ilinker == nullptr)\n        return;\n    ilinker->relocate_import(myimport);\n    int len;\n    oimpdlls = ilinker->getLoader(&len);\n    assert(len == (int) soimpdlls);\n    // OutputFile::dump(\"x1.imp\", oimpdlls, soimpdlls);\n}\n\ntemplate <typename LEXX, typename ord_mask_t>\nunsigned PeFile::processImports0(ord_mask_t ord_mask) { // pass 1\n    if (isefi) {\n        if (IDSIZE(PEDIR_IMPORT))\n            throwCantPack(\"imports not supported on EFI\");\n        return 0;\n    }\n\n    unsigned dllnum = 0;\n    const unsigned skip = IDADDR(PEDIR_IMPORT);\n    const unsigned take = IDSIZE(PEDIR_IMPORT);\n    import_desc *const im_start = (import_desc *) ibuf.subref(\"bad import %#x\", skip, take);\n    if (IDADDR(PEDIR_IMPORT) != 0) {\n        for (const import_desc *im = im_start;; ++dllnum, ++im) {\n            const unsigned skip2 = ptr_udiff_bytes(im, ibuf);\n            (void) ibuf.subref(\"bad import %#x\", skip2, sizeof(*im));\n            if (im->dllname == 0)\n                break;\n        }\n    }\n    if (dllnum > 4096) // just some arbitrary limit/sanity check\n        throwCantPack(\"too many DLL imports %u\", dllnum);\n\n    struct UDll final {\n        const byte *name;\n        const byte *shname;\n        unsigned ordinal;\n        unsigned iat;\n        const LEXX *lookupt;\n        unsigned original_position;\n        bool isk32;\n\n        static int __acc_cdecl_qsort compare(const void *aa, const void *bb) {\n            const UDll *a = *(const UDll *const *) aa;\n            const UDll *b = *(const UDll *const *) bb;\n            if (a->original_position == b->original_position) // identical object, poor qsort()\n                return 0;\n            if (a->isk32 != b->isk32)\n                return a->isk32 ? -1 : 1;\n            if ((*a->lookupt != 0) != (*b->lookupt != 0))\n                return (*a->lookupt != 0) ? -1 : 1;\n            int rc = strcasecmp(a->name, b->name);\n            if (rc != 0)\n                return rc;\n            if ((a->ordinal != 0) != (b->ordinal != 0))\n                return (a->ordinal != 0) ? -1 : 1;\n            if (a->shname && b->shname) {\n                rc = (int) (upx_safe_strlen(a->shname) - upx_safe_strlen(b->shname));\n                if (rc != 0)\n                    return rc;\n                rc = strcmp(a->shname, b->shname);\n                if (rc != 0)\n                    return rc;\n            } else if ((a->shname != nullptr) != (b->shname != nullptr))\n                return (a->shname != nullptr) ? -1 : 1;\n            // What could remain?\n            // make sort order deterministic\n            return a->original_position < b->original_position ? -1 : 1;\n        }\n    };\n\n    // +1 for dllnum=0\n    Array(UDll, dlls, dllnum + 1);\n    Array(UDll *, idlls, dllnum + 1);\n\n    soimport = 1024; // safety\n\n    for (unsigned ic = 0; ic < dllnum; ic++) {\n        const import_desc *const im = im_start + ic;\n        idlls[ic] = dlls + ic;\n        dlls[ic].name = ibuf.subref(\"bad dllname %#x\", im->dllname, 1);\n        dlls[ic].shname = nullptr;\n        dlls[ic].ordinal = 0;\n        dlls[ic].iat = im->iat;\n        const unsigned skip2 = (im->oft ? im->oft : im->iat);\n        dlls[ic].lookupt = (LEXX *) ibuf.subref(\"bad dll lookupt %#x\", skip2, sizeof(LEXX));\n        dlls[ic].original_position = ic;\n        dlls[ic].isk32 = strcasecmp(kernelDll(), dlls[ic].name) == 0;\n\n        soimport += strlen(dlls[ic].name) + 1 + 4;\n\n        for (IPTR_VAR(const LEXX, tarr, dlls[ic].lookupt); *tarr; tarr += 1) {\n            if (*tarr & ord_mask) {\n                importbyordinal = true;\n                soimport += 2; // ordinal num: 2 bytes\n                dlls[ic].ordinal = *tarr & 0xffff;\n            } else {\n                // it's an import by name\n                IPTR_VAR(const byte, const name, ibuf + (*tarr + 2));\n                unsigned len = strlen(name);\n                soimport += len + 1;\n                if (dlls[ic].shname == nullptr || len < strlen(dlls[ic].shname))\n                    dlls[ic].shname = ibuf + (*tarr + 2);\n            }\n            soimport++; // separator\n        }\n    }\n    mb_oimport.alloc(soimport);\n    mb_oimport.clear();\n    oimport = mb_oimport;\n\n    // NOLINTNEXTLINE(bugprone-multi-level-implicit-pointer-conversion)\n    upx_qsort(idlls, dllnum, sizeof(idlls[0]), UDll::compare);\n\n    info(\"Processing imports: %d DLLs\", dllnum);\n    for (unsigned ic = 0; ic < dllnum; ic++) {\n        info(\"  DLL %3d %s %s\", ic, idlls[ic]->name, idlls[ic]->shname);\n    }\n\n    ilinker = new ImportLinker(sizeof(LEXX));\n    // create the new import table\n    addStubImports();\n\n    for (unsigned ic = 0; ic < dllnum; ic++) {\n        if (idlls[ic]->isk32) {\n            // for kernel32.dll we need to put all the imported\n            // ordinals into the output import table, as on\n            // some versions of windows GetProcAddress does not resolve them\n            if (strcasecmp(idlls[ic]->name, \"kernel32.dll\"))\n                continue;\n            if (idlls[ic]->ordinal)\n                for (const LEXX *tarr = idlls[ic]->lookupt; *tarr; tarr++)\n                    if (*tarr & ord_mask) {\n                        ilinker->add_import(kernelDll(), *tarr & 0xffff);\n                        kernel32ordinal = true;\n                    }\n        } else if (!ilinker->hasDll(idlls[ic]->name)) {\n            if (idlls[ic]->shname && !idlls[ic]->ordinal)\n                ilinker->add_import(idlls[ic]->name, idlls[ic]->shname);\n            else\n                ilinker->add_import(idlls[ic]->name, idlls[ic]->ordinal);\n        }\n    }\n\n    soimpdlls = ilinker->build();\n\n    Interval names(ibuf), iats(ibuf), lookups(ibuf);\n\n    // create the preprocessed data\n    SPAN_S_VAR(byte, ppi, oimport); // preprocessed imports\n    for (unsigned ic = 0; ic < dllnum; ic++) {\n        const LEXX *tarr = idlls[ic]->lookupt;\n        set_le32(ppi, ilinker->getAddress(idlls[ic]->name));\n        set_le32(ppi + 4, idlls[ic]->iat - rvamin);\n        ppi += 8;\n        for (; *tarr; tarr++)\n            if (*tarr & ord_mask) {\n                const unsigned ord = *tarr & 0xffff;\n                if (idlls[ic]->isk32 && kernel32ordinal) {\n                    *ppi++ = 0xfe; // signed + odd parity\n                    set_le32(ppi, ilinker->getAddress(idlls[ic]->name, ord));\n                    ppi += 4;\n                } else {\n                    *ppi++ = 0xff;\n                    set_le16(ppi, ord);\n                    ppi += 2;\n                }\n            } else {\n                *ppi++ = 1;\n                const unsigned skip2 = 2 + *tarr;\n                const unsigned take2 = 1 + strlen(ibuf.subref(\"bad import name %#x\", skip2, 1));\n                memcpy(ppi, ibuf.subref(\"bad import name %#x\", skip2, take2), take2);\n                ppi += take2;\n                names.add_interval(*tarr, 2 + take2);\n            }\n        ppi++;\n\n        const unsigned esize = ptr_udiff_bytes(tarr, idlls[ic]->lookupt);\n        lookups.add_interval(idlls[ic]->lookupt, esize);\n        if (ptr_diff_bytes(ibuf.subref(\"bad import name %#x\", idlls[ic]->iat, 1),\n                           idlls[ic]->lookupt) != 0) {\n            memcpy(ibuf.subref(\"bad import name %#x\", idlls[ic]->iat, esize), idlls[ic]->lookupt,\n                   esize);\n            iats.add_interval(idlls[ic]->iat, esize);\n        }\n        names.add_interval(idlls[ic]->name, strlen(idlls[ic]->name) + 1 + 1);\n    }\n    ppi += 4;\n    assert(ppi < oimport + soimport);\n    soimport = ptr_diff_bytes(ppi, oimport);\n\n    if (soimport == 4)\n        soimport = 0;\n\n    // OutputFile::dump(\"x0.imp\", oimport, soimport);\n\n    unsigned ilen = 0;\n    names.flatten();\n    if (names.ivnum > 1) {\n        // The area occupied by the dll and imported names is not continuous\n        // so to still support uncompression, I can't zero the iat area.\n        // This decreases compression ratio, so FIXME somehow.\n        infoWarning(\"can't remove unneeded imports\");\n        ilen += sizeof(import_desc) * dllnum;\n#if TESTING\n        if (opt->verbose > 3)\n            names.dump();\n#endif\n        // do some work for the unpacker\n        for (unsigned ic = 0; ic < dllnum; ic++) {\n            import_desc *const im = im_start + ic;\n            memset(im, FILLVAL, sizeof(*im));\n            im->dllname = ptr_udiff_bytes(dlls[idlls[ic]->original_position].name, ibuf);\n        }\n    } else {\n        iats.add_interval(im_start, sizeof(import_desc) * dllnum);\n        // zero unneeded data\n        iats.clear();\n        lookups.clear();\n    }\n    names.clear();\n\n    iats.add_interval(&names);\n    iats.add_interval(&lookups);\n    iats.flatten();\n    for (unsigned ic = 0; ic < iats.ivnum; ic++)\n        ilen += iats.ivarr[ic].len;\n\n    info(\"Imports: original size: %u bytes, preprocessed size: %u bytes\", ilen, soimport);\n    return names.ivnum == 1 ? names.ivarr[0].start : 0;\n}\n\n/*************************************************************************\n// export handling\n**************************************************************************/\n\nPeFile::Export::Export(char *_base) : base(_base), iv((byte *) _base) {\n    COMPILE_TIME_ASSERT(sizeof(export_dir_t) == 40)\n    COMPILE_TIME_ASSERT_ALIGNED1(export_dir_t)\n    ename = functionptrs = ordinals = nullptr;\n    names = nullptr;\n    mem_clear(&edir);\n    size = 0;\n}\n\nPeFile::Export::~Export() noexcept {\n    ::free(ename);\n    delete[] functionptrs;\n    delete[] ordinals;\n    if (names) {\n        const unsigned limit = edir.names + edir.functions;\n        for (unsigned ic = 0; ic < limit; ic++)\n            if (names[ic])\n                ::free(names[ic]); // allocated by strdup()\n        delete[] names;\n    }\n}\n\nvoid PeFile::Export::convert(unsigned eoffs, unsigned esize) {\n    memcpy(&edir, base + eoffs, sizeof(export_dir_t));\n    size = sizeof(export_dir_t);\n    iv.add_interval(eoffs, size);\n\n    if (!edir.name || eoffs + esize <= (unsigned) edir.name) {\n        char msg[50];\n        snprintf(msg, sizeof(msg), \"bad export directory name RVA %#x\", (unsigned) edir.name);\n        throwInternalError(msg);\n    }\n    unsigned len = strlen(base + edir.name) + 1;\n    ename = strdup(base + edir.name);\n    size += len;\n    iv.add_interval(edir.name, len);\n\n    // This test is weak because it does not consider other necessary storage.\n    // But it does detect outrageous individual members.\n    // Note: sizeof(LE32) <= sizeof(char *)\n    if (UPX_RSIZE_MAX_MEM / sizeof(char *) <= edir.functions ||\n        UPX_RSIZE_MAX_MEM / sizeof(char *) <= edir.names) {\n        throwCantPack(\"export directory too big:  functions=%#x  names=%#x\",\n                      (unsigned) edir.functions, (unsigned) edir.names);\n    }\n    len = sizeof(LE32) * edir.functions;\n    functionptrs = New(char, len + 1);\n    memcpy(functionptrs, base + edir.addrtable, len);\n    size += len;\n    iv.add_interval(edir.addrtable, len);\n\n    unsigned ic;\n    names = New(char *, edir.names + edir.functions + 1);\n    for (ic = 0; ic < edir.names; ic++) {\n        char *n = base + get_le32(base + edir.nameptrtable + ic * sizeof(LE32));\n        len = strlen(n) + 1;\n        names[ic] = strdup(n);\n        size += len;\n        iv.add_interval(get_le32(base + edir.nameptrtable + ic * sizeof(LE32)), len);\n    }\n    iv.add_interval(edir.nameptrtable, sizeof(LE32) * edir.names);\n    size += sizeof(LE32) * edir.names;\n\n    LE32 *fp = (LE32 *) functionptrs;\n    // export forwarders\n    for (ic = 0; ic < edir.functions; ic++)\n        if (fp[ic] >= eoffs && fp[ic] < eoffs + esize) {\n            char *forw = base + fp[ic];\n            len = strlen(forw) + 1;\n            iv.add_interval(forw, len);\n            size += len;\n            names[ic + edir.names] = strdup(forw);\n        } else\n            names[ic + edir.names] = nullptr;\n\n    len = 2 * edir.names;\n    ordinals = New(char, len + 1);\n    memcpy(ordinals, base + edir.ordinaltable, len);\n    size += len;\n    iv.add_interval(edir.ordinaltable, len);\n    iv.flatten();\n    if (iv.ivnum == 1)\n        iv.clear();\n#if TESTING\n    else\n        iv.dump();\n#endif\n}\n\nvoid PeFile::Export::build(char *newbase, unsigned newoffs) {\n    char *const functionp = newbase + sizeof(edir);\n    char *const namep = functionp + sizeof(LE32) * edir.functions;\n    char *const ordinalp = namep + sizeof(LE32) * edir.names;\n    char *const enamep = ordinalp + 2 * edir.names;\n    char *exports = enamep + strlen(ename) + 1;\n\n    edir.addrtable = newoffs + ptr_diff_bytes(functionp, newbase);\n    edir.ordinaltable = newoffs + ptr_diff_bytes(ordinalp, newbase);\n    assert(ordinals != nullptr); // pacify clang-tidy\n    memcpy(ordinalp, ordinals, 2 * edir.names);\n\n    edir.name = newoffs + ptr_diff_bytes(enamep, newbase);\n    strcpy(enamep, ename);\n    edir.nameptrtable = newoffs + ptr_diff_bytes(namep, newbase);\n    unsigned ic;\n    for (ic = 0; ic < edir.names; ic++) {\n        strcpy(exports, names[ic]);\n        set_le32(namep + sizeof(LE32) * ic, newoffs + ptr_diff_bytes(exports, newbase));\n        exports += strlen(exports) + 1;\n    }\n\n    memcpy(functionp, functionptrs, sizeof(LE32) * edir.functions);\n    for (ic = 0; ic < edir.functions; ic++)\n        if (names[edir.names + ic]) {\n            strcpy(exports, names[edir.names + ic]);\n            set_le32(functionp + sizeof(LE32) * ic, newoffs + ptr_diff_bytes(exports, newbase));\n            exports += strlen(exports) + 1;\n        }\n\n    memcpy(newbase, &edir, sizeof(edir));\n    assert(exports - newbase == (int) size);\n}\n\nvoid PeFile::processExports(Export *xport) // pass1\n{\n    soexport = ALIGN_UP(IDSIZE(PEDIR_EXPORT), 4u);\n    if (soexport == 0)\n        return;\n    if (!isdll && opt->win32_pe.compress_exports) {\n        infoWarning(\"exports compressed, --compress-exports=0 might be needed\");\n        soexport = 0;\n        return;\n    }\n    xport->convert(IDADDR(PEDIR_EXPORT), IDSIZE(PEDIR_EXPORT));\n    soexport = ALIGN_UP(xport->getsize(), 4u);\n    mb_oexport.alloc(soexport);\n    mb_oexport.clear();\n    oexport = mb_oexport;\n}\n\nvoid PeFile::processExports(Export *xport, unsigned newoffs) // pass2\n{\n    if (soexport)\n        xport->build((char *) raw_bytes(oexport, 0), newoffs);\n}\n\n/*************************************************************************\n// TLS handling\n**************************************************************************/\n\n// thanks for theowl for providing me some docs, so that now I understand\n// what I'm doing here :)\n\n// 1999-10-17: this was tricky to find:\n// when the fixup records and the tls area are on the same page, then\n// the tls area is not relocated, because the relocation is done by\n// the virtual memory manager only for pages which are not yet loaded.\n// of course it was impossible to debug this ;-)\n\ntemplate <>\nstruct PeFile::tls_traits<LE32> final {\n    struct alignas(1) tls {\n        LE32 datastart; // VA tls init data start\n        LE32 dataend;   // VA tls init data end\n        LE32 tlsindex;  // VA tls index\n        LE32 callbacks; // VA tls callbacks\n        byte _[8];      // zero init, characteristics\n    };\n\n    static constexpr unsigned sotls = 24;\n    static constexpr unsigned cb_size = 4;\n    typedef unsigned cb_value_t;\n    static constexpr unsigned reloc_type = IMAGE_REL_BASED_HIGHLOW;\n    static constexpr int tls_handler_offset_reloc = 4;\n};\n\ntemplate <>\nstruct PeFile::tls_traits<LE64> final {\n    struct alignas(1) tls {\n        LE64 datastart; // VA tls init data start\n        LE64 dataend;   // VA tls init data end\n        LE64 tlsindex;  // VA tls index\n        LE64 callbacks; // VA tls callbacks\n        byte _[8];      // zero init, characteristics\n    };\n\n    static constexpr unsigned sotls = 40;\n    static constexpr unsigned cb_size = 8;\n    typedef upx_uint64_t cb_value_t;\n    static constexpr unsigned reloc_type = IMAGE_REL_BASED_DIR64;\n    static constexpr int tls_handler_offset_reloc = -1; // no need to relocate\n};\n\ntemplate <typename LEXX>\nvoid PeFile::processTls1(Interval *iv, typename tls_traits<LEXX>::cb_value_t imagebase,\n                         unsigned imagesize) { // pass 1\n    typedef typename tls_traits<LEXX>::tls tls;\n    typedef typename tls_traits<LEXX>::cb_value_t cb_value_t;\n    constexpr unsigned cb_size = tls_traits<LEXX>::cb_size;\n\n    COMPILE_TIME_ASSERT(sizeof(tls) == tls_traits<LEXX>::sotls)\n    COMPILE_TIME_ASSERT_ALIGNED1(tls)\n\n    if (isefi && IDSIZE(PEDIR_TLS))\n        throwCantPack(\"TLS not supported on EFI\");\n\n    const unsigned take = ALIGN_UP(IDSIZE(PEDIR_TLS), 4u);\n    sotls = take;\n    if (!sotls)\n        return;\n    const unsigned skip = IDADDR(PEDIR_TLS);\n    const tls *const tlsp = (const tls *) ibuf.subref(\"bad tls %#x\", skip, sizeof(tls));\n\n    // note: TLS callbacks are not implemented in Windows 95/98/ME\n    if (tlsp->callbacks) {\n        if (tlsp->callbacks < imagebase)\n            throwCantPack(\"invalid TLS callback\");\n        else if (tlsp->callbacks - imagebase + 4 >= imagesize)\n            throwCantPack(\"invalid TLS callback\");\n        cb_value_t v =\n            *(LEXX *) ibuf.subref(\"bad TLS %#x\", (tlsp->callbacks - imagebase), sizeof(LEXX));\n\n        if (v != 0) {\n            // count number of callbacks, just for information string - Stefan Widmann\n            unsigned num_callbacks = 0;\n            unsigned callback_offset = 0;\n            while (*(LEXX *) ibuf.subref(\n                \"bad TLS %#x\", tlsp->callbacks - imagebase + callback_offset, sizeof(LEXX))) {\n                // increment number of callbacks\n                num_callbacks++;\n                callback_offset += cb_size;\n            }\n            info(\"TLS: %u callback(s) found, adding TLS callback handler\", num_callbacks);\n            // set flag to include necessary sections in loader\n            use_tls_callbacks = true;\n            // define linker symbols\n            tlscb_ptr = tlsp->callbacks;\n        }\n    }\n\n    const unsigned tlsdatastart = tlsp->datastart - imagebase;\n    const unsigned tlsdataend = tlsp->dataend - imagebase;\n\n    // now some ugly stuff: find the relocation entries in the tls data area\n    const unsigned skip2 = IDADDR(PEDIR_BASERELOC);\n    const unsigned take2 = IDSIZE(PEDIR_BASERELOC);\n    Reloc rel(ibuf.subref(\"bad tls reloc %#x\", skip2, take2), take2);\n    unsigned pos, type;\n    while (rel.next(pos, type))\n        if (pos >= tlsdatastart && pos < tlsdataend)\n            iv->add_interval(pos, type);\n\n    sotls = sizeof(tls) + tlsdataend - tlsdatastart;\n    // if TLS callbacks are used, we need two more {D|Q}WORDS at the end of the TLS\n    // ... and those dwords should be correctly aligned\n    if (use_tls_callbacks)\n        sotls = ALIGN_UP(sotls, cb_size) + 2 * cb_size;\n    const unsigned aligned_sotls = ALIGN_UP(sotls, usizeof(LEXX));\n\n    // the PE loader wants this stuff uncompressed\n    mb_otls.alloc(aligned_sotls);\n    mb_otls.clear();\n    otls = mb_otls; // => otls now is a SPAN_S\n    const unsigned skip1 = IDADDR(PEDIR_TLS);\n    const unsigned take1 = sizeof(tls);\n    memcpy(otls, ibuf.subref(\"bad tls %#x\", skip1, take1), take1);\n    // WARNING: this can access data in BSS\n    const unsigned take3 = sotls - sizeof(tls);\n    memcpy(otls + sizeof(tls), ibuf.subref(\"bad tls %#x\", tlsdatastart, take3), take3);\n    tlsindex = tlsp->tlsindex - imagebase;\n    // NEW: subtract two dwords if TLS callbacks are used - Stefan Widmann\n    info(\"TLS: %u bytes tls data and %u relocations added\",\n         sotls - (unsigned) sizeof(tls) - (use_tls_callbacks ? 2 * cb_size : 0), iv->ivnum);\n\n    // makes sure tls index is zero after decompression\n    if (tlsindex && tlsindex < imagesize)\n        set_le32(ibuf.subref(\"bad tlsindex %#x\", tlsindex, sizeof(unsigned)), 0);\n}\n\ntemplate <typename LEXX>\nvoid PeFile::processTls2(Reloc *const rel, const Interval *const iv, unsigned newaddr,\n                         typename tls_traits<LEXX>::cb_value_t imagebase) { // pass 2\n    typedef typename tls_traits<LEXX>::tls tls;\n    typedef typename tls_traits<LEXX>::cb_value_t cb_value_t;\n    constexpr unsigned cb_size = tls_traits<LEXX>::cb_size;\n    constexpr unsigned reloc_type = tls_traits<LEXX>::reloc_type;\n    static_assert(reloc_type > IMAGE_REL_BASED_IGNORE && reloc_type < 16);\n    constexpr int tls_handler_offset_reloc = tls_traits<LEXX>::tls_handler_offset_reloc;\n\n    if (sotls == 0)\n        return;\n    // add new relocation entries\n\n    if (tls_handler_offset > 0 && tls_handler_offset_reloc > 0)\n        rel->add_reloc(tls_handler_offset + tls_handler_offset_reloc, reloc_type);\n\n    unsigned ic;\n    // NEW: if TLS callbacks are used, relocate the VA of the callback chain, too - Stefan Widmann\n    for (ic = 0; ic < (use_tls_callbacks ? sizeof(LE32) * cb_size : (sizeof(LE32) - 1) * cb_size);\n         ic += cb_size)\n        rel->add_reloc(newaddr + ic, reloc_type);\n\n    SPAN_S_VAR(tls, const tlsp, mb_otls);\n    // now the relocation entries in the tls data area\n    for (ic = 0; ic < iv->ivnum; ic += sizeof(LE32)) {\n        SPAN_S_VAR(byte, const pp,\n                   otls + (iv->ivarr[ic].start - (tlsp->datastart - imagebase) + sizeof(tls)));\n        LEXX *const p = (LEXX *) raw_bytes(pp, sizeof(LEXX));\n        cb_value_t kc = *p;\n        if (kc < tlsp->dataend && kc >= tlsp->datastart) {\n            kc += newaddr + sizeof(tls) - tlsp->datastart;\n            *p = kc + imagebase;\n            rel->add_reloc(kc, iv->ivarr[ic].len);\n        } else\n            rel->add_reloc(kc - imagebase, iv->ivarr[ic].len);\n    }\n\n    const unsigned tls_data_size = tlsp->dataend - tlsp->datastart;\n    tlsp->datastart = newaddr + sizeof(tls) + imagebase;\n    tlsp->dataend = tlsp->datastart + tls_data_size;\n\n    // NEW: if we have TLS callbacks to handle, we create a pointer to the new callback chain -\n    // Stefan Widmann\n    tlsp->callbacks = (use_tls_callbacks ? newaddr + sotls + imagebase - 2 * cb_size : 0);\n\n    if (use_tls_callbacks) {\n        // set handler offset\n        SPAN_S_VAR(byte, pp, otls);\n        pp = otls + (sotls - 2 * cb_size);\n        *(LEXX *) raw_bytes(pp, sizeof(LEXX)) = tls_handler_offset + imagebase;\n        pp = otls + (sotls - 1 * cb_size);\n        *(LEXX *) raw_bytes(pp, sizeof(LEXX)) = 0; // end of one-item list\n        // add relocation for TLS handler offset\n        rel->add_reloc(newaddr + sotls - 2 * cb_size, reloc_type);\n    }\n}\n\n/*************************************************************************\n// Load Configuration handling\n**************************************************************************/\n\nvoid PeFile::processLoadConf(Interval *iv) { // pass 1\n    if (IDSIZE(PEDIR_LOAD_CONFIG) == 0)\n        return;\n\n    const unsigned lcaddr = IDADDR(PEDIR_LOAD_CONFIG);\n    const byte *const loadconf = ibuf.subref(\"bad loadconf %#x\", lcaddr, 4);\n    soloadconf = get_le32(loadconf);\n    if (soloadconf == 0)\n        return;\n    static constexpr unsigned MAX_SOLOADCONF = 256; // XXX FIXME: Why?\n    if (soloadconf > MAX_SOLOADCONF)\n        info(\"Load Configuration directory %u > %u\", soloadconf, MAX_SOLOADCONF);\n\n    // if there were relocation entries referring to the load config table\n    // then we need them for the copy of the table too\n    const unsigned skip = IDADDR(PEDIR_BASERELOC);\n    const unsigned take = IDSIZE(PEDIR_BASERELOC);\n    Reloc rel(ibuf.subref(\"bad reloc %#x\", skip, take), take);\n    unsigned pos, type;\n    while (rel.next(pos, type))\n        if (pos >= lcaddr && pos < lcaddr + soloadconf) {\n            iv->add_interval(pos - lcaddr, type);\n            NO_printf(\"loadconf reloc detected: %x\\n\", pos);\n        }\n\n    mb_oloadconf.alloc(soloadconf);\n    oloadconf = (byte *) mb_oloadconf.getVoidPtr();\n    memcpy(oloadconf, loadconf, soloadconf);\n}\n\nvoid PeFile::processLoadConf(Reloc *rel, const Interval *iv,\n                             unsigned newaddr) // pass2\n{\n    // now we have the address of the new load config table\n    // so we can create the new relocation entries\n    for (unsigned ic = 0; ic < iv->ivnum; ic++) {\n        rel->add_reloc(iv->ivarr[ic].start + newaddr, iv->ivarr[ic].len);\n        NO_printf(\"loadconf reloc added: %x %d\\n\", iv->ivarr[ic].start + newaddr,\n                  iv->ivarr[ic].len);\n    }\n}\n\n/*************************************************************************\n// resource handling\n**************************************************************************/\n\nstruct alignas(1) PeFile::Resource::res_dir_entry final {\n    LE32 tnl; // Type | Name | Language id - depending on level\n    LE32 child;\n};\n\nstruct alignas(1) PeFile::Resource::res_dir final {\n    byte _[12]; // flags, timedate, version\n    LE16 namedentr;\n    LE16 identr;\n    // it's usually safe to assume that every res_dir contains\n    // at least one res_dir_entry - check() complains otherwise\n    res_dir_entry entries[1];\n\n    unsigned Sizeof() const { return 16 + mem_size(sizeof(res_dir_entry), namedentr + identr); }\n};\n\nstruct alignas(1) PeFile::Resource::res_data final {\n    LE32 offset;\n    LE32 size;\n    byte _[8]; // codepage, reserved\n};\n\nstruct PeFile::Resource::upx_rnode /*not_final*/ {\n    unsigned id;\n    byte *name;\n    upx_rnode *parent;\n};\n\nstruct PeFile::Resource::upx_rbranch final : public PeFile::Resource::upx_rnode {\n    unsigned nc;\n    upx_rnode **children;\n    res_dir data;\n};\n\nstruct PeFile::Resource::upx_rleaf final : public PeFile::Resource::upx_rnode {\n    upx_rleaf *next;\n    unsigned newoffset;\n    res_data data;\n};\n\nPeFile::Resource::Resource(const byte *ibufstart_, const byte *ibufend_) : root(nullptr) {\n    ibufstart = ibufstart_;\n    ibufend = ibufend_;\n}\n\nPeFile::Resource::Resource(const byte *p, const byte *ibufstart_, const byte *ibufend_) {\n    ibufstart = ibufstart_;\n    ibufend = ibufend_;\n    newstart = nullptr;\n    init(p);\n}\n\nPeFile::Resource::~Resource() noexcept {\n    if (root) {\n        destroy(root, 0);\n        root = nullptr;\n    }\n}\n\nunsigned PeFile::Resource::dirsize() const { return ALIGN_UP(dsize + ssize, 4u); }\n\nbool PeFile::Resource::next() {\n    // wow, builtin autorewind... :-)\n    current = current ? current->next : head;\n    return current != nullptr;\n}\n\nunsigned PeFile::Resource::itype() const { return current->parent->parent->id; }\n\nconst byte *PeFile::Resource::ntype() const { return current->parent->parent->name; }\n\nunsigned PeFile::Resource::size() const { return ALIGN_UP(current->data.size, 4u); }\n\nunsigned PeFile::Resource::offs() const { return current->data.offset; }\n\nunsigned &PeFile::Resource::newoffs() { return current->newoffset; }\n\nvoid PeFile::Resource::dump() const { dump(root, 0); }\n\nunsigned PeFile::Resource::iname() const { return current->parent->id; }\n\nconst byte *PeFile::Resource::nname() const { return current->parent->name; }\n\n/*\n    unsigned ilang() const {return current->id;}\n    const byte *nlang() const {return current->name;}\n*/\n\nvoid PeFile::Resource::init(const byte *res) {\n    COMPILE_TIME_ASSERT(sizeof(res_dir_entry) == 8)\n    COMPILE_TIME_ASSERT(sizeof(res_dir) == 16 + 8)\n    COMPILE_TIME_ASSERT(sizeof(res_data) == 16)\n    COMPILE_TIME_ASSERT_ALIGNED1(res_dir_entry)\n    COMPILE_TIME_ASSERT_ALIGNED1(res_dir)\n    COMPILE_TIME_ASSERT_ALIGNED1(res_data)\n\n    start = res;\n    root = head = current = nullptr;\n    dsize = ssize = 0;\n    check((const res_dir *) start, 0);\n    root = convert(start, nullptr, 0);\n}\n\nvoid PeFile::Resource::check(const res_dir *node, unsigned level) {\n    ibufcheck(node, sizeof(*node));\n    int ic = node->identr + node->namedentr;\n    if (ic == 0)\n        return;\n    for (const res_dir_entry *rde = node->entries; --ic >= 0; rde++) {\n        ibufcheck(rde, sizeof(*rde));\n        if (((rde->child & 0x80000000) == 0) ^ (level == 2))\n            throwCantPack(\"unsupported resource structure\");\n        else if (level != 2)\n            check((const res_dir *) (start + (rde->child & 0x7fffffff)), level + 1);\n    }\n}\n\nvoid PeFile::Resource::ibufcheck(const void *m, unsigned siz) {\n    if (m < ibufstart || m > ibufend - siz)\n        throwCantUnpack(\"corrupted resources\");\n}\n\nPeFile::Resource::upx_rnode *PeFile::Resource::convert(const void *rnode, upx_rnode *parent,\n                                                       unsigned level) {\n    if (level == 3) {\n        const res_data *node = ACC_STATIC_CAST(const res_data *, rnode);\n        ibufcheck(node, sizeof(*node));\n        upx_rleaf *leaf = new upx_rleaf;\n        leaf->id = 0;\n        leaf->name = nullptr;\n        leaf->parent = parent;\n        leaf->next = head;\n        leaf->newoffset = 0;\n        leaf->data = *node;\n\n        head = leaf; // append node to a linked list for traversal\n        dsize += sizeof(res_data);\n        return leaf;\n    }\n\n    const res_dir *node = ACC_STATIC_CAST(const res_dir *, rnode);\n    ibufcheck(node, sizeof(*node));\n    int ic = node->identr + node->namedentr;\n    if (ic == 0)\n        return nullptr;\n\n    upx_rbranch *branch = new upx_rbranch;\n    branch->id = 0;\n    branch->name = nullptr;\n    branch->parent = parent;\n    branch->nc = ic;\n    branch->children = New(upx_rnode *, ic);\n    branch->data = *node;\n    if (!root)         // first one\n        root = branch; // prevent leak if xcheck throws (hacked unpack or test)\n\n    for (const res_dir_entry *rde = node->entries + ic - 1; --ic >= 0; rde--) {\n        upx_rnode *child = convert(start + (rde->child & 0x7fffffff), branch, level + 1);\n        xcheck(child);\n        branch->children[ic] = child;\n        child->id = rde->tnl;\n        if (child->id & 0x80000000) {\n            const byte *p = start + (child->id & 0x7fffffff);\n            ibufcheck(p, 2);\n            const unsigned len = 2 + 2 * get_le16(p);\n            ibufcheck(p, len);\n            child->name = New(byte, len);\n            memcpy(child->name, p, len); // copy unicode string\n            ssize += len;                // size of unicode strings\n        }\n    }\n    dsize += node->Sizeof();\n    return branch;\n}\n\nvoid PeFile::Resource::build(const upx_rnode *node, unsigned &bpos, unsigned &spos,\n                             unsigned level) {\n    if (level == 3) {\n        if (bpos + sizeof(res_data) > dirsize())\n            throwCantUnpack(\"corrupted resources\");\n\n        res_data *l = (res_data *) (newstart + bpos);\n        const upx_rleaf *leaf = (const upx_rleaf *) node;\n        *l = leaf->data;\n        if (leaf->newoffset)\n            l->offset = leaf->newoffset;\n        bpos += sizeof(*l);\n        return;\n    }\n    if (bpos + sizeof(res_dir) > dirsize())\n        throwCantUnpack(\"corrupted resources\");\n\n    res_dir *const b = (res_dir *) (newstart + bpos);\n    const upx_rbranch *branch = (const upx_rbranch *) node;\n    *b = branch->data;\n    bpos += b->Sizeof();\n    res_dir_entry *be = b->entries;\n    for (unsigned ic = 0; ic < branch->nc; ic++, be++) {\n        xcheck(branch->children[ic]);\n        be->tnl = branch->children[ic]->id;\n        be->child = bpos + ((level < 2) ? 0x80000000 : 0);\n\n        const byte *p;\n        if ((p = branch->children[ic]->name) != nullptr) {\n            be->tnl = spos + 0x80000000;\n            if (spos + get_le16(p) * 2 + 2 > dirsize())\n                throwCantUnpack(\"corrupted resources\");\n            memcpy(newstart + spos, p, get_le16(p) * 2 + 2);\n            spos += get_le16(p) * 2 + 2;\n        }\n\n        build(branch->children[ic], bpos, spos, level + 1);\n    }\n}\n\nbyte *PeFile::Resource::build() {\n    mb_start.dealloc();\n    newstart = nullptr;\n    if (dirsize()) {\n        mb_start.alloc(dirsize());\n        newstart = static_cast<byte *>(mb_start.getVoidPtr());\n        unsigned bpos = 0, spos = dsize;\n        build(root, bpos, spos, 0);\n\n        // dirsize() is 4 bytes aligned, so we may need to zero\n        // up to 2 bytes to make valgrind happy\n        while (spos < dirsize())\n            newstart[spos++] = 0;\n    }\n\n    return newstart;\n}\n\nvoid PeFile::Resource::destroy(upx_rnode *node, unsigned level) noexcept {\n    xcheck(node);\n    if (level == 3) {\n        upx_rleaf *leaf = ACC_STATIC_CAST(upx_rleaf *, node);\n        delete[] leaf->name;\n        leaf->name = nullptr;\n        delete leaf;\n    } else {\n        upx_rbranch *branch = ACC_STATIC_CAST(upx_rbranch *, node);\n        delete[] branch->name;\n        branch->name = nullptr;\n        for (int ic = branch->nc; --ic >= 0;)\n            destroy(branch->children[ic], level + 1);\n        delete[] branch->children;\n        branch->children = nullptr;\n        delete branch;\n    }\n}\n\nstatic void lame_print_unicode(const byte *p) {\n    for (unsigned ic = 0; ic < get_le16(p); ic++)\n        printf(\"%c\", (char) p[ic * 2 + 2]);\n}\n\nvoid PeFile::Resource::dump(const upx_rnode *node, unsigned level) const {\n    if (level) {\n        for (unsigned ic = 1; ic < level; ic++)\n            printf(\"\\t\\t\");\n        if (node->name)\n            lame_print_unicode(node->name);\n        else\n            printf(\"0x%x\", node->id);\n        printf(\"\\n\");\n    }\n    if (level == 3)\n        return;\n    const upx_rbranch *const branch = (const upx_rbranch *) node;\n    for (unsigned ic = 0; ic < branch->nc; ic++)\n        dump(branch->children[ic], level + 1);\n}\n\nvoid PeFile::Resource::clear(byte *node, unsigned level, Interval *iv) {\n    if (level == 3)\n        iv->add_interval(node, sizeof(res_data));\n    else {\n        const res_dir *const rd = (res_dir *) node;\n        const unsigned n = rd->identr + rd->namedentr;\n        const res_dir_entry *rde = rd->entries;\n        for (unsigned ic = 0; ic < n; ic++, rde++)\n            clear(newstart + (rde->child & 0x7fffffff), level + 1, iv);\n        iv->add_interval(rd, rd->Sizeof());\n    }\n}\n\nbool PeFile::Resource::clear() {\n    newstart = const_cast<byte *>(start);\n    Interval iv(newstart);\n    clear(newstart, 0, &iv);\n    iv.flatten();\n    if (iv.ivnum == 1)\n        iv.clear();\n#if TESTING\n    if (opt->verbose > 3)\n        iv.dump();\n#endif\n    return iv.ivnum == 1;\n}\n\nvoid PeFile::processResources(Resource *res, unsigned newaddr) {\n    if (IDSIZE(PEDIR_RESOURCE) == 0)\n        return;\n    while (res->next())\n        if (res->newoffs())\n            res->newoffs() += newaddr;\n    if (res->dirsize()) {\n        byte *p = res->build();\n        memcpy(oresources, p, res->dirsize());\n    }\n}\n\nstatic bool match(unsigned itype, const byte *ntype, unsigned iname, const byte *nname,\n                  const char *keep) {\n    // format of string keep: type1[/name1],type2[/name2], ....\n    // typex and namex can be string or number\n    // hopefully resource names do not have '/' or ',' characters inside\n\n    struct Helper final {\n        static bool match(unsigned num, const byte *unistr, const char *mkeep) {\n            if (!unistr)\n                return (unsigned) atoi(mkeep) == num;\n            unsigned ic;\n            for (ic = 0; ic < get_le16(unistr); ic++)\n                if (unistr[2 + ic * 2] != (byte) mkeep[ic])\n                    return false;\n            return mkeep[ic] == 0 || mkeep[ic] == ',' || mkeep[ic] == '/';\n        }\n    };\n\n    // FIXME this comparison is not too exact\n    for (;;) {\n        const char *delim1 = strchr(keep, '/');\n        const char *delim2 = strchr(keep, ',');\n        if (Helper::match(itype, ntype, keep)) {\n            if (!delim1)\n                return true;\n            if (delim2 && delim2 < delim1)\n                return true;\n            if (Helper::match(iname, nname, delim1 + 1))\n                return true;\n        }\n        if (delim2 == nullptr)\n            break;\n        keep = delim2 + 1;\n    }\n    return false;\n}\n\nvoid PeFile::processResources(Resource *res) {\n    const unsigned vaddr = IDADDR(PEDIR_RESOURCE);\n    if ((soresources = IDSIZE(PEDIR_RESOURCE)) == 0)\n        return;\n\n    // setup default options for resource compression\n    if (opt->win32_pe.compress_resources.isThird())\n        opt->win32_pe.compress_resources = !isefi;\n    if (!opt->win32_pe.compress_resources) {\n        opt->win32_pe.compress_icons = false;\n        for (int i = 0; i < RT_LAST; i++)\n            opt->win32_pe.compress_rt[i] = false;\n    }\n    if (opt->win32_pe.compress_rt[RT_STRING].isThird()) {\n        // by default, don't compress RT_STRINGs of screensavers (\".scr\")\n        opt->win32_pe.compress_rt[RT_STRING] = true;\n        if (fn_has_ext(fi->getName(), \"scr\"))\n            opt->win32_pe.compress_rt[RT_STRING] = false;\n    }\n\n    res->init(ibuf.subref(\"bad res %#x\", vaddr, 1));\n\n    for (soresources = res->dirsize(); res->next(); soresources += 4 + res->size())\n        ;\n    if (!soresources)\n        return; // empty .rsrc Section\n    mb_oresources.alloc(soresources);\n    mb_oresources.clear();\n    oresources = mb_oresources; // => SPAN_S\n    SPAN_S_VAR(byte, ores, oresources + res->dirsize());\n\n    char *keep_icons = nullptr; // icon ids in the first icon group\n    const auto keep_icons_deleter = upx::ArrayDeleter(&keep_icons, 1); // don't leak memory\n    unsigned iconsin1stdir = 0;\n    if (opt->win32_pe.compress_icons == 2)\n        while (res->next()) // there is no rewind() in Resource\n            if (res->itype() == RT_GROUP_ICON && iconsin1stdir == 0) {\n                iconsin1stdir = get_le16(ibuf.subref(\"bad resoff %#x\", res->offs() + 4, 2));\n                delete[] keep_icons;\n                keep_icons = nullptr;\n                keep_icons = New(char, 1 + iconsin1stdir * 9);\n                *keep_icons = 0;\n                for (unsigned ic = 0; ic < iconsin1stdir; ic++)\n                    upx_safe_snprintf(\n                        keep_icons + strlen(keep_icons), 9, \"3/%u,\",\n                        get_le16(ibuf.subref(\"bad resoff %#x\", res->offs() + 6 + ic * 14 + 12, 2)));\n                if (*keep_icons)\n                    keep_icons[strlen(keep_icons) - 1] = 0;\n            }\n\n    // the icon id which should not be compressed when compress_icons == 1\n    unsigned first_icon_id = (unsigned) -1;\n    if (opt->win32_pe.compress_icons == 1)\n        while (res->next())\n            if (res->itype() == RT_GROUP_ICON && first_icon_id == (unsigned) -1)\n                first_icon_id = get_le16(ibuf.subref(\"bad resoff %#x\", res->offs() + 6 + 12, 2));\n\n    bool compress_icon = opt->win32_pe.compress_icons > 1;\n    bool compress_idir = opt->win32_pe.compress_icons == 3;\n\n    // some statistics\n    unsigned usize = 0;\n    unsigned csize = 0;\n    unsigned unum = 0;\n    unsigned cnum = 0;\n\n    while (res->next()) {\n        const unsigned rtype = res->itype();\n        bool do_compress = true;\n        if (!opt->win32_pe.compress_resources)\n            do_compress = false;\n        else if (rtype == RT_ICON) // icon\n        {\n            if (opt->win32_pe.compress_icons == 0)\n                do_compress = false;\n            else if (opt->win32_pe.compress_icons == 1)\n                if ((first_icon_id == (unsigned) -1 || first_icon_id == res->iname()))\n                    do_compress = compress_icon;\n        } else if (rtype == RT_GROUP_ICON) // icon directory\n            do_compress = compress_idir && opt->win32_pe.compress_icons;\n        else if (rtype > 0 && rtype < RT_LAST)\n            do_compress = opt->win32_pe.compress_rt[rtype] ? true : false;\n\n        if (do_compress && keep_icons)\n            do_compress &=\n                !match(res->itype(), res->ntype(), res->iname(), res->nname(), keep_icons);\n        if (do_compress)\n            do_compress &= !match(res->itype(), res->ntype(), res->iname(), res->nname(),\n                                  \"TYPELIB,REGISTRY,16\");\n        if (do_compress)\n            do_compress &= !match(res->itype(), res->ntype(), res->iname(), res->nname(),\n                                  opt->win32_pe.keep_resource);\n\n        if (do_compress) {\n            csize += res->size();\n            cnum++;\n            continue;\n        }\n\n        usize += res->size();\n        unum++;\n\n        set_le32(ores, res->offs()); // save original offset\n        ores += 4;\n        const unsigned take = res->size();\n        ICHECK(ibuf + res->offs(), take);\n        memcpy(ores, ibuf.subref(\"bad resoff %#x\", res->offs(), take), take);\n        ibuf.fill(res->offs(), take, FILLVAL);\n        res->newoffs() = ptr_diff_bytes(ores, oresources);\n        if (rtype == RT_ICON && opt->win32_pe.compress_icons == 1)\n            compress_icon = true;\n        else if (rtype == RT_GROUP_ICON) {\n            if (opt->win32_pe.compress_icons == 1) {\n                icondir_offset = 4 + ptr_diff_bytes(ores, oresources);\n                icondir_count = get_le16(oresources + icondir_offset);\n                set_le16(oresources + icondir_offset, 1);\n            }\n            compress_idir = true;\n        }\n        ores += res->size();\n    }\n    soresources = ptr_diff_bytes(ores, oresources);\n\n    if (!res->clear()) {\n        // The area occupied by the resource directory is not continuous\n        // so to still support uncompression, I can't zero this area.\n        // This decreases compression ratio, so FIXME somehow.\n        infoWarning(\"can't remove unneeded resource directory\");\n    }\n    info(\"Resources: compressed %u (%u bytes), not compressed %u (%u bytes)\", cnum, csize, unum,\n         usize);\n}\n\nunsigned PeFile::virta2objnum(unsigned addr, SPAN_0(pe_section_t) sect, unsigned objs) {\n    unsigned ic;\n    for (ic = 0; ic < objs; ic++) {\n        if (sect->vaddr <= addr && sect->vaddr + sect->vsize > addr)\n            return ic;\n        sect++;\n    }\n    // throwCantPack(\"virta2objnum() failed\");\n    return ic;\n}\n\nunsigned PeFile::tryremove(unsigned vaddr, unsigned objs) {\n    unsigned ic = virta2objnum(vaddr, isection, objs);\n    if (ic && ic == objs - 1) {\n        NO_fprintf(stderr, \"removed section: %d size: 0x%x\\n\", ic, (int) isection[ic].size);\n        info(\"removed section: %d size: 0x%x\", ic, (int) isection[ic].size);\n        objs--;\n    }\n    return objs;\n}\n\nunsigned PeFile::stripDebug(unsigned overlaystart) {\n    if (IDADDR(PEDIR_DEBUG) == 0)\n        return overlaystart;\n\n    struct alignas(1) DebugDir final {\n        byte _[16]; // flags, time/date, version, type\n        LE32 size;\n        byte __[4]; // rva\n        LE32 fpos;\n    };\n\n    COMPILE_TIME_ASSERT(sizeof(DebugDir) == 28)\n    COMPILE_TIME_ASSERT_ALIGNED1(DebugDir)\n    COMPILE_TIME_ASSERT(sizeof(((DebugDir *) nullptr)->_) == 16)\n    COMPILE_TIME_ASSERT(sizeof(((DebugDir *) nullptr)->__) == 4)\n\n    const unsigned skip = IDADDR(PEDIR_DEBUG);\n    const unsigned take = IDSIZE(PEDIR_DEBUG);\n    const DebugDir *dd = (const DebugDir *) ibuf.subref(\"bad debug %#x\", skip, take);\n    for (unsigned ic = 0; ic < IDSIZE(PEDIR_DEBUG) / sizeof(DebugDir); ic++, dd++)\n        if (overlaystart == dd->fpos)\n            overlaystart += dd->size;\n    ibuf.fill(IDADDR(PEDIR_DEBUG), IDSIZE(PEDIR_DEBUG), FILLVAL);\n    return overlaystart;\n}\n\n/*************************************************************************\n// pack\n**************************************************************************/\n\nvoid PeFile::readSectionHeaders(unsigned objs, unsigned sizeof_ih) {\n    if (objs == 0)\n        return;\n    mb_isection.alloc(mem_size(sizeof(pe_section_t), objs));\n    isection = SPAN_S_MAKE(pe_section_t, mb_isection); // => isection now is a SPAN_S\n    if (file_size_u < pe_offset + sizeof_ih + sizeof(pe_section_t) * objs) {\n        char buf[32];\n        snprintf(buf, sizeof(buf), \"too many sections %d\", objs);\n        throwCantPack(buf);\n    }\n    fi->seek(pe_offset + sizeof_ih, SEEK_SET);\n    fi->readx(isection, sizeof(pe_section_t) * objs);\n    rvamin = isection[0].vaddr;\n    const unsigned rvalast = isection[-1 + objs].vsize + isection[-1 + objs].vaddr;\n    for (unsigned j = 0; j < objs; ++j) { // expect: first is min, last is max\n        unsigned lo = isection[j].vaddr, hi = isection[j].vsize + lo;\n        if (hi < lo) { // this checks first and last sections, too!\n            char buf[64];\n            snprintf(buf, sizeof(buf), \"bad section[%d] wrap-around %#x %#x\", j, lo, hi - lo);\n            throwCantPack(buf);\n        }\n        if (lo < rvamin) {\n            char buf[64];\n            snprintf(buf, sizeof(buf), \"bad section .rva [%d] %#x < [0] %#x\", j, lo, rvamin);\n            throwCantPack(buf);\n        }\n        if (rvalast < hi) {\n            char buf[80];\n            snprintf(buf, sizeof(buf), \"bad section .rva+.vsize  [%d] %#x > [%d] %#x\", j, hi,\n                     (-1 + objs), rvalast);\n            throwCantPack(buf);\n        }\n    }\n\n    infoHeader(\"[Processing %s, format %s, %d sections]\", fn_basename(fi->getName()), getName(),\n               objs);\n}\n\nvoid PeFile::checkHeaderValues(unsigned subsystem, unsigned mask, unsigned ih_entry,\n                               unsigned ih_filealign) {\n    if ((1u << subsystem) & ~mask) {\n        char buf[100];\n        upx_safe_snprintf(buf, sizeof(buf), \"PE: subsystem %u is not supported\", subsystem);\n        throwCantPack(buf);\n    }\n    // check CLR Runtime Header directory entry\n    if (IDSIZE(PEDIR_COM_DESCRIPTOR))\n        throwCantPack(\".NET files are not yet supported\");\n\n    if (isection == nullptr)\n        throwCantPack(\"No section was found\");\n\n    if (memcmp(isection[0].name, \"UPX\", 3) == 0)\n        throwAlreadyPackedByUPX();\n\n    if (!opt->force && IDSIZE(15))\n        throwCantPack(\"file is possibly packed/protected (try --force)\");\n\n    if (ih_entry && ih_entry < rvamin)\n        throwCantPack(\"run a virus scanner on this file!\");\n\n    const unsigned fam1 = ih_filealign - 1;\n    if (!upx::has_single_bit(ih_filealign)) { // ih_filealign is not a power of 2\n        char buf[32];\n        snprintf(buf, sizeof(buf), \"bad file alignment %#x\", 1 + fam1);\n        throwCantPack(buf);\n    }\n}\n\nunsigned PeFile::handleStripRelocs(upx_uint64_t ih_imagebase, upx_uint64_t default_imagebase,\n                                   LE16 &dllflags) {\n    if (opt->win32_pe.strip_relocs < 0) {\n        if (isdll || isefi || dllflags & IMAGE_DLLCHARACTERISTICS_DYNAMIC_BASE)\n            opt->win32_pe.strip_relocs = false;\n        else\n            opt->win32_pe.strip_relocs = ih_imagebase >= default_imagebase;\n    }\n    if (opt->win32_pe.strip_relocs) {\n        if (isdll || isefi)\n            throwCantPack(\"--strip-relocs is not allowed with DLL and EFI images\");\n        if (dllflags & IMAGE_DLLCHARACTERISTICS_DYNAMIC_BASE) {\n            if (opt->force) // Disable ASLR\n            {\n                // The bit is set, so clear it with XOR\n                dllflags ^= IMAGE_DLLCHARACTERISTICS_DYNAMIC_BASE;\n                // HIGH_ENTROPY_VA has no effect without DYNAMIC_BASE, so clear\n                // it also if set\n                dllflags &= ~(unsigned) IMAGE_DLLCHARACTERISTICS_HIGH_ENTROPY_VA;\n            } else\n                throwCantPack(\"--strip-relocs is not allowed with ASLR (use \"\n                              \"with --force to remove)\");\n        }\n        if (!opt->force && ih_imagebase < default_imagebase)\n            throwCantPack(\"--strip-relocs may not support this imagebase (try \"\n                          \"with --force)\");\n        return IMAGE_FILE_RELOCS_STRIPPED;\n    } else\n        info(\"Base relocations stripping is disabled for this image\");\n    return 0;\n}\n\nunsigned PeFile::readSections(unsigned objs, unsigned usize, unsigned ih_filealign,\n                              unsigned ih_datasize) {\n    const unsigned xtrasize = UPX_MAX(ih_datasize, 65536u) + IDSIZE(PEDIR_IMPORT) +\n                              IDSIZE(PEDIR_BOUND_IMPORT) + IDSIZE(PEDIR_IAT) +\n                              IDSIZE(PEDIR_DELAY_IMPORT) + IDSIZE(PEDIR_BASERELOC);\n    ibuf.alloc(usize + xtrasize);\n\n    // BOUND IMPORT support. FIXME: is this ok?\n    ibufgood = isection[0].rawdataptr;\n    fi->seek(0, SEEK_SET);\n    fi->readx(ibuf, ibufgood);\n\n    // Interval holes(ibuf);\n\n    unsigned ic, jc, overlaystart = 0;\n    ibuf.clear(0, usize);\n    for (ic = jc = 0; ic < objs; ic++) {\n        if (isection[ic].rawdataptr && overlaystart < isection[ic].rawdataptr + isection[ic].size)\n            overlaystart = ALIGN_UP(isection[ic].rawdataptr + isection[ic].size, ih_filealign);\n        if (isection[ic].vsize == 0)\n            isection[ic].vsize = isection[ic].size;\n        if ((isection[ic].flags & IMAGE_SCN_CNT_UNINITIALIZED_DATA) ||\n            isection[ic].rawdataptr == 0 || (isection[ic].flags & IMAGE_SCN_LNK_INFO)) {\n            // holes.add_interval(isection[ic].vaddr, isection[ic].vsize);\n            continue;\n        }\n        if (isection[ic].vaddr + isection[ic].size > usize)\n            throwCantPack(\"section size problem\");\n        if (!isrtm && ((isection[ic].flags & (IMAGE_SCN_MEM_WRITE | IMAGE_SCN_MEM_SHARED)) ==\n                       (IMAGE_SCN_MEM_WRITE | IMAGE_SCN_MEM_SHARED)))\n            if (!opt->force)\n                throwCantPack(\"writable shared sections not supported (try --force)\");\n        if (jc && isection[ic].rawdataptr - jc > ih_filealign && !opt->force)\n            throwCantPack(\"superfluous data between sections (try --force)\");\n        fi->seek(isection[ic].rawdataptr, SEEK_SET);\n        jc = isection[ic].size;\n        if (jc > isection[ic].vsize)\n            jc = isection[ic].vsize;\n        if (isection[ic].vsize == 0) // hack for some tricky programs - may this break other progs?\n            jc = isection[ic].vsize = isection[ic].size;\n        if (isection[ic].vaddr + jc > ibuf.getSize())\n            throwInternalError(\"buffer too small 1\");\n        fi->readx(ibuf.subref(\"bad section %#x\", isection[ic].vaddr, jc), jc);\n        ibufgood = upx::umax(ibufgood, jc + isection[ic].vaddr); // FIXME: simplistic\n        jc += isection[ic].rawdataptr;\n    }\n    return overlaystart;\n}\n\nvoid PeFile::callCompressWithFilters(Filter &ft, int filter_strategy, unsigned ih_codebase) {\n    compressWithFilters(&ft, 2048, NULL_cconf, filter_strategy, ih_codebase, rvamin, 0, nullptr, 0);\n}\n\nvoid PeFile::callProcessStubRelocs(Reloc &rel, unsigned &ic) {\n    // WinCE wants relocation data at the beginning of a section\n    rel.finish(oxrelocs, soxrelocs);\n    if (opt->win32_pe.strip_relocs)\n        soxrelocs = 0;\n    ODADDR(PEDIR_BASERELOC) = soxrelocs ? ic : 0;\n    ODSIZE(PEDIR_BASERELOC) = soxrelocs;\n    ic += soxrelocs;\n}\n\nvoid PeFile::callProcessResources(Resource &res, unsigned &ic) {\n    if (soresources)\n        processResources(&res, ic);\n    ODADDR(PEDIR_RESOURCE) = soresources ? ic : 0;\n    ODSIZE(PEDIR_RESOURCE) = soresources;\n    ic += soresources;\n}\n\ntemplate <typename LEXX, typename ht>\nvoid PeFile::pack0(OutputFile *fo, ht &ih, ht &oh, unsigned subsystem_mask,\n                   upx_uint64_t default_imagebase, bool last_section_rsrc_only) {\n    // FIXME: we need to think about better support for --exact\n    if (opt->exact)\n        throwCantPackExact();\n\n    const unsigned objs = ih.objects;\n    readSectionHeaders(objs, sizeof(ih));\n    if (!opt->force && needForceOption())\n        throwCantPack(\"unexpected value in PE header (try --force)\");\n\n    if (ih.dllflags & IMAGE_DLLCHARACTERISTICS_FORCE_INTEGRITY) {\n        if (opt->force)\n            ih.dllflags &= ~(unsigned) IMAGE_DLLCHARACTERISTICS_FORCE_INTEGRITY;\n        else\n            throwCantPack(\"image forces integrity check (use --force to remove)\");\n    }\n    checkHeaderValues(ih.subsystem, subsystem_mask, ih.entry, ih.filealign);\n\n    // remove certificate directory entry\n    if (IDSIZE(PEDIR_SECURITY))\n        IDSIZE(PEDIR_SECURITY) = IDADDR(PEDIR_SECURITY) = 0;\n\n    if (ih.flags & IMAGE_FILE_RELOCS_STRIPPED)\n        opt->win32_pe.strip_relocs = true;\n    else\n        ih.flags |= handleStripRelocs(ih.imagebase, default_imagebase, ih.dllflags);\n\n    if (isefi) {\n        // PIC for EFI only to avoid false positive detections of Win32 images\n        // without relocations fixed address is smaller\n        if (!opt->win32_pe.strip_relocs)\n            use_stub_relocs = false;\n\n        // EFI build tools already clear DOS stub\n        // and small file alignment benefits from extra space\n        byte stub[0x40];\n        memset(stub, 0, sizeof(stub));\n        set_le16(stub, 'M' + 'Z' * 256);\n        set_le32(stub + sizeof(stub) - sizeof(LE32), sizeof(stub));\n        fo->write(stub, sizeof(stub));\n        pe_offset = sizeof(stub);\n    } else\n        handleStub(fi, fo, pe_offset);\n    unsigned overlaystart = readSections(objs, ih.imagesize, ih.filealign, ih.datasize);\n    unsigned overlay = file_size_u - stripDebug(overlaystart);\n    if (overlay >= file_size_u)\n        overlay = 0;\n    checkOverlay(overlay);\n\n    if (ih.dllflags & IMAGE_DLLCHARACTERISTICS_GUARD_CF) {\n        if (opt->force) {\n            const unsigned lcsize = IDSIZE(PEDIR_LOAD_CONFIG);\n            const unsigned lcaddr = IDADDR(PEDIR_LOAD_CONFIG);\n            const unsigned gfpos = 14 * sizeof(ih.imagebase) + 6 * sizeof(LE32) + 4 * sizeof(LE16);\n            if (lcaddr && lcsize >= gfpos + sizeof(LE32))\n                // GuardFlags: Set IMAGE_GUARD_SECURITY_COOKIE_UNUSED\n                // and clear the rest\n                set_le32(ibuf.subref(\"bad guard flags at %#x\", lcaddr + gfpos, sizeof(LE32)),\n                         0x00000800);\n            ih.dllflags ^= IMAGE_DLLCHARACTERISTICS_GUARD_CF;\n        } else\n            throwCantPack(\"GUARD_CF enabled PE files are not supported (use --force to disable)\");\n    }\n\n    Resource res(ibuf, ibuf + ibuf.getSize());\n    Interval tlsiv(ibuf);\n    Interval loadconfiv(ibuf);\n    Export xport((char *) (byte *) ibuf);\n\n    const unsigned dllstrings = processImports();\n    processTls(&tlsiv); // call before processRelocs!!\n    processLoadConf(&loadconfiv);\n    processResources(&res);\n    processExports(&xport);\n    processRelocs();\n\n    // OutputFile::dump(\"x1\", ibuf, usize);\n\n    // some checks for broken linkers - disable filter if necessary\n    bool allow_filter = true;\n    if (/*FIXME ih.codebase == ih.database\n        ||*/ ih.codebase + ih.codesize > ih.imagesize ||\n        (isection[virta2objnum(ih.codebase, isection, objs)].flags & IMAGE_SCN_CNT_CODE) == 0)\n        allow_filter = false;\n\n    const unsigned oam1 = ih.objectalign - 1;\n    if (!upx::has_single_bit(ih.objectalign)) { // ih.objectalign is not a power of 2\n        char buf[32];\n        snprintf(buf, sizeof(buf), \"bad object alignment %#x\", 1 + oam1);\n        throwCantPack(buf);\n    }\n\n    // FIXME: if the last object has a bss then this won't work\n    // newvsize = (isection[objs-1].vaddr + isection[objs-1].size + oam1) &~ oam1;\n    // temporary solution:\n    unsigned newvsize = (isection[objs - 1].vaddr + isection[objs - 1].vsize + oam1) & ~oam1;\n\n    NO_fprintf(stderr, \"newvsize=%x objs=%d\\n\", newvsize, objs);\n    if ((upx_uint64_t) newvsize + soimport + sorelocs > ibuf.getSize())\n        throwInternalError(\"buffer too small 2\");\n    memcpy(ibuf + newvsize, oimport, soimport);\n    memcpy(ibuf + newvsize + soimport, orelocs, sorelocs);\n\n    cimports = newvsize - rvamin;  // rva of preprocessed imports\n    crelocs = cimports + soimport; // rva of preprocessed fixups\n\n    ph.u_len = newvsize + soimport + sorelocs;\n\n    // some extra_info data for uncompression support\n    unsigned s = 0;\n    byte *const p1 = ibuf.subref(\"bad ph.u_len %#x\", ph.u_len, sizeof(ih));\n    memcpy(p1 + s, &ih, sizeof(ih));\n    s += sizeof(ih);\n    memcpy(p1 + s, isection, ih.objects * sizeof(*isection));\n    s += ih.objects * sizeof(*isection);\n    if (soimport) {\n        set_le32(p1 + s, cimports);\n        set_le32(p1 + s + 4, dllstrings);\n        s += 8;\n    }\n    if (sorelocs) {\n        set_le32(p1 + s, crelocs);\n        p1[s + 4] = (byte) (big_relocs & 6);\n        s += 5;\n    }\n    if (soresources) {\n        set_le16(p1 + s, icondir_count);\n        s += 2;\n    }\n    // end of extra_info data\n\n    set_le32(p1 + s, ptr_diff_bytes(p1, ibuf) - rvamin);\n    s += 4;\n    ph.u_len += s;\n    obuf.allocForCompression(ph.u_len);\n\n    // prepare packheader\n    if (ph.u_len < rvamin) { // readSectionHeaders() should have caught this\n        char buf[64];\n        snprintf(buf, sizeof(buf), \"bad PE header  ph.u_len=%#x  rvamin=%#x\", ph.u_len, rvamin);\n        throwInternalError(buf);\n    }\n    ph.u_len -= rvamin;\n    // prepare filter\n    Filter ft(ph.level);\n    ft.buf_len = ih.codesize;\n    ft.addvalue = ih.codebase - rvamin;\n    // compress\n    int filter_strategy = allow_filter ? 0 : -3;\n\n    // disable filters for files with broken headers\n    if (ih.codebase + ih.codesize > ph.u_len) {\n        ft.buf_len = 1;\n        filter_strategy = -3;\n    }\n\n    callCompressWithFilters(ft, filter_strategy, ih.codebase);\n    // info: see buildLoader()\n    newvsize = (ph.u_len + rvamin + ph.overlap_overhead + oam1) & ~oam1;\n    if (tlsindex && ((newvsize - ph.c_len - 1024 + oam1) & ~oam1) > tlsindex + 4)\n        tlsindex = 0;\n\n    const int oh_filealign = UPX_MIN(ih.filealign, 0x200u);\n    const unsigned fam1 = oh_filealign - 1;\n\n    int identsize = 0;\n    const unsigned codesize = getLoaderSection(\"IDENTSTR\", &identsize);\n    assert(identsize > 0);\n    unsigned ic;\n    getLoaderSection(\"UPX1HEAD\", (int *) &ic);\n    identsize += ic;\n\n    const bool has_oxrelocs =\n        !opt->win32_pe.strip_relocs && (use_stub_relocs || sotls || loadconfiv.ivnum);\n    const bool has_ncsection = has_oxrelocs || soimpdlls || soexport || soresources;\n    const unsigned oobjs = last_section_rsrc_only ? 4 : has_ncsection ? 3 : 2;\n    ////pe_section_t osection[oobjs];\n    pe_section_t osection[4];\n    memset(osection, 0, sizeof(osection));\n    // section 0 : bss\n    //         1 : [ident + header] + packed_data + unpacker + tls + loadconf\n    //         2 : not compressed data\n    //         3 : resource data -- wince/arm 5 needs a new section for this\n\n    // the last section should start with the resource data, because lots of lame\n    // windoze codes assume that resources starts on the beginning of a section\n\n    // note: there should be no data in the last section which needs fixup\n\n    // identsplit - number of ident + (upx header) bytes to put into the PE header\n    const unsigned sizeof_osection = sizeof(osection[0]) * oobjs;\n    int identsplit = pe_offset + sizeof_osection + sizeof(ht);\n    if ((identsplit & fam1) == 0)\n        identsplit = 0;\n    else if (((identsplit + identsize) ^ identsplit) < oh_filealign)\n        identsplit = identsize;\n    else\n        identsplit = ALIGN_UP_GAP(identsplit, oh_filealign);\n    ic = identsize - identsplit;\n\n    const unsigned c_len =\n        ((ph.c_len + ic) & 15) == 0 ? ph.c_len : ph.c_len + 16 - ((ph.c_len + ic) & 15);\n    obuf.clear(ph.c_len, c_len - ph.c_len);\n\n    const unsigned aligned_sotls = ALIGN_UP(sotls, usizeof(LEXX));\n    const unsigned s1size =\n        ALIGN_UP(ic + c_len + codesize, usizeof(LEXX)) + aligned_sotls + soloadconf;\n    const unsigned s1addr = (newvsize - (ic + c_len) + oam1) & ~oam1;\n\n    const unsigned ncsection = (s1addr + s1size + oam1) & ~oam1;\n    const unsigned upxsection = s1addr + ic + c_len;\n\n    Reloc rel(1024); // new stub relocations are put here\n    addNewRelocations(rel, upxsection);\n\n    // new PE header\n    memcpy(&oh, &ih, sizeof(oh));\n    oh.filealign = oh_filealign; // identsplit depends on this\n\n    oh.entry = upxsection;\n    oh.objects = oobjs;\n    oh.chksum = 0;\n\n    // fill the data directory\n    ODADDR(PEDIR_DEBUG) = 0;\n    ODSIZE(PEDIR_DEBUG) = 0;\n    ODADDR(PEDIR_IAT) = 0;\n    ODSIZE(PEDIR_IAT) = 0;\n    ODADDR(PEDIR_BOUND_IMPORT) = 0;\n    ODSIZE(PEDIR_BOUND_IMPORT) = 0;\n\n    // tls & loadconf are put into section 1\n    ic = s1addr + s1size - aligned_sotls - soloadconf;\n\n    if (use_tls_callbacks)\n        tls_handler_offset = linker->getSymbolOffset(\"PETLSC2\") + upxsection;\n\n    processTls(&rel, &tlsiv, ic);\n    ODADDR(PEDIR_TLS) = aligned_sotls ? ic : 0;\n    ODSIZE(PEDIR_TLS) = aligned_sotls ? (sizeof(LEXX) == 4 ? 0x18 : 0x28) : 0;\n    ic += aligned_sotls;\n\n    processLoadConf(&rel, &loadconfiv, ic);\n    ODADDR(PEDIR_LOAD_CONFIG) = soloadconf ? ic : 0;\n    ODSIZE(PEDIR_LOAD_CONFIG) = soloadconf;\n    ic += soloadconf;\n\n    const bool rel_at_sections_start = last_section_rsrc_only;\n\n    ic = ncsection;\n    if (!last_section_rsrc_only)\n        callProcessResources(res, ic);\n    if (rel_at_sections_start)\n        callProcessStubRelocs(rel, ic);\n\n    processImports2(ic, getProcessImportParam(upxsection));\n    ODADDR(PEDIR_IMPORT) = soimpdlls ? ic : 0;\n    ODSIZE(PEDIR_IMPORT) = soimpdlls;\n    ic += soimpdlls;\n\n    processExports(&xport, ic);\n    ODADDR(PEDIR_EXPORT) = soexport ? ic : 0;\n    ODSIZE(PEDIR_EXPORT) = soexport;\n    if (!isdll && opt->win32_pe.compress_exports) {\n        ODADDR(PEDIR_EXPORT) = IDADDR(PEDIR_EXPORT);\n        ODSIZE(PEDIR_EXPORT) = IDSIZE(PEDIR_EXPORT);\n    }\n    ic += soexport;\n\n    if (!rel_at_sections_start)\n        callProcessStubRelocs(rel, ic);\n\n    // when the resource is put alone into section 3\n    const unsigned res_start = (ic + oam1) & ~oam1;\n    if (last_section_rsrc_only)\n        callProcessResources(res, ic = res_start);\n\n    defineSymbols(ncsection, upxsection, sizeof(oh), identsize - identsplit, s1addr);\n    defineFilterSymbols(&ft);\n    relocateLoader();\n    const unsigned lsize = getLoaderSize();\n    MemBuffer loader(lsize);\n    memcpy(loader, getLoader(), lsize);\n    patchPackHeader(loader, lsize);\n\n    const unsigned ncsize =\n        soxrelocs + soimpdlls + soexport + (!last_section_rsrc_only ? soresources : 0);\n    assert((soxrelocs == 0) == !has_oxrelocs);\n    assert((ncsize == 0) == !has_ncsection);\n\n    // this one is tricky: it seems windoze touches 4 bytes after\n    // the end of the relocation data - so we have to increase\n    // the virtual size of this section\n    const unsigned ncsize_virt_increase = soxrelocs && (ncsize & oam1) == 0 ? 8 : 0;\n\n    // fill the sections\n    strcpy(osection[0].name, \"UPX0\");\n    strcpy(osection[1].name, \"UPX1\");\n    // after some windoze debugging I found that the name of the sections\n    // DOES matter :( .rsrc is used by oleaut32.dll (TYPELIBS)\n    // and because of this lame dll, the resource stuff must be the\n    // first in the 3rd section - the author of this dll seems to be\n    // too idiot to use the data directories... M$ suxx 4 ever!\n    // ... even worse: exploder.exe in NiceTry also depends on this to\n    // locate version info\n    strcpy(osection[2].name, !last_section_rsrc_only && soresources ? \".rsrc\" : \"UPX2\");\n\n    osection[0].vaddr = rvamin;\n    osection[1].vaddr = s1addr;\n    osection[2].vaddr = ncsection;\n\n    osection[0].size = 0;\n    osection[1].size = (s1size + fam1) & ~fam1;\n    osection[2].size = (ncsize + fam1) & ~fam1;\n\n    osection[0].vsize = osection[1].vaddr - osection[0].vaddr;\n    if (!last_section_rsrc_only) {\n        osection[1].vsize = (osection[1].size + oam1) & ~oam1;\n        osection[2].vsize = (osection[2].size + ncsize_virt_increase + oam1) & ~oam1;\n        oh.imagesize = osection[2].vaddr + osection[2].vsize;\n        osection[0].rawdataptr = (pe_offset + sizeof(ht) + sizeof_osection + fam1) & ~(size_t) fam1;\n        osection[1].rawdataptr = osection[0].rawdataptr;\n    } else {\n        osection[1].vsize = osection[1].size;\n        osection[2].vsize = osection[2].size;\n        osection[0].rawdataptr = 0;\n        osection[1].rawdataptr = (pe_offset + sizeof(ht) + sizeof_osection + fam1) & ~(size_t) fam1;\n    }\n    osection[2].rawdataptr = osection[1].rawdataptr + osection[1].size;\n\n    osection[0].flags = IMAGE_SCN_CNT_UNINITIALIZED_DATA | IMAGE_SCN_MEM_READ |\n                        IMAGE_SCN_MEM_WRITE | IMAGE_SCN_MEM_EXECUTE;\n    osection[1].flags = IMAGE_SCN_CNT_INITIALIZED_DATA | IMAGE_SCN_MEM_READ | IMAGE_SCN_MEM_WRITE |\n                        IMAGE_SCN_MEM_EXECUTE;\n    osection[2].flags = IMAGE_SCN_CNT_INITIALIZED_DATA | IMAGE_SCN_MEM_READ | IMAGE_SCN_MEM_WRITE;\n\n    if (last_section_rsrc_only) {\n        strcpy(osection[3].name, \".rsrc\");\n        osection[3].vaddr = res_start;\n        osection[3].size = (soresources + fam1) & ~fam1;\n        osection[3].vsize = osection[3].size;\n        osection[3].rawdataptr = osection[2].rawdataptr + osection[2].size;\n        osection[2].flags = IMAGE_SCN_CNT_INITIALIZED_DATA | IMAGE_SCN_MEM_READ;\n        osection[3].flags = IMAGE_SCN_CNT_INITIALIZED_DATA | IMAGE_SCN_MEM_READ;\n        oh.imagesize = (osection[3].vaddr + osection[3].vsize + oam1) & ~oam1;\n        if (soresources == 0) {\n            oh.objects = 3;\n            mem_clear(&osection[3]);\n        }\n    }\n\n    oh.bsssize = osection[0].vsize;\n    oh.datasize = osection[2].vsize + (oobjs > 3 ? osection[3].vsize : 0);\n    setOhDataBase(osection);\n    oh.codesize = osection[1].vsize;\n    oh.codebase = osection[1].vaddr;\n    setOhHeaderSize(osection);\n    if (rvamin < osection[0].rawdataptr) {\n        throwCantPack(\"object alignment too small rvamin=%#x oraw=%#x\", rvamin,\n                      unsigned(osection[0].rawdataptr));\n    }\n\n    if (opt->win32_pe.strip_relocs)\n        oh.flags |= IMAGE_FILE_RELOCS_STRIPPED;\n\n    ibuf.clear(0, oh.filealign);\n\n    info(\"Image size change: %u -> %u KiB\", ih.imagesize / 1024, oh.imagesize / 1024);\n\n    infoHeader(\"[Writing compressed file]\");\n\n    // write loader + compressed file\n    fo->write(&oh, sizeof(oh));\n    fo->write(osection, sizeof(osection[0]) * oobjs);\n    // some alignment\n    if (identsplit == identsize) {\n        unsigned n = osection[!last_section_rsrc_only ? 0 : 1].rawdataptr - fo->getBytesWritten() -\n                     identsize;\n        assert(n <= oh.filealign);\n        fo->write(ibuf, n);\n    }\n    fo->write(loader + codesize, identsize);\n    infoWriting(\"loader\", fo->getBytesWritten());\n    fo->write(obuf, c_len);\n    infoWriting(\"compressed data\", c_len);\n    fo->write(loader, codesize);\n    if (opt->debug.dump_stub_loader)\n        OutputFile::dump(opt->debug.dump_stub_loader, loader, codesize);\n    if ((ic = fo->getBytesWritten() & (sizeof(LEXX) - 1)) != 0)\n        fo->write(ibuf, sizeof(LEXX) - ic);\n    fo->write(otls, aligned_sotls);\n    fo->write(oloadconf, soloadconf);\n    if ((ic = fo->getBytesWritten() & fam1) != 0)\n        fo->write(ibuf, oh.filealign - ic);\n    if (!last_section_rsrc_only)\n        fo->write(oresources, soresources);\n    else\n        fo->write(oxrelocs, soxrelocs);\n    fo->write(oimpdlls, soimpdlls);\n    fo->write(oexport, soexport);\n    if (!last_section_rsrc_only)\n        fo->write(oxrelocs, soxrelocs);\n\n    if ((ic = fo->getBytesWritten() & fam1) != 0)\n        fo->write(ibuf, oh.filealign - ic);\n\n    if (last_section_rsrc_only) {\n        fo->write(oresources, soresources);\n        if ((ic = fo->getBytesWritten() & fam1) != 0)\n            fo->write(ibuf, oh.filealign - ic);\n    }\n\n#if 0\n    printf(\"%-13s: program hdr  : %8d bytes\\n\", getName(), (int) sizeof(oh));\n    printf(\"%-13s: sections     : %8d bytes\\n\", getName(), (int) sizeof(osection[0]) * oobjs);\n    printf(\"%-13s: ident        : %8d bytes\\n\", getName(), (int) identsize);\n    printf(\"%-13s: compressed   : %8d bytes\\n\", getName(), (int) c_len);\n    printf(\"%-13s: decompressor : %8d bytes\\n\", getName(), (int) codesize);\n    printf(\"%-13s: tls          : %8d bytes\\n\", getName(), (int) sotls);\n    printf(\"%-13s: aligned_tls  : %8d bytes\\n\", getName(), (int) aligned_sotls);\n    printf(\"%-13s: resources    : %8d bytes\\n\", getName(), (int) soresources);\n    printf(\"%-13s: imports      : %8d bytes\\n\", getName(), (int) soimpdlls);\n    printf(\"%-13s: exports      : %8d bytes\\n\", getName(), (int) soexport);\n    printf(\"%-13s: relocs       : %8d bytes\\n\", getName(), (int) soxrelocs);\n    printf(\"%-13s: loadconf     : %8d bytes\\n\", getName(), (int) soloadconf);\n    // linker->dumpSymbols();\n#endif\n\n    // verify\n    verifyOverlappingDecompression();\n\n    // copy the overlay\n    copyOverlay(fo, overlay, obuf);\n\n    // finally check the compression ratio\n    if (!checkFinalCompressionRatio(fo))\n        throwNotCompressible();\n}\n\n/*************************************************************************\n// unpack\n**************************************************************************/\n\nvoid PeFile::rebuildRelocs(SPAN_S(byte) & extra_info, unsigned bits, unsigned flags,\n                           upx_uint64_t imagebase) {\n    assert(bits == 32 || bits == 64);\n    if (!ODADDR(PEDIR_BASERELOC) || !ODSIZE(PEDIR_BASERELOC) ||\n        (flags & IMAGE_FILE_RELOCS_STRIPPED))\n        return;\n\n    if (ODSIZE(PEDIR_BASERELOC) == 8) // some tricky dlls use this\n    {\n        omemcpy(obuf + (ODADDR(PEDIR_BASERELOC) - rvamin), \"\\x0\\x0\\x0\\x0\\x8\\x0\\x0\\x0\", 8);\n        return;\n    }\n\n    const unsigned orig_crelocs = mem_size(1, get_le32(extra_info));\n    const byte big = extra_info[4];\n    extra_info += 5;\n\n    SPAN_S_VAR(const byte, rdata, obuf + orig_crelocs, obuf);\n    MemBuffer mb_wrkmem;\n    unsigned relocnum = unoptimizeReloc(rdata, mb_wrkmem, obuf, orig_crelocs, bits, true);\n\n    // 16-bit relocations\n    unsigned r16 = 0;\n    if (big & 6) { // count 16-bit relocations\n        SPAN_S_VAR(const LE32, q, SPAN_TYPE_CAST(const LE32, rdata));\n        while (*q++)\n            r16++;\n        if ((big & 6) == 6)\n            while (*++q)\n                r16++;\n    }\n    Reloc rel(relocnum + r16);\n    if (big & 6) { // add 16-bit relocations\n        SPAN_S_VAR(const LE32, q, SPAN_TYPE_CAST(const LE32, rdata));\n        while (*q)\n            rel.add_reloc(*q++ + rvamin, (big & 4) ? IMAGE_REL_BASED_LOW : IMAGE_REL_BASED_HIGH);\n        if ((big & 6) == 6)\n            while (*++q)\n                rel.add_reloc(*q + rvamin, IMAGE_REL_BASED_HIGH);\n        // rdata = (const byte *) raw_bytes(q, 0); // advance rdata\n    }\n\n    SPAN_S_VAR(byte, const wrkmem, mb_wrkmem);\n    for (unsigned ic = 0; ic < relocnum; ic++) {\n        OPTR_VAR(byte, const p, obuf + get_le32(wrkmem + sizeof(LE32) * ic));\n        if (bits == 32)\n            set_le32(p, get_le32(p) + imagebase + rvamin);\n        else\n            set_le64(p, get_le64(p) + imagebase + rvamin);\n        rel.add_reloc(rvamin + get_le32(wrkmem + sizeof(LE32) * ic),\n                      bits == 32 ? IMAGE_REL_BASED_HIGHLOW : IMAGE_REL_BASED_DIR64);\n    }\n    rel.finish(oxrelocs, soxrelocs);\n\n    omemcpy(obuf + (ODADDR(PEDIR_BASERELOC) - rvamin), oxrelocs, soxrelocs);\n    delete[] oxrelocs;\n    oxrelocs = nullptr;\n    mb_wrkmem.dealloc();\n\n    ODSIZE(PEDIR_BASERELOC) = soxrelocs;\n}\n\nvoid PeFile::rebuildExports() {\n    if (ODSIZE(PEDIR_EXPORT) == 0 || ODADDR(PEDIR_EXPORT) == IDADDR(PEDIR_EXPORT))\n        return; // nothing to do\n\n    opt->win32_pe.compress_exports = 0;\n    Export xport((char *) (byte *) ibuf - isection[2].vaddr);\n    processExports(&xport);\n    processExports(&xport, ODADDR(PEDIR_EXPORT));\n    omemcpy(obuf + (ODADDR(PEDIR_EXPORT) - rvamin), oexport, soexport);\n}\n\nvoid PeFile::rebuildTls() {\n    // this is an easy one : just do nothing ;-)\n}\n\nnamespace {\ntemplate <class T>\nstruct VPtr final { // \"virtual pointer\" pointing before a buffer\n    static_assert(sizeof(T) == 1);\n    SPAN_S(T) base;\n    size_t x;\n    // return base + (n - x)\n    SPAN_S(T) operator+(size_t n) const { return base + mem_size_get_n(sizeof(T), n - x); }\n};\n} // namespace\n\nvoid PeFile::rebuildResources(SPAN_S(byte) & extra_info, unsigned lastvaddr) {\n    if (ODSIZE(PEDIR_RESOURCE) == 0 || IDSIZE(PEDIR_RESOURCE) == 0)\n        return;\n\n    icondir_count = get_le16(extra_info);\n    extra_info += 2;\n\n    const unsigned vaddr = IDADDR(PEDIR_RESOURCE);\n\n    if (vaddr < lastvaddr || (vaddr - lastvaddr) > ibuf.getSize())\n        throwCantUnpack(\"corrupted PE header\");\n\n    // INFO: use VPtr for \"virtual pointer\" pointing before a buffer\n    //// const byte *const r = ibuf.raw_bytes(0) - lastvaddr;\n    VPtr<const byte> const r{ibuf, lastvaddr};\n    Resource res(raw_bytes(r + vaddr, 0), ibuf, ibuf + ibuf.getSize());\n    while (res.next())\n        if (res.offs() > vaddr) {\n            ICHECK(r + (res.offs() - 4), 4);\n            unsigned origoffs = get_le32(r + (res.offs() - 4));\n            res.newoffs() = origoffs;\n            omemcpy(obuf + (origoffs - rvamin), r + res.offs(), res.size());\n            if (icondir_count && res.itype() == RT_GROUP_ICON) {\n                set_le16(obuf + (origoffs - rvamin + 4), icondir_count);\n                icondir_count = 0;\n            }\n        }\n    if (res.dirsize()) {\n        byte *p = res.build();\n        OCHECK(obuf + (ODADDR(PEDIR_RESOURCE) - rvamin), 16);\n        // write back when the original is zeroed\n        if (get_le32(obuf + (ODADDR(PEDIR_RESOURCE) - rvamin + 12)) == 0)\n            omemcpy(obuf + (ODADDR(PEDIR_RESOURCE) - rvamin), p, res.dirsize());\n    }\n}\n\ntemplate <typename LEXX, typename ord_mask_t>\nvoid PeFile::rebuildImports(SPAN_S(byte) & extra_info, ord_mask_t ord_mask, bool set_oft) {\n    if (ODADDR(PEDIR_IMPORT) == 0 || ODSIZE(PEDIR_IMPORT) <= sizeof(import_desc))\n        return;\n\n    OPTR_VAR(const byte, const imdata, obuf + mem_size(1, get_le32(extra_info)));\n    const unsigned inamespos = mem_size(1, get_le32(extra_info + 4));\n    extra_info += 8;\n\n    unsigned sdllnames = 0;\n\n    IPTR_VAR_OFFSET(const byte, const import, IDADDR(PEDIR_IMPORT) - isection[2].vaddr);\n    OPTR_VAR(const byte, p, raw_bytes(imdata, 4));\n\n    for (; get_le32(p) != 0; ++p) {\n        const byte *dname = raw_bytes(import + mem_size(1, get_le32(p)), 1);\n        const unsigned dlen = strlen(dname);\n        ICHECK(dname, dlen + 1);\n\n        sdllnames += dlen + 1;\n        for (p += 8; *p;)\n            if (*p == 1)\n                p += 1 + strlen(p + 1) + 1;\n            else if (*p == 0xff)\n                p += 3; // ordinal\n            else\n                p += 5;\n    }\n    sdllnames = ALIGN_UP(sdllnames, 2u);\n\n    // INFO: use VPtr for \"virtual pointer\" pointing before a buffer\n    //// byte *const Obuf = obuf.raw_bytes(0) - rvamin;\n    VPtr<byte> const Obuf{obuf, rvamin};\n    SPAN_S_VAR(import_desc, im, (import_desc *) raw_bytes(Obuf + ODADDR(PEDIR_IMPORT), 0), obuf);\n    SPAN_0_VAR(byte, dllnames, inamespos ? raw_bytes(Obuf + inamespos, 0) : nullptr, obuf);\n    SPAN_0_VAR(byte, const importednames_start, inamespos ? dllnames + sdllnames : nullptr);\n    SPAN_0_VAR(byte, importednames, importednames_start);\n\n    for (p = imdata; get_le32(p) != 0; ++p) {\n        // restore the name of the dll\n        const byte *dname = raw_bytes(import + get_le32(p), 1);\n        const unsigned dlen = strlen(dname);\n        ICHECK(dname, dlen + 1);\n\n        const unsigned iatoffs = get_le32(p + 4) + rvamin;\n        if (inamespos) {\n            // now I rebuild the dll names\n            omemcpy(dllnames, dname, dlen + 1);\n            im->dllname = ptr_udiff_bytes(dllnames, obuf) + rvamin;\n            //;;;printf(\"\\ndll: %s:\",dllnames);\n            dllnames += dlen + 1;\n        } else {\n            omemcpy(Obuf + im->dllname, dname, dlen + 1);\n        }\n        im->iat = iatoffs;\n        if (set_oft)\n            im->oft = iatoffs;\n\n        OPTR_VAR(LEXX, newiat, (LEXX *) raw_bytes(Obuf + iatoffs, 0));\n\n        // restore the imported names+ordinals\n        for (p += 8; *p; ++newiat)\n            if (*p == 1) {\n                const unsigned ilen = strlen(++p) + 1;\n                if (inamespos) {\n                    if (ptr_udiff_bytes(importednames, importednames_start) & 1)\n                        importednames -= 1;\n                    omemcpy(importednames + 2, p, ilen);\n                    //;;;printf(\" %s\",importednames+2);\n                    *newiat = ptr_udiff_bytes(importednames, obuf) + rvamin;\n                    importednames += 2 + ilen;\n                } else {\n                    // Beware overlap!\n                    omemmove(Obuf + (*newiat + 2), p, ilen);\n                }\n                p += ilen;\n            } else if (*p == 0xff) {\n                *newiat = get_le16(p + 1) + ord_mask;\n                //;;;printf(\" %x\",(unsigned)*newiat);\n                p += 3;\n            } else {\n                *newiat = *(const LEXX *) raw_bytes(import + get_le32(p + 1), sizeof(LEXX));\n                assert(*newiat & ord_mask);\n                p += 5;\n            }\n        *newiat = 0;\n        im++;\n    }\n    // memset(imdata, 0, ptr_udiff_bytes(p, imdata));\n}\n\ntemplate <typename ht, typename LEXX, typename ord_mask_t>\nvoid PeFile::unpack0(OutputFile *fo, const ht &ih, ht &oh, ord_mask_t ord_mask, bool set_oft) {\n    // infoHeader(\"[Processing %s, format %s, %d sections]\", fn_basename(fi->getName()), getName(),\n    // objs);\n\n    handleStub(fi, fo, pe_offset);\n    if (ih.filealign == 0)\n        throwCantUnpack(\"unexpected value in the PE header\");\n\n    const unsigned iobjs = ih.objects;\n    const unsigned overlay =\n        file_size_u -\n        ALIGN_UP(isection[iobjs - 1].rawdataptr + isection[iobjs - 1].size, ih.filealign);\n    checkOverlay(overlay);\n\n    ibuf.alloc(ph.c_len);\n    obuf.allocForDecompression(ph.u_len);\n    fi->seek(isection[1].rawdataptr - 64 + ph.buf_offset + ph.getPackHeaderSize(), SEEK_SET);\n    fi->readx(ibuf, ibufgood = ph.c_len);\n\n    // decompress\n    decompress(ibuf, obuf);\n    unsigned skip = get_le32(obuf + (ph.u_len - 4));\n    unsigned take = sizeof(oh);\n    SPAN_S_VAR(byte, extra_info, obuf);\n    extra_info = obuf.subref(\"bad extra_info offset %#x\", skip, take);\n    // byte *const eistart = raw_bytes(extra_info, 0);\n\n    memcpy(&oh, extra_info, take);\n    extra_info += take;\n    skip += take;\n    unsigned objs = oh.objects;\n\n    if ((int) objs <= 0 || (iobjs > 2 && isection[2].size == 0))\n        throwCantUnpack(\"unexpected value in the PE header\");\n    Array(pe_section_t, osection, objs);\n    take = sizeof(pe_section_t) * objs;\n    extra_info = obuf.subref(\"bad extra section size at %#x\", skip, take);\n    memcpy(osection, extra_info, take);\n    extra_info += take;\n    skip += take;\n    rvamin = osection[0].vaddr;\n\n    if (iobjs > 2) {\n        // read the noncompressed section\n        const unsigned size = isection[2].size;\n        ibuf.dealloc();\n        ibuf.alloc(size + 1);\n        fi->seek(isection[2].rawdataptr, SEEK_SET);\n        fi->readx(ibuf, ibufgood = size);\n        ibuf[size] = 0; // allow strlen() up to 'size'\n    }\n\n    // unfilter\n    if (ph.filter) {\n        Filter ft(ph.level);\n        ft.init(ph.filter, oh.codebase - rvamin);\n        ft.cto = (byte) ph.filter_cto;\n        OCHECK(obuf + (oh.codebase - rvamin), oh.codesize);\n        ft.unfilter(obuf + (oh.codebase - rvamin), oh.codesize);\n    }\n\n    // FIXME: ih.flags is checked here because of a bug in UPX 0.92\n    if (ih.flags & IMAGE_FILE_RELOCS_STRIPPED) {\n        oh.flags |= IMAGE_FILE_RELOCS_STRIPPED;\n        ODADDR(PEDIR_BASERELOC) = 0;\n        ODSIZE(PEDIR_BASERELOC) = 0;\n    }\n\n    rebuildImports<LEXX>(extra_info, ord_mask, set_oft);\n    rebuildRelocs(extra_info, sizeof(ih.imagebase) * 8, oh.flags, oh.imagebase);\n    rebuildTls();\n    rebuildExports();\n\n    if (iobjs > 3) {\n        // read the resource section if present\n        ibuf.dealloc();\n        ibuf.alloc(isection[3].size);\n        fi->seek(isection[3].rawdataptr, SEEK_SET);\n        fi->readx(ibuf, ibufgood = isection[3].size);\n    }\n\n    rebuildResources(extra_info, isection[ih.objects - 1].vaddr);\n\n    // FIXME: this does bad things if the relocation section got removed\n    //  during compression ...\n    // memset(eistart, 0, ptr_udiff_bytes(extra_info, eistart) + 4);\n\n    // fill the data directory\n    ODADDR(PEDIR_DEBUG) = 0;\n    ODSIZE(PEDIR_DEBUG) = 0;\n    ODADDR(PEDIR_IAT) = 0;\n    ODSIZE(PEDIR_IAT) = 0;\n    ODADDR(PEDIR_BOUND_IMPORT) = 0;\n    ODSIZE(PEDIR_BOUND_IMPORT) = 0;\n\n    setOhHeaderSize(osection);\n    oh.chksum = 0;\n\n    // write decompressed file\n    if (fo) {\n        unsigned ic = 0;\n        while (ic < objs && osection[ic].rawdataptr == 0)\n            ic++;\n\n        ibuf.dealloc();\n        ibuf.alloc(osection[ic].rawdataptr);\n        ibuf.clear();\n        infoHeader(\"[Writing uncompressed file]\");\n\n        // write header + decompressed file\n        fo->write(&oh, sizeof(oh));\n        fo->write(osection, objs * sizeof(pe_section_t));\n        fo->write(ibuf, osection[ic].rawdataptr - fo->getBytesWritten());\n        for (ic = 0; ic < objs; ic++)\n            if (osection[ic].rawdataptr)\n                fo->write(obuf + (osection[ic].vaddr - rvamin),\n                          ALIGN_UP(osection[ic].size, oh.filealign));\n        copyOverlay(fo, overlay, obuf);\n    }\n    ibuf.dealloc();\n}\n\nint PeFile::canUnpack0(unsigned max_sections, unsigned objs, unsigned ih_entry, unsigned ih_size) {\n    const unsigned min_sections = isefi ? 2 : 3;\n    if (objs < min_sections)\n        return -1;\n    mb_isection.alloc(mem_size(sizeof(pe_section_t), objs));\n    isection = SPAN_S_MAKE(pe_section_t, mb_isection); // => isection now is a SPAN_S\n    fi->seek(pe_offset + ih_size, SEEK_SET);\n    fi->readx(isection, sizeof(pe_section_t) * objs);\n    bool is_packed = (objs <= max_sections && (IDSIZE(15) || ih_entry > isection[1].vaddr));\n    bool found_ph = false;\n    if (memcmp(isection[0].name, \"UPX\", 3) == 0) {\n        // current version\n        fi->seek(isection[1].rawdataptr - 64, SEEK_SET);\n        found_ph = readPackHeader(1024);\n        if (!found_ph) {\n            // old versions\n            fi->seek(isection[2].rawdataptr, SEEK_SET);\n            found_ph = readPackHeader(1024);\n        }\n    }\n    if (is_packed && found_ph)\n        return true;\n    if (!is_packed && !found_ph)\n        return -1;\n    if (is_packed && ih_entry < isection[2].vaddr) {\n        byte buf[256];\n        bool x = false;\n\n        memset(buf, 0, sizeof(buf));\n        try {\n            fi->seek(ih_entry - isection[1].vaddr + isection[1].rawdataptr, SEEK_SET);\n            fi->read(buf, sizeof(buf));\n\n            // FIXME this is for x86\n            static const byte magic[] = \"\\x8b\\x1e\\x83\\xee\\xfc\\x11\\xdb\";\n            // mov ebx, [esi];    sub esi, -4;    adc ebx,ebx\n\n            int offset = find(buf, sizeof(buf), magic, 7);\n            if (offset >= 0 && find(buf + offset + 1, sizeof(buf) - offset - 1, magic, 7) >= 0)\n                x = true;\n        } catch (...) {\n            // x = true;\n        }\n        if (x)\n            throwCantUnpack(\"file is modified/hacked/protected; take care!!!\");\n        else\n            throwCantUnpack(\"file is possibly modified/hacked/protected; take care!\");\n        return false; // not reached\n    }\n\n    // FIXME: what should we say here ?\n    // throwCantUnpack(\"file is possibly modified/hacked/protected; take care!\");\n    return false;\n}\n\nupx_uint64_t PeFile::ilinkerGetAddress(const char *d, const char *n) const {\n    return ilinker->getAddress(d, n);\n}\n\nPeFile::~PeFile() noexcept {\n    oimpdlls = nullptr;\n    delete[] oxrelocs;\n    delete ilinker;\n    // delete res;\n}\n\n/*************************************************************************\n//  PeFile32\n**************************************************************************/\n\nPeFile32::PeFile32(InputFile *f) : super(f) {\n    COMPILE_TIME_ASSERT(sizeof(pe_header_t) == 248)\n    COMPILE_TIME_ASSERT_ALIGNED1(pe_header_t)\n\n    iddirs = ih.ddirs;\n    oddirs = oh.ddirs;\n}\n\nPeFile32::~PeFile32() noexcept {}\n\nvoid PeFile32::readPeHeader() {\n    fi->readx(&ih, sizeof(ih));\n    if (31 < (unsigned) ih.subsystem) {\n        throwCantPack(\"bad ih.subsystem 0x%x\", (unsigned) ih.subsystem);\n    }\n    isefi = ((1u << ih.subsystem) &\n             ((1u << IMAGE_SUBSYSTEM_EFI_APPLICATION) |\n              (1u << IMAGE_SUBSYSTEM_EFI_BOOT_SERVICE_DRIVER) |\n              (1u << IMAGE_SUBSYSTEM_EFI_RUNTIME_DRIVER) | (1u << IMAGE_SUBSYSTEM_EFI_ROM))) != 0;\n    isdll = !isefi && (ih.flags & IMAGE_FILE_DLL) != 0;\n    use_dep_hack &= !isefi;\n    use_clear_dirty_stack &= !isefi;\n}\n\nvoid PeFile32::pack0(OutputFile *fo, unsigned subsystem_mask, upx_uint64_t default_imagebase,\n                     bool last_section_rsrc_only) {\n    super::pack0<LE32>(fo, ih, oh, subsystem_mask, default_imagebase, last_section_rsrc_only);\n    // infoWarning(\"End of PeFile32::pack0\");\n}\n\nvoid PeFile32::unpack(OutputFile *fo) {\n    bool set_oft = getFormat() == UPX_F_WINCE_ARM;\n    unpack0<pe_header_t, LE32>(fo, ih, oh, 1U << 31, set_oft);\n}\n\ntribool PeFile32::canUnpack() {\n    if (!canPack()) // this calls readFileHeader() and readPeHeader()\n        return false;\n    return canUnpack0(getFormat() == UPX_F_WINCE_ARM ? 4 : 3, ih.objects, ih.entry, sizeof(ih));\n}\n\nunsigned PeFile32::processImports() { // pass 1\n    return processImports0<LE32>(1u << 31);\n}\n\nvoid PeFile32::processTls(Interval *iv) { processTls1<LE32>(iv, ih.imagebase, ih.imagesize); }\n\nvoid PeFile32::processTls(Reloc *r, const Interval *iv, unsigned a) {\n    processTls2<LE32>(r, iv, a, ih.imagebase);\n}\n\n/*************************************************************************\n//  PeFile64\n**************************************************************************/\n\nPeFile64::PeFile64(InputFile *f) : super(f) {\n    COMPILE_TIME_ASSERT(sizeof(pe_header_t) == 264)\n    COMPILE_TIME_ASSERT_ALIGNED1(pe_header_t)\n\n    iddirs = ih.ddirs;\n    oddirs = oh.ddirs;\n}\n\nPeFile64::~PeFile64() noexcept {}\n\nvoid PeFile64::readPeHeader() {\n    fi->readx(&ih, sizeof(ih));\n    if (31 < (unsigned) ih.subsystem) {\n        throwCantPack(\"bad ih.subsystem 0x%x\", (unsigned) ih.subsystem);\n    }\n    isefi = ((1u << ih.subsystem) &\n             ((1u << IMAGE_SUBSYSTEM_EFI_APPLICATION) |\n              (1u << IMAGE_SUBSYSTEM_EFI_BOOT_SERVICE_DRIVER) |\n              (1u << IMAGE_SUBSYSTEM_EFI_RUNTIME_DRIVER) | (1u << IMAGE_SUBSYSTEM_EFI_ROM))) != 0;\n    isdll = !isefi && (ih.flags & IMAGE_FILE_DLL) != 0;\n    use_dep_hack &= !isefi;\n    use_clear_dirty_stack &= !isefi;\n}\n\nvoid PeFile64::pack0(OutputFile *fo, unsigned subsystem_mask, upx_uint64_t default_imagebase) {\n    super::pack0<LE64>(fo, ih, oh, subsystem_mask, default_imagebase, false);\n}\n\nvoid PeFile64::unpack(OutputFile *fo) { unpack0<pe_header_t, LE64>(fo, ih, oh, 1ULL << 63, false); }\n\ntribool PeFile64::canUnpack() {\n    if (!canPack()) // this calls readFileHeader() and readPeHeader()\n        return false;\n    return canUnpack0(3, ih.objects, ih.entry, sizeof(ih));\n}\n\nunsigned PeFile64::processImports() { // pass 1\n    return processImports0<LE64>(1ULL << 63);\n}\n\nvoid PeFile64::processTls(Interval *iv) { processTls1<LE64>(iv, ih.imagebase, ih.imagesize); }\n\nvoid PeFile64::processTls(Reloc *r, const Interval *iv, unsigned a) {\n    processTls2<LE64>(r, iv, a, ih.imagebase);\n}\n\n/*\n extra_info added to help uncompression:\n\n <ih sizeof(pe_head)>\n <pe_section_t objs*sizeof(pe_section_t)>\n <start of compressed imports 4> - optional           \\\n <start of the names from uncompressed imports> - opt /\n <start of compressed relocs 4> - optional   \\\n <relocation type indicator 1> - optional    /\n <icondir_count 2> - optional\n <offset of extra info 4>\n*/\n\n/* vim:set ts=4 sw=4 et: */\n","size_bytes":122414},"src/ui.cpp":{"content":"/* ui.cpp -- User Interface\n\n   This file is part of the Resize executable compressor.\n\n   Copyright (C) 2025 WHO-AM-I-404\n   Based on UPX - Ultimate Packer for eXecutables\n   Copyright (C) 1996-2025 Markus Franz Xaver Johannes Oberhumer\n   Copyright (C) 1996-2025 Laszlo Molnar\n   All Rights Reserved.\n\n   Resize and the UCL library are free software; you can redistribute them\n   and/or modify them under the terms of the GNU General Public License as\n   published by the Free Software Foundation; either version 2 of\n   the License, or (at your option) any later version.\n\n   This program is distributed in the hope that it will be useful,\n   but WITHOUT ANY WARRANTY; without even the implied warranty of\n   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n   GNU General Public License for more details.\n\n   You should have received a copy of the GNU General Public License\n   along with this program; see the file COPYING.\n   If not, write to the Free Software Foundation, Inc.,\n   59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.\n\n   WHO-AM-I-404 <who-am-i-404@proton.me>\n   Based on original work by:\n   Markus F.X.J. Oberhumer <markus@oberhumer.com>\n   Laszlo Molnar <ezerotven+github@gmail.com>\n */\n\n// INFO: not thread-safe; instantiated and used by class Packer, and the\n// static (global) variables are also updated in work.cpp\n\n#include \"conf.h\"\n#include \"file.h\"\n#include \"packer.h\"\n#include \"ui.h\"\n#include \"console/screen.h\"\n\n#if 1 && (USE_SCREEN)\n#define UI_USE_SCREEN 1\n#endif\n\nenum {\n    M_QUIET,    // nothing at all '-qqq'\n    M_INFO,     // print a one line info after compression '-qq'\n    M_MSG,      // print \"compressing\", then \"\\r\" and M_INFO\n    M_CB_TERM,  // 1 line callback using stdout\n    M_CB_SCREEN // 2 line callback using screen\n};\n\nstruct UiPacker::State final {\n    int mode;\n\n    unsigned u_len;\n    unsigned step;\n    unsigned next_update;\n\n    int pass;\n    int total_passes;\n\n    // message stuff\n    char msg_buf[1 + 79 + 1];\n    int pos;               // last progress bar position\n    unsigned spin_counter; // for spinner\n\n    int bar_pos;\n    int bar_len;\n    int pass_digits; // number of digits needed to print total_passes\n\n#if (UI_USE_SCREEN)\n    screen_t *screen;\n    int screen_init_done;\n    int b_cx, b_cy;\n    int s_cx, s_cy;\n    int s_fg, s_bg;\n    int c_fg;\n    int scroll_up;\n    int cursor_shape;\n#else\n    void *screen;\n#endif\n};\n\n// static\nunsigned UiPacker::total_files = 0;\nunsigned UiPacker::total_files_done = 0;\nupx_uint64_t UiPacker::total_c_len = 0;\nupx_uint64_t UiPacker::total_u_len = 0;\nupx_uint64_t UiPacker::total_fc_len = 0;\nupx_uint64_t UiPacker::total_fu_len = 0;\nunsigned UiPacker::update_c_len = 0;\nunsigned UiPacker::update_u_len = 0;\nunsigned UiPacker::update_fc_len = 0;\nunsigned UiPacker::update_fu_len = 0;\n\n/*************************************************************************\n// constants\n**************************************************************************/\n\nstatic const char header_line1[] = \"        File size         Ratio      Format      Name\\n\";\nstatic const char header_line2[] = \"   --------------------   ------   -----------   -----------\\n\";\n\nstatic const char progress_filler[4 + 1] = \".*[]\";\n\nstatic void init_global_constants(void) noexcept {\n#if 0 && (ACC_OS_DOS16 || ACC_OS_DOS32)\n    // FIXME: should test codepage here\n\n#if 1 && (ACC_OS_DOS32) && defined(__DJGPP__)\n    /* check for Windows NT/2000/XP */\n    if (_get_dos_version(1) == 0x0532)\n        return;\n#endif\n\n    char *p;\n    for (p = header_line2; *p; p++)\n        if (*p == '-')\n            *p = '\\xc4';\n\n    //strcpy(progress_filler, \"\\x07\\xb0[]\");\n    //strcpy(progress_filler, \"\\x07\\xb1[]\");\n    strcpy(progress_filler, \"\\xf9\\xfe[]\");\n#endif\n}\n\n/*************************************************************************\n//\n**************************************************************************/\n\nstatic const char *mkline(upx_uint64_t fu_len, upx_uint64_t fc_len, upx_uint64_t u_len,\n                          upx_uint64_t c_len, const char *format_name, const char *filename,\n                          bool decompress = false) {\n    static char buf[2048]; // static! // TODO later: check if affected by WITH_THREADS\n    char r[7 + 1];\n    char fn[15 + 1];\n    const char *f;\n\n    // Large ratios can happen because of overlays that are\n    // appended after a program is packed.\n    unsigned ratio = get_ratio(fu_len, fc_len);\n    if (ratio >= 1000 * 1000)\n        strcpy(r, \"overlay\");\n    else\n        upx_safe_snprintf(r, sizeof(r), \"%3u.%02u%%\", ratio / 10000, (ratio % 10000) / 100);\n    if (decompress)\n        f = \"%10lld <-%10lld  %7s %15s %s\";\n    else\n        f = \"%10lld ->%10lld  %7s %15s %s\";\n    center_string(fn, sizeof(fn), format_name);\n    assert(strlen(fn) == 15);\n    upx_safe_snprintf(buf, sizeof(buf), f, (long long) fu_len, (long long) fc_len, r, fn, filename);\n    UNUSED(u_len);\n    UNUSED(c_len);\n    return buf;\n}\n\n/*************************************************************************\n//\n**************************************************************************/\n\nUiPacker::UiPacker(const PackerBase *pb_) : pb(pb_) {\n    static upx_std_once_flag init_done;\n    upx_std_call_once(init_done, init_global_constants);\n\n    cb.reset();\n\n    s = new State;\n    mem_clear(s);\n    s->msg_buf[0] = '\\r';\n\n#if defined(UI_USE_SCREEN)\n    // FIXME - ugly hack\n    s->screen = sobject_get_screen();\n#endif\n\n    if (opt->verbose < 0)\n        s->mode = M_QUIET;\n    else if (opt->verbose == 0 || !acc_isatty(STDOUT_FILENO))\n        s->mode = M_INFO;\n    else if (opt->verbose == 1 || opt->no_progress)\n        s->mode = M_MSG;\n    else if (s->screen == nullptr)\n        s->mode = M_CB_TERM;\n    else\n        s->mode = M_CB_SCREEN;\n}\n\nUiPacker::~UiPacker() noexcept {\n    cb.reset();\n    // owner\n    upx::owner_delete(s);\n}\n\n/*************************************************************************\n// start callback\n**************************************************************************/\n\nvoid UiPacker::printInfo(int nl) {\n    if (opt->all_methods && s->total_passes > 1)\n        con_fprintf(stdout, \"Compressing %s [%s]%s\", pb->fi->getName(), pb->getName(),\n                    nl ? \"\\n\" : \"\");\n    else {\n        char method_name[32 + 1];\n        set_method_name(method_name, sizeof(method_name), pb->ph.method, pb->ph.level);\n        con_fprintf(stdout, \"Compressing %s [%s, %s]%s\", pb->fi->getName(), pb->getName(),\n                    method_name, nl ? \"\\n\" : \"\");\n    }\n}\n\nvoid UiPacker::startCallback(unsigned u_len, unsigned step, int pass, int total_passes) {\n    s->u_len = u_len;\n    s->step = step;\n    s->next_update = step;\n\n    s->pass = pass;\n    s->total_passes = total_passes;\n    // printf(\"startCallback %d %d\\n\", s->pass, s->total_passes);\n\n    s->bar_len = 64;\n    s->pos = -2;\n    s->spin_counter = 0;\n    s->bar_pos = 1; // because of the leading '\\r'\n    s->pass_digits = 0;\n\n    cb.reset();\n\n    if (s->pass < 0) // no callback wanted\n        return;\n\n    if (s->mode <= M_INFO)\n        return;\n    if (s->mode == M_MSG) {\n        if (pass <= 1) {\n            printInfo(0);\n            fflush(stdout);\n            printSetNl(2);\n        }\n        return;\n    }\n\n    cb.nprogress = progress_callback;\n    cb.user = this; // parameter for static function UiPacker::progress_callback()\n\n    if (s->mode == M_CB_TERM) {\n        const char *fname = fn_basename(pb->fi->getName());\n        int l = (int) strlen(fname);\n        if (l > 0 && l <= 30) {\n            strcpy(&s->msg_buf[s->bar_pos], fname);\n            s->bar_pos += l;\n            s->msg_buf[s->bar_pos++] = ' ';\n            s->msg_buf[s->bar_pos++] = ' ';\n            s->bar_len -= l + 2;\n        }\n    }\n\n    // set pass\n    if (total_passes > 1) {\n        int buflen, l;\n        do {\n            s->pass_digits++;\n            total_passes /= 10;\n        } while (total_passes > 0);\n        buflen = sizeof(s->msg_buf) - s->bar_pos;\n        l = upx_safe_snprintf(&s->msg_buf[s->bar_pos], buflen, \"%*d/%*d  \", s->pass_digits, s->pass,\n                              s->pass_digits, s->total_passes);\n        if (l > 0 && s->bar_len - l > 10) {\n            s->bar_len -= l;\n            s->bar_pos += l;\n        }\n    }\n\n#if (UI_USE_SCREEN)\n    if (s->mode == M_CB_SCREEN) {\n        if (!s->screen_init_done) {\n            s->screen_init_done = 1;\n            if (s->screen->hideCursor)\n                s->cursor_shape = s->screen->hideCursor(s->screen);\n            s->s_fg = s->screen->getFg(s->screen);\n            s->s_bg = s->screen->getBg(s->screen);\n            s->screen->getCursor(s->screen, &s->s_cx, &s->s_cy);\n            s->scroll_up = s->screen->getScrollCounter(s->screen);\n            printInfo(1);\n            s->screen->getCursor(s->screen, &s->b_cx, &s->b_cy);\n            s->scroll_up = s->screen->getScrollCounter(s->screen) - s->scroll_up;\n        }\n    }\n#endif /* UI_USE_SCREEN */\n}\n\n// may only get called directly after startCallback()\nvoid UiPacker::firstCallback() {\n    if (s->pos == -2)\n        doCallback(0, 0);\n}\n\n// make sure we reach 100% in the progress bar\nvoid UiPacker::finalCallback(unsigned u_len, unsigned c_len) {\n    s->next_update = u_len;\n    doCallback(u_len, c_len);\n}\n\n/*************************************************************************\n// end callback\n**************************************************************************/\n\nvoid UiPacker::endCallback() {\n    bool done = (s->total_passes <= 0 || s->pass >= s->total_passes);\n    endCallback(done);\n}\n\nvoid UiPacker::endCallback(bool done) {\n    if (s->pass < 0) // no callback wanted\n        return;\n\n    if (s->mode == M_CB_TERM) {\n        if (done)\n            printClearLine(stdout);\n        else\n            printSetNl(2);\n    }\n\n// restore screen\n#if (UI_USE_SCREEN)\n    if (s->mode == M_CB_SCREEN) {\n        if (done) {\n            int cx, cy, sy;\n            assert(s->screen_init_done);\n            s->screen_init_done = 0;\n            assert(s->s_cx == 0 && s->b_cx == 0);\n            s->screen->getCursor(s->screen, &cx, &cy);\n            sy = UPX_MAX(0, s->s_cy - s->scroll_up);\n            while (cy >= sy)\n                s->screen->clearLine(s->screen, cy--);\n            s->screen->setCursor(s->screen, s->s_cx, sy);\n            s->screen->setFg(s->screen, s->s_fg);\n            s->screen->setBg(s->screen, s->s_bg);\n            if (s->cursor_shape > 0)\n                s->screen->setCursorShape(s->screen, s->cursor_shape);\n        } else {\n            // not needed:\n            //   s->screen->clearLine(s->screen, s->b_cy);\n            //   s->screen->setCursor(s->screen, s->b_cx, s->b_cy);\n        }\n    }\n#endif /* UI_USE_SCREEN */\n\n    cb.reset();\n#if 0\n    printf(\"callback: pass %d, step %6d, updates %6d\\n\",\n           s->pass, s->step, s->spin_counter);\n#endif\n}\n\n/*************************************************************************\n// the callback\n**************************************************************************/\n\n/*static*/\nvoid __acc_cdecl UiPacker::progress_callback(upx_callback_t *cb, unsigned isize, unsigned osize) {\n    // printf(\"%6d %6d %d\\n\", isize, osize, state);\n    UiPacker *self = (UiPacker *) cb->user;\n    self->doCallback(isize, osize);\n}\n\nvoid UiPacker::doCallback(unsigned isize, unsigned osize) {\n    int i;\n    static const char spinner[] = \"|/-\\\\\";\n\n    if (s->pass < 0) // no callback wanted\n        return;\n\n    if (s->u_len == 0 || isize > s->u_len)\n        return;\n    // check if we should update the display\n    if (s->step > 0 && isize > 0 && isize < s->u_len) {\n        if (isize < s->next_update)\n            return;\n        s->next_update += s->step;\n    }\n\n    // compute progress position\n    int pos = -1;\n    if (isize >= s->u_len)\n        pos = s->bar_len;\n    else if (isize > 0) {\n        pos = get_ratio(s->u_len, isize) * s->bar_len / 1000000;\n        assert(pos >= 0);\n        assert(pos <= s->bar_len);\n    }\n\n#if 0\n    printf(\"%6d %6d %6d %6d %3d %3d\\n\", isize, osize, s->step, s->next_update, pos, s->pos);\n    return;\n#endif\n\n    if (pos < s->pos)\n        return;\n    if (pos < 0 && pos == s->pos)\n        return;\n\n    // fill the progress bar\n    char *m = &s->msg_buf[s->bar_pos];\n    *m++ = progress_filler[2];\n    for (i = 0; i < s->bar_len; i++)\n        *m++ = progress_filler[i <= pos ? 1 : 0];\n    *m++ = progress_filler[3];\n\n    // compute current compression ratio\n    unsigned ratio = 1000000;\n    if (osize > 0)\n        ratio = get_ratio(isize, osize);\n\n    int buflen = (int) (&s->msg_buf[sizeof(s->msg_buf)] - m);\n    upx_safe_snprintf(m, buflen, \"  %3d.%1d%%  %c \", ratio / 10000, (ratio % 10000) / 1000,\n                      spinner[s->spin_counter & 3]);\n    assert(strlen(s->msg_buf) < 1 + 80);\n\n    s->pos = pos;\n    s->spin_counter++;\n\n    if (s->mode == M_CB_TERM) {\n        const char *msg = &s->msg_buf[0];\n        int fg = con_fg(stdout, FG_CYAN);\n        con_fprintf(stdout, \"%s\", msg); // avoid backslash interpretation\n        (void) con_fg(stdout, fg);\n        fflush(stdout);\n        printSetNl(1);\n        UNUSED(fg);\n        return;\n    }\n\n#if (UI_USE_SCREEN)\n    if (s->mode == M_CB_SCREEN) {\n        const char *msg = &s->msg_buf[1];\n#if 0\n        s->screen->putString(s->screen,msg,s->b_cx,s->b_cy);\n#else\n        // FIXME: this doesn't honor '--mono' etc.\n        int attr = FG_CYAN | s->s_bg;\n        s->screen->putStringAttr(s->screen, msg, attr, s->b_cx, s->b_cy);\n#endif\n        s->screen->refresh(s->screen);\n    }\n#endif /* UI_USE_SCREEN */\n}\n\n/*************************************************************************\n// pack\n**************************************************************************/\n\nvoid UiPacker::uiPackStart(const OutputFile *fo) {\n    total_files++;\n    UNUSED(fo);\n}\n\nvoid UiPacker::uiPackEnd(const OutputFile *fo) {\n    uiUpdate(fo->st_size());\n\n    if (s->mode == M_QUIET)\n        return;\n    if (s->mode == M_MSG) {\n        // We must put this here and not in endCallback() as we may\n        // have multiple passes.\n        printClearLine(stdout);\n    }\n\n    const char *name = pb->fi->getName();\n    if (opt->output_name)\n        name = opt->output_name;\n    else if (opt->to_stdout)\n        name = \"<stdout>\";\n    con_fprintf(stdout, \"%s\\n\",\n                mkline(pb->ph.u_file_size, fo->st_size(), pb->ph.u_len, pb->ph.c_len, pb->getName(),\n                       fn_basename(name)));\n    printSetNl(0);\n}\n\n/*static*/ void UiPacker::uiPackTotal() {\n    uiListTotal();\n    uiFooter(\"Packed\");\n}\n\n/*************************************************************************\n// unpack\n**************************************************************************/\n\nvoid UiPacker::uiUnpackStart(const OutputFile *fo) {\n    total_files++;\n    UNUSED(fo);\n}\n\nvoid UiPacker::uiUnpackEnd(const OutputFile *fo) {\n    uiUpdate(-1, fo->getBytesWritten());\n\n    if (s->mode == M_QUIET)\n        return;\n\n    const char *name = pb->fi->getName();\n    if (opt->output_name)\n        name = opt->output_name;\n    else if (opt->to_stdout)\n        name = \"<stdout>\";\n    con_fprintf(stdout, \"%s\\n\",\n                mkline(fo->getBytesWritten(), pb->file_size, pb->ph.u_len, pb->ph.c_len,\n                       pb->getName(), fn_basename(name), true));\n    printSetNl(0);\n}\n\n/*static*/ void UiPacker::uiUnpackTotal() {\n    uiListTotal(true);\n    uiFooter(\"Unpacked\");\n}\n\n/*************************************************************************\n// list\n**************************************************************************/\n\nvoid UiPacker::uiListStart() { total_files++; }\n\nvoid UiPacker::uiList() {\n    const char *name = pb->fi->getName();\n    con_fprintf(\n        stdout, \"%s\\n\",\n        mkline(pb->ph.u_file_size, pb->file_size, pb->ph.u_len, pb->ph.c_len, pb->getName(), name));\n    printSetNl(0);\n}\n\nvoid UiPacker::uiListEnd() { uiUpdate(); }\n\n/*static*/ void UiPacker::uiListTotal(bool decompress) {\n    if (opt->verbose >= 1 && total_files >= 2) {\n        char name[32];\n        upx_safe_snprintf(name, sizeof(name), \"[ %u file%s ]\", total_files_done,\n                          total_files_done == 1 ? \"\" : \"s\");\n        con_fprintf(\n            stdout, \"%s%s\\n\", header_line2,\n            mkline(total_fu_len, total_fc_len, total_u_len, total_c_len, \"\", name, decompress));\n        printSetNl(0);\n    }\n}\n\n/*************************************************************************\n// test\n**************************************************************************/\n\nvoid UiPacker::uiTestStart() {\n    total_files++;\n\n    if (opt->verbose >= 1) {\n        con_fprintf(stdout, \"testing %s \", pb->fi->getName());\n        fflush(stdout);\n        printSetNl(1);\n    }\n}\n\nvoid UiPacker::uiTestEnd() {\n    if (opt->verbose >= 1) {\n        con_fprintf(stdout, \"[OK]\\n\");\n        fflush(stdout);\n        printSetNl(0);\n    }\n    uiUpdate();\n}\n\n/*static*/ void UiPacker::uiTestTotal() { uiFooter(\"Tested\"); }\n\n/*************************************************************************\n// info\n**************************************************************************/\n\nbool UiPacker::uiFileInfoStart() {\n    total_files++;\n\n    int fg = con_fg(stdout, FG_CYAN);\n    con_fprintf(stdout, \"%s [%s, %s]\\n\", pb->fi->getName(), pb->getFullName(opt), pb->getName());\n    fg = con_fg(stdout, fg);\n    UNUSED(fg);\n    if (pb->ph.c_len > 0) {\n        con_fprintf(stdout, \"  %8llu bytes\", pb->file_size_u);\n        con_fprintf(stdout, \", compressed by UPX %d, method %d, level %d, filter 0x%02x/0x%02x\\n\",\n                    pb->ph.version, pb->ph.method, pb->ph.level, pb->ph.filter, pb->ph.filter_cto);\n        return false;\n    } else {\n        con_fprintf(stdout, \"  %8llu bytes\", pb->file_size_u);\n        con_fprintf(stdout, \", not compressed by UPX\\n\");\n        return true;\n    }\n}\n\nvoid UiPacker::uiFileInfoEnd() { uiUpdate(); }\n\n/*static*/ void UiPacker::uiFileInfoTotal() {}\n\n/*************************************************************************\n// util\n**************************************************************************/\n\n/*static*/ void UiPacker::uiHeader() {\n    static upx_std_atomic(bool) done;\n    if (done)\n        return;\n    done = true;\n    if (opt->cmd == CMD_TEST || opt->cmd == CMD_FILEINFO)\n        return;\n    if (opt->verbose >= 1) {\n        con_fprintf(stdout, \"%s%s\", header_line1, header_line2);\n    }\n}\n\n/*static*/ void UiPacker::uiFooter(const char *t) {\n    static upx_std_atomic(bool) done;\n    if (done)\n        return;\n    done = true;\n    if (opt->verbose >= 1) {\n        assert(total_files >= total_files_done);\n        unsigned n1 = total_files;\n        unsigned n2 = total_files_done;\n        unsigned n3 = total_files - total_files_done;\n        if (n3 == 0)\n            con_fprintf(stdout, \"\\n%s %u file%s.\\n\", t, n1, n1 == 1 ? \"\" : \"s\");\n        else\n            con_fprintf(stdout, \"\\n%s %u file%s: %u ok, %u error%s.\\n\", t, n1, n1 == 1 ? \"\" : \"s\",\n                        n2, n3, n3 == 1 ? \"\" : \"s\");\n    }\n}\n\nvoid UiPacker::uiUpdate(upx_off_t fc_len, upx_off_t fu_len) {\n    update_fc_len = (fc_len >= 0) ? fc_len : pb->file_size_u;\n    update_fu_len = (fu_len >= 0) ? fu_len : pb->ph.u_file_size;\n    update_c_len = pb->ph.c_len;\n    update_u_len = pb->ph.u_len;\n}\n\n/*static*/ void UiPacker::uiConfirmUpdate() {\n    total_files_done++;\n    total_fc_len += update_fc_len;\n    total_fu_len += update_fu_len;\n    total_c_len += update_c_len;\n    total_u_len += update_u_len;\n}\n\n/* vim:set ts=4 sw=4 et: */\n","size_bytes":19428},"src/work.cpp":{"content":"/* work.cpp -- main work driver\n\n   This file is part of the Resize executable compressor.\n\n   Copyright (C) 2025 WHO-AM-I-404\n   Based on UPX - Ultimate Packer for eXecutables\n   Copyright (C) 2025 WHO-AM-I-404\n   Based on UPX - Ultimate Packer for eXecutables\n   Copyright (C) 1996-2025 Markus Franz Xaver Johannes Oberhumer\n   Copyright (C) 1996-2025 Laszlo Molnar\n   All Rights Reserved.\n\n   Resize and the UCL library are free software; you can redistribute them\n   and/or modify them under the terms of the GNU General Public License as\n   published by the Free Software Foundation; either version 2 of\n   the License, or (at your option) any later version.\n\n   This program is distributed in the hope that it will be useful,\n   but WITHOUT ANY WARRANTY; without even the implied warranty of\n   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n   GNU General Public License for more details.\n\n   You should have received a copy of the GNU General Public License\n   along with this program; see the file COPYING.\n   If not, write to the Free Software Foundation, Inc.,\n   59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.\n\n   WHO-AM-I-404 <who-am-i-404@proton.me>\n   Based on original work by:\n   Markus F.X.J. Oberhumer <markus@oberhumer.com>\n   Laszlo Molnar <ezerotven+github@gmail.com>\n */\n\n// This file implements the central loop, and it uses class PackMaster to\n// dispatch. PackMaster by itself will instantiate a concrete subclass of\n// class PackerBase which then does the actual work; search for \"HERE\".\n// And see p_com.cpp for a simple executable format.\n//\n// Additionally this file also has the burden to deal with all those pesky\n// low-level file handling issues.\n\n#define WANT_WINDOWS_LEAN_H 1 // _get_osfhandle, GetFileTime, SetFileTime\n#include \"util/system_headers.h\"\n#if USE_UTIMENSAT\n#include <sys/types.h>\n#include <fcntl.h>\n#include <sys/stat.h>\n#endif\n#include \"conf.h\"\n#include \"file.h\"\n#include \"packmast.h\"\n#include \"ui.h\"\n#include \"util/membuffer.h\"\n\n#if USE_UTIMENSAT && defined(AT_FDCWD)\n#elif defined(_WIN32) || defined(__CYGWIN__)\n#define USE_SETFILETIME 1\n#elif (ACC_OS_DOS32) && defined(__DJGPP__)\n#define USE_FTIME 1\n#elif ((ACC_OS_WIN32 || ACC_OS_WIN64) && (ACC_CC_INTELC || ACC_CC_MSC))\n#define USE__FUTIME 1\n#elif HAVE_UTIME\n#define USE_UTIME 1\n#endif\n\n#if !defined(SH_DENYRW)\n#define SH_DENYRW (-1)\n#endif\n#if !defined(SH_DENYWR)\n#define SH_DENYWR (-1)\n#endif\n\n/*************************************************************************\n// file util\n**************************************************************************/\n\nnamespace {\n\nstruct XStat final {\n    struct stat st;\n#if USE_SETFILETIME\n    FILETIME ft_atime;\n    FILETIME ft_mtime;\n#elif USE_FTIME\n    struct ftime ft_ftime;\n#endif\n};\n\n// ignore errors in some cases and silence __attribute__((__warn_unused_result__))\n#define IGNORE_ERROR(var) ACC_UNUSED(var)\n\nenum OpenMode { RO_MUST_EXIST, WO_MUST_EXIST_TRUNCATE, WO_MUST_CREATE, WO_CREATE_OR_TRUNCATE };\n\nstatic constexpr int get_open_flags(OpenMode om) noexcept {\n    constexpr int wo_flags = O_WRONLY | O_BINARY;\n    if (om == WO_MUST_EXIST_TRUNCATE)\n        return wo_flags | O_TRUNC; // will cause an error if file does not exist\n    if (om == WO_MUST_CREATE)\n        return wo_flags | O_CREAT | O_EXCL; // will cause an error if file already exists\n    if (om == WO_CREATE_OR_TRUNCATE)\n        return wo_flags | O_CREAT | O_TRUNC; // create if not exists, otherwise truncate\n    // RO_MUST_EXIST\n    return O_RDONLY | O_BINARY; // will cause an error if file does not exist\n}\n\n// set file time of an open file\nstatic void set_fd_timestamp(int fd, const XStat *xst) noexcept {\n#if USE_SETFILETIME\n    BOOL r = SetFileTime((HANDLE) _get_osfhandle(fd), nullptr, &xst->ft_atime, &xst->ft_mtime);\n    IGNORE_ERROR(r);\n#elif USE_FTIME\n    struct ftime ft_ftime = xst->ft_ftime; // djgpp2 libc bug/feature: not const, so use a copy\n    int r = setftime(fd, &ft_ftime);\n    IGNORE_ERROR(r);\n#elif USE__FUTIME\n    struct _utimbuf u = {};\n    u.actime = xst->st.st_atime;\n    u.modtime = xst->st.st_mtime;\n    int r = _futime(fd, &u);\n    IGNORE_ERROR(r);\n#endif\n    // maybe unused\n    UNUSED(fd);\n    UNUSED(xst);\n}\n\nstatic void copy_file_contents(const char *iname, const char *oname, OpenMode om,\n                               const XStat *oname_timestamp) may_throw {\n    InputFile fi;\n    fi.sopen(iname, get_open_flags(RO_MUST_EXIST), SH_DENYWR);\n    fi.seek(0, SEEK_SET);\n    int flags = get_open_flags(om);\n    int shmode = SH_DENYWR;\n    int omode = 0600; // affected by umask; ignored unless O_CREAT\n    OutputFile fo;\n    fo.sopen(oname, flags, shmode, omode);\n    fo.seek(0, SEEK_SET);\n    MemBuffer buf(256 * 1024 * 1024);\n    for (;;) {\n        size_t bytes = fi.read(buf, buf.getSize());\n        if (bytes == 0)\n            break;\n        fo.write(buf, bytes);\n    }\n    if (oname_timestamp != nullptr)\n        set_fd_timestamp(fo.getFd(), oname_timestamp);\n    fi.closex();\n    fo.closex();\n}\n\nstatic void copy_file_attributes(const XStat *xst, const char *oname, bool preserve_mode,\n                                 bool preserve_ownership, bool preserve_timestamp) noexcept {\n    const struct stat *const st = &xst->st;\n    // copy time stamp\n    if (preserve_timestamp) {\n#if USE_UTIMENSAT && defined(AT_FDCWD)\n        struct timespec times[2] = {};\n#if HAVE_STRUCT_STAT_ST_MTIMESPEC_TV_NSEC\n        // macOS\n        times[0] = st->st_atimespec;\n        times[1] = st->st_mtimespec;\n#else\n        // POSIX.1-2008\n        times[0] = st->st_atim;\n        times[1] = st->st_mtim;\n#endif\n        int r = utimensat(AT_FDCWD, oname, &times[0], 0);\n        IGNORE_ERROR(r);\n#elif USE_UTIME\n        struct utimbuf u = {};\n        u.actime = st->st_atime;\n        u.modtime = st->st_mtime;\n        int r = utime(oname, &u);\n        IGNORE_ERROR(r);\n#endif\n    }\n#if HAVE_CHOWN\n    // copy the group ownership\n    if (preserve_ownership) {\n        int r = chown(oname, -1, st->st_gid);\n        IGNORE_ERROR(r);\n    }\n#endif\n#if HAVE_CHMOD\n    // copy permissions\n    if (preserve_mode) {\n        int r = chmod(oname, st->st_mode);\n        IGNORE_ERROR(r);\n    }\n#endif\n#if HAVE_CHOWN\n    // copy the user ownership\n    if (preserve_ownership) {\n        int r = chown(oname, st->st_uid, -1);\n        IGNORE_ERROR(r);\n    }\n#endif\n    // maybe unused\n    UNUSED(xst);\n    UNUSED(st);\n    UNUSED(oname);\n    UNUSED(preserve_mode);\n    UNUSED(preserve_ownership);\n    UNUSED(preserve_timestamp);\n}\n\n} // namespace\n\n/*************************************************************************\n// process one file\n**************************************************************************/\n\nvoid do_one_file(const char *const iname, char *const oname) may_throw {\n    oname[0] = 0; // make empty\n\n    // check iname stat\n    XStat xst = {};\n    struct stat &st = xst.st;\n#if HAVE_LSTAT\n    int rr = lstat(iname, &st);\n#else\n    int rr = stat(iname, &st);\n#endif\n    if (rr != 0) {\n        if (errno == ENOENT)\n            throw FileNotFoundException(iname, errno);\n        else\n            throwIOException(iname, errno);\n    }\n#if HAVE_LSTAT\n    if (S_ISLNK(st.st_mode))\n        throwIOException(\"is a symlink -- skipped\");\n#endif\n    if (S_ISDIR(st.st_mode))\n        throwIOException(\"is a directory -- skipped\");\n    if (!(S_ISREG(st.st_mode)))\n        throwIOException(\"not a regular file -- skipped\");\n#if defined(__unix__)\n    // no special bits may be set\n    if ((st.st_mode & (S_ISUID | S_ISGID | S_ISVTX)) != 0)\n        throwIOException(\"file has special permissions -- skipped\");\n#endif\n    if (st.st_size <= 0)\n        throwIOException(\"empty file -- skipped\");\n    if (st.st_size < 512)\n        throwIOException(\"file is too small -- skipped\");\n    if (!mem_size_valid_bytes(st.st_size))\n        throwIOException(\"file is too large -- skipped\");\n    if ((st.st_mode & S_IWUSR) == 0) {\n        bool skip = true;\n        if (opt->output_name)\n            skip = false;\n        else if (opt->to_stdout)\n            skip = false;\n        else if (opt->backup)\n            skip = false;\n        if (skip)\n            throwIOException(\"file is write protected -- skipped\");\n    }\n\n    // open input file\n    InputFile fi;\n    fi.sopen(iname, get_open_flags(RO_MUST_EXIST), SH_DENYWR);\n\n    if (opt->preserve_timestamp) {\n#if USE_SETFILETIME\n        if (GetFileTime((HANDLE) _get_osfhandle(fi.getFd()), nullptr, &xst.ft_atime,\n                        &xst.ft_mtime) == 0)\n            throwIOException(\"cannot determine file timestamp\");\n#elif USE_FTIME\n        if (getftime(fi.getFd(), &xst.ft_ftime) != 0)\n            throwIOException(\"cannot determine file timestamp\");\n#endif\n    }\n\n    // open output file\n    // NOTE: only use \"preserve_link\" if you really need it, e.g. it can fail\n    //   with ETXTBSY and other unexpected errors; renaming files is much safer\n    OutputFile fo;\n    bool preserve_link = opt->preserve_link;\n    bool copy_timestamp_only = false;\n    if (opt->cmd == CMD_COMPRESS || opt->cmd == CMD_DECOMPRESS) {\n        if (opt->to_stdout) {\n            preserve_link = false; // not needed\n            if (!fo.openStdout(1, opt->force ? true : false))\n                throwIOException(\"data not written to a terminal; Use '-f' to force.\");\n        } else {\n            char tname[ACC_FN_PATH_MAX + 1];\n            if (opt->output_name) {\n                strcpy(tname, opt->output_name);\n                if ((opt->force_overwrite || opt->force >= 2) && !preserve_link)\n                    (void) FileBase::unlink_noexcept(tname); // IGNORE_ERROR\n            } else {\n                if (st.st_nlink < 2)\n                    preserve_link = false; // not needed\n                if (!maketempname(tname, sizeof(tname), iname, \".upx\"))\n                    throwIOException(\"could not create a temporary file name\");\n            }\n            int flags = get_open_flags(WO_MUST_CREATE); // don't overwrite files by default\n            if (opt->output_name && preserve_link) {\n                flags = get_open_flags(WO_CREATE_OR_TRUNCATE);\n#if HAVE_LSTAT\n                struct stat ost = {};\n                int r = lstat(tname, &ost);\n                if (r == 0 && S_ISREG(ost.st_mode)) {\n                    preserve_link = ost.st_nlink >= 2;\n                } else if (r == 0 && S_ISLNK(ost.st_mode)) {\n                    // output_name is a symlink (valid or dangling)\n                    (void) FileBase::unlink_noexcept(tname); // IGNORE_ERROR\n                    preserve_link = false;                   // not needed\n                } else {\n                    preserve_link = false; // not needed\n                }\n#endif\n                if (preserve_link) {\n                    flags = get_open_flags(WO_MUST_EXIST_TRUNCATE);\n                    copy_timestamp_only = true;\n                }\n            } else if (opt->force_overwrite || opt->force) {\n                flags = get_open_flags(WO_CREATE_OR_TRUNCATE);\n            }\n            int shmode = SH_DENYWR;\n#if (ACC_ARCH_M68K && ACC_OS_TOS && ACC_CC_GNUC) && defined(__MINT__)\n            // TODO later: check current mintlib if this hack is still needed\n            flags |= O_TRUNC;\n            shmode = O_DENYRW;\n#endif\n            // cannot rely on open() because of umask\n            // int omode = st.st_mode | 0600;\n            int omode = opt->preserve_mode ? 0600 : 0666; // affected by umask; only for O_CREAT\n            fo.sopen(tname, flags, shmode, omode);\n            // open succeeded - now set oname[]\n            strcpy(oname, tname);\n        }\n    }\n\n    // handle command - actual work starts HERE\n    PackMaster pm(&fi, opt);\n    if (opt->cmd == CMD_COMPRESS)\n        pm.pack(&fo);\n    else if (opt->cmd == CMD_DECOMPRESS)\n        pm.unpack(&fo);\n    else if (opt->cmd == CMD_TEST)\n        pm.test();\n    else if (opt->cmd == CMD_LIST)\n        pm.list();\n    else if (opt->cmd == CMD_FILEINFO)\n        pm.fileInfo();\n    else\n        throwInternalError(\"invalid command\");\n\n    // copy time stamp\n    if (oname[0] && opt->preserve_timestamp && fo.isOpen())\n        set_fd_timestamp(fo.getFd(), &xst);\n\n    // close files\n    fi.closex();\n    fo.closex();\n\n    // rename or copy files\n    if (oname[0] && !opt->output_name) {\n        // both iname and oname do exist; rename oname to iname\n        if (opt->backup) {\n            char bakname[ACC_FN_PATH_MAX + 1];\n            if (!makebakname(bakname, sizeof(bakname), iname))\n                throwIOException(\"could not create a backup file name\");\n            if (preserve_link) {\n                copy_file_contents(iname, bakname, WO_MUST_CREATE, &xst);\n                copy_file_attributes(&xst, bakname, true, true, true);\n                const XStat *xstamp = opt->preserve_timestamp ? &xst : nullptr;\n                copy_file_contents(oname, iname, WO_MUST_EXIST_TRUNCATE, xstamp);\n                FileBase::unlink(oname);\n                copy_timestamp_only = true;\n            } else {\n                FileBase::rename(iname, bakname);\n                FileBase::rename(oname, iname);\n            }\n        } else if (preserve_link) {\n            const XStat *xstamp = opt->preserve_timestamp ? &xst : nullptr;\n            copy_file_contents(oname, iname, WO_MUST_EXIST_TRUNCATE, xstamp);\n            FileBase::unlink(oname);\n            copy_timestamp_only = true;\n        } else {\n            FileBase::unlink(iname);\n            FileBase::rename(oname, iname);\n        }\n        // now iname is the new packed/unpacked file and oname does not exist any longer\n    }\n\n    // copy file attributes\n    if (oname[0]) {\n        oname[0] = 0; // done with oname\n        const char *name = opt->output_name ? opt->output_name : iname;\n        if (copy_timestamp_only)\n            copy_file_attributes(&xst, name, false, false, opt->preserve_timestamp);\n        else\n            copy_file_attributes(&xst, name, opt->preserve_mode, opt->preserve_ownership,\n                                 opt->preserve_timestamp);\n    }\n\n    UiPacker::uiConfirmUpdate();\n}\n\n/*************************************************************************\n// process all files from the commandline\n**************************************************************************/\n\nstatic void unlink_ofile(char *oname) noexcept {\n    if (oname && oname[0]) {\n        (void) FileBase::unlink_noexcept(oname); // IGNORE_ERROR\n        oname[0] = 0;                            // done with oname\n    }\n}\n\nint do_files(int i, int argc, char *argv[]) may_throw {\n    upx_compiler_sanity_check();\n    if (opt->verbose >= 1) {\n        show_header();\n        UiPacker::uiHeader();\n    }\n\n    for (; i < argc; i++) {\n        infoHeader();\n\n        const char *const iname = argv[i];\n        char oname[ACC_FN_PATH_MAX + 1];\n        oname[0] = 0;\n\n        try {\n            do_one_file(iname, oname);\n        } catch (const Exception &e) {\n            unlink_ofile(oname);\n            if (opt->verbose >= 1 || (opt->verbose >= 0 && !e.isWarning()))\n                printErr(iname, e);\n            main_set_exit_code(e.isWarning() ? EXIT_WARN : EXIT_ERROR);\n            // this is not fatal, continue processing more files\n        } catch (const Error &e) {\n            unlink_ofile(oname);\n            printErr(iname, e);\n            main_set_exit_code(EXIT_ERROR);\n            return -1; // fatal error\n        } catch (std::bad_alloc *e) {\n            unlink_ofile(oname);\n            printErr(iname, \"out of memory\");\n            UNUSED(e);\n            // delete e;\n            main_set_exit_code(EXIT_ERROR);\n            return -1; // fatal error\n        } catch (const std::bad_alloc &) {\n            unlink_ofile(oname);\n            printErr(iname, \"out of memory\");\n            main_set_exit_code(EXIT_ERROR);\n            return -1; // fatal error\n        } catch (std::exception *e) {\n            unlink_ofile(oname);\n            printUnhandledException(iname, e);\n            // delete e;\n            main_set_exit_code(EXIT_ERROR);\n            return -1; // fatal error\n        } catch (const std::exception &e) {\n            unlink_ofile(oname);\n            printUnhandledException(iname, &e);\n            main_set_exit_code(EXIT_ERROR);\n            return -1; // fatal error\n        } catch (...) {\n            unlink_ofile(oname);\n            printUnhandledException(iname, nullptr);\n            main_set_exit_code(EXIT_ERROR);\n            return -1; // fatal error\n        }\n    }\n\n    if (opt->cmd == CMD_COMPRESS)\n        UiPacker::uiPackTotal();\n    else if (opt->cmd == CMD_DECOMPRESS)\n        UiPacker::uiUnpackTotal();\n    else if (opt->cmd == CMD_LIST)\n        UiPacker::uiListTotal();\n    else if (opt->cmd == CMD_TEST)\n        UiPacker::uiTestTotal();\n    else if (opt->cmd == CMD_FILEINFO)\n        UiPacker::uiFileInfoTotal();\n    return 0;\n}\n\n/* vim:set ts=4 sw=4 et: */\n","size_bytes":16810},"misc/make/Makefile-extra.mk":{"content":"#\n# RESIZE top-level Makefile - needs GNU make and CMake >= 3.13\n# Copyright (C) Markus Franz Xaver Johannes Oberhumer\n#\n\nifeq ($(RESIZE_MAKEFILE_EXTRA_MK_INCLUDED),)\noverride RESIZE_MAKEFILE_EXTRA_MK_INCLUDED := 1\n\n#***********************************************************************\n# support functions\n#***********************************************************************\n\noverride check_defined   = $(foreach 1,$1,$(if $(filter undefined,$(origin $1)),$(error ERROR: variable '$1' is not defined),))\noverride check_undefined = $(foreach 1,$1,$(if $(filter undefined,$(origin $1)),,$(error ERROR: variable '$1' is already defined)))\n\n# return \"1\" or empty-string\noverride eq = $(if $(subst x$1,,x$2)$(subst x$2,,x$1),,1)\noverride ne = $(if $(subst x$1,,x$2)$(subst x$2,,x$1),1,)\n\noverride tolower = $(subst A,a,$(subst B,b,$(subst C,c,$(subst D,d,$(subst E,e,$(subst F,f,$(subst G,g,$(subst H,h,$(subst I,i,$(subst J,j,$(subst K,k,$(subst L,l,$(subst M,m,$(subst N,n,$(subst O,o,$(subst P,p,$(subst Q,q,$(subst R,r,$(subst S,s,$(subst T,t,$(subst U,u,$(subst V,v,$(subst W,w,$(subst X,x,$(subst Y,y,$(subst Z,z,$1))))))))))))))))))))))))))\noverride toupper = $(subst a,A,$(subst b,B,$(subst c,C,$(subst d,D,$(subst e,E,$(subst f,F,$(subst g,G,$(subst h,H,$(subst i,I,$(subst j,J,$(subst k,K,$(subst l,L,$(subst m,M,$(subst n,N,$(subst o,O,$(subst p,P,$(subst q,Q,$(subst r,R,$(subst s,S,$(subst t,T,$(subst u,U,$(subst v,V,$(subst w,W,$(subst x,X,$(subst y,Y,$(subst z,Z,$1))))))))))))))))))))))))))\n\n# canonicalize the case of CMAKE_BUILD_TYPE to \"Debug\" and \"Release\"\noverride cm_build_type = $(if $(call eq,$1,),$(error EMPTY-build-type),$(if $(call eq,$(call tolower,$1),debug),Debug,$(if $(call eq,$(call tolower,$1),release),Release,$(if $(call eq,$(call tolower,$1),none),None,$1))))\n\n#***********************************************************************\n# extra builds: some pre-defined build configurations\n#***********************************************************************\n\n$(call check_defined,run_config run_build)\n$(call check_undefined,run_config_and_build)\n\ndefine run_config_and_build\n\t$(call run_config,$1,$2)\n\t$(call run_build,$1,$2)\nendef\n\n# force building with clang/clang++\nbuild/extra/clang/debug:   PHONY; $(call run_config_and_build,$@,Debug)\nbuild/extra/clang/release: PHONY; $(call run_config_and_build,$@,Release)\nbuild/extra/clang/%: export CC  = clang\nbuild/extra/clang/%: export CXX = clang++\n\n# force building with clang/clang++ -m32\nbuild/extra/clang-m32/debug:   PHONY; $(call run_config_and_build,$@,Debug)\nbuild/extra/clang-m32/release: PHONY; $(call run_config_and_build,$@,Release)\nbuild/extra/clang-m32/%: export CC  = clang   -m32\nbuild/extra/clang-m32/%: export CXX = clang++ -m32\n\n# force building with clang/clang++ -mx32\nbuild/extra/clang-mx32/debug:   PHONY; $(call run_config_and_build,$@,Debug)\nbuild/extra/clang-mx32/release: PHONY; $(call run_config_and_build,$@,Release)\nbuild/extra/clang-mx32/%: export CC  = clang   -mx32\nbuild/extra/clang-mx32/%: export CXX = clang++ -mx32\n\n# force building with clang/clang++ -m64\nbuild/extra/clang-m64/debug:   PHONY; $(call run_config_and_build,$@,Debug)\nbuild/extra/clang-m64/release: PHONY; $(call run_config_and_build,$@,Release)\nbuild/extra/clang-m64/%: export CC  = clang   -m64\nbuild/extra/clang-m64/%: export CXX = clang++ -m64\n\n# force building with clang/clang++ -flto=auto\nbuild/extra/clang-lto-auto/debug:   PHONY; $(call run_config_and_build,$@,Debug)\nbuild/extra/clang-lto-auto/release: PHONY; $(call run_config_and_build,$@,Release)\nbuild/extra/clang-lto-auto/%: export CC  = clang   -flto=auto\nbuild/extra/clang-lto-auto/%: export CXX = clang++ -flto=auto\n\n# force building with clang/clang++ -pie\nbuild/extra/clang-pie/debug:   PHONY; $(call run_config_and_build,$@,Debug)\nbuild/extra/clang-pie/release: PHONY; $(call run_config_and_build,$@,Release)\nbuild/extra/clang-pie/%: export CC  = clang   -pie -fPIE -Wno-unused-command-line-argument\nbuild/extra/clang-pie/%: export CXX = clang++ -pie -fPIE -Wno-unused-command-line-argument\nbuild/extra/clang-pie/%: export RESIZE_CONFIG_DISABLE_SHARED_LIBS = ON\n\n# force building with clang/clang++ -static\nbuild/extra/clang-static/debug:   PHONY; $(call run_config_and_build,$@,Debug)\nbuild/extra/clang-static/release: PHONY; $(call run_config_and_build,$@,Release)\nbuild/extra/clang-static/%: export CC  = clang   -static\nbuild/extra/clang-static/%: export CXX = clang++ -static\nbuild/extra/clang-static/%: export RESIZE_CONFIG_DISABLE_SHARED_LIBS = ON\n\n# force building with clang/clang++ -static-pie\nbuild/extra/clang-static-pie/debug:   PHONY; $(call run_config_and_build,$@,Debug)\nbuild/extra/clang-static-pie/release: PHONY; $(call run_config_and_build,$@,Release)\nbuild/extra/clang-static-pie/%: export CC  = clang   -static-pie -fPIE -Wno-unused-command-line-argument\nbuild/extra/clang-static-pie/%: export CXX = clang++ -static-pie -fPIE -Wno-unused-command-line-argument\nbuild/extra/clang-static-pie/%: export RESIZE_CONFIG_DISABLE_SHARED_LIBS = ON\n\n# force building with clang/clang++ -static -flto\nbuild/extra/clang-static-lto/debug:   PHONY; $(call run_config_and_build,$@,Debug)\nbuild/extra/clang-static-lto/release: PHONY; $(call run_config_and_build,$@,Release)\nbuild/extra/clang-static-lto/%: export CC  = clang   -static -flto\nbuild/extra/clang-static-lto/%: export CXX = clang++ -static -flto\nbuild/extra/clang-static-lto/%: export RESIZE_CONFIG_DISABLE_SHARED_LIBS = ON\n\n# force building with clang/clang++ C++20 (and C17)\nbuild/extra/clang-std-cxx20/debug:   PHONY; $(call run_config_and_build,$@,Debug)\nbuild/extra/clang-std-cxx20/release: PHONY; $(call run_config_and_build,$@,Release)\nbuild/extra/clang-std-cxx20/%: export CC  = clang   -std=gnu17\nbuild/extra/clang-std-cxx20/%: export CXX = clang++ -std=gnu++20\nbuild/extra/clang-std-cxx20/%: export RESIZE_CONFIG_DISABLE_C_STANDARD = ON\nbuild/extra/clang-std-cxx20/%: export RESIZE_CONFIG_DISABLE_CXX_STANDARD = ON\n\n# force building with clang/clang++ C++23 (and C23)\nbuild/extra/clang-std-cxx23/debug:   PHONY; $(call run_config_and_build,$@,Debug)\nbuild/extra/clang-std-cxx23/release: PHONY; $(call run_config_and_build,$@,Release)\nbuild/extra/clang-std-cxx23/%: export CC  = clang   -std=gnu2x -Wno-constant-logical-operand\nbuild/extra/clang-std-cxx23/%: export CXX = clang++ -std=gnu++2b\nbuild/extra/clang-std-cxx23/%: export RESIZE_CONFIG_DISABLE_C_STANDARD = ON\nbuild/extra/clang-std-cxx23/%: export RESIZE_CONFIG_DISABLE_CXX_STANDARD = ON\n\n# force building with clang/clang++ C++26 (and C23)\nbuild/extra/clang-std-cxx26/debug:   PHONY; $(call run_config_and_build,$@,Debug)\nbuild/extra/clang-std-cxx26/release: PHONY; $(call run_config_and_build,$@,Release)\nbuild/extra/clang-std-cxx26/%: export CC  = clang   -std=gnu2x -Wno-constant-logical-operand\nbuild/extra/clang-std-cxx26/%: export CXX = clang++ -std=gnu++2c\nbuild/extra/clang-std-cxx26/%: export RESIZE_CONFIG_DISABLE_C_STANDARD = ON\nbuild/extra/clang-std-cxx26/%: export RESIZE_CONFIG_DISABLE_CXX_STANDARD = ON\n\n# force building with gcc/g++\nbuild/extra/gcc/debug:   PHONY; $(call run_config_and_build,$@,Debug)\nbuild/extra/gcc/release: PHONY; $(call run_config_and_build,$@,Release)\nbuild/extra/gcc/%: export CC  = gcc\nbuild/extra/gcc/%: export CXX = g++\n\n# force building with gcc/g++ -m32\nbuild/extra/gcc-m32/debug:   PHONY; $(call run_config_and_build,$@,Debug)\nbuild/extra/gcc-m32/release: PHONY; $(call run_config_and_build,$@,Release)\nbuild/extra/gcc-m32/%: export CC  = gcc -m32\nbuild/extra/gcc-m32/%: export CXX = g++ -m32\n\n# force building with gcc/g++ -mx32\nbuild/extra/gcc-mx32/debug:   PHONY; $(call run_config_and_build,$@,Debug)\nbuild/extra/gcc-mx32/release: PHONY; $(call run_config_and_build,$@,Release)\nbuild/extra/gcc-mx32/%: export CC  = gcc -mx32\nbuild/extra/gcc-mx32/%: export CXX = g++ -mx32\n\n# force building with gcc/g++ -m64\nbuild/extra/gcc-m64/debug:   PHONY; $(call run_config_and_build,$@,Debug)\nbuild/extra/gcc-m64/release: PHONY; $(call run_config_and_build,$@,Release)\nbuild/extra/gcc-m64/%: export CC  = gcc -m64\nbuild/extra/gcc-m64/%: export CXX = g++ -m64\n\n# force building with gcc/g++ -flto=auto\nbuild/extra/gcc-lto-auto/debug:   PHONY; $(call run_config_and_build,$@,Debug)\nbuild/extra/gcc-lto-auto/release: PHONY; $(call run_config_and_build,$@,Release)\nbuild/extra/gcc-lto-auto/%: export CC  = gcc -flto=auto\nbuild/extra/gcc-lto-auto/%: export CXX = g++ -flto=auto\n\n# force building with gcc/g++ -pie\nbuild/extra/gcc-pie/debug:   PHONY; $(call run_config_and_build,$@,Debug)\nbuild/extra/gcc-pie/release: PHONY; $(call run_config_and_build,$@,Release)\nbuild/extra/gcc-pie/%: export CC  = gcc -pie -fPIE\nbuild/extra/gcc-pie/%: export CXX = g++ -pie -fPIE\nbuild/extra/gcc-pie/%: export RESIZE_CONFIG_DISABLE_SHARED_LIBS = ON\n\n# force building with gcc/g++ -static\nbuild/extra/gcc-static/debug:   PHONY; $(call run_config_and_build,$@,Debug)\nbuild/extra/gcc-static/release: PHONY; $(call run_config_and_build,$@,Release)\nbuild/extra/gcc-static/%: export CC  = gcc -static\nbuild/extra/gcc-static/%: export CXX = g++ -static\nbuild/extra/gcc-static/%: export RESIZE_CONFIG_DISABLE_SHARED_LIBS = ON\n\n# force building with gcc/g++ -static-pie\nbuild/extra/gcc-static-pie/debug:   PHONY; $(call run_config_and_build,$@,Debug)\nbuild/extra/gcc-static-pie/release: PHONY; $(call run_config_and_build,$@,Release)\nbuild/extra/gcc-static-pie/%: export CC  = gcc -static-pie -fPIE\nbuild/extra/gcc-static-pie/%: export CXX = g++ -static-pie -fPIE\nbuild/extra/gcc-static-pie/%: export RESIZE_CONFIG_DISABLE_SHARED_LIBS = ON\n\n# force building with gcc/g++ -static -flto\nbuild/extra/gcc-static-lto/debug:   PHONY; $(call run_config_and_build,$@,Debug)\nbuild/extra/gcc-static-lto/release: PHONY; $(call run_config_and_build,$@,Release)\nbuild/extra/gcc-static-lto/%: export CC  = gcc -static -flto\nbuild/extra/gcc-static-lto/%: export CXX = g++ -static -flto\nbuild/extra/gcc-static-lto/%: export RESIZE_CONFIG_DISABLE_SHARED_LIBS = ON\n\n# force building with gcc/g++ C++20 (and C17)\nbuild/extra/gcc-std-cxx20/debug:   PHONY; $(call run_config_and_build,$@,Debug)\nbuild/extra/gcc-std-cxx20/release: PHONY; $(call run_config_and_build,$@,Release)\nbuild/extra/gcc-std-cxx20/%: export CC  = gcc -std=gnu17\nbuild/extra/gcc-std-cxx20/%: export CXX = g++ -std=gnu++20\nbuild/extra/gcc-std-cxx20/%: export RESIZE_CONFIG_DISABLE_C_STANDARD = ON\nbuild/extra/gcc-std-cxx20/%: export RESIZE_CONFIG_DISABLE_CXX_STANDARD = ON\n\n# force building with gcc/g++ C++23 (and C23)\nbuild/extra/gcc-std-cxx23/debug:   PHONY; $(call run_config_and_build,$@,Debug)\nbuild/extra/gcc-std-cxx23/release: PHONY; $(call run_config_and_build,$@,Release)\nbuild/extra/gcc-std-cxx23/%: export CC  = gcc -std=gnu2x\nbuild/extra/gcc-std-cxx23/%: export CXX = g++ -std=gnu++2b\nbuild/extra/gcc-std-cxx23/%: export RESIZE_CONFIG_DISABLE_C_STANDARD = ON\nbuild/extra/gcc-std-cxx23/%: export RESIZE_CONFIG_DISABLE_CXX_STANDARD = ON\n\n# force building with gcc/g++ C++26 (and C23)\nbuild/extra/gcc-std-cxx26/debug:   PHONY; $(call run_config_and_build,$@,Debug)\nbuild/extra/gcc-std-cxx26/release: PHONY; $(call run_config_and_build,$@,Release)\nbuild/extra/gcc-std-cxx26/%: export CC  = gcc -std=gnu23\nbuild/extra/gcc-std-cxx26/%: export CXX = g++ -std=gnu++26\nbuild/extra/gcc-std-cxx26/%: export RESIZE_CONFIG_DISABLE_C_STANDARD = ON\nbuild/extra/gcc-std-cxx26/%: export RESIZE_CONFIG_DISABLE_CXX_STANDARD = ON\n\n# cross compiler: Linux glibc aarch64-linux-gnu (arm64)\nbuild/extra/cross-linux-gnu-aarch64/debug:   PHONY; $(call run_config_and_build,$@,Debug)\nbuild/extra/cross-linux-gnu-aarch64/release: PHONY; $(call run_config_and_build,$@,Release)\nbuild/extra/cross-linux-gnu-aarch64/%: export CC  = aarch64-linux-gnu-gcc\nbuild/extra/cross-linux-gnu-aarch64/%: export CXX = aarch64-linux-gnu-g++\nbuild/extra/cross-linux-gnu-aarch64/%: CMAKE_SYSTEM_NAME ?= Linux\nbuild/extra/cross-linux-gnu-aarch64/%: CMAKE_CROSSCOMPILING_EMULATOR ?= qemu-aarch64\n\n# cross compiler: Linux glibc arm-linux-gnueabihf\nbuild/extra/cross-linux-gnu-arm-eabihf/debug:   PHONY; $(call run_config_and_build,$@,Debug)\nbuild/extra/cross-linux-gnu-arm-eabihf/release: PHONY; $(call run_config_and_build,$@,Release)\nbuild/extra/cross-linux-gnu-arm-eabihf/%: export CC  = arm-linux-gnueabihf-gcc\nbuild/extra/cross-linux-gnu-arm-eabihf/%: export CXX = arm-linux-gnueabihf-g++ -Wno-psabi\nbuild/extra/cross-linux-gnu-arm-eabihf/%: CMAKE_SYSTEM_NAME ?= Linux\nbuild/extra/cross-linux-gnu-arm-eabihf/%: CMAKE_CROSSCOMPILING_EMULATOR ?= qemu-arm\n\n# cross compiler: Windows x86 win32 MinGW (i386)\nbuild/extra/cross-windows-mingw32/debug:   PHONY; $(call run_config_and_build,$@,Debug)\nbuild/extra/cross-windows-mingw32/release: PHONY; $(call run_config_and_build,$@,Release)\nbuild/extra/cross-windows-mingw32/%: export CC  = i686-w64-mingw32-gcc -static -D_WIN32_WINNT=0x0501\nbuild/extra/cross-windows-mingw32/%: export CXX = i686-w64-mingw32-g++ -static -D_WIN32_WINNT=0x0501\nbuild/extra/cross-windows-mingw32/%: CMAKE_SYSTEM_NAME ?= Windows\nbuild/extra/cross-windows-mingw32/%: CMAKE_SYSTEM_PROCESSOR ?= X86\nbuild/extra/cross-windows-mingw32/%: CMAKE_CROSSCOMPILING_EMULATOR ?= wine\n\n# cross compiler: Windows x64 win64 MinGW (amd64)\nbuild/extra/cross-windows-mingw64/debug:   PHONY; $(call run_config_and_build,$@,Debug)\nbuild/extra/cross-windows-mingw64/release: PHONY; $(call run_config_and_build,$@,Release)\nbuild/extra/cross-windows-mingw64/%: export CC  = x86_64-w64-mingw32-gcc -static -D_WIN32_WINNT=0x0501\nbuild/extra/cross-windows-mingw64/%: export CXX = x86_64-w64-mingw32-g++ -static -D_WIN32_WINNT=0x0501\nbuild/extra/cross-windows-mingw64/%: CMAKE_SYSTEM_NAME ?= Windows\nbuild/extra/cross-windows-mingw64/%: CMAKE_SYSTEM_PROCESSOR ?= AMD64\nbuild/extra/cross-windows-mingw64/%: CMAKE_CROSSCOMPILING_EMULATOR ?= wine\n\n# cross compiler: macOS arm64 (aarch64)\nbuild/extra/cross-darwin-arm64/debug:   PHONY; $(call run_config_and_build,$@,Debug)\nbuild/extra/cross-darwin-arm64/release: PHONY; $(call run_config_and_build,$@,Release)\nbuild/extra/cross-darwin-arm64/%: export CC  = clang   -target arm64-apple-darwin\nbuild/extra/cross-darwin-arm64/%: export CXX = clang++ -target arm64-apple-darwin\nbuild/extra/cross-darwin-arm64/%: CMAKE_SYSTEM_NAME ?= Darwin\nbuild/extra/cross-darwin-arm64/%: CMAKE_SYSTEM_PROCESSOR ?= arm64\n\n# cross compiler: macOS x86_64 (amd64)\nbuild/extra/cross-darwin-x86_64/debug:   PHONY; $(call run_config_and_build,$@,Debug)\nbuild/extra/cross-darwin-x86_64/release: PHONY; $(call run_config_and_build,$@,Release)\nbuild/extra/cross-darwin-x86_64/%: export CC  = clang   -target x86_64-apple-darwin\nbuild/extra/cross-darwin-x86_64/%: export CXX = clang++ -target x86_64-apple-darwin\nbuild/extra/cross-darwin-x86_64/%: CMAKE_SYSTEM_NAME ?= Darwin\nbuild/extra/cross-darwin-x86_64/%: CMAKE_SYSTEM_PROCESSOR ?= x86_64\n\n#***********************************************************************\n# C/C++ static analyzers\n#***********************************************************************\n\n# force building with clang Static Analyzer (scan-build)\nSCAN_BUILD = scan-build\nbuild/analyze/clang-analyzer/debug:   PHONY; $(call run_config_and_build,$@,Debug)\nbuild/analyze/clang-analyzer/release: PHONY; $(call run_config_and_build,$@,Release)\nbuild/analyze/clang-analyzer/%: override CMAKE := $(SCAN_BUILD) $(CMAKE)\nbuild/analyze/clang-analyzer/%: export CCC_CC  ?= clang\nbuild/analyze/clang-analyzer/%: export CCC_CXX ?= clang++\n\n# run clang-tidy: uses file compile_commands.json from an existing clang build;\n#   does not create any actual files, so purely PHONY\nCLANG_TIDY_BUILD_BASE = build/extra/clang\nRUN_CLANG_TIDY = time python3 ./misc/analyze/clang-tidy/run-clang-tidy.py -p \"$<\"\nRUN_CLANG_TIDY_WERROR = $(RUN_CLANG_TIDY) '-warnings-as-errors=*'\nbuild/analyze/clang-tidy-resize/debug build/analyze/clang-tidy-resize/release: $$(CLANG_TIDY_BUILD_BASE)/$$(notdir $$@) PHONY\n\t$(RUN_CLANG_TIDY_WERROR) -config-file ./.clang-tidy '/src/.*\\.cpp'\nbuild/analyze/clang-tidy-bzip2/debug build/analyze/clang-tidy-bzip2/release: $$(CLANG_TIDY_BUILD_BASE)/$$(notdir $$@) PHONY\n\t$(RUN_CLANG_TIDY)        -config-file ./misc/analyze/clang-tidy/clang-tidy-bzip2.yml /vendor/bzip2/\nbuild/analyze/clang-tidy-ucl/debug build/analyze/clang-tidy-ucl/release: $$(CLANG_TIDY_BUILD_BASE)/$$(notdir $$@) PHONY\n\t$(RUN_CLANG_TIDY_WERROR) -config-file ./misc/analyze/clang-tidy/clang-tidy-ucl.yml   /vendor/ucl/\nbuild/analyze/clang-tidy-zlib/debug build/analyze/clang-tidy-zlib/release: $$(CLANG_TIDY_BUILD_BASE)/$$(notdir $$@) PHONY\n\t$(RUN_CLANG_TIDY)        -config-file ./misc/analyze/clang-tidy/clang-tidy-zlib.yml  /vendor/zlib/\nbuild/analyze/clang-tidy-zstd/debug build/analyze/clang-tidy-zstd/release: $$(CLANG_TIDY_BUILD_BASE)/$$(notdir $$@) PHONY\n\t$(RUN_CLANG_TIDY)        -config-file ./misc/analyze/clang-tidy/clang-tidy-zstd.yml  /vendor/zstd/\nbuild/analyze/clang-tidy/debug build/analyze/clang-tidy/release: build/analyze/clang-tidy-resize/$$(notdir $$@)\nbuild/analyze/clang-tidy/debug build/analyze/clang-tidy/release: build/analyze/clang-tidy-bzip2/$$(notdir $$@)\nbuild/analyze/clang-tidy/debug build/analyze/clang-tidy/release: build/analyze/clang-tidy-ucl/$$(notdir $$@)\nbuild/analyze/clang-tidy/debug build/analyze/clang-tidy/release: build/analyze/clang-tidy-zlib/$$(notdir $$@)\nbuild/analyze/clang-tidy/debug build/analyze/clang-tidy/release: build/analyze/clang-tidy-zstd/$$(notdir $$@)\n\n# OLD names [deprecated]\nbuild/extra/scan-build/debug:   build/analyze/clang-analyzer/debug PHONY\nbuild/extra/scan-build/release: build/analyze/clang-analyzer/release PHONY\n\n#***********************************************************************\n# advanced: generic eXtra target\n#***********************************************************************\n\n# usage:\n#   make RESIZE_XTARGET=my-target CC=\"my-cc -flags\" CXX=\"my-cxx -flags\"\n#   make RESIZE_XTARGET=my-target CC=\"my-cc -flags\" CXX=\"my-cxx -flags\" xtarget/debug\n\nifneq ($(RESIZE_XTARGET),)\nifneq ($(CC),)\nifneq ($(CXX),)\n\nRESIZE_XTARGET := $(RESIZE_XTARGET)\nbuild/$(RESIZE_XTARGET)/debug:   PHONY; $(call run_config_and_build,$@,Debug)\nbuild/$(RESIZE_XTARGET)/release: PHONY; $(call run_config_and_build,$@,Release)\nbuild/$(RESIZE_XTARGET)/%: export CC  := $(CC)\nbuild/$(RESIZE_XTARGET)/%: export CXX := $(CXX)\n# shortcuts\nxtarget/debug:   build/$(RESIZE_XTARGET)/debug PHONY\nxtarget/release: build/$(RESIZE_XTARGET)/release PHONY\nxtarget/all:     xtarget/debug xtarget/release PHONY\nxtarget/debug+test:   build/$(RESIZE_XTARGET)/debug+test PHONY\nxtarget/release+test: build/$(RESIZE_XTARGET)/release+test PHONY\nxtarget/all+test:     xtarget/debug+test xtarget/release+test PHONY\n# set new default\n.DEFAULT_GOAL := build/$(RESIZE_XTARGET)/release\n\nendif\nendif\nendif\n\n#***********************************************************************\n# assemble cmake config flags; useful for CI jobs\n#\n# info: by default CMake only honors the CC and CXX environment variables; make\n# it easy to set other variables like CMAKE_AR or CMAKE_RANLIB\n#***********************************************************************\n\nRESIZE_CMAKE_CONFIG_FLAGS += $(RESIZE_CMAKE_CONFIG_FLAGS_GENERATOR)\nRESIZE_CMAKE_CONFIG_FLAGS += $(RESIZE_CMAKE_CONFIG_FLAGS_TOOLSET)\nRESIZE_CMAKE_CONFIG_FLAGS += $(RESIZE_CMAKE_CONFIG_FLAGS_PLATFORM)\n\n$(call check_undefined,__add_cmake_config)\n# promote an environment or Make variable to a CMake cache entry:\n__add_cmake_config = $(and $($1),-D$1=\"$($1)\")\n\n# pass common CMake settings\nRESIZE_CMAKE_CONFIG_FLAGS += $(call __add_cmake_config,CMAKE_INSTALL_PREFIX)\nRESIZE_CMAKE_CONFIG_FLAGS += $(call __add_cmake_config,CMAKE_VERBOSE_MAKEFILE)\n# pass common CMake toolchain settings\nRESIZE_CMAKE_CONFIG_FLAGS += $(call __add_cmake_config,CMAKE_ADDR2LINE)\nRESIZE_CMAKE_CONFIG_FLAGS += $(call __add_cmake_config,CMAKE_AR)\nRESIZE_CMAKE_CONFIG_FLAGS += $(call __add_cmake_config,CMAKE_DLLTOOL)\nRESIZE_CMAKE_CONFIG_FLAGS += $(call __add_cmake_config,CMAKE_LINKER)\nRESIZE_CMAKE_CONFIG_FLAGS += $(call __add_cmake_config,CMAKE_NM)\nRESIZE_CMAKE_CONFIG_FLAGS += $(call __add_cmake_config,CMAKE_OBJCOPY)\nRESIZE_CMAKE_CONFIG_FLAGS += $(call __add_cmake_config,CMAKE_OBJDUMP)\nRESIZE_CMAKE_CONFIG_FLAGS += $(call __add_cmake_config,CMAKE_RANLIB)\nRESIZE_CMAKE_CONFIG_FLAGS += $(call __add_cmake_config,CMAKE_READELF)\nRESIZE_CMAKE_CONFIG_FLAGS += $(call __add_cmake_config,CMAKE_STRIP)\nRESIZE_CMAKE_CONFIG_FLAGS += $(call __add_cmake_config,CMAKE_TAPI)\n# pass common CMake LTO toolchain settings\nRESIZE_CMAKE_CONFIG_FLAGS += $(call __add_cmake_config,CMAKE_C_COMPILER_AR)\nRESIZE_CMAKE_CONFIG_FLAGS += $(call __add_cmake_config,CMAKE_C_COMPILER_RANLIB)\nRESIZE_CMAKE_CONFIG_FLAGS += $(call __add_cmake_config,CMAKE_CXX_COMPILER_AR)\nRESIZE_CMAKE_CONFIG_FLAGS += $(call __add_cmake_config,CMAKE_CXX_COMPILER_RANLIB)\n# pass common CMake cross compilation settings\nRESIZE_CMAKE_CONFIG_FLAGS += $(call __add_cmake_config,CMAKE_SYSTEM_NAME)\nRESIZE_CMAKE_CONFIG_FLAGS += $(call __add_cmake_config,CMAKE_SYSTEM_PROCESSOR)\nRESIZE_CMAKE_CONFIG_FLAGS += $(call __add_cmake_config,CMAKE_CROSSCOMPILING_EMULATOR)\n# pass RESIZE config options; see CMakeLists.txt\nRESIZE_CMAKE_CONFIG_FLAGS += $(call __add_cmake_config,RESIZE_CONFIG_DISABLE_GITREV)\nRESIZE_CMAKE_CONFIG_FLAGS += $(call __add_cmake_config,RESIZE_CONFIG_DISABLE_SANITIZE)\nRESIZE_CMAKE_CONFIG_FLAGS += $(call __add_cmake_config,RESIZE_CONFIG_DISABLE_WERROR)\nRESIZE_CMAKE_CONFIG_FLAGS += $(call __add_cmake_config,RESIZE_CONFIG_DISABLE_WSTRICT)\nRESIZE_CMAKE_CONFIG_FLAGS += $(call __add_cmake_config,RESIZE_CONFIG_DISABLE_SELF_PACK_TEST)\nRESIZE_CMAKE_CONFIG_FLAGS += $(call __add_cmake_config,RESIZE_CONFIG_DISABLE_EXHAUSTIVE_TESTS)\n# pass RESIZE extra compile options; see CMakeLists.txt\nRESIZE_CMAKE_CONFIG_FLAGS += $(call __add_cmake_config,RESIZE_CONFIG_EXTRA_COMPILE_OPTIONS_BZIP2)\nRESIZE_CMAKE_CONFIG_FLAGS += $(call __add_cmake_config,RESIZE_CONFIG_EXTRA_COMPILE_OPTIONS_UCL)\nRESIZE_CMAKE_CONFIG_FLAGS += $(call __add_cmake_config,RESIZE_CONFIG_EXTRA_COMPILE_OPTIONS_RESIZE)\nRESIZE_CMAKE_CONFIG_FLAGS += $(call __add_cmake_config,RESIZE_CONFIG_EXTRA_COMPILE_OPTIONS_ZLIB)\nRESIZE_CMAKE_CONFIG_FLAGS += $(call __add_cmake_config,RESIZE_CONFIG_EXTRA_COMPILE_OPTIONS_ZSTD)\n\n#***********************************************************************\n# check git submodules\n#***********************************************************************\n\nSUBMODULES = doctest lzma-sdk ucl valgrind zlib\n\n$(foreach 1,$(SUBMODULES),$(if $(wildcard vendor/$1/[CL]*),,\\\n    $(error ERROR: missing git submodule '$1'; run 'git submodule update --init')))\n\nendif # RESIZE_MAKEFILE_EXTRA_MK_INCLUDED\n","size_bytes":22537},"misc/scripts/check_whitespace.sh":{"content":"#! /usr/bin/env bash\n## vim:set ts=4 sw=4 et:\nset -e; set -o pipefail\n\n# Copyright (C) Markus Franz Xaver Johannes Oberhumer\n\n[[ -z $1 ]] || cd \"$1\" || exit 1\n\nfind . \\\n    -type d -name '.git' -prune -o \\\n    -type d -name '.hg' -prune -o \\\n    -type d -name 'build*' -prune -o \\\n    -type d -name 'tmp*' -prune -o \\\n    -type d -name 'vendor' -prune -o \\\n    -type f -iname '*.bat' -prune -o \\\n    -type f -iname '*.exe' -prune -o \\\n    -type f -iname '*.o' -prune -o \\\n    -type f -iname '*.obj' -prune -o \\\n    -type f -iname '*.out' -prune -o \\\n    -type f -iname '*.pdf' -prune -o \\\n    -type f -iname '*.swp' -prune -o \\\n    -type f -print0 | \\\nLC_ALL=C sort -z | xargs -0r perl -n -e '\n    #print(\"$ARGV\\n\");\n    if (m,[\\x00\\x01\\x02\\x7f\\xfe\\xff],) { print \"ERROR: binary file detected $ARGV: $_\"; exit(1); }\n    if (m,[\\r\\x1a],) { print \"ERROR: DOS EOL detected $ARGV: $_\"; exit(1); }\n    if (m,([ \\t]+)$,) {\n        if ($ARGV =~ m,\\.patch$,) { }\n        else { print \"ERROR: trailing whitespace detected $ARGV: $_\"; exit(1); }\n    }\n    if (m,\\t,) {\n        if ($ARGV =~ m,\\.patch$,) { }\n        elsif ($ARGV =~ m,(^|/)(gnu|m)?make(file|vars),i) { }\n        elsif ($ARGV =~ m,\\.mk$,) { }\n        elsif ($ARGV =~ m,/tmp/.*\\.(disasm|dump)$,) { }\n        elsif ($ARGV =~ m,/src/stub/src/arch/.*/lzma\\w+\\.S$,) { }\n        else { print \"ERROR: hard TAB detected $ARGV: $_\"; exit(1); }\n    }\n' || exit 1\n","size_bytes":1407},"misc/scripts/check_whitespace_git.sh":{"content":"#! /usr/bin/env bash\n## vim:set ts=4 sw=4 et:\nset -e; set -o pipefail\n\n# Copyright (C) Markus Franz Xaver Johannes Oberhumer\n\n[[ -z $1 ]] || cd \"$1\" || exit 1\n[[ -d .git ]] || exit 1\n\ngit ls-files --full-name -z | perl -0 -n -e '\n    s,^,./,;\n    if (m,^\\./src/lzma-sdk(\\0|$),) { }\n    elsif (m,^\\./vendor/,) { }\n    elsif (m,\\.bat(\\0|$),) { }\n    elsif (m,\\.exe(\\0|$),) { }\n    else { print; }\n' | LC_ALL=C sort -z | xargs -0r perl -n -e '\n    #print(\"$ARGV\\n\");\n    if (m,[\\x00\\x01\\x02\\x7f\\xfe\\xff],) { print \"ERROR: binary file detected $ARGV: $_\"; exit(1); }\n    if (m,[\\r\\x1a],) { print \"ERROR: DOS EOL detected $ARGV: $_\"; exit(1); }\n    if (m,([ \\t]+)$,) {\n        if ($ARGV =~ m,\\.patch$,) { }\n        else { print \"ERROR: trailing whitespace detected $ARGV: $_\"; exit(1); }\n    }\n    if (m,\\t,) {\n        if ($ARGV =~ m,\\.patch$,) { }\n        elsif ($ARGV =~ m,(^|/)(gnu|m)?make(file|vars),i) { }\n        elsif ($ARGV =~ m,\\.mk$,) { }\n        elsif ($ARGV =~ m,/tmp/.*\\.(disasm|dump)$,) { }\n        elsif ($ARGV =~ m,/src/stub/src/arch/.*/lzma\\w+\\.S$,) { }\n        else { print \"ERROR: hard TAB detected $ARGV: $_\"; exit(1); }\n    }\n' || exit 1\n","size_bytes":1154},"misc/scripts/readlink-en.py":{"content":"#! /usr/bin/env python3\n## vim:set ts=4 sw=4 et: -*- coding: utf-8 -*-\n\n# simulate \"readlink -en FILE\"\n# - result may differ from actual readlink(1) for edge cases\n# - works with Python2 and Python3\n#\n# Copyright (C) Markus Franz Xaver Johannes Oberhumer\n\nimport os, sys\nif len(sys.argv) != 2:\n    sys.exit(1)\nreal_path = os.path.realpath(sys.argv[1])\nif not os.path.exists(real_path):\n    sys.exit(1)\nsys.stdout.write(real_path)\nsys.stdout.flush()\n","size_bytes":449},"misc/scripts/readlink-fn.py":{"content":"#! /usr/bin/env python3\n## vim:set ts=4 sw=4 et: -*- coding: utf-8 -*-\n\n# simulate \"readlink -fn FILE\" for systems that lack it (e.g. macOS-11)\n# - result may differ from actual readlink(1) for edge cases\n# - works with Python2 and Python3\n#\n# Copyright (C) Markus Franz Xaver Johannes Oberhumer\n\nimport os, sys\nif len(sys.argv) != 2:\n    sys.exit(1)\nreal_path = os.path.realpath(sys.argv[1])\nsys.stdout.write(real_path)\nsys.stdout.flush()\n","size_bytes":440},"misc/scripts/run_cmake_config.sh":{"content":"#! /usr/bin/env bash\n## vim:set ts=4 sw=4 et:\nset -e; set -o pipefail\n\n# Copyright (C) Markus Franz Xaver Johannes Oberhumer\n# assemble cmake config flags; useful for CI jobs\n# also see misc/make/Makefile-extra.mk\n\ncmake_config_flags=()\n\n# promote an environment variable to a CMake cache entry:\n__add_cmake_config() {\n    [[ -z \"${!1}\" ]] || cmake_config_flags+=( -D$1=\"${!1}\" )\n}\n\n# pass common CMake settings\nfor v in CMAKE_INSTALL_PREFIX CMAKE_VERBOSE_MAKEFILE; do\n    __add_cmake_config $v\ndone\n# pass common CMake toolchain settings\nfor v in CMAKE_ADDR2LINE CMAKE_AR CMAKE_DLLTOOL CMAKE_LINKER CMAKE_NM CMAKE_OBJCOPY CMAKE_OBJDUMP CMAKE_RANLIB CMAKE_READELF CMAKE_STRIP CMAKE_TAPI; do\n    __add_cmake_config $v\ndone\n# pass common CMake LTO toolchain settings\nfor v in CMAKE_C_COMPILER_AR CMAKE_C_COMPILER_RANLIB CMAKE_CXX_COMPILER_AR CMAKE_CXX_COMPILER_RANLIB; do\n    __add_cmake_config $v\ndone\n# pass common CMake cross compilation settings\nfor v in CMAKE_SYSTEM_NAME CMAKE_SYSTEM_PROCESSOR CMAKE_CROSSCOMPILING_EMULATOR; do\n    __add_cmake_config $v\ndone\n# pass RESIZE config options; see CMakeLists.txt\nfor v in RESIZE_CONFIG_DISABLE_GITREV RESIZE_CONFIG_DISABLE_SANITIZE RESIZE_CONFIG_DISABLE_WERROR RESIZE_CONFIG_DISABLE_WSTRICT RESIZE_CONFIG_DISABLE_SELF_PACK_TEST RESIZE_CONFIG_DISABLE_EXHAUSTIVE_TESTS; do\n    __add_cmake_config $v\ndone\n# pass RESIZE extra compile options; see CMakeLists.txt\nfor v in RESIZE_CONFIG_EXTRA_COMPILE_OPTIONS_BZIP2 RESIZE_CONFIG_EXTRA_COMPILE_OPTIONS_UCL RESIZE_CONFIG_EXTRA_COMPILE_OPTIONS_RESIZE RESIZE_CONFIG_EXTRA_COMPILE_OPTIONS_ZLIB RESIZE_CONFIG_EXTRA_COMPILE_OPTIONS_ZSTD; do\n    __add_cmake_config $v\ndone\n\nexec \"${CMAKE:-cmake}\" $RESIZE_CMAKE_CONFIG_FLAGS \"${cmake_config_flags[@]}\" \"$@\"\nexit 99\n","size_bytes":1749},"misc/scripts/upx-clang-format.sh":{"content":"#! /usr/bin/env bash\n## vim:set ts=4 sw=4 et:\nset -e; set -o pipefail\n\n# Copyright (C) Markus Franz Xaver Johannes Oberhumer\n#\n# \"Gofmt's style is nobody's favourite, but gofmt is everybody's favourite.\" --Rob Pike\n#\n# NOTE: we are using clang-format-15.0.6 from upx-stubtools\n# see https://github.com/upx/upx-stubtools/releases\n#\n# NOTE: we use .clang-format config from upx.git/.clang-format\n\nif [[ ! -f $UPX_CLANG_FORMAT ]]; then\n    UPX_CLANG_FORMAT=\"$HOME/local/bin/bin-upx/clang-format-15.0.6\"\nfi\nif [[ ! -f $UPX_CLANG_FORMAT ]]; then\n    UPX_CLANG_FORMAT=\"$HOME/.local/bin/bin-upx/clang-format-15.0.6\"\nfi\nif [[ ! -f $UPX_CLANG_FORMAT ]]; then\n    UPX_CLANG_FORMAT=\"$HOME/bin/bin-upx/clang-format-15.0.6\"\nfi\nif [[ ! -f $UPX_CLANG_FORMAT ]]; then\n    echo \"ERROR: $0: cannot find clang-format-15.0.6\"\n    echo \"ERROR: $0: please visit https://github.com/upx/upx-stubtools\"\n    exit 1\nfi\n\n# limit memory usage to 1 GiB (in case of clang-format problems with invalid files)\nulimit -v 1048576 || true\n\n#echo \"$UPX_CLANG_FORMAT\"\nexec \"$UPX_CLANG_FORMAT\" -style=file \"$@\"\nexit 99\n","size_bytes":1080},"misc/testsuite/mimic_ctest.sh":{"content":"#! /usr/bin/env bash\n## vim:set ts=4 sw=4 et:\nset -e; set -o pipefail\nargv0=$0; argv0abs=$(readlink -fn \"$argv0\"); argv0dir=$(dirname \"$argv0abs\")\n\n#\n# Copyright (C) Markus Franz Xaver Johannes Oberhumer\n#\n# mimic running \"ctest\", i.e. the \"test\" section of CMakeLists.txt\n#   - does not redirect stdout\n#   - allows freely setting $resize_exe_runner, while CMake is restricted to configure-time settings\n#\n# requires:\n#   $resize_exe                (required, but with convenience fallback \"./resize\")\n# optional settings:\n#   $resize_exe_runner         (e.g. \"qemu-x86_64 -cpu Nehalem\" or \"valgrind\")\n#\n\n# Debugging aid for locating failing commands.  Depends on 'bash' shell.\n# (BASH_LINENO is relative to current FUNCTION only; non-function ==> 0)\n# Notice single-quoting of entire first argument.\ntrap 'echo ERROR: pwd=\\\"$PWD\\\"  file=\\\"$BASH_SOURCE\\\"  line=${BASH_LINENO[0]}  cmd=\\\"$BASH_COMMAND\\\"' ERR\n# Example: \"false a b c\" ==> ERROR: pwd=\"path/misc/testsuite\" file=\"./mimic_ctest.sh\" line=0 cmd=\"false a b c\"\n\n#***********************************************************************\n# init & checks\n#***********************************************************************\n\n# resize_exe\n[[ -z $resize_exe && -f ./resize && -x ./resize ]] && resize_exe=./resize # convenience fallback\nif [[ -z $resize_exe ]]; then echo \"RESIZE-ERROR: please set \\$resize_exe\"; exit 1; fi\nif [[ ! -f $resize_exe ]]; then echo \"RESIZE-ERROR: file '$resize_exe' does not exist\"; exit 1; fi\nresize_exe=$(readlink -fn \"$resize_exe\") # make absolute\n[[ -f $resize_exe ]] || exit 1\n\n# set emu and run_resize\nemu=()\nif [[ -n $resize_exe_runner ]]; then\n    # usage examples:\n    #   export resize_exe_runner=\"qemu-x86_64 -cpu Nehalem\"\n    #   export resize_exe_runner=\"valgrind --leak-check=no --error-exitcode=1 --quiet\"\n    #   export resize_exe_runner=\"wine\"\n    IFS=' ' read -r -a emu <<< \"$resize_exe_runner\" # split at spaces into array\nelif [[ -n $CMAKE_CROSSCOMPILING_EMULATOR ]]; then\n    IFS=';' read -r -a emu <<< \"$CMAKE_CROSSCOMPILING_EMULATOR\" # split at semicolons into array\nfi\nrun_resize=( \"${emu[@]}\" \"$resize_exe\" )\necho \"run_resize='${run_resize[*]}'\"\n\n# run_resize sanity check\nif ! \"${run_resize[@]}\" --version-short >/dev/null; then echo \"RESIZE-ERROR: FATAL: resize --version-short FAILED\"; exit 1; fi\nif ! \"${run_resize[@]}\" -L >/dev/null 2>&1; then echo \"RESIZE-ERROR: FATAL: resize -L FAILED\"; exit 1; fi\nif ! \"${run_resize[@]}\" --help >/dev/null;  then echo \"RESIZE-ERROR: FATAL: resize --help FAILED\"; exit 1; fi\n\n#***********************************************************************\n# see CMakeLists.txt\n#\n# IDEA: create a Makefile and use \"make -j8\" so that these tests can\n#   run in parallel much like \"ctest --parallel 8\"\n#***********************************************************************\n\n# similar to cmake function resize_cache_bool_vars()\nset_cmake_bool_vars() {\n    local default_value=\"$1\"; shift\n    local var_name\n    for var_name do\n        case \"${!var_name}\" in\n            0 | FALSE | OFF | false | off) eval \"export $var_name=OFF\" ;;\n            1 | TRUE | ON | true | on) eval \"export $var_name=ON\" ;;\n            *) eval \"export $var_name=$default_value\" ;;\n        esac\n    done\n}\n\nset -x\nset_cmake_bool_vars OFF RESIZE_CONFIG_DISABLE_SELF_PACK_TEST\nset_cmake_bool_vars OFF RESIZE_CONFIG_DISABLE_RUN_UNPACKED_TEST\nset_cmake_bool_vars OFF RESIZE_CONFIG_DISABLE_RUN_PACKED_TEST\nif [[ \"${emu[0]}\" == *valgrind* ]]; then # valgrind is SLOW\n    set_cmake_bool_vars ON  RESIZE_CONFIG_DISABLE_EXHAUSTIVE_TESTS\nelse\n    set_cmake_bool_vars OFF RESIZE_CONFIG_DISABLE_EXHAUSTIVE_TESTS\nfi\n\nexport RESIZE=\"--prefer-ucl --no-color --no-progress\"\nexport RESIZE_DEBUG_DISABLE_GITREV_WARNING=1\nexport RESIZE_DEBUG_DOCTEST_DISABLE=1 # already checked above\n\n\"${run_resize[@]}\" --version\n\"${run_resize[@]}\" --version-short\n\"${run_resize[@]}\" --license\n\"${run_resize[@]}\" --help\n\"${run_resize[@]}\" --help-short\n\"${run_resize[@]}\" --help-verbose\n\"${run_resize[@]}\" --sysinfo\n\"${run_resize[@]}\" --sysinfo -v\n\"${run_resize[@]}\" --sysinfo -vv\n\nif [[ $RESIZE_CONFIG_DISABLE_SELF_PACK_TEST == ON ]]; then\n    echo \"Self-pack test disabled. All done.\"; exit 0\nfi\n\nexe=\".out\"\nresize_self_exe=$resize_exe\nfo=\"--force-overwrite\"\n\n\"${run_resize[@]}\" -3               \"${resize_self_exe}\" ${fo} -o resize-packed${exe}\n\"${run_resize[@]}\" -3 --all-filters \"${resize_self_exe}\" ${fo} -o resize-packed-fa${exe}\n\"${run_resize[@]}\" -3 --no-filter   \"${resize_self_exe}\" ${fo} -o resize-packed-fn${exe}\n\"${run_resize[@]}\" -3 --all-filters --debug-use-random-filter \"${resize_self_exe}\" ${fo} -o resize-packed-fr${exe}\n\"${run_resize[@]}\" -3 --nrv2b       \"${resize_self_exe}\" ${fo} -o resize-packed-nrv2b${exe}\n\"${run_resize[@]}\" -3 --nrv2d       \"${resize_self_exe}\" ${fo} -o resize-packed-nrv2d${exe}\n\"${run_resize[@]}\" -3 --nrv2e       \"${resize_self_exe}\" ${fo} -o resize-packed-nrv2e${exe}\n\"${run_resize[@]}\" -1 --lzma        \"${resize_self_exe}\" ${fo} -o resize-packed-lzma${exe}\n\n\"${run_resize[@]}\" -l         resize-packed${exe} resize-packed-fa${exe} resize-packed-fn${exe} resize-packed-fr${exe} resize-packed-nrv2b${exe} resize-packed-nrv2d${exe} resize-packed-nrv2e${exe} resize-packed-lzma${exe}\n\"${run_resize[@]}\" --fileinfo resize-packed${exe} resize-packed-fa${exe} resize-packed-fn${exe} resize-packed-fr${exe} resize-packed-nrv2b${exe} resize-packed-nrv2d${exe} resize-packed-nrv2e${exe} resize-packed-lzma${exe}\n\"${run_resize[@]}\" -t         resize-packed${exe} resize-packed-fa${exe} resize-packed-fn${exe} resize-packed-fr${exe} resize-packed-nrv2b${exe} resize-packed-nrv2d${exe} resize-packed-nrv2e${exe} resize-packed-lzma${exe}\n\n\"${run_resize[@]}\" -d resize-packed${exe}       ${fo} -o resize-unpacked${exe}\n\"${run_resize[@]}\" -d resize-packed-fa${exe}    ${fo} -o resize-unpacked-fa${exe}\n\"${run_resize[@]}\" -d resize-packed-fn${exe}    ${fo} -o resize-unpacked-fn${exe}\n\"${run_resize[@]}\" -d resize-packed-fr${exe}    ${fo} -o resize-unpacked-fr${exe}\n\"${run_resize[@]}\" -d resize-packed-nrv2b${exe} ${fo} -o resize-unpacked-nrv2b${exe}\n\"${run_resize[@]}\" -d resize-packed-nrv2d${exe} ${fo} -o resize-unpacked-nrv2d${exe}\n\"${run_resize[@]}\" -d resize-packed-nrv2e${exe} ${fo} -o resize-unpacked-nrv2e${exe}\n\"${run_resize[@]}\" -d resize-packed-lzma${exe}  ${fo} -o resize-unpacked-lzma${exe}\n\n# all unpacked files must be identical\ncmp -s resize-unpacked${exe} resize-unpacked-fa${exe}\ncmp -s resize-unpacked${exe} resize-unpacked-fn${exe}\ncmp -s resize-unpacked${exe} resize-unpacked-fr${exe}\ncmp -s resize-unpacked${exe} resize-unpacked-nrv2b${exe}\ncmp -s resize-unpacked${exe} resize-unpacked-nrv2d${exe}\ncmp -s resize-unpacked${exe} resize-unpacked-nrv2e${exe}\ncmp -s resize-unpacked${exe} resize-unpacked-lzma${exe}\n\nif [[ $RESIZE_CONFIG_DISABLE_RUN_UNPACKED_TEST != ON ]]; then\n    \"${emu[@]}\" ./resize-unpacked${exe} --version-short\nfi\n\nif [[ $RESIZE_CONFIG_DISABLE_RUN_PACKED_TEST != ON ]]; then\n    \"${emu[@]}\" ./resize-packed${exe}       --version-short\n    \"${emu[@]}\" ./resize-packed-fa${exe}    --version-short\n    \"${emu[@]}\" ./resize-packed-fn${exe}    --version-short\n    \"${emu[@]}\" ./resize-packed-fr${exe}    --version-short\n    \"${emu[@]}\" ./resize-packed-nrv2b${exe} --version-short\n    \"${emu[@]}\" ./resize-packed-nrv2d${exe} --version-short\n    \"${emu[@]}\" ./resize-packed-nrv2e${exe} --version-short\n    \"${emu[@]}\" ./resize-packed-lzma${exe}  --version-short\nfi\n\nif [[ $RESIZE_CONFIG_DISABLE_EXHAUSTIVE_TESTS != ON ]]; then\n    set +x\n    for method in nrv2b nrv2d nrv2e lzma; do\n        for level in 1 2 3 4 5 6 7; do\n            for small in normal small; do\n                s=\"${method}-${level}\"\n                ss=\n                if [[ $small == \"small\" ]]; then\n                    s=\"${method}-${level}-${small}\"\n                    ss=\"--small\"\n                fi\n                echo \"========== $s ==========\"\n                \"${run_resize[@]}\" -qq --${method} -${level} ${ss} --all-filters --debug-use-random-filter \"${resize_self_exe}\" ${fo} -o resize-packed-${s}${exe}\n                \"${run_resize[@]}\" -qq -l resize-packed-${s}${exe}\n                \"${run_resize[@]}\" -qq --fileinfo resize-packed-${s}${exe}\n                \"${run_resize[@]}\" -qq -t resize-packed-${s}${exe}\n                \"${run_resize[@]}\" -qq -d resize-packed-${s}${exe} ${fo} -o resize-unpacked-${s}${exe}\n                cmp -s resize-unpacked${exe} resize-unpacked-${s}${exe}\n                if [[ $RESIZE_CONFIG_DISABLE_RUN_PACKED_TEST != ON ]]; then\n                    : ${resize_run_packed_test_count:=20}\n                    for ((i = 0; i < $resize_run_packed_test_count; i++)); do\n                        \"${emu[@]}\" ./resize-packed-${s}${exe} --version-short\n                    done\n                fi\n            done\n        done\n    done\nfi\n\necho \"run_resize='${run_resize[*]}'\"\necho \"All done.\"\n","size_bytes":8854},"misc/testsuite/mimic_ctest_sigsegv.sh":{"content":"#! /usr/bin/env bash\n## vim:set ts=4 sw=4 et:\nset -e; set -o pipefail\nargv0=$0; argv0abs=$(readlink -fn \"$argv0\"); argv0dir=$(dirname \"$argv0abs\")\n\n#\n# Copyright (C) Markus Franz Xaver Johannes Oberhumer\n#\n# mimic running \"ctest\", i.e. the \"test\" section of CMakeLists.txt\n#   - does not redirect stdout\n#   - allows freely setting $resize_exe_runner, while CMake is restricted to configure-time settings\n#\n# requires:\n#   $resize_exe                (required, but with convenience fallback \"./resize\")\n# optional settings:\n#   $resize_exe_runner         (e.g. \"qemu-x86_64 -cpu Nehalem\" or \"valgrind\")\n#\n\ncat >catch-sigsegv.gdb <<'EOF'\ncatch signal SIGSEGV\ncommands\n    x/i $pc\n    info reg\n    x/32i $pc-0x20\n    quit 77\nend\nEOF\n\ncatcher=$(readlink -fn catch-sigsegv.gdb)\n\nfunction emu_gdb() {\n    gdb -q -x \"$catcher\" <<EOF --args \"$@\"\n    run\nEOF\n}\n\nif [[ -n $resize_exe_runner ]]; then\n    true\nelif [[ -n $CMAKE_CROSSCOMPILING_EMULATOR ]]; then\n    true\nelse\n    resize_exe_runner=emu_gdb\n    : ${resize_run_packed_test_count:=20}\nfi\n\nsource \"$argv0dir/mimic_ctest.sh\"\n","size_bytes":1075},"misc/testsuite/test_symlinks.sh":{"content":"#! /usr/bin/env bash\n## vim:set ts=4 sw=4 et:\nset -e; set -o pipefail\nargv0=$0; argv0abs=$(readlink -fn \"$argv0\"); argv0dir=$(dirname \"$argv0abs\")\n\n#\n# Copyright (C) Markus Franz Xaver Johannes Oberhumer\n#\n# test file system behaviour with symlinks; requires:\n#   $resize_exe                (required, but with convenience fallback \"./resize\")\n# optional settings:\n#   $resize_exe_runner         (e.g. \"qemu-x86_64 -cpu Nehalem\" or \"valgrind\")\n#   $resize_test_file\n#\n\n# IMPORTANT NOTE: this script only works on Unix\n# IMPORTANT NOTE: do NOT run as user root!\numask 0022\n\n# disable on macOS for now, see https://github.com/resize/resize/issues/612\nif [[ \"$(uname)\" == Darwin ]]; then\n    case \"$RESIZE_DEBUG_FORCE_PACK_MACOS\" in\n        \"\" | \"0\") echo \"$0: SKIPPED\"; exit 0 ;;\n    esac\nfi\n\nid || true\necho \"PWD='$PWD'\"\nif [[ $UID == 0 || $EUID == 0 ]]; then\n    echo \"ERROR: do not run as root: UID=$UID EUID=$EUID\"\n    exit 91\nfi\n\n#***********************************************************************\n# init & checks\n#***********************************************************************\n\n# resize_exe\n[[ -z $resize_exe && -f ./resize && -x ./resize ]] && resize_exe=./resize # convenience fallback\nif [[ -z $resize_exe ]]; then echo \"RESIZE-ERROR: please set \\$resize_exe\"; exit 1; fi\nif [[ ! -f $resize_exe ]]; then echo \"RESIZE-ERROR: file '$resize_exe' does not exist\"; exit 1; fi\nresize_exe=$(readlink -fn \"$resize_exe\") # make absolute\n[[ -f $resize_exe ]] || exit 1\n\n# set emu and run_resize\nemu=()\nif [[ -n $resize_exe_runner ]]; then\n    # usage examples:\n    #   export resize_exe_runner=\"qemu-x86_64 -cpu Nehalem\"\n    #   export resize_exe_runner=\"valgrind --leak-check=no --error-exitcode=1 --quiet\"\n    #   export resize_exe_runner=\"wine\"\n    IFS=' ' read -r -a emu <<< \"$resize_exe_runner\" # split at spaces into array\nelif [[ -n $CMAKE_CROSSCOMPILING_EMULATOR ]]; then\n    IFS=';' read -r -a emu <<< \"$CMAKE_CROSSCOMPILING_EMULATOR\" # split at semicolons into array\nfi\nrun_resize=( \"${emu[@]}\" \"$resize_exe\" )\necho \"run_resize='${run_resize[*]}'\"\n\n# run_resize sanity check\nif ! \"${run_resize[@]}\" --version-short >/dev/null; then echo \"RESIZE-ERROR: FATAL: resize --version-short FAILED\"; exit 1; fi\nif ! \"${run_resize[@]}\" -L >/dev/null 2>&1; then echo \"RESIZE-ERROR: FATAL: resize -L FAILED\"; exit 1; fi\nif ! \"${run_resize[@]}\" --help >/dev/null;  then echo \"RESIZE-ERROR: FATAL: resize --help FAILED\"; exit 1; fi\n\n#***********************************************************************\n# util functions\n#***********************************************************************\n\nexit_code=0\nnum_errors=0\nall_errors=\n\nfailed() {\n    ####exit $1\n    # log error and keep going\n    exit_code=1\n    local a=\"$(basename \"$(dirname \"$PWD\")\")\"\n    local b=\"$(basename \"$PWD\")\"\n    let num_errors+=1 || true\n    all_errors=\"${all_errors} $a/$b/$1\"\n    echo \"    FAILED $b/$1\"\n}\n\nassert_file() {\n    local f\n    for f in \"$@\"; do\n        [[ ! -L \"$f\" && -f \"$f\" ]] && continue\n        echo \"failed '$f': not a regular file\"\n        failed 21\n    done\n}\n\nassert_symlink_to_file() {\n    local f\n    for f in \"$@\"; do\n        [[ -L \"$f\" && -f \"$f\" ]] && continue\n        echo \"failed '$f': not a symlink to file\"\n        failed 22\n    done\n}\n\nassert_symlink_to_dir() {\n    local f\n    for f in \"$@\"; do\n        [[ -L \"$f\" && -d \"$f\" ]] && continue\n        echo \"failed '$f': not a symlink to dir\"\n        failed 23\n    done\n}\n\nassert_symlink_dangling() {\n    local f\n    for f in \"$@\"; do\n        [[ -L \"$f\" && ! -e \"$f\" ]] && continue\n        echo \"failed '$f': not a dangling symlink\"\n        failed 24\n    done\n}\n\ncopy_directory() {\n    if command -v rsync >/dev/null; then\n        rsync -aH \"$1/\" \"$2\"\n    else\n        cp -ai \"$1\" \"$2\"\n    fi\n}\n\ncreate_files() {\n    # clean\n    local d\n    for d in z_dir_1 z_dir_2 z_dir_3 z_dir_4; do\n        if [[ -d $d ]]; then\n            chmod -R +rwx \"./$d\"\n            rm -rf \"./$d\"\n        fi\n    done\n\n    mkdir z_dir_1\n    cd z_dir_1\n    : > z_file\n    ln -s z_file z_symlink_file\n    : > z_file_link_1\n    ln z_file_link_1 z_file_link_2\n    ln -s z_file_link_1 z_symlink_file_link\n    mkdir z_dir\n    ln -s z_dir z_symlink_dir\n    ln -s z_file_missing z_symlink_dangling\n    assert_file             z_file*\n    assert_symlink_to_file  z_symlink_file\n    assert_symlink_to_dir   z_symlink_dir\n    assert_symlink_dangling z_symlink_dangling\n    cd ..\n\n    # write-protect z_dir_2/z_file*\n    copy_directory z_dir_1 z_dir_2\n    chmod a-w z_dir_2/z_file*\n\n    # write-protect z_dir_3 itself\n    copy_directory z_dir_1 z_dir_3\n    chmod a-w z_dir_3\n\n    # write-protect everything in z_dir_4\n    copy_directory z_dir_1 z_dir_4\n    chmod -R a-w z_dir_4\n}\n\nprint_header() {\n    local x='==========='; x=\"$x$x$x$x$x$x$x\"\n    echo -e \"\\n${x}\\n${1}\\n${x}\\n\"\n}\n\nenter_dir() {\n    cd \"$1\" || exit 1\n    echo \"===== $(basename \"$PWD\")\"\n}\nleave_dir() {\n    echo \"===== $(basename \"$PWD\") files\"\n    ls -lA\n    cd ..\n}\n\n#***********************************************************************\n# setup\n#***********************************************************************\n\n#set -x # debug\n\nexport RESIZE=\"--prefer-ucl --no-color --no-progress\"\nexport RESIZE_DEBUG_DISABLE_GITREV_WARNING=1\nexport RESIZE_DEBUG_DOCTEST_DISABLE=1 # already checked above\n\n# get $test_file\nif [[ -f $resize_test_file ]]; then\n    test_file=\"$(readlink -fn \"$resize_test_file\")\"\nelse\n    for test_file in /usr/bin/gmake /usr/bin/make /usr/bin/env /bin/ls; do\n        if [[ -f $test_file ]]; then\n            test_file=\"$(readlink -fn \"$test_file\")\"\n            break\n        fi\n    done\nfi\nls -l \"$test_file\"\nfile \"$test_file\" || true\n\n# create and enter a tmpdir in the current directory\ntmpdir=\"$(mktemp -d tmp-resize-test-XXXXXX)\"\ncd \"./$tmpdir\" || exit 1\n\n#***********************************************************************\n# default\n#***********************************************************************\n\nprint_header \"default\"\nflags=\"-qq -2 --no-filter\"\nmkdir default\ncd default\ncreate_files\nenter_dir z_dir_1\n\"${run_resize[@]}\" $flags                 z_symlink_file      && failed 10\n\"${run_resize[@]}\" $flags \"$test_file\" -o z_file_new          || failed 11\n\"${run_resize[@]}\" $flags \"$test_file\" -o z_dir               && failed 12\n\"${run_resize[@]}\" $flags \"$test_file\" -o z_file              && failed 13\n\"${run_resize[@]}\" $flags \"$test_file\" -o z_file_link_1       && failed 14\n\"${run_resize[@]}\" $flags \"$test_file\" -o z_symlink_file      && failed 15\n\"${run_resize[@]}\" $flags \"$test_file\" -o z_symlink_file_link && failed 16\n\"${run_resize[@]}\" $flags \"$test_file\" -o z_symlink_dir       && failed 17\n\"${run_resize[@]}\" $flags \"$test_file\" -o z_symlink_dangling  && failed 18\nassert_symlink_to_file  z_symlink_file z_symlink_file_link\nassert_symlink_to_dir   z_symlink_dir\nassert_symlink_dangling z_symlink_dangling\nleave_dir\nenter_dir z_dir_2\n\"${run_resize[@]}\" $flags                 z_symlink_file      && failed 10\n\"${run_resize[@]}\" $flags \"$test_file\" -o z_file_new          || failed 11\n\"${run_resize[@]}\" $flags \"$test_file\" -o z_dir               && failed 12\n\"${run_resize[@]}\" $flags \"$test_file\" -o z_file              && failed 13\n\"${run_resize[@]}\" $flags \"$test_file\" -o z_file_link_1       && failed 14\n\"${run_resize[@]}\" $flags \"$test_file\" -o z_symlink_file      && failed 15\n\"${run_resize[@]}\" $flags \"$test_file\" -o z_symlink_file_link && failed 16\n\"${run_resize[@]}\" $flags \"$test_file\" -o z_symlink_dir       && failed 17\n\"${run_resize[@]}\" $flags \"$test_file\" -o z_symlink_dangling  && failed 18\nassert_symlink_to_file  z_symlink_file z_symlink_file_link\nassert_symlink_to_dir   z_symlink_dir\nassert_symlink_dangling z_symlink_dangling\nleave_dir\nenter_dir z_dir_3\n\"${run_resize[@]}\" $flags                 z_symlink_file      && failed 10\n\"${run_resize[@]}\" $flags \"$test_file\" -o z_file_new          && failed 11\n\"${run_resize[@]}\" $flags \"$test_file\" -o z_dir               && failed 12\n\"${run_resize[@]}\" $flags \"$test_file\" -o z_file              && failed 13\n\"${run_resize[@]}\" $flags \"$test_file\" -o z_file_link_1       && failed 14\n\"${run_resize[@]}\" $flags \"$test_file\" -o z_symlink_file      && failed 15\n\"${run_resize[@]}\" $flags \"$test_file\" -o z_symlink_file_link && failed 16\n\"${run_resize[@]}\" $flags \"$test_file\" -o z_symlink_dir       && failed 17\n\"${run_resize[@]}\" $flags \"$test_file\" -o z_symlink_dangling  && failed 18\nassert_symlink_to_file  z_symlink_file z_symlink_file_link\nassert_symlink_to_dir   z_symlink_dir\nassert_symlink_dangling z_symlink_dangling\nleave_dir\nenter_dir z_dir_4\n\"${run_resize[@]}\" $flags                 z_symlink_file      && failed 10\n\"${run_resize[@]}\" $flags \"$test_file\" -o z_file_new          && failed 11\n\"${run_resize[@]}\" $flags \"$test_file\" -o z_dir               && failed 12\n\"${run_resize[@]}\" $flags \"$test_file\" -o z_file              && failed 13\n\"${run_resize[@]}\" $flags \"$test_file\" -o z_file_link_1       && failed 14\n\"${run_resize[@]}\" $flags \"$test_file\" -o z_symlink_file      && failed 15\n\"${run_resize[@]}\" $flags \"$test_file\" -o z_symlink_file_link && failed 16\n\"${run_resize[@]}\" $flags \"$test_file\" -o z_symlink_dir       && failed 17\n\"${run_resize[@]}\" $flags \"$test_file\" -o z_symlink_dangling  && failed 18\nassert_symlink_to_file  z_symlink_file z_symlink_file_link\nassert_symlink_to_dir   z_symlink_dir\nassert_symlink_dangling z_symlink_dangling\nleave_dir\ncd ..\n\n#***********************************************************************\n# force-overwrite\n#***********************************************************************\n\nprint_header \"force-overwrite\"\nflags=\"-qq -2 --no-filter --force-overwrite\"\nmkdir force-overwrite\ncd force-overwrite\ncreate_files\nenter_dir z_dir_1\n\"${run_resize[@]}\" $flags                 z_symlink_file      && failed 10\n\"${run_resize[@]}\" $flags \"$test_file\" -o z_file_new          || failed 11\n\"${run_resize[@]}\" $flags \"$test_file\" -o z_dir               && failed 12\n\"${run_resize[@]}\" $flags \"$test_file\" -o z_file              || failed 13\n\"${run_resize[@]}\" $flags \"$test_file\" -o z_file_link_1       || failed 14\n\"${run_resize[@]}\" $flags \"$test_file\" -o z_symlink_file      || failed 15\n\"${run_resize[@]}\" $flags \"$test_file\" -o z_symlink_file_link || failed 16\n\"${run_resize[@]}\" $flags \"$test_file\" -o z_symlink_dir       || failed 17\n\"${run_resize[@]}\" $flags \"$test_file\" -o z_symlink_dangling  || failed 18\nassert_file z_symlink_file z_symlink_file_link\nassert_file z_symlink_dir\nassert_file z_symlink_dangling\nleave_dir\nenter_dir z_dir_2\n\"${run_resize[@]}\" $flags                 z_symlink_file      && failed 10\n\"${run_resize[@]}\" $flags \"$test_file\" -o z_file_new          || failed 11\n\"${run_resize[@]}\" $flags \"$test_file\" -o z_dir               && failed 12\n\"${run_resize[@]}\" $flags \"$test_file\" -o z_file              || failed 13\n\"${run_resize[@]}\" $flags \"$test_file\" -o z_file_link_1       || failed 14\n\"${run_resize[@]}\" $flags \"$test_file\" -o z_symlink_file      || failed 15\n\"${run_resize[@]}\" $flags \"$test_file\" -o z_symlink_file_link || failed 16\n\"${run_resize[@]}\" $flags \"$test_file\" -o z_symlink_dir       || failed 17\n\"${run_resize[@]}\" $flags \"$test_file\" -o z_symlink_dangling  || failed 18\nassert_file z_symlink_file z_symlink_file_link\nassert_file z_symlink_dir\nassert_file z_symlink_dangling\nleave_dir\nenter_dir z_dir_3\n\"${run_resize[@]}\" $flags                 z_symlink_file      && failed 10\n\"${run_resize[@]}\" $flags \"$test_file\" -o z_file_new          && failed 11\n\"${run_resize[@]}\" $flags \"$test_file\" -o z_dir               && failed 12\n\"${run_resize[@]}\" $flags \"$test_file\" -o z_file              || failed 13\n\"${run_resize[@]}\" $flags \"$test_file\" -o z_file_link_1       || failed 14\n\"${run_resize[@]}\" $flags \"$test_file\" -o z_symlink_file      || failed 15\n\"${run_resize[@]}\" $flags \"$test_file\" -o z_symlink_file_link || failed 16\n\"${run_resize[@]}\" $flags \"$test_file\" -o z_symlink_dir       && failed 17\n\"${run_resize[@]}\" $flags \"$test_file\" -o z_symlink_dangling  && failed 18\nassert_symlink_to_file  z_symlink_file z_symlink_file_link\nassert_symlink_to_dir   z_symlink_dir\nassert_symlink_dangling z_symlink_dangling\nleave_dir\nenter_dir z_dir_4\n\"${run_resize[@]}\" $flags                 z_symlink_file      && failed 10\n\"${run_resize[@]}\" $flags \"$test_file\" -o z_file_new          && failed 11\n\"${run_resize[@]}\" $flags \"$test_file\" -o z_dir               && failed 12\n\"${run_resize[@]}\" $flags \"$test_file\" -o z_file              || failed 13\n\"${run_resize[@]}\" $flags \"$test_file\" -o z_file_link_1       || failed 14\n\"${run_resize[@]}\" $flags \"$test_file\" -o z_symlink_file      || failed 15\n\"${run_resize[@]}\" $flags \"$test_file\" -o z_symlink_file_link || failed 16\n\"${run_resize[@]}\" $flags \"$test_file\" -o z_symlink_dir       && failed 17\n\"${run_resize[@]}\" $flags \"$test_file\" -o z_symlink_dangling  && failed 18\nassert_symlink_to_file  z_symlink_file z_symlink_file_link\nassert_symlink_to_dir   z_symlink_dir\nassert_symlink_dangling z_symlink_dangling\nleave_dir\ncd ..\n\n#***********************************************************************\n# link\n#***********************************************************************\n\nprint_header \"link\"\nflags=\"-qq -2 --no-filter --link\"\nmkdir link\ncd link\ncreate_files\nenter_dir z_dir_1\n\"${run_resize[@]}\" $flags                 z_symlink_file      && failed 10\n\"${run_resize[@]}\" $flags \"$test_file\" -o z_file_new          || failed 11\n\"${run_resize[@]}\" $flags \"$test_file\" -o z_dir               && failed 12\n\"${run_resize[@]}\" $flags \"$test_file\" -o z_file              || failed 13\n\"${run_resize[@]}\" $flags \"$test_file\" -o z_file_link_1       || failed 14\n\"${run_resize[@]}\" $flags \"$test_file\" -o z_symlink_file      || failed 15\n\"${run_resize[@]}\" $flags \"$test_file\" -o z_symlink_file_link || failed 16\n\"${run_resize[@]}\" $flags \"$test_file\" -o z_symlink_dir       || failed 17\n\"${run_resize[@]}\" $flags \"$test_file\" -o z_symlink_dangling  || failed 18\nassert_file z_symlink_file z_symlink_file_link\nassert_file z_symlink_dir\nassert_file z_symlink_dangling\nleave_dir\nenter_dir z_dir_2\n\"${run_resize[@]}\" $flags                 z_symlink_file      && failed 10\n\"${run_resize[@]}\" $flags \"$test_file\" -o z_file_new          || failed 11\n\"${run_resize[@]}\" $flags \"$test_file\" -o z_dir               && failed 12\n\"${run_resize[@]}\" $flags \"$test_file\" -o z_file              && failed 13\n\"${run_resize[@]}\" $flags \"$test_file\" -o z_file_link_1       && failed 14\n\"${run_resize[@]}\" $flags \"$test_file\" -o z_symlink_file      || failed 15\n\"${run_resize[@]}\" $flags \"$test_file\" -o z_symlink_file_link || failed 16\n\"${run_resize[@]}\" $flags \"$test_file\" -o z_symlink_dir       || failed 17\n\"${run_resize[@]}\" $flags \"$test_file\" -o z_symlink_dangling  || failed 18\nassert_file z_symlink_file z_symlink_file_link\nassert_file z_symlink_dir\nassert_file z_symlink_dangling\nleave_dir\nenter_dir z_dir_3\n\"${run_resize[@]}\" $flags                 z_symlink_file      && failed 10\n\"${run_resize[@]}\" $flags \"$test_file\" -o z_file_new          && failed 11\n\"${run_resize[@]}\" $flags \"$test_file\" -o z_dir               && failed 12\n\"${run_resize[@]}\" $flags \"$test_file\" -o z_file              || failed 13\n\"${run_resize[@]}\" $flags \"$test_file\" -o z_file_link_1       || failed 14\n\"${run_resize[@]}\" $flags \"$test_file\" -o z_symlink_file      || failed 15\n\"${run_resize[@]}\" $flags \"$test_file\" -o z_symlink_file_link || failed 16\n\"${run_resize[@]}\" $flags \"$test_file\" -o z_symlink_dir       && failed 17\n\"${run_resize[@]}\" $flags \"$test_file\" -o z_symlink_dangling  && failed 18\nassert_symlink_to_file  z_symlink_file z_symlink_file_link\nassert_symlink_to_dir   z_symlink_dir\nassert_symlink_dangling z_symlink_dangling\nleave_dir\nenter_dir z_dir_4\n\"${run_resize[@]}\" $flags                 z_symlink_file      && failed 10\n\"${run_resize[@]}\" $flags \"$test_file\" -o z_file_new          && failed 11\n\"${run_resize[@]}\" $flags \"$test_file\" -o z_dir               && failed 12\n\"${run_resize[@]}\" $flags \"$test_file\" -o z_file              && failed 13\n\"${run_resize[@]}\" $flags \"$test_file\" -o z_file_link_1       && failed 14\n\"${run_resize[@]}\" $flags \"$test_file\" -o z_symlink_file      || failed 15\n\"${run_resize[@]}\" $flags \"$test_file\" -o z_symlink_file_link || failed 16\n\"${run_resize[@]}\" $flags \"$test_file\" -o z_symlink_dir       && failed 17\n\"${run_resize[@]}\" $flags \"$test_file\" -o z_symlink_dangling  && failed 18\nassert_symlink_to_file  z_symlink_file z_symlink_file_link\nassert_symlink_to_dir   z_symlink_dir\nassert_symlink_dangling z_symlink_dangling\nleave_dir\ncd ..\n\n#***********************************************************************\n# done\n#***********************************************************************\n\n# clean up\ncd ..\nchmod -R +rwx \"./$tmpdir\"\nrm -rf \"./$tmpdir\"\n\nif [[ $exit_code == 0 ]]; then\n    echo \"RESIZE testsuite passed. All done.\"\nelse\n    echo \"RESIZE-ERROR: RESIZE testsuite FAILED:${all_errors}\"\n    echo \"RESIZE-ERROR: RESIZE testsuite FAILED with $num_errors error(s). See log file.\"\nfi\nexit $exit_code\n","size_bytes":17031},"misc/testsuite/upx_testsuite_1-expected_sha256sums.sh":{"content":"########## begin .sha256sums.recreate\nexpected_sha256sums__t010_decompressed=\"\\\n24158f78c34c4ef94bb7773a6dda7231d289be76c2f5f60e8b9ddb3f800c100e *amd64-linux.elf/upx-3.91\n24808d572483f4cd713d66894b3da406755038737007a78b076528e6407e3132 *amd64-linux.elf/upx-3.95\nd88eaad0528bcecec9f51cbe015a117c8cf350a3f6d8308f2b0517d4fd19d189 *amd64-win64.pe/upx-3.95.exe\nf7279729eb975e4238f8b8ee56fefa41ccbeb35ef0ffe4c34f8047baab78fff5 *arm-linux.elf/upx-3.95\ne09df2a69f88c692138447f274ba7f99cdd11f8696c71ac8d3761606c95ab5c5 *arm-wince.pe/upx-3.91.exe\nce81113f8a4ff1cd806811cb80ab8bea5c9c6fbced47451c7f07e50700f9817b *arm64-linux.elf/upx-3.95\nb1c1c38d50007616aaf8e942839648c80a6111023e0b411e5fa7a06c543aeb4a *armeb-linux.elf/upx-3.91\n84b90eb0d617571fe4885639925b35ca6a61060cb2616bb5bf729b4d701653e4 *armeb-linux.elf/upx-3.95\nbcac77a287289301a45fde9a75e4e6c9ad7f8d57856bae6eafaae12ae4445a34 *i386-dos32.djgpp2.coff/upx-3.91.exe\n7d331e508449497f64cd47abdd3f00f70307f508ad3fd692d333feb97beccead *i386-dos32.djgpp2.coff/upx-3.95.exe\n730a513b72a094697f827e4ac1a4f8ef58a614fc7a7ad448fa58d60cd89af7ed *i386-linux.elf/upx-3.91\na1f3e5ffa7b2cfebe1e475ac1f4c7683b1b8b4e292aa0d04386cc0314dd162c9 *i386-linux.elf/upx-3.95\ne90fb09a808334c2674996760d42c82f8352e3f671f6b66c11481e772785c4d2 *i386-win32.pe/upx-3.91.exe\n07bd50c1d80f6ff651228e6fc0ba3a583a472915772244f232696b34156a9d27 *i386-win32.pe/upx-3.95.exe\n8e5333ea040f5594d3e67d5b09e005d52b3a52ef55099a7c11d7e39ead38e66d *m68k-atari.tos/upx-3.91.ttp\n8902f38ec3d95d8e077e3ab5fdbb5bad408859913a35deb87041f4f053cd6605 *mips-linux.elf/upx-3.95\nc3f44b4d00a87384c03a6f9e7aec809c1addfe3e271244d38a474f296603088c *mipsel-linux.elf/upx-3.91\ndd1496bc4e9c32a5d5dd47e3eaabf7b134ca001d48807eebfd3d5e28c8a2ab58 *mipsel-linux.elf/upx-3.95\nb8c35fa2956da17ca505956e9f5017bb5f3a746322647e24ccb8ff28059cafa4 *powerpc-linux.elf/upx-3.91\n2bc00a51daa0bada19a8fa1bd2c227a8596844fa1b0aa3611087f195072700e2 *powerpc-linux.elf/upx-3.95\na0950546dc17fca9437219431d8ddb0249ce5b08e899e0c799a87ac982adee70 *powerpc64le-linux.elf/upx-3.95\n\"\nexpected_sha256sums__t020_canonicalized=\"\\\n24158f78c34c4ef94bb7773a6dda7231d289be76c2f5f60e8b9ddb3f800c100e *amd64-linux.elf/upx-3.91\n24808d572483f4cd713d66894b3da406755038737007a78b076528e6407e3132 *amd64-linux.elf/upx-3.95\nd88eaad0528bcecec9f51cbe015a117c8cf350a3f6d8308f2b0517d4fd19d189 *amd64-win64.pe/upx-3.95.exe\nf7279729eb975e4238f8b8ee56fefa41ccbeb35ef0ffe4c34f8047baab78fff5 *arm-linux.elf/upx-3.95\ne09df2a69f88c692138447f274ba7f99cdd11f8696c71ac8d3761606c95ab5c5 *arm-wince.pe/upx-3.91.exe\nce81113f8a4ff1cd806811cb80ab8bea5c9c6fbced47451c7f07e50700f9817b *arm64-linux.elf/upx-3.95\nb1c1c38d50007616aaf8e942839648c80a6111023e0b411e5fa7a06c543aeb4a *armeb-linux.elf/upx-3.91\n84b90eb0d617571fe4885639925b35ca6a61060cb2616bb5bf729b4d701653e4 *armeb-linux.elf/upx-3.95\nbcac77a287289301a45fde9a75e4e6c9ad7f8d57856bae6eafaae12ae4445a34 *i386-dos32.djgpp2.coff/upx-3.91.exe\n7d331e508449497f64cd47abdd3f00f70307f508ad3fd692d333feb97beccead *i386-dos32.djgpp2.coff/upx-3.95.exe\n730a513b72a094697f827e4ac1a4f8ef58a614fc7a7ad448fa58d60cd89af7ed *i386-linux.elf/upx-3.91\na1f3e5ffa7b2cfebe1e475ac1f4c7683b1b8b4e292aa0d04386cc0314dd162c9 *i386-linux.elf/upx-3.95\ne90fb09a808334c2674996760d42c82f8352e3f671f6b66c11481e772785c4d2 *i386-win32.pe/upx-3.91.exe\n07bd50c1d80f6ff651228e6fc0ba3a583a472915772244f232696b34156a9d27 *i386-win32.pe/upx-3.95.exe\n8e5333ea040f5594d3e67d5b09e005d52b3a52ef55099a7c11d7e39ead38e66d *m68k-atari.tos/upx-3.91.ttp\n8902f38ec3d95d8e077e3ab5fdbb5bad408859913a35deb87041f4f053cd6605 *mips-linux.elf/upx-3.95\nc3f44b4d00a87384c03a6f9e7aec809c1addfe3e271244d38a474f296603088c *mipsel-linux.elf/upx-3.91\ndd1496bc4e9c32a5d5dd47e3eaabf7b134ca001d48807eebfd3d5e28c8a2ab58 *mipsel-linux.elf/upx-3.95\nb8c35fa2956da17ca505956e9f5017bb5f3a746322647e24ccb8ff28059cafa4 *powerpc-linux.elf/upx-3.91\n2bc00a51daa0bada19a8fa1bd2c227a8596844fa1b0aa3611087f195072700e2 *powerpc-linux.elf/upx-3.95\na0950546dc17fca9437219431d8ddb0249ce5b08e899e0c799a87ac982adee70 *powerpc64le-linux.elf/upx-3.95\n\"\nexpected_sha256sums__t110_compress_ucl_nrv2b_3_no_filter=\"\\\n836d9c5d9092421e49aeb573cde449ef740afbfea54d131ccbd88d8c7d87860d *amd64-linux.elf/upx-3.91\n9776a2d030719f9d74413d17c1bb732aaabb610b341031facd2c1a75348fc661 *amd64-linux.elf/upx-3.95\n822718cc0f6ac5e57bb23eeb65be6f3f7e73df8b062853abddcc924ec8207596 *amd64-win64.pe/upx-3.95.exe\n40353c37020fd4bb713c5d54273b8dc07666e262b83a4f0652ccb8a236465f9c *arm-linux.elf/upx-3.95\n1440d6b44968954baf56fbc2a0739a51873455876114d4445ae4b67cb5e7893b *arm-wince.pe/upx-3.91.exe\n35c08bf5086fe21ff19e3512359e54ac97c6d4513e6bb9ef4a59294bebf18f6a *arm64-linux.elf/upx-3.95\n0ca2dcd9e8b5c3f16dcb31e30b42ec57a70b8fe90281d412081095a3d7812f01 *armeb-linux.elf/upx-3.91\n462a72efbb580a2e90564412737bb3c1db1d930cde5b4f2c94782df91c8e4f4b *armeb-linux.elf/upx-3.95\na7ee051c5f9dcf233e2ee248274121b99fb8f098eff95469bc0638a7423723f0 *i386-dos32.djgpp2.coff/upx-3.91.exe\n85cf31be166cb59587a99419cdd0fc5a79825d7508ab2c9a4bc0d700d603354d *i386-dos32.djgpp2.coff/upx-3.95.exe\nfc7656d9a877967be7e339bfc98a0c63ea7b5abc30b96fa9e5931c75ecbe9827 *i386-linux.elf/upx-3.91\nd454a7639e96b986ad422b02045ecfefa3b9405901eaa32d92a2c489292b9600 *i386-linux.elf/upx-3.95\n934dd17076c0298d35a738533ea668e1fcbf8fc85c6671fcdd3a12e7722502ce *i386-win32.pe/upx-3.91.exe\n519a9f6b3de56f5f080151074b9d5d81e31c1961cd6e395f73d2d522b7f7f8e0 *i386-win32.pe/upx-3.95.exe\na7bd9f616231d883f6700b09e3c9a0af2880c6b5e5b0ce1cd8f06de43c48856c *m68k-atari.tos/upx-3.91.ttp\n7a0479691e51ea4a8a0246a1f0ffa9694ee2f0e0cf3aa43dc0f1324c4d427ba3 *mips-linux.elf/upx-3.95\nf60bab42fe3914109ab1b9f5d00a5be753cd0a2c1a79a3998d58800efedbfff7 *mipsel-linux.elf/upx-3.91\nb6d8cc9e2023a3fc415166afc378ccf2eb505487df84c8d959ec74b3fb4f8256 *mipsel-linux.elf/upx-3.95\nacd3dc5ed3e4c4eeaa42e7cca71a79d687dd844ce5f384666ed6e78327b5a8e3 *powerpc-linux.elf/upx-3.91\n03600584c97fa466ef58239452baf9ec6ff2f06b79d97d45c8490953080de6e3 *powerpc-linux.elf/upx-3.95\n3f02885d1e94e59062eb78c4c910cde042475a6cadb77a85a603de747a50f45c *powerpc64le-linux.elf/upx-3.95\n\"\nexpected_sha256sums__t120_compress_ucl_nrv2d_3_no_filter=\"\\\n8431343adec632690cec669038c246438c799e7dc1b8bc85586e0d2bcd2eebad *amd64-linux.elf/upx-3.91\n1852bded40be6eb5ddb07a491476dcfcca69cadda45a5f128aa8f967d567fa0b *amd64-linux.elf/upx-3.95\n5ab022e2c3ecb09931e2181fb5f7699f35e2b453b54c823e42653c84b0df5f2c *amd64-win64.pe/upx-3.95.exe\n6de0cf1903760710a95cb5330d0ffb406a93f081dbe6806935f51b0c75e23f03 *arm-linux.elf/upx-3.95\n53121baf42c85991900aa3947f3d817fe6e894bc6f325ab1d576de6fba5fbcbf *arm-wince.pe/upx-3.91.exe\n3c9e49445280de6a771e77f6a88b3c3957815baa193e92a893d5defe6699f50a *arm64-linux.elf/upx-3.95\n627a3c77adfcd4ef8c32f1638a6b99e20e79bb914cbcebed6fb9ad5f96936530 *armeb-linux.elf/upx-3.91\n7faf9f0adf508cf29bf0ac2a62234df06d6c9153d6d59cf61019361db906daf8 *armeb-linux.elf/upx-3.95\n51e4faea51e12c7442b27bb50150f532ac51d8102f77a669cbce82f2675a2ef2 *i386-dos32.djgpp2.coff/upx-3.91.exe\n1196f578ab0b862bae8ac6b5166b770f072cf0ac521a2a23a6347c19ea82a0da *i386-dos32.djgpp2.coff/upx-3.95.exe\n3015651261f28fb43ed43a8c1fa257bcfcdc788e6fd3f436f3de23733736c724 *i386-linux.elf/upx-3.91\n8cca96ea354af889f5e9d3074b2c7005f982463a3f22e1cca2bc01aed9232de1 *i386-linux.elf/upx-3.95\n3edf364443a3cd56efd04e95cc7d7c1846bf76addedd7263cfe8330771f19509 *i386-win32.pe/upx-3.91.exe\n48141fd66443f85ea867d7fa0bb3a50debb10f15bdb26c71888026e17c88d3a8 *i386-win32.pe/upx-3.95.exe\n07e1c09a953a9c87afa33d1236f46244280161bf3802273a523d380318886177 *m68k-atari.tos/upx-3.91.ttp\n39b3a5c780d9354714d5e2ed69068511422f8faf9ab660706adc8ad5ecdf3598 *mips-linux.elf/upx-3.95\n123ce137e4cd555470fcf9fe67df75179b6f337fee66d075ddc06f9848817a37 *mipsel-linux.elf/upx-3.91\nb78d8cd3a3402fed266c737cc34a32cc21b2b67b573e9e9071d4faf9fca89b89 *mipsel-linux.elf/upx-3.95\nea9cae1d1701db3a0c53e9a651766db5bdc30032f48913a4a9e99f193a800acc *powerpc-linux.elf/upx-3.91\naea86bf87870a1e48a454ac1ea9a80d90d8abe5113d418a71d8a9c4a74bb2d0a *powerpc-linux.elf/upx-3.95\n62038c87489dc5cd3772e8e4051cf1d416edecf267d37f390a649f4ae657e0f9 *powerpc64le-linux.elf/upx-3.95\n\"\nexpected_sha256sums__t130_compress_ucl_nrv2e_3_no_filter=\"\\\nf817034e8b7765d8b422dac9cb6f24f78ce5bfd7169cd3b33e8224e00b131eca *amd64-linux.elf/upx-3.91\nd21441a05514c085c10e99b00d8cc4d45484297a8e4e8a246364ca4347d0ed56 *amd64-linux.elf/upx-3.95\n7bd7cd37093200fa94d21dd7fdfef4d7fb9c3049fbf5f408f1f242cb8d9c6a55 *amd64-win64.pe/upx-3.95.exe\nd328a89b333d0b36e96d0c61375bf686e8f3b73a188dd4d0df4d78e30af08632 *arm-linux.elf/upx-3.95\nad0a7a18e87657d28260b7c527d284863becd3c5f92259c570125465f88d4042 *arm-wince.pe/upx-3.91.exe\n0b700f0f7dde3118694155e876e6c2003ef701fe94856d6562936ec081278747 *arm64-linux.elf/upx-3.95\n53a1d04fa62e25e64e6f792b079e21b4c42676a73503ae6d9e67ae16c98e6d04 *armeb-linux.elf/upx-3.91\n33ed1e3b84836d2af52295ba0b90343ac0b8d524539ce3b8d0aa9f19a51d70dd *armeb-linux.elf/upx-3.95\n6fcdc8e34ce8b3501db2260c8a921c6e963954fdeffedfefca353a27bcc02d56 *i386-dos32.djgpp2.coff/upx-3.91.exe\n6f4f901c1838252f9b3104060475a6f13a2ebec830096ff28d870148580e4287 *i386-dos32.djgpp2.coff/upx-3.95.exe\n8127f8380300508e8062e9391e321abd0429a6a31fec41e769cc7fe80af27e27 *i386-linux.elf/upx-3.91\nb0a7e6b822f038b7940a54ea160b045d2241e3dfa15a5081a23fbc4d42fb6773 *i386-linux.elf/upx-3.95\nc78db15a8113b806e56812fd842fb467d2a9c9557fcdc0467dae3f4c33316630 *i386-win32.pe/upx-3.91.exe\n89314e8621c4a00e1a65e045686245d3c1e2ba0a858f1dcc8f3cc2d0eedccfb5 *i386-win32.pe/upx-3.95.exe\n710ad88b63cc7e0fa0b413ebdbcebf41140678f551b5dd883ed6220507be3601 *m68k-atari.tos/upx-3.91.ttp\nc7e3478872650b7f4f8ccb4a0649944e62f44f5a9249cb9425210333e1f2fdf4 *mips-linux.elf/upx-3.95\ncd9b3d3780a79cb416b261d622e8e86f2369fa8bb9bc49b529c50cac2980d528 *mipsel-linux.elf/upx-3.91\n5baf7db9e4335c0227106262efc9d18ad23b88c6d6bb636656aea67bb063b6ec *mipsel-linux.elf/upx-3.95\naba8bd826ee52d533f9e1c4270d4f4194fe8d8747ea10a1d3ce59b6443f1a9f2 *powerpc-linux.elf/upx-3.91\n6f737ccbf8c830476bed9c4dd33dd7757ea25bf2f8fb03b44d03e9b77ada0f1b *powerpc-linux.elf/upx-3.95\nd313dd128a54189b9551a529b1ed21b222aa0394a30f9ba552cde96edcd4011e *powerpc64le-linux.elf/upx-3.95\n\"\nexpected_sha256sums__t140_compress_lzma_2_no_filter=\"\\\nfefac6fbd1e95479eb4066519f9bd801a30c29966685840b6a011e2911b984ca *amd64-linux.elf/upx-3.91\n64487a0e0aade092a8ff7e6d8d9528ca550540cac8d432005ba610179782d042 *amd64-linux.elf/upx-3.95\na55ec5a7f2911f6da8b9336daf4f1051e753cfb7a4458c7f7baa6b63340c6daf *amd64-win64.pe/upx-3.95.exe\n9f405739b904bb85053b75187c9175e4ac7f66a07ac5e320eaa4e9771e1ec79e *arm-linux.elf/upx-3.95\n7a6c603eecf214e5d6742f1fce922223c97c8bd2527678a968640dd6c1bc0d71 *arm-wince.pe/upx-3.91.exe\nc8435e2f82ba72a0b6abad4146539d40d495461c5e480af705b2bbd21d192128 *arm64-linux.elf/upx-3.95\n21fc48eaaedc73fe9239159fb864c6149f729ef1661a8407b88ad9c9a19f9a54 *armeb-linux.elf/upx-3.91\n742db587dc53f616c7b276a930c3f586da2b7c3ce6ccd523c041e88a9671b99b *armeb-linux.elf/upx-3.95\n7a8eaa5139b95cc56591200fce62d3c9af163671467952cab6fcf487318107bb *i386-dos32.djgpp2.coff/upx-3.91.exe\n9b5fc0f54a5f811bda190c36fb2fa5c5b03c6c3de0c62693e4191230b5a419b8 *i386-dos32.djgpp2.coff/upx-3.95.exe\n68b4ce63cb0bd7dd5b287e1f9fa5d9bc234ac36359ce3ebff863984c503a698e *i386-linux.elf/upx-3.91\naa75cf22f0b59cc796de678198432a3dc2d40ab871e4989dd97ff1a6c148f294 *i386-linux.elf/upx-3.95\n0e0780f5fccc52f6c78414f7279263b26e31de7c6ca1ec65a240e37cf0a4f5c9 *i386-win32.pe/upx-3.91.exe\n3ddd6265d69e374f5f0f8c9f602e0e59c895da2f3fef611ef89f0ee4ae2c592b *i386-win32.pe/upx-3.95.exe\ne268c98fdacfd04268d76644f2bb4746ae04b57801407aaa1867798840eeeea0 *m68k-atari.tos/upx-3.91.ttp\n499e1d1486810cfa5b6662e30189183979e25f45d35654d8cd60fd793d0c07d8 *mips-linux.elf/upx-3.95\n4a30189ad7312eafb2d47e1b526ec22eaf614a895f8dce96f3e1c7385438f44c *mipsel-linux.elf/upx-3.91\n339d38602413d97d9bba113f39884815af10ebcdccf37e3f5e8d0879f262a048 *mipsel-linux.elf/upx-3.95\n6d4f9d4383ebc9d8411d06a7c219dcf3e8513ea8c989f2d31ab382602f873ba5 *powerpc-linux.elf/upx-3.91\n5dd727d8d5a35cc0ab86d629285d8ff450f52b538118679edaa886ce9c1fed7d *powerpc-linux.elf/upx-3.95\nefec1e5bbb9bcf11dbc7081adfc2020de18fae326ad86194551c44fba0d2148d *powerpc64le-linux.elf/upx-3.95\n\"\nexpected_sha256sums__t150_compress_ucl_2_all_filters=\"\\\n05b29bde32af1e63e837e2be499567c4b10d7e692c88082f24e3417e0c7b9f40 *amd64-linux.elf/upx-3.91\n65c142ee01af09fa8741932c1f21d466be971aad059cc5afddbb7ecdf142c1bb *amd64-linux.elf/upx-3.95\ncbb5c90bd9195bd9e3acd931312a70deeccfab5540f398ceda8826f8d6b332bf *amd64-win64.pe/upx-3.95.exe\n1ea1bb18c0ac85c07450f0a6704b84e58a1322556757e2943340ef381b2ce675 *arm-linux.elf/upx-3.95\n76a5f0518fc797bd3f132ce6eb61ca187b5d463f191417883a73d4584716c23a *arm-wince.pe/upx-3.91.exe\n4df30002376a4f18029ea9dd8260d395bec3a3fa11fbc5aa19859c2f0efdc2e6 *arm64-linux.elf/upx-3.95\nba03fd4889210435c9673f2dcbd2269162037090eccc79cf7d2b896e64a57e2e *armeb-linux.elf/upx-3.91\n681f32d01c76ff31776b8d6f1556daa38eee297f675aa40ff1bb2e47e12adf15 *armeb-linux.elf/upx-3.95\naa05c3a2953f0f2d70842cba45786b707a79ffef22fd084f51e304762cc67765 *i386-dos32.djgpp2.coff/upx-3.91.exe\nc677241e9a8753ba1332ac3875ab6398fb2d792d2627edd9e58f2535b3131abe *i386-dos32.djgpp2.coff/upx-3.95.exe\n7bcd42f58dcc8ddb6cb1a4e33d56b584fe6d49b002b01a0859571d1324dd593a *i386-linux.elf/upx-3.91\nb6fe6220c0b3f4df131da3aaae566810f2aa1f13b63d23de3ead9174d08d82e1 *i386-linux.elf/upx-3.95\n8ec02f816f4727b519e8775edc1afb1df32991319a6c6f050ece416011925379 *i386-win32.pe/upx-3.91.exe\nd5aeeedada49c0c2870ea450ed66b2cea31369bccfccf9407378ae0fb0736deb *i386-win32.pe/upx-3.95.exe\ne414ad0aba43790d0498b26c23055fb051129b6cbe3e070a1406c91ac5b8032b *m68k-atari.tos/upx-3.91.ttp\nc5107a84d32de820c81401259a7dd23435ea625588d56c6c75ad6fa14b0dbf8b *mips-linux.elf/upx-3.95\n78473f7d7ddf56812b8dee087ca62517ecdbd10fa14972ba6670338fc19061d1 *mipsel-linux.elf/upx-3.91\nfd9ea397a29b41a2143f9e02217e181d0075d7ad7d87bdbadc7fc94bfb1b0d76 *mipsel-linux.elf/upx-3.95\nc47d1299f6ecf86e62528fc54979117b2b2ddbb6c80f553689402399fc7eab28 *powerpc-linux.elf/upx-3.91\n77c3b4ba6909a4e20180bc13775e280086d67240519c323c2005f3fcee6e0b78 *powerpc-linux.elf/upx-3.95\ne3ce51b863905a4831958c72541b04e9f893f0d9827f32e615822db7aebd56bc *powerpc64le-linux.elf/upx-3.95\n\"\nexpected_sha256sums__t160_compress_all_methods_1_no_filter=\"\\\n94c91b97fcce7402a4494b22699b2450e8e4e2a9f4ddd66e1133c76ce198c167 *amd64-linux.elf/upx-3.91\n5b3e85adb37919d051c6eaff205b8e1d77a2dfde0d8e7dcdee7c22f8fd5dc8c7 *amd64-linux.elf/upx-3.95\n5a0ecb45658904bcd0b823b77dba039c9814e2eff4ed429784c36b7074b9858c *amd64-win64.pe/upx-3.95.exe\nde93a219ca3c4ea84bd9c1b5fb37ff4aaa0a08ea6eac18da6d7a5865e4dad19c *arm-linux.elf/upx-3.95\nfdbe0395ac401285edb9c2f9bfbb0fbd3c0eaad5052a88d8369b1a66b35a8a3e *arm-wince.pe/upx-3.91.exe\nacdb7ff90d7c6f403872ec333e2987ee74e99d6e1390863b321b528d312c1084 *arm64-linux.elf/upx-3.95\n54860e61da36414dc105aafcdbb86c79b745913a7d0da911fa58a6941f111e2d *armeb-linux.elf/upx-3.91\n7c36b75cc8a0712515e12a9e565df4ca43bff6cc0077afb282d367fcc2ee2acd *armeb-linux.elf/upx-3.95\n0a0099246096d20ff6035a4df6566954b9d8aff9ed8fdbd35aa5ee4995b02bfe *i386-dos32.djgpp2.coff/upx-3.91.exe\n5df7aa9f0896df87eb8798119ad16a9b89c87a7568a67339e33b5baa99ec361f *i386-dos32.djgpp2.coff/upx-3.95.exe\n53e5aae9bc70f58e3dc2aef5a94f66df2517d547670e72ee2b3189b7da809f41 *i386-linux.elf/upx-3.91\nadaa1e2f46f7a235ab838b15aa7e820057e5ed7011d9d07c67dc770a88e3dd62 *i386-linux.elf/upx-3.95\nf3d33c5c9809943a902133490bcf0cfbe39a5ef1635a0c29b3bdc4f35dfffa50 *i386-win32.pe/upx-3.91.exe\n474e68a2390cf0376f59402eaef4c902daa49428b628e025b1c8506428a37937 *i386-win32.pe/upx-3.95.exe\n1561dd69f67e8705804dba41ebd876bce6a4ce8ed8b0bc0d0e7628697e7fee68 *m68k-atari.tos/upx-3.91.ttp\n74f7f69b4a8b2b7c428fa55e3970ee767c1947f19ed1b0644870ecb6b3cb713d *mips-linux.elf/upx-3.95\n12a42365234c001a52586b74a9597dc7d65184ddf1ee1d40734823a3443cd92a *mipsel-linux.elf/upx-3.91\n68f674d081d87e86e54f0051eee9e2bc85b566051992774ab28ff3173cbcb75a *mipsel-linux.elf/upx-3.95\nf569d8f49d7110bb8b262a48055b39d889e9977c40c5f1b21e74f8cbf93b27ae *powerpc-linux.elf/upx-3.91\nd8227a8a88c083760889acaf259e7da59eab75a23e341289bc8e3c60563ae344 *powerpc-linux.elf/upx-3.95\ne4b58ed65025b765953af02e80be9a171c49b6c707c835949b1c888fdbe8bba0 *powerpc64le-linux.elf/upx-3.95\n\"\nexpected_sha256sums__t170_compress_all_methods_no_lzma_5_no_filter=\"\\\n52a39c30b60abb82c1ec2826297eb46abdc29b5dd55d7a7a41dd2fc1c573f60a *amd64-linux.elf/upx-3.91\nf0c728c42e8775767e0d963e1eef7ca78711f3f6dd180df980a1faef926d7cac *amd64-linux.elf/upx-3.95\ne07e9babdeb12fddeebbfa1b0293163cc5e63017d6f0933d02587c8da1e90a82 *amd64-win64.pe/upx-3.95.exe\nf0359efa2247e9ea756f54c85e7518d61f3b293e08f566c3812c64c7d5f0db0f *arm-linux.elf/upx-3.95\n8d1706ab02013b536c3a4cec20d40a96591ffa45fdcb464ccd3f038567006d79 *arm-wince.pe/upx-3.91.exe\n14932490ff17e27bb5bedde576b8683892c4720f4a0058f373aab9f8894fda09 *arm64-linux.elf/upx-3.95\n64a73512e40c2fb49d8ae3a1d496b379c97b8724cf8ca4461a85825ff04366a0 *armeb-linux.elf/upx-3.91\n078e7cd073ba071f17ad4292e2211b7d635f57e974546e7f156cc87f9aa716e2 *armeb-linux.elf/upx-3.95\ndda2c348c43741a1bd65049a8e7b51be1ebf873d215370ec002185c85390c168 *i386-dos32.djgpp2.coff/upx-3.91.exe\n560392427ded22f2f3fea59ef10e55d65cf841001e67b1e4558ef13514baa602 *i386-dos32.djgpp2.coff/upx-3.95.exe\nf3f8feceebe8536633554b204df68c2e94e1d1a313fe7a576b7f5d404c916083 *i386-linux.elf/upx-3.91\ne7f98419e346670f72d66ac25f3d6ad53201e768819980eecae24d801366be27 *i386-linux.elf/upx-3.95\n3510bc5627237752bedd275e73c42bc02cd46145ff916e7bccbdec663f763ee4 *i386-win32.pe/upx-3.91.exe\nad47c7522167f6f7e47d495e1fa119431386ca5ea9bc16b6a4b9cb38cf9cd29f *i386-win32.pe/upx-3.95.exe\n1c999e5c6cded8c99a7f6b4595879893ae63d2af1388dc61dd8b4e3106676480 *m68k-atari.tos/upx-3.91.ttp\n55a098c2cdce1917b76ce0845f434fc23b0bd30b34e884b19401c51c8c7f4756 *mips-linux.elf/upx-3.95\n4b6487d412f43acb8e41951a2135e56025139a9ad3e57102749df4d4bef934fa *mipsel-linux.elf/upx-3.91\n1dcd626fc4566c608e987fd6999b695793c5cae7f78872e3d1a9a23942fea188 *mipsel-linux.elf/upx-3.95\n2047a4a880322bf41e8afbb4787f6103364de4a299b543808251a4144c4d990b *powerpc-linux.elf/upx-3.91\n63679bd238f30bfb14853246eb257536471fea10f942b2adfdd43cbef21dea30 *powerpc-linux.elf/upx-3.95\nc75d1548db879ed589b55bc1319869b49d37595f4560a64b34016951dc02f997 *powerpc64le-linux.elf/upx-3.95\n\"\n########## end .sha256sums.recreate\n","size_bytes":18159},"misc/testsuite/upx_testsuite_1.sh":{"content":"#! /usr/bin/env bash\n## vim:set ts=4 sw=4 et:\nset -e; set -o pipefail\nargv0=$0; argv0abs=$(readlink -fn \"$argv0\"); argv0dir=$(dirname \"$argv0abs\")\n\n#\n# Copyright (C) Markus Franz Xaver Johannes Oberhumer\n#\n# very first version of the upx-testsuite; requires:\n#   $upx_exe                (required, but with convenience fallback \"./upx\")\n#   $upx_testsuite_SRCDIR   (required, but with convenience fallback)\n#   $upx_testsuite_BUILDDIR (optional)\n#\n# optional settings:\n#   $upx_exe_runner         (e.g. \"qemu-x86_64 -cpu Nehalem\" or \"valgrind\")\n#   $UPX_TESTSUITE_VERBOSE\n#   $UPX_TESTSUITE_LEVEL\n#\n# see https://github.com/upx/upx-testsuite.git\n#\n\n#***********************************************************************\n# init & checks\n#***********************************************************************\n\n# upx_exe\n[[ -z $upx_exe && -f ./upx && -x ./upx ]] && upx_exe=./upx # convenience fallback\nif [[ -z $upx_exe ]]; then echo \"UPX-ERROR: please set \\$upx_exe\"; exit 1; fi\nif [[ ! -f $upx_exe ]]; then echo \"UPX-ERROR: file '$upx_exe' does not exist\"; exit 1; fi\nupx_exe=$(readlink -fn \"$upx_exe\") # make absolute\n[[ -f $upx_exe ]] || exit 1\n\n# set emu and run_upx\nemu=()\nif [[ -n $upx_exe_runner ]]; then\n    # usage examples:\n    #   export upx_exe_runner=\"qemu-x86_64 -cpu Nehalem\"\n    #   export upx_exe_runner=\"valgrind --leak-check=no --error-exitcode=1 --quiet\"\n    #   export upx_exe_runner=\"wine\"\n    IFS=' ' read -r -a emu <<< \"$upx_exe_runner\" # split at spaces into array\nelif [[ -n $CMAKE_CROSSCOMPILING_EMULATOR ]]; then\n    IFS=';' read -r -a emu <<< \"$CMAKE_CROSSCOMPILING_EMULATOR\" # split at semicolons into array\nfi\nrun_upx=( \"${emu[@]}\" \"$upx_exe\" )\necho \"run_upx='${run_upx[*]}'\"\n\n# run_upx sanity check\nif ! \"${run_upx[@]}\" --version-short >/dev/null; then echo \"UPX-ERROR: FATAL: upx --version-short FAILED\"; exit 1; fi\nif ! \"${run_upx[@]}\" -L >/dev/null 2>&1; then echo \"UPX-ERROR: FATAL: upx -L FAILED\"; exit 1; fi\nif ! \"${run_upx[@]}\" --help >/dev/null;  then echo \"UPX-ERROR: FATAL: upx --help FAILED\"; exit 1; fi\n\n# upx_testsuite_SRCDIR\nif [[ -z $upx_testsuite_SRCDIR ]]; then\n    # convenience fallback: search standard locations below upx top-level directory\n    if [[                 -d \"$argv0dir/../../../upx--upx-testsuite.git/files/packed\" ]]; then\n        upx_testsuite_SRCDIR=\"$argv0dir/../../../upx--upx-testsuite.git\"\n    elif [[               -d \"$argv0dir/../../../upx-testsuite.git/files/packed\" ]]; then\n        upx_testsuite_SRCDIR=\"$argv0dir/../../../upx-testsuite.git\"\n    elif [[               -d \"$argv0dir/../../../upx-testsuite/files/packed\" ]]; then\n        upx_testsuite_SRCDIR=\"$argv0dir/../../../upx-testsuite\"\n    fi\nfi\nif [[ ! -d \"$upx_testsuite_SRCDIR/files/packed\" ]]; then\n    echo \"invalid or missing \\$upx_testsuite_SRCDIR:\"\n    echo \"  please git clone https://github.com/upx/upx-testsuite.git\"\n    echo \"  and set (export) the envvar upx_testsuite_SRCDIR to the local file path\"\n    exit 1\nfi\nupx_testsuite_SRCDIR=$(readlink -fn \"$upx_testsuite_SRCDIR\") # make absolute\n[[ -d $upx_testsuite_SRCDIR ]] || exit 1\n\n# upx_testsuite_BUILDDIR\nif [[ -z $upx_testsuite_BUILDDIR ]]; then\n    upx_testsuite_BUILDDIR=\"./tmp-upx-testsuite\"\nfi\nmkdir -p \"$upx_testsuite_BUILDDIR\" || exit 1\nupx_testsuite_BUILDDIR=$(readlink -fn \"$upx_testsuite_BUILDDIR\") # make absolute\n[[ -d $upx_testsuite_BUILDDIR ]] || exit 1\ncd / && cd \"$upx_testsuite_BUILDDIR\" || exit 1\n: > ./.mfxnobackup\n\n# run_upx sanity check after \"cd\"\nif ! \"${run_upx[@]}\" --version-short >/dev/null; then\n    echo \"UPX-ERROR: FATAL: upx --version-short FAILED\"\n    echo \"please make sure that \\$upx_exe contains ABSOLUTE file paths and can be run from any directory\"\n    echo \"INFO: run_upx='${run_upx[*]}'\"\n    exit 1\nfi\n\n#***********************************************************************\n# setup\n#***********************************************************************\n\n#set -x # debug\n\nexit_code=0\nnum_errors=0\nall_errors=\n\nexport UPX=\"--prefer-ucl --no-color --no-progress\"\nexport UPX_DEBUG_DISABLE_GITREV_WARNING=1\nexport UPX_DEBUG_DOCTEST_DISABLE=1 # already checked above\n\ncase $UPX_TESTSUITE_LEVEL in\n    [0-8]) ;;\n    *) UPX_TESTSUITE_LEVEL=999 ;;\nesac\nif [[ $UPX_TESTSUITE_LEVEL == 0 ]]; then\n    echo \"UPX testsuite SKIPPED.\"\n    exit 0\nfi\n\nrm -rf ./testsuite_1\nmkdir testsuite_1 || exit 1\ncd testsuite_1 || exit 1\n\n#***********************************************************************\n# support functions\n#***********************************************************************\n\nrun_upx() {\n    local flags=\"--disable-random-id --fake-stub-version=5.01 --fake-stub-year=2025\"\n    local ec=0\n    if [[ $UPX_TESTSUITE_VERBOSE == 1 ]]; then\n        echo \"LOG: '${run_upx[*]}' $*\"\n    fi\n    \"${run_upx[@]}\" $flags \"$@\" || ec=$?\n    if [[ $ec != 0 ]]; then\n        echo \"FATAL: '${run_upx[*]}' $*\"\n        echo \"  (exit code was $ec)\"\n        exit 42\n    fi\n}\n\ntestsuite_header() {\n    local x='==========='; x=\"$x$x$x$x$x$x$x\"\n    echo -e \"\\n${x}\\n${1}\\n${x}\\n\"\n}\n\ntestsuite_split_f() {\n    fd=$(dirname \"$1\")\n    fb=$(basename \"$1\")\n    fsubdir=$(basename \"$fd\")\n    # sanity checks\n    if [[ ! -f $1 || -z $fsubdir || -z $fb ]]; then\n        fd=''; fb=''; fsubdir=''\n    fi\n}\n\ntestsuite_check_sha() {\n    (cd \"$1\" && sha256sum -b [0-9a-zA-Z]*/* | LC_ALL=C sort -k2) > $1/.sha256sums.current\n    echo\n    cat $1/.sha256sums.current\n    if ! cmp -s $1/.sha256sums.expected $1/.sha256sums.current; then\n        echo \"UPX-ERROR: $1 FAILED: checksum mismatch\"\n        diff -u $1/.sha256sums.expected $1/.sha256sums.current || true\n        exit_code=99\n        let num_errors+=1 || true\n        all_errors=\"${all_errors} $1\"\n        #exit 99\n    fi\n    echo\n}\n\ntestsuite_check_sha_decompressed() {\n    (cd \"$1\" && sha256sum -b [0-9a-zA-Z]*/* | LC_ALL=C sort -k2) > $1/.sha256sums.current\n    if ! cmp -s $1/.sha256sums.expected $1/.sha256sums.current; then\n        cat $1/.sha256sums.current\n        echo \"UPX-ERROR: FATAL: $1 FAILED: decompressed checksum mismatch\"\n        diff -u $1/.sha256sums.expected $1/.sha256sums.current || true\n        exit 98\n    fi\n}\n\ntestsuite_use_canonicalized=1\ntestsuite_run_compress() {\n    testsuite_header $testdir\n    local files f\n    if [[ $testsuite_use_canonicalized == 1 ]]; then\n        files='t020_canonicalized/*/*'\n    else\n        files='t010_decompressed/*/*'\n    fi\n    for f in $files; do\n        testsuite_split_f \"$f\"\n        [[ -z $fb ]] && continue\n        echo \"# $f\"\n        mkdir -p \"$testdir/$fsubdir\" \"$testdir/.decompressed/$fsubdir\"\n        run_upx -qq --prefer-ucl \"$@\" \"$f\" -o \"$testdir/$fsubdir/$fb\"\n        run_upx -qq -d \"$testdir/$fsubdir/$fb\" -o \"$testdir/.decompressed/$fsubdir/$fb\"\n    done\n    testsuite_check_sha $testdir\n    run_upx -qq -l \"$testdir\"/*/*\n    run_upx -qq --file-info \"$testdir\"/*/*\n    run_upx -q -t \"$testdir\"/*/*\n    if [[ $testsuite_use_canonicalized == 1 ]]; then\n        # check that after decompression the file matches the canonicalized version\n        cp t020_canonicalized/.sha256sums.expected $testdir/.decompressed/\n        testsuite_check_sha_decompressed $testdir/.decompressed\n        rm -rf \"./$testdir/.decompressed\"\n    fi\n}\n\n#***********************************************************************\n# expected checksums\n#\n# To ease maintenance of this script in case of updates this section\n# can be automatically re-created from the current checksums -\n# see call of function recreate_expected_sha256sums below.\n#***********************************************************************\n\nrecreate_expected_sha256sums() {\n    local o=\"$1\"\n    local files f d\n    echo \"########## begin .sha256sums.recreate\" > \"$o\"\n    files='*/.sha256sums.current'\n    for f in $files; do\n        d=$(dirname \"$f\")\n        echo \"expected_sha256sums__${d}=\"'\"\\' >> \"$o\"\n        cat \"$f\" >> \"$o\"\n        echo '\"' >> \"$o\"\n    done\n    echo \"########## end .sha256sums.recreate\" >> \"$o\"\n}\n\nsource \"$argv0dir/upx_testsuite_1-expected_sha256sums.sh\" || exit 1\n\n#***********************************************************************\n# decompression tests\n#***********************************************************************\n\ntestdir=t010_decompressed\nmkdir $testdir; v=expected_sha256sums__$testdir; echo -n \"${!v}\" >$testdir/.sha256sums.expected\n\ntestsuite_header $testdir\nfor f in \"$upx_testsuite_SRCDIR\"/files/packed/*/upx-3.9[15]*; do\n    testsuite_split_f \"$f\"\n    [[ -z $fb ]] && continue\n    echo \"# $f\"\n    mkdir -p \"$testdir/$fsubdir\"\n    run_upx -qq -d \"$f\" -o \"$testdir/$fsubdir/$fb\"\ndone\ntestsuite_check_sha $testdir\n\n# run one pack+unpack step to canonicalize the files\ntestdir=t020_canonicalized\nmkdir $testdir; v=expected_sha256sums__$testdir; echo -n \"${!v}\" >$testdir/.sha256sums.expected\n\ntestsuite_header $testdir\nfor f in t010_decompressed/*/*; do\n    testsuite_split_f \"$f\"\n    [[ -z $fb ]] && continue\n    echo \"# $f\"\n    mkdir -p \"$testdir/$fsubdir/.packed\"\n    run_upx -qq --prefer-ucl -1 \"$f\" -o \"$testdir/$fsubdir/.packed/$fb\"\n    run_upx -qq -d \"$testdir/$fsubdir/.packed/$fb\" -o \"$testdir/$fsubdir/$fb\"\ndone\ntestsuite_check_sha $testdir\n\n#***********************************************************************\n# compression tests\n# info: we use fast compression levels because we want to\n#   test UPX and not the compression libraries\n#***********************************************************************\n\nif [[ $UPX_TESTSUITE_LEVEL -ge 2 ]]; then\ntestdir=t110_compress_ucl_nrv2b_3_no_filter\nmkdir $testdir; v=expected_sha256sums__$testdir; echo -n \"${!v}\" >$testdir/.sha256sums.expected\ntime testsuite_run_compress --nrv2b -3 --no-filter\nfi\n\nif [[ $UPX_TESTSUITE_LEVEL -ge 3 ]]; then\ntestdir=t120_compress_ucl_nrv2d_3_no_filter\nmkdir $testdir; v=expected_sha256sums__$testdir; echo -n \"${!v}\" >$testdir/.sha256sums.expected\ntime testsuite_run_compress --nrv2d -3 --no-filter\nfi\n\nif [[ $UPX_TESTSUITE_LEVEL -ge 4 ]]; then\ntestdir=t130_compress_ucl_nrv2e_3_no_filter\nmkdir $testdir; v=expected_sha256sums__$testdir; echo -n \"${!v}\" >$testdir/.sha256sums.expected\ntime testsuite_run_compress --nrv2e -3 --no-filter\nfi\n\nif [[ $UPX_TESTSUITE_LEVEL -ge 5 ]]; then\ntestdir=t140_compress_lzma_2_no_filter\nmkdir $testdir; v=expected_sha256sums__$testdir; echo -n \"${!v}\" >$testdir/.sha256sums.expected\ntime testsuite_run_compress --lzma -2 --no-filter\nfi\n\nif [[ $UPX_TESTSUITE_LEVEL -ge 6 ]]; then\ntestdir=t150_compress_ucl_2_all_filters\nmkdir $testdir; v=expected_sha256sums__$testdir; echo -n \"${!v}\" >$testdir/.sha256sums.expected\ntime testsuite_run_compress -2 --all-filters\nfi\n\nif [[ $UPX_TESTSUITE_LEVEL -ge 7 ]]; then\ntestdir=t160_compress_all_methods_1_no_filter\nmkdir $testdir; v=expected_sha256sums__$testdir; echo -n \"${!v}\" >$testdir/.sha256sums.expected\ntime testsuite_run_compress --all-methods -1 --no-filter\nfi\n\nif [[ $UPX_TESTSUITE_LEVEL -ge 8 ]]; then\ntestdir=t170_compress_all_methods_no_lzma_5_no_filter\nmkdir $testdir; v=expected_sha256sums__$testdir; echo -n \"${!v}\" >$testdir/.sha256sums.expected\ntime testsuite_run_compress --all-methods --no-lzma -5 --no-filter\nfi\n\n#***********************************************************************\n# summary\n#***********************************************************************\n\n# recreate checksums from current version for an easy update in case of changes\nrecreate_expected_sha256sums .sha256sums.recreate\n\ntestsuite_header \"UPX testsuite summary: level $UPX_TESTSUITE_LEVEL\"\nrun_upx --version-short\necho\necho \"upx_exe='$upx_exe'\"\nls -l \"$upx_exe\"\nif command -v file >/dev/null; then\n    file \"$upx_exe\" || true\nfi\necho \"run_upx='${run_upx[*]}'\"\necho \"upx_testsuite_SRCDIR='$upx_testsuite_SRCDIR'\"\necho \"upx_testsuite_BUILDDIR='$upx_testsuite_BUILDDIR'\"\necho \".sha256sums.{expected,current} counts:\"\ncat ./*/.sha256sums.expected | LC_ALL=C sort | wc\ncat ./*/.sha256sums.current  | LC_ALL=C sort | wc\necho\nif [[ $exit_code == 0 ]]; then\n    echo \"UPX testsuite passed. All done.\"\nelse\n    echo \"UPX-ERROR: UPX testsuite FAILED:${all_errors}\"\n    echo \"UPX-ERROR: UPX testsuite FAILED with $num_errors error(s). See log file.\"\nfi\nexit $exit_code\n","size_bytes":12063},"src/check/dt_check.cpp":{"content":"/* dt_check.cpp -- doctest check\n\n   This file is part of the Resize executable compressor.\n\n   Copyright (C) 2025 WHO-AM-I-404\n   Based on UPX - Ultimate Packer for eXecutables\n   Copyright (C) 1996-2025 Markus Franz Xaver Johannes Oberhumer\n   All Rights Reserved.\n\n   Resize and the UCL library are free software; you can redistribute them\n   and/or modify them under the terms of the GNU General Public License as\n   published by the Free Software Foundation; either version 2 of\n   the License, or (at your option) any later version.\n\n   This program is distributed in the hope that it will be useful,\n   but WITHOUT ANY WARRANTY; without even the implied warranty of\n   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n   GNU General Public License for more details.\n\n   You should have received a copy of the GNU General Public License\n   along with this program; see the file COPYING.\n   If not, write to the Free Software Foundation, Inc.,\n   59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.\n\n   Markus F.X.J. Oberhumer\n   <markus@oberhumer.com>\n */\n\n// doctest checks, and various tests to catch toolchain/qemu/sanitizer/valgrind/wine/etc\n// problems; grown historically; modern compilers will optimize away much of this code\n\n#include \"../util/system_headers.h\"\n#include <cmath> // std::isinf std::isnan\n#include \"../conf.h\"\n\n/*************************************************************************\n// upx_doctest_check()\n//\n// honors environment variables:\n//   UPX_DEBUG_DOCTEST_DISABLE\n//   UPX_DEBUG_DOCTEST_VERBOSE\n//\n// HINT: set \"UPX_DEBUG_DOCTEST_DISABLE=1\" for improved debugging experience\n**************************************************************************/\n\nint upx_doctest_check(int argc, char **argv) {\n#if defined(DOCTEST_CONFIG_DISABLE)\n    UNUSED(argc);\n    UNUSED(argv);\n    return 0;\n#else\n    if (is_envvar_true(\"UPX_DEBUG_DOCTEST_DISABLE\", \"UPX_DEBUG_DISABLE_DOCTEST\"))\n        return 0;\n    bool minimal = true;   // don't show summary\n    bool duration = false; // don't show timings\n    bool success = false;  // don't show all succeeding tests\n#if DEBUG\n    // default for debug builds: do show the [doctest] summary\n    minimal = false;\n#endif\n    const char *e = upx_getenv(\"UPX_DEBUG_DOCTEST_VERBOSE\");\n    if (e && e[0]) {\n        if (strcmp(e, \"0\") == 0) {\n            minimal = true;\n        } else if (strcmp(e, \"1\") == 0) {\n            minimal = false;\n        } else if (strcmp(e, \"2\") == 0) {\n            minimal = false;\n            duration = true;\n        } else if (strcmp(e, \"3\") == 0) {\n            minimal = false;\n            duration = true;\n            success = true;\n        }\n    }\n    doctest::Context context;\n    if (minimal)\n        context.setOption(\"dt-minimal\", true);\n    if (duration)\n        context.setOption(\"dt-duration\", true);\n    if (success)\n        context.setOption(\"dt-success\", true);\n    // this requires that main_get_options() understands/ignores doctest \"--dt-XXX\" options\n    if (argc > 0 && argv != nullptr)\n        context.applyCommandLine(argc, argv);\n    int r = context.run();\n    if (r != 0)\n        return 1;\n    if (context.shouldExit())\n        return 2;\n    return 0;\n#endif // DOCTEST_CONFIG_DISABLE\n}\n\nint upx_doctest_check() { return upx_doctest_check(0, nullptr); }\n\n/*************************************************************************\n// check fundamental types\n**************************************************************************/\n\nstatic_assert(std::is_integral<ptrdiff_t>::value, \"\");\nstatic_assert(std::is_integral<size_t>::value, \"\");\nstatic_assert(std::is_integral<intptr_t>::value, \"\");\nstatic_assert(std::is_integral<uintptr_t>::value, \"\");\n\nstatic_assert(std::is_signed<ptrdiff_t>::value, \"\");\nstatic_assert(!std::is_signed<size_t>::value, \"\");\nstatic_assert(std::is_signed<intptr_t>::value, \"\");\nstatic_assert(!std::is_signed<uintptr_t>::value, \"\");\n\nstatic_assert(!std::is_unsigned<ptrdiff_t>::value, \"\");\nstatic_assert(std::is_unsigned<size_t>::value, \"\");\nstatic_assert(!std::is_unsigned<intptr_t>::value, \"\");\nstatic_assert(std::is_unsigned<uintptr_t>::value, \"\");\n\n#if defined(__SIZEOF_SHORT__)\nstatic_assert(sizeof(short) == __SIZEOF_SHORT__, \"\");\n#endif\n#if defined(__SIZEOF_INT__)\nstatic_assert(sizeof(int) == __SIZEOF_INT__, \"\");\n#endif\n#if defined(__SIZEOF_LONG__)\nstatic_assert(sizeof(long) == __SIZEOF_LONG__, \"\");\n#endif\n#if defined(__SIZEOF_LONG_LONG__)\nstatic_assert(sizeof(long long) == __SIZEOF_LONG_LONG__, \"\");\n#endif\n#if defined(__SIZEOF_INT128__)\nstatic_assert(16 == __SIZEOF_INT128__, \"\");\nstatic_assert(sizeof(__int128) == __SIZEOF_INT128__, \"\");\nstatic_assert(sizeof(unsigned __int128) == __SIZEOF_INT128__, \"\");\nstatic_assert(sizeof(upx_int128_t) == __SIZEOF_INT128__, \"\");\nstatic_assert(sizeof(upx_uint128_t) == __SIZEOF_INT128__, \"\");\n#endif\n#if defined(__SIZEOF_PTRDIFF_T__)\nstatic_assert(sizeof(ptrdiff_t) == __SIZEOF_PTRDIFF_T__, \"\");\n#endif\n#if defined(__SIZEOF_SIZE_T__)\nstatic_assert(sizeof(size_t) == __SIZEOF_SIZE_T__, \"\");\n#endif\n#if defined(__SIZEOF_POINTER__)\nstatic_assert(sizeof(void *) == __SIZEOF_POINTER__, \"\");\nstatic_assert(sizeof(intptr_t) == __SIZEOF_POINTER__, \"\");\nstatic_assert(sizeof(uintptr_t) == __SIZEOF_POINTER__, \"\");\n#endif\n#if defined(__SIZEOF_PTRADDR_T__)\nstatic_assert(sizeof(__PTRADDR_TYPE__) == __SIZEOF_PTRADDR_T__, \"\");\nstatic_assert(sizeof(upx_ptraddr_t) == __SIZEOF_PTRADDR_T__, \"\");\n#endif\n\n#if defined(__SCHAR_WIDTH__)\nstatic_assert(8 * sizeof(signed char) == __SCHAR_WIDTH__, \"\");\n#endif\n#if defined(__SHRT_WIDTH__)\nstatic_assert(8 * sizeof(short) == __SHRT_WIDTH__, \"\");\n#endif\n#if defined(__INT_WIDTH__)\nstatic_assert(8 * sizeof(int) == __INT_WIDTH__, \"\");\n#endif\n#if defined(__LONG_WIDTH__)\nstatic_assert(8 * sizeof(long) == __LONG_WIDTH__, \"\");\n#endif\n#if defined(__LLONG_WIDTH__)\nstatic_assert(8 * sizeof(long long) == __LLONG_WIDTH__, \"\");\n#endif\n#if defined(__INTMAX_WIDTH__)\nstatic_assert(8 * sizeof(intmax_t) == __INTMAX_WIDTH__, \"\");\nstatic_assert(8 * sizeof(uintmax_t) == __INTMAX_WIDTH__, \"\");\n#endif\n#if defined(__PTRDIFF_WIDTH__)\nstatic_assert(8 * sizeof(ptrdiff_t) == __PTRDIFF_WIDTH__, \"\");\n#endif\n#if defined(__SIZE_WIDTH__)\nstatic_assert(8 * sizeof(size_t) == __SIZE_WIDTH__, \"\");\n#endif\n#if defined(__INTPTR_WIDTH__)\nstatic_assert(8 * sizeof(intptr_t) == __INTPTR_WIDTH__, \"\");\nstatic_assert(8 * sizeof(uintptr_t) == __INTPTR_WIDTH__, \"\");\n#endif\n#if defined(__UINTPTR_WIDTH__)\nstatic_assert(8 * sizeof(intptr_t) == __UINTPTR_WIDTH__, \"\");\nstatic_assert(8 * sizeof(uintptr_t) == __UINTPTR_WIDTH__, \"\");\n#endif\n#if defined(__PTRADDR_WIDTH__)\nstatic_assert(8 * sizeof(__PTRADDR_TYPE__) == __PTRADDR_WIDTH__, \"\");\nstatic_assert(8 * sizeof(upx_ptraddr_t) == __PTRADDR_WIDTH__, \"\");\n#endif\n\n// true types from compiler\ntypedef decltype((const char *) nullptr - (const char *) nullptr) true_ptrdiff_t;\ntypedef decltype(sizeof(0)) true_size_t;\n\n// expected types from pre-defined macros\n#if defined(__PTRDIFF_TYPE__)\ntypedef __PTRDIFF_TYPE__ expected_ptrdiff_t;\n#endif\n#if defined(__SIZE_TYPE__)\ntypedef __SIZE_TYPE__ expected_size_t;\n#endif\n#if defined(__INTPTR_TYPE__)\ntypedef __INTPTR_TYPE__ expected_intptr_t;\n#endif\n#if defined(__UINTPTR_TYPE__)\ntypedef __UINTPTR_TYPE__ expected_uintptr_t;\n#endif\n#if defined(__PTRADDR_TYPE__)\ntypedef __PTRADDR_TYPE__ expected_ptraddr_t;\n#endif\n\n#define ASSERT_COMPATIBLE_TYPE(A, B)                                                               \\\n    static_assert(std::is_integral<A>::value, \"\");                                                 \\\n    static_assert(std::is_integral<B>::value, \"\");                                                 \\\n    static_assert(std::is_signed<A>::value == std::is_signed<B>::value, \"\");                       \\\n    static_assert(std::is_unsigned<A>::value == std::is_unsigned<B>::value, \"\");                   \\\n    static_assert(std::is_signed<A>::value == !std::is_unsigned<A>::value, \"\");                    \\\n    static_assert(std::is_signed<B>::value == !std::is_unsigned<B>::value, \"\");                    \\\n    static_assert(sizeof(A) == sizeof(B), \"\");                                                     \\\n    static_assert(alignof(A) == alignof(B), \"\")\n\n#define ASSERT_SAME_TYPE(A, B)                                                                     \\\n    ASSERT_COMPATIBLE_TYPE(A, B);                                                                  \\\n    static_assert(std::is_same<A, B>::value, \"\")\n\n// C vs C++ headers\nASSERT_SAME_TYPE(ptrdiff_t, std::ptrdiff_t);\nASSERT_SAME_TYPE(size_t, std::size_t);\nASSERT_SAME_TYPE(intptr_t, std::intptr_t);\nASSERT_SAME_TYPE(uintptr_t, std::uintptr_t);\n\n// true types\nASSERT_SAME_TYPE(ptrdiff_t, true_ptrdiff_t);\nASSERT_SAME_TYPE(size_t, true_size_t);\n#if __cplusplus >= 201103L\ntypedef decltype(nullptr) true_nullptr_t;\nstatic_assert(std::is_same<std::nullptr_t, true_nullptr_t>::value, \"\");\n#endif\n\n// expected types\n#if defined(__PTRDIFF_TYPE__)\nstatic_assert(std::is_signed<expected_ptrdiff_t>::value, \"\");\nASSERT_SAME_TYPE(ptrdiff_t, expected_ptrdiff_t);\n#endif\n#if defined(__SIZE_TYPE__)\nstatic_assert(std::is_unsigned<expected_size_t>::value, \"\");\nASSERT_SAME_TYPE(size_t, expected_size_t);\n#endif\n#if defined(__INTPTR_TYPE__)\nstatic_assert(std::is_signed<expected_intptr_t>::value, \"\");\nASSERT_COMPATIBLE_TYPE(intptr_t, expected_intptr_t); // some toolchains are buggy\n#endif\n#if defined(__UINTPTR_TYPE__)\nstatic_assert(std::is_unsigned<expected_uintptr_t>::value, \"\");\nASSERT_COMPATIBLE_TYPE(uintptr_t, expected_uintptr_t); // some toolchains are buggy\n#endif\n#if defined(__PTRADDR_TYPE__)\nstatic_assert(std::is_unsigned<expected_ptraddr_t>::value, \"\");\nASSERT_SAME_TYPE(upx_ptraddr_t, expected_ptraddr_t);\n#endif\n\n// UPX types\nASSERT_SAME_TYPE(signed char, upx_int8_t);\nASSERT_SAME_TYPE(unsigned char, upx_uint8_t);\nASSERT_SAME_TYPE(short, upx_int16_t);\nASSERT_SAME_TYPE(unsigned short, upx_uint16_t);\nASSERT_SAME_TYPE(int, upx_int32_t);\nASSERT_SAME_TYPE(unsigned, upx_uint32_t);\n#if (__SIZEOF_LONG_LONG__ + 0 < 128)\nASSERT_SAME_TYPE(long long, upx_int64_t);\nASSERT_SAME_TYPE(unsigned long long, upx_uint64_t);\n#endif\n\n/*************************************************************************\n// compile-time checks\n**************************************************************************/\n\nstatic_assert(no_bswap16(0x04030201) == 0x0201);\nstatic_assert(no_bswap32(0x04030201) == 0x04030201);\nstatic_assert(no_bswap64(0x0807060504030201ull) == 0x0807060504030201ull);\n#if !(ACC_CC_MSC) || defined(upx_is_constant_evaluated)\nstatic_assert(bswap16(0x04030201) == 0x0102);\nstatic_assert(bswap32(0x04030201) == 0x01020304);\nstatic_assert(bswap64(0x0807060504030201ull) == 0x0102030405060708ull);\nstatic_assert(bswap16(bswap16(0xf4f3f2f1)) == no_bswap16(0xf4f3f2f1));\nstatic_assert(bswap32(bswap32(0xf4f3f2f1)) == no_bswap32(0xf4f3f2f1));\nstatic_assert(bswap64(bswap64(0xf8f7f6f5f4f3f2f1ull)) == no_bswap64(0xf8f7f6f5f4f3f2f1ull));\n#endif\n\nstatic_assert(sign_extend32(0u + 0, 8) == 0);\nstatic_assert(sign_extend32(0u + 1, 8) == 1);\nstatic_assert(sign_extend32(0u + 127, 8) == 127);\nstatic_assert(sign_extend32(0u + 128, 8) == -128);\nstatic_assert(sign_extend32(0u - 1, 8) == -1);\nstatic_assert(sign_extend32(0u + 256, 8) == 0);\nstatic_assert(sign_extend32(0u + 257, 8) == 1);\nstatic_assert(sign_extend32(0u + 383, 8) == 127);\nstatic_assert(sign_extend32(0u + 384, 8) == -128);\nstatic_assert(sign_extend32(0u + 511, 8) == -1);\nstatic_assert(sign_extend64(upx_uint64_t(0) + 0, 1) == 0);\nstatic_assert(sign_extend64(upx_uint64_t(0) + 1, 1) == -1);\n\nstatic_assert(CHAR_BIT == 8);\n#if 0 // does not work with MSVC\n#if '\\0' - 1 < 0\nstatic_assert(CHAR_MAX == 127);\n#else\nstatic_assert(CHAR_MAX == 255);\n#endif\n#if L'\\0' - 1 < 0\nstatic_assert((wchar_t) -1 < 0);\n#else\nstatic_assert((wchar_t) -1 > 0);\n#endif\n#endif\n\n/*************************************************************************\n// upx_compiler_sanity_check()\n// assert a sane architecture and compiler\n**************************************************************************/\n\nnamespace {\n\ntemplate <class T>\nstruct CheckIntegral {\n    static_assert(upx_is_integral<T>::value);\n    static_assert(upx_is_integral_v<T>);\n    struct TestT {\n        T a;\n        T x[2];\n    };\n    template <class U>\n    struct TestU {\n        U a = {};\n        const U b = {};\n        static constexpr U c = {};\n        U x[2] = {};\n        const U y[2] = {};\n        static constexpr U z[2] = {};\n    };\n    template <class U>\n    static void checkU(void) noexcept {\n        {\n            U a = {};\n            const U b = {};\n            constexpr U c = {};\n            U x[2] = {};\n            const U y[2] = {};\n            constexpr U z[2] = {};\n            assert_noexcept(a == 0);\n            assert_noexcept(b == 0);\n            assert_noexcept(c == 0);\n            assert_noexcept(x[0] == 0 && x[1] == 0);\n            assert_noexcept(y[0] == 0 && y[1] == 0);\n            assert_noexcept(z[0] == 0 && z[1] == 0);\n#if defined(upx_is_constant_evaluated)\n            static_assert(c == 0);\n            static_assert(z[0] == 0 && z[1] == 0);\n#endif\n        }\n        {\n            TestU<U> t;\n            assert_noexcept(t.a == 0);\n            assert_noexcept(t.b == 0);\n            assert_noexcept(t.c == 0);\n            assert_noexcept(t.x[0] == 0 && t.x[1] == 0);\n            assert_noexcept(t.y[0] == 0 && t.y[1] == 0);\n            assert_noexcept(t.z[0] == 0 && t.z[1] == 0);\n        }\n#if __cplusplus <= 201703L\n        static_assert(std::is_pod<U>::value); // std::is_pod is deprecated in C++20\n#endif\n        static_assert(std::is_standard_layout<U>::value);\n        static_assert(std::is_trivial<U>::value);\n        // more checks, these are probably implied by std::is_trivial\n        static_assert(std::is_nothrow_default_constructible<U>::value);\n        static_assert(std::is_nothrow_destructible<U>::value);\n        static_assert(std::is_trivially_copyable<U>::value);\n        static_assert(std::is_trivially_default_constructible<U>::value);\n        // UPX extras\n        static_assert(upx_is_integral<U>::value);\n        static_assert(upx_is_integral_v<U>);\n    }\n    static void check_core(void) noexcept {\n        {\n            TestT t = {};\n            assert_noexcept(t.a == 0);\n            assert_noexcept(t.x[0] == 0 && t.x[1] == 0);\n        }\n        {\n            const TestT t = {};\n            assert_noexcept(t.a == 0);\n            assert_noexcept(t.x[0] == 0 && t.x[1] == 0);\n        }\n        {\n            constexpr TestT t = {};\n            assert_noexcept(t.a == 0);\n            assert_noexcept(t.x[0] == 0 && t.x[1] == 0);\n        }\n        {\n            TestT t;\n            mem_clear(&t);\n            assert_noexcept(t.a == 0);\n            assert_noexcept(t.x[0] == 0 && t.x[1] == 0);\n        }\n        checkU<T>();\n        checkU<typename std::add_const<T>::type>();\n        {\n            T zero, one, three, four;\n            zero = 0;\n            one = 1;\n            three = 3;\n            four = 4;\n            assert_noexcept(zero == 0);\n            assert_noexcept(one == 1);\n            assert_noexcept(three == 3);\n            assert_noexcept(four == 4);\n            // min / max\n            assert_noexcept(upx::min(one, four) == 1);\n            assert_noexcept(upx::min(one, four) == one);\n            assert_noexcept(upx::max(one, four) == 4);\n            assert_noexcept(upx::max(one, four) == four);\n        }\n    }\n    static void check(void) noexcept {\n        check_core();\n        {\n            T zero, one, three, four;\n            zero = 0;\n            one = 1;\n            three = 3;\n            four = 4;\n            // align - needs binary expressions which do not work\n            // on CHERI uintptr_t because of pointer provenance\n            assert_noexcept(upx::align_down(zero, four) == 0);\n            assert_noexcept(upx::align_down(zero, four) == zero);\n            assert_noexcept(upx::align_down(one, four) == 0);\n            assert_noexcept(upx::align_down(one, four) == zero);\n            assert_noexcept(upx::align_down(three, four) == 0);\n            assert_noexcept(upx::align_down(three, four) == zero);\n            assert_noexcept(upx::align_down(four, four) == 4);\n            assert_noexcept(upx::align_down(four, four) == four);\n            assert_noexcept(upx::align_up(zero, four) == 0);\n            assert_noexcept(upx::align_up(zero, four) == zero);\n            assert_noexcept(upx::align_up(one, four) == 4);\n            assert_noexcept(upx::align_up(one, four) == four);\n            assert_noexcept(upx::align_up(three, four) == 4);\n            assert_noexcept(upx::align_up(three, four) == four);\n            assert_noexcept(upx::align_up(four, four) == 4);\n            assert_noexcept(upx::align_up(four, four) == four);\n            assert_noexcept(upx::align_up_gap(zero, four) == 0);\n            assert_noexcept(upx::align_up_gap(zero, four) == zero);\n            assert_noexcept(upx::align_up_gap(one, four) == 3);\n            assert_noexcept(upx::align_up_gap(one, four) == three);\n            assert_noexcept(upx::align_up_gap(three, four) == 1);\n            assert_noexcept(upx::align_up_gap(three, four) == one);\n            assert_noexcept(upx::align_up_gap(four, four) == 0);\n            assert_noexcept(upx::align_up_gap(four, four) == zero);\n        }\n    }\n};\n\ntemplate <class T>\nstruct CheckAlignment {\n    static void check(void) noexcept {\n        COMPILE_TIME_ASSERT_ALIGNED1(T)\n        struct alignas(1) Test1 {\n            char a;\n            T b;\n        };\n        struct alignas(1) Test2 {\n            char a;\n            T b[3];\n        };\n        COMPILE_TIME_ASSERT_ALIGNED1(Test1)\n        COMPILE_TIME_ASSERT_ALIGNED1(Test2)\n        Test1 t1[7];\n        Test2 t2[7];\n        static_assert(sizeof(Test1) == 1 + sizeof(T));\n        static_assert(sizeof(t1) == 7 + 7 * sizeof(T));\n        static_assert(sizeof(Test2) == 1 + 3 * sizeof(T));\n        static_assert(sizeof(t2) == 7 + 21 * sizeof(T));\n        UNUSED(t1);\n        UNUSED(t2);\n    }\n};\n\ntemplate <class T>\nstruct TestBELE {\n    static noinline bool test(void) noexcept {\n        static_assert(upx::is_same_any_v<T, BE16, BE32, BE64, LE16, LE32, LE64>);\n        static_assert(\n            upx::is_same_any_v<typename T::integral_conversion_type, upx_uint32_t, upx_uint64_t>);\n        CheckIntegral<T>::check();\n        CheckAlignment<T>::check();\n        // arithmetic checks\n        {\n            T all_bits = {}; // == zero\n            assert_noexcept(all_bits == 0);\n            assert_noexcept(!upx::has_single_bit(all_bits));\n            all_bits += 1;\n            assert_noexcept(upx::has_single_bit(all_bits));\n            all_bits -= 2;\n            assert_noexcept(!upx::has_single_bit(all_bits));\n            T v1;\n            v1 = 1;\n            v1 *= 4;\n            v1 /= 2;\n            v1 -= 1;\n            T v2;\n            v2 = 1;\n            assert_noexcept((v1 == v2));\n            assert_noexcept(!(v1 != v2));\n            assert_noexcept((v1 <= v2));\n            assert_noexcept((v1 >= v2));\n            assert_noexcept(!(v1 < v2));\n            assert_noexcept(!(v1 > v2));\n            v2 ^= all_bits;\n            assert_noexcept(!(v1 == v2));\n            assert_noexcept((v1 != v2));\n            assert_noexcept((v1 <= v2));\n            assert_noexcept(!(v1 >= v2));\n            assert_noexcept((v1 < v2));\n            assert_noexcept(!(v1 > v2));\n            v2 += 2;\n            assert_noexcept(v1 == 1);\n            assert_noexcept(v2 == 0);\n            v1 <<= 1;\n            v1 |= v2;\n            v1 >>= 1;\n            v2 &= v1;\n            v2 /= v1;\n            v2 *= v1;\n            v1 += v2;\n            v1 -= v2;\n            assert_noexcept(v1 == 1);\n            assert_noexcept(v2 == 0);\n            if ((v1 ^ v2) != 1)\n                return false;\n        }\n        // min/max\n        {\n            constexpr T a = {}; // == zero\n            typedef typename T::integral_conversion_type U;\n            constexpr U b = 1;\n            assert_noexcept(upx::min(a, a) == 0);\n            assert_noexcept(upx::min(a, a) == a);\n            assert_noexcept(upx::min(a, b) == 0);\n            assert_noexcept(upx::min(a, b) == a);\n            assert_noexcept(upx::min(b, a) == 0);\n            assert_noexcept(upx::min(b, a) == a);\n            assert_noexcept(upx::min(b, b) == 1);\n            assert_noexcept(upx::min(b, b) == b);\n            assert_noexcept(upx::max(a, a) == 0);\n            assert_noexcept(upx::max(a, a) == a);\n            assert_noexcept(upx::max(a, b) == 1);\n            assert_noexcept(upx::max(a, b) == b);\n            assert_noexcept(upx::max(b, a) == 1);\n            assert_noexcept(upx::max(b, a) == b);\n            assert_noexcept(upx::max(b, b) == 1);\n            assert_noexcept(upx::max(b, b) == b);\n            T minus_one_t = {}, minus_two_t = {};\n            minus_one_t -= 1;\n            minus_two_t -= 2;\n            const U minus_one_u = minus_one_t;\n            const U minus_two_u = minus_two_t;\n            assert_noexcept(upx::min(minus_one_t, minus_one_t) == minus_one_t);\n            assert_noexcept(upx::min(minus_one_t, minus_one_t) == minus_one_u);\n            assert_noexcept(upx::min(minus_one_u, minus_one_t) == minus_one_t);\n            assert_noexcept(upx::min(minus_one_u, minus_one_t) == minus_one_u);\n            assert_noexcept(upx::min(minus_one_t, minus_one_u) == minus_one_t);\n            assert_noexcept(upx::min(minus_one_t, minus_one_u) == minus_one_u);\n            assert_noexcept(upx::min(minus_two_t, minus_one_t) == minus_two_t);\n            assert_noexcept(upx::min(minus_two_t, minus_one_t) == minus_two_u);\n            assert_noexcept(upx::min(minus_two_u, minus_one_t) == minus_two_t);\n            assert_noexcept(upx::min(minus_two_u, minus_one_t) == minus_two_u);\n            assert_noexcept(upx::min(minus_two_t, minus_one_u) == minus_two_t);\n            assert_noexcept(upx::min(minus_two_t, minus_one_u) == minus_two_u);\n            assert_noexcept(upx::min(minus_one_t, minus_two_t) == minus_two_t);\n            assert_noexcept(upx::min(minus_one_t, minus_two_t) == minus_two_u);\n            assert_noexcept(upx::min(minus_one_u, minus_two_t) == minus_two_t);\n            assert_noexcept(upx::min(minus_one_u, minus_two_t) == minus_two_u);\n            assert_noexcept(upx::min(minus_one_t, minus_two_u) == minus_two_t);\n            assert_noexcept(upx::min(minus_one_t, minus_two_u) == minus_two_u);\n            assert_noexcept(upx::max(minus_one_t, minus_one_t) == minus_one_t);\n            assert_noexcept(upx::max(minus_one_t, minus_one_t) == minus_one_u);\n            assert_noexcept(upx::max(minus_one_u, minus_one_t) == minus_one_t);\n            assert_noexcept(upx::max(minus_one_u, minus_one_t) == minus_one_u);\n            assert_noexcept(upx::max(minus_one_t, minus_one_u) == minus_one_t);\n            assert_noexcept(upx::max(minus_one_t, minus_one_u) == minus_one_u);\n            assert_noexcept(upx::max(minus_two_t, minus_one_t) == minus_one_t);\n            assert_noexcept(upx::max(minus_two_t, minus_one_t) == minus_one_u);\n            assert_noexcept(upx::max(minus_two_u, minus_one_t) == minus_one_t);\n            assert_noexcept(upx::max(minus_two_u, minus_one_t) == minus_one_u);\n            assert_noexcept(upx::max(minus_two_t, minus_one_u) == minus_one_t);\n            assert_noexcept(upx::max(minus_two_t, minus_one_u) == minus_one_u);\n            assert_noexcept(upx::max(minus_one_t, minus_two_t) == minus_one_t);\n            assert_noexcept(upx::max(minus_one_t, minus_two_t) == minus_one_u);\n            assert_noexcept(upx::max(minus_one_u, minus_two_t) == minus_one_t);\n            assert_noexcept(upx::max(minus_one_u, minus_two_t) == minus_one_u);\n            assert_noexcept(upx::max(minus_one_t, minus_two_u) == minus_one_t);\n            assert_noexcept(upx::max(minus_one_t, minus_two_u) == minus_one_u);\n        }\n        // constexpr\n        {\n            constexpr T zero = {};\n            constexpr T zero_copy = T::make(zero);\n            assert_noexcept(zero_copy == 0);\n            assert_noexcept(!upx::has_single_bit(zero));\n#if defined(upx_is_constant_evaluated)\n            static_assert(zero_copy == 0);\n            static_assert(zero_copy == zero);\n            static_assert(!upx::has_single_bit(zero));\n            static_assert(!upx::has_single_bit(zero_copy));\n#endif\n        }\n#if defined(upx_is_constant_evaluated)\n        {\n            typedef typename T::integral_conversion_type U;\n            constexpr T one = T::make(1);\n            static_assert(one == 1);\n            static_assert(upx::has_single_bit(one));\n            constexpr T four = T::make(one + 3);\n            static_assert(four == 4);\n            static_assert(upx::has_single_bit(four));\n            constexpr U all_bits_u = (U) T::make(U(0) - U(1));\n            constexpr T all_bits = T::make(all_bits_u);\n            static_assert(all_bits == all_bits_u);\n            static_assert(all_bits == T::make(one - 2));\n            static_assert(!upx::has_single_bit(all_bits));\n            static_assert(one == one);\n            static_assert(!(one == four));\n            static_assert(!(one == all_bits));\n            static_assert(one < four);\n            static_assert(one < all_bits);\n            static_assert(upx::min(one, four) == 1);\n            static_assert(upx::min(one, four) == one);\n            static_assert(upx::min(U(1), four) == 1);\n            static_assert(upx::min(one, U(4)) == 1);\n            static_assert(upx::max(one, four) == 4);\n            static_assert(upx::max(one, four) == four);\n            static_assert(upx::max(U(1), four) == 4);\n            static_assert(upx::max(one, U(4)) == 4);\n            static_assert(upx::align_down(one, four) == 0);\n            static_assert(upx::align_up(one, four) == 4);\n            static_assert(upx::align_up(one, four) == four);\n            static_assert(upx::align_up_gap(one, four) == 3);\n            static_assert(upx::align_up_gap(one, four) == T::make(four - 1));\n            static_assert(upx::align_up_gap(one, four) == T::make(four - one));\n            static_assert(upx::align_up_gap(one, four) == T::make(four + one - one - one));\n            static_assert(upx::align_up_gap(one, four) == T::make(four + one - 2 * one));\n            static_assert(upx::align_down_gap(T::make(4), four) == 0);\n            static_assert(upx::align_down_gap(T::make(5), four) == 1);\n            static_assert(upx::align_down_gap(T::make(6), four) == 2);\n            static_assert(upx::align_down_gap(T::make(7), four) == 3);\n            static_assert(upx::align_down_gap(T::make(8), four) == 0);\n            constexpr T one_copy = T::make(one);\n            static_assert(one_copy == one);\n            static_assert(one_copy == 1);\n        }\n#endif\n        return true;\n    }\n};\n\ntemplate <class T, bool T_is_signed>\nstruct CheckSignedness {\n    static_assert(std::is_integral_v<T>);\n    static_assert(std::is_signed_v<T> == T_is_signed);\n    static_assert(std::is_unsigned_v<T> == !T_is_signed);\n    template <class U, bool U_is_signed>\n    static inline void checkU(void) noexcept {\n        static_assert(std::is_integral_v<U>);\n        static_assert(std::is_signed_v<U> == U_is_signed);\n        static_assert(std::is_unsigned_v<U> == !U_is_signed);\n        static_assert(sizeof(U) == sizeof(T));\n        static_assert(alignof(U) == alignof(T));\n        constexpr U all_bits = U(U(0) - U(1));\n        static_assert(all_bits == U(~U(0)));\n        static_assert(U_is_signed ? (all_bits < 0) : (all_bits > 0));\n    }\n    static void check(void) noexcept {\n        checkU<T, T_is_signed>();\n        using signed_type = std::make_signed_t<T>;\n        checkU<signed_type, true>();\n        using unsigned_type = std::make_unsigned_t<T>;\n        checkU<unsigned_type, false>();\n    }\n};\n\ntemplate <class A, class B>\nstruct CheckTypePair {\n    static_assert(std::is_integral_v<A>);\n    static_assert(std::is_integral_v<B>);\n    static_assert(std::is_signed_v<A>);\n    static_assert(!std::is_unsigned_v<A>);\n    static_assert(std::is_unsigned_v<B>);\n    static_assert(!std::is_signed_v<B>);\n    static_assert(std::is_same_v<A, std::make_signed_t<A> >);\n    static_assert(std::is_same_v<A, std::make_signed_t<B> >);\n    static_assert(std::is_same_v<B, std::make_unsigned_t<A> >);\n    static_assert(std::is_same_v<B, std::make_unsigned_t<B> >);\n    static_assert(sizeof(A) == sizeof(B));\n    static_assert(alignof(A) == alignof(B));\n    static inline void check(void) noexcept {}\n};\n\ntemplate <class A, class B>\nstruct TestNoAliasingStruct { // check working -fno-strict-aliasing\n    static noinline bool test(A *a, B *b) noexcept {\n        *a = 0;\n        *b = 0;\n        *b -= 3;\n        return *a != 0;\n    }\n};\ntemplate <class A, class B>\nstatic forceinline bool testNoAliasing(A *a, B *b) noexcept {\n    return TestNoAliasingStruct<A, B>::test(a, b);\n}\n\ntemplate <class T>\nstruct TestIntegerWrap { // check working -fno-strict-overflow\n    static inline bool inc_gt(const T x) noexcept { return x + 1 > x; }\n    static inline bool dec_lt(const T x) noexcept { return x - 1 < x; }\n    static inline bool neg_eq(const T x) noexcept { return T(T(0) - x) == x; }\n};\n\n//\n// basic exception handling checks to early catch toolchain/qemu/wine/etc problems\n//\n\nstruct TestDestructor {\n    explicit TestDestructor(int *pp, int vv) noexcept : p(pp), v(vv) {}\n    virtual noinline ~TestDestructor() noexcept { *p = (*p << 2) + v; }\n    int *p;\n    int v;\n};\n\nstatic noinline void throwSomeValue(int x) may_throw {\n    if (x < 0)\n        throw int(x);\n    else\n        throw size_t(x);\n}\n\nstatic noinline void check_exceptions_2(void (*func)(int), int *x) may_throw {\n    TestDestructor d(x, *x);\n    func(*x);\n}\n\nstatic noinline void check_basic_cxx_exception_handling(void (*func)(int)) noexcept {\n    bool cxx_exception_handling_works = false;\n    int x = 1;\n    try {\n        TestDestructor d(&x, 3);\n        check_exceptions_2(func, &x);\n    } catch (const size_t &e) {\n        if (e == 1 && x == 23)\n            cxx_exception_handling_works = true;\n    } catch (...) {\n    }\n    assert_noexcept(cxx_exception_handling_works);\n}\n\n//\n// basic floating point checks to early catch toolchain/qemu/wine/etc problems\n//\n\nstatic noinline float i64_f32_add_div(upx_int64_t a, upx_int64_t b) { return (a + b) / 1000000.0f; }\nstatic noinline float u64_f32_add_div(upx_uint64_t a, upx_uint64_t b) {\n    return (a + b) / 1000000.0f;\n}\nstatic noinline float i64_f32_sub_div(upx_int64_t a, upx_int64_t b) { return (a - b) / 1000000.0f; }\nstatic noinline float u64_f32_sub_div(upx_uint64_t a, upx_uint64_t b) {\n    return (a - b) / 1000000.0f;\n}\n\nstatic noinline double i64_f64_add_div(upx_int64_t a, upx_int64_t b) { return (a + b) / 1000000.0; }\nstatic noinline double u64_f64_add_div(upx_uint64_t a, upx_uint64_t b) {\n    return (a + b) / 1000000.0;\n}\nstatic noinline double i64_f64_sub_div(upx_int64_t a, upx_int64_t b) { return (a - b) / 1000000.0; }\nstatic noinline double u64_f64_sub_div(upx_uint64_t a, upx_uint64_t b) {\n    return (a - b) / 1000000.0;\n}\n\ntemplate <class Int, class Float>\nstruct TestFloat {\n    static constexpr Int X = 1000000;\n    static noinline Float div(Int a, Float f) { return a / f; }\n    static noinline Float add_div(Int a, Int b, Float f) { return Float(a + b) / f; }\n    static noinline Float sub_div(Int a, Int b, Float f) { return Float(a - b) / f; }\n    static noinline Float add_div_x(Int a, Int b) { return Float(a + b) / Float(X); }\n    static noinline Float sub_div_x(Int a, Int b) { return Float(a - b) / Float(X); }\n    static noinline void check() noexcept {\n        assert_noexcept(div(2 * X, Float(X)) == Float(2));\n        assert_noexcept(add_div(X, X, Float(X)) == Float(2));\n        assert_noexcept(add_div_x(X, X) == Float(2));\n        assert_noexcept(sub_div(3 * X, X, Float(X)) == Float(2));\n        assert_noexcept(sub_div_x(3 * X, X) == Float(2));\n        // extra debugging; floating point edge cases cause portability problems in practice\n        static const char envvar[] = \"UPX_DEBUG_TEST_FLOAT_DIVISION_BY_ZERO\";\n        if (is_envvar_true(envvar)) {\n#if defined(__FAST_MATH__)\n            // warning: comparison with NaN always evaluates to false in fast floating point modes\n            fprintf(stderr, \"upx: WARNING: ignoring %s: __FAST_MATH__\\n\", envvar);\n#else\n            assert_noexcept(std::isnan(div(0, Float(0))));\n            assert_noexcept(std::isinf(div(1, Float(0))));\n            assert_noexcept(std::isinf(div(Int(-1), Float(0))));\n#endif\n        }\n    }\n};\n\nstatic noinline void check_basic_floating_point(void) noexcept {\n    assert_noexcept(i64_f32_add_div(1000000, 1000000) == 2.0f);\n    assert_noexcept(u64_f32_add_div(1000000, 1000000) == 2.0f);\n    assert_noexcept(i64_f32_sub_div(3000000, 1000000) == 2.0f);\n    assert_noexcept(u64_f32_sub_div(3000000, 1000000) == 2.0f);\n    assert_noexcept(i64_f64_add_div(1000000, 1000000) == 2.0);\n    assert_noexcept(u64_f64_add_div(1000000, 1000000) == 2.0);\n    assert_noexcept(i64_f64_sub_div(3000000, 1000000) == 2.0);\n    assert_noexcept(u64_f64_sub_div(3000000, 1000000) == 2.0);\n    TestFloat<upx_int32_t, float>::check();\n    TestFloat<upx_uint32_t, float>::check();\n    TestFloat<upx_int64_t, float>::check();\n    TestFloat<upx_uint64_t, float>::check();\n    TestFloat<upx_int32_t, double>::check();\n    TestFloat<upx_uint32_t, double>::check();\n    TestFloat<upx_int64_t, double>::check();\n    TestFloat<upx_uint64_t, double>::check();\n}\n\n} // namespace\n\n#define ACC_WANT_ACC_CHK_CH 1\n#undef ACCCHK_ASSERT\n#include \"../util/miniacc.h\"\n\nvoid upx_compiler_sanity_check(void) noexcept {\n    check_basic_floating_point();\n\n    if (is_envvar_true(\"UPX_DEBUG_DOCTEST_DISABLE\", \"UPX_DEBUG_DISABLE_DOCTEST\")) {\n        // If UPX_DEBUG_DOCTEST_DISABLE is set then we don't want to throw any\n        // exceptions in order to improve debugging experience.\n    } else {\n        // check working C++ exception handling to early catch toolchain/qemu/wine/etc problems\n        check_basic_cxx_exception_handling(throwSomeValue);\n    }\n\n    // check_basic_decltype()\n    {\n        auto a = +0;\n        constexpr auto b = -0;\n        const auto &c = -1;\n        static_assert((std::is_same<int, decltype(a)>::value));\n        static_assert((std::is_same<const int, decltype(b)>::value));\n        static_assert((std::is_same<const int &, decltype(c)>::value));\n        UNUSED(a);\n        UNUSED(b);\n        UNUSED(c);\n    }\n\n#define ACC_WANT_ACC_CHK_CH 1\n#undef ACCCHK_ASSERT\n#define ACCCHK_ASSERT(expr) ACC_COMPILE_TIME_ASSERT(expr)\n#include \"../util/miniacc.h\"\n#undef ACCCHK_ASSERT\n\n    static_assert(sizeof(char) == 1);\n    static_assert(sizeof(short) == 2);\n    static_assert(sizeof(int) == 4);\n    static_assert(sizeof(long) >= 4);\n    static_assert(sizeof(long long) >= 8);\n    static_assert(sizeof(void *) >= 4);\n    static_assert(sizeof(upx_off_t) >= 8);\n    static_assert(sizeof(upx_off_t) >= sizeof(long long));\n\n// __int64\n#if defined(_MSC_VER)\n    {\n        ASSERT_SAME_TYPE(long long, __int64);\n        ASSERT_SAME_TYPE(unsigned long long, unsigned __int64);\n        typedef __int64 my_int64;\n        typedef unsigned __int64 my_uint64;\n        ASSERT_SAME_TYPE(long long, my_int64);\n        ASSERT_SAME_TYPE(unsigned long long, my_uint64);\n    }\n#endif\n\n    static_assert(sizeof(BE16) == 2);\n    static_assert(sizeof(BE32) == 4);\n    static_assert(sizeof(BE64) == 8);\n    static_assert(sizeof(LE16) == 2);\n    static_assert(sizeof(LE32) == 4);\n    static_assert(sizeof(LE64) == 8);\n\n    COMPILE_TIME_ASSERT_ALIGNED1(BE16)\n    COMPILE_TIME_ASSERT_ALIGNED1(BE32)\n    COMPILE_TIME_ASSERT_ALIGNED1(BE64)\n    COMPILE_TIME_ASSERT_ALIGNED1(LE16)\n    COMPILE_TIME_ASSERT_ALIGNED1(LE32)\n    COMPILE_TIME_ASSERT_ALIGNED1(LE64)\n\n    // check that these types are not some multi-word macro\n#define CHECK_TYPE(T) (void) (T())\n    CHECK_TYPE(int8_t);\n    CHECK_TYPE(uint8_t);\n    CHECK_TYPE(int16_t);\n    CHECK_TYPE(uint16_t);\n    CHECK_TYPE(int32_t);\n    CHECK_TYPE(uint32_t);\n    CHECK_TYPE(int64_t);\n    CHECK_TYPE(uint64_t);\n    CHECK_TYPE(intmax_t);\n    CHECK_TYPE(uintmax_t);\n    CHECK_TYPE(ptrdiff_t);\n    CHECK_TYPE(size_t);\n    CHECK_TYPE(intptr_t);\n    CHECK_TYPE(uintptr_t);\n#if 0\n    CHECK_TYPE(acc_int8_t);\n    CHECK_TYPE(acc_uint8_t);\n    CHECK_TYPE(acc_int16_t);\n    CHECK_TYPE(acc_uint16_t);\n    CHECK_TYPE(acc_int32_t);\n    CHECK_TYPE(acc_uint32_t);\n    CHECK_TYPE(acc_int64_t);\n    CHECK_TYPE(acc_uint64_t);\n    CHECK_TYPE(acc_intptr_t);\n    CHECK_TYPE(acc_uintptr_t);\n#endif\n    CHECK_TYPE(upx_int8_t);\n    CHECK_TYPE(upx_uint8_t);\n    CHECK_TYPE(upx_int16_t);\n    CHECK_TYPE(upx_uint16_t);\n    CHECK_TYPE(upx_int32_t);\n    CHECK_TYPE(upx_uint32_t);\n    CHECK_TYPE(upx_int64_t);\n    CHECK_TYPE(upx_uint64_t);\n#if (__SIZEOF_INT128__ == 16)\n    CHECK_TYPE(upx_int128_t);\n    CHECK_TYPE(upx_uint128_t);\n#endif\n    CHECK_TYPE(upx_ptraddr_t);\n    CHECK_TYPE(upx_uintptr_t);\n    CHECK_TYPE(upx_uptrdiff_t);\n    CHECK_TYPE(upx_ssize_t);\n#undef CHECK_TYPE\n\n    CheckIntegral<char>::check();\n    CheckIntegral<signed char>::check();\n    CheckIntegral<unsigned char>::check();\n    CheckIntegral<short>::check();\n    CheckIntegral<unsigned short>::check();\n    CheckIntegral<int>::check();\n    CheckIntegral<unsigned>::check();\n    CheckIntegral<long>::check();\n    CheckIntegral<unsigned long>::check();\n    CheckIntegral<long long>::check();\n    CheckIntegral<unsigned long long>::check();\n    CheckIntegral<intmax_t>::check();\n    CheckIntegral<uintmax_t>::check();\n    CheckIntegral<upx_int8_t>::check();\n    CheckIntegral<upx_uint8_t>::check();\n    CheckIntegral<upx_int16_t>::check();\n    CheckIntegral<upx_uint16_t>::check();\n    CheckIntegral<upx_int32_t>::check();\n    CheckIntegral<upx_uint32_t>::check();\n    CheckIntegral<upx_int64_t>::check();\n    CheckIntegral<upx_uint64_t>::check();\n    CheckIntegral<upx_off_t>::check();\n    CheckIntegral<ptrdiff_t>::check();\n    CheckIntegral<size_t>::check();\n    CheckIntegral<upx_ptraddr_t>::check();\n#if defined(__CHERI__) && defined(__CHERI_PURE_CAPABILITY__)\n    static_assert(sizeof(upx_ptraddr_t) == 8);\n    static_assert(alignof(upx_ptraddr_t) == 8);\n    static_assert(sizeof(void *) == 16);\n    static_assert(alignof(void *) == 16);\n    static_assert(sizeof(uintptr_t) == 16);\n    static_assert(alignof(uintptr_t) == 16);\n    // warning: binary expression on capability types 'unsigned __intcap' and 'unsigned __intcap'\n    CheckIntegral<intptr_t>::check_core();\n    CheckIntegral<uintptr_t>::check_core();\n    CheckIntegral<upx_uintptr_t>::check_core();\n#else\n    CheckIntegral<intptr_t>::check();\n    CheckIntegral<uintptr_t>::check();\n    CheckIntegral<upx_uintptr_t>::check();\n#endif\n#if (__SIZEOF_INT128__ == 16)\n#if defined(_CPP_VER) || defined(_WIN32) // int128 is not fully supported by MSVC libstdc++ yet\n#else\n    CheckIntegral<upx_int128_t>::check();\n    CheckIntegral<upx_uint128_t>::check();\n#endif\n#endif\n\n    CheckSignedness<char, false>::check(); // -funsigned-char\n    CheckSignedness<signed char, true>::check();\n    CheckSignedness<unsigned char, false>::check();\n    CheckSignedness<short, true>::check();\n    CheckSignedness<unsigned short, false>::check();\n    CheckSignedness<int, true>::check();\n    CheckSignedness<unsigned, false>::check();\n    CheckSignedness<long, true>::check();\n    CheckSignedness<unsigned long, false>::check();\n    CheckSignedness<long long, true>::check();\n    CheckSignedness<unsigned long long, false>::check();\n    CheckSignedness<intmax_t, true>::check();\n    CheckSignedness<uintmax_t, false>::check();\n    CheckSignedness<upx_int8_t, true>::check();\n    CheckSignedness<upx_uint8_t, false>::check();\n    CheckSignedness<upx_int16_t, true>::check();\n    CheckSignedness<upx_uint16_t, false>::check();\n    CheckSignedness<upx_int32_t, true>::check();\n    CheckSignedness<upx_uint32_t, false>::check();\n    CheckSignedness<upx_int64_t, true>::check();\n    CheckSignedness<upx_uint64_t, false>::check();\n#if (__SIZEOF_INT128__ == 16)\n#if defined(_CPP_VER) || defined(_WIN32) // int128 is not fully supported by MSVC libstdc++ yet\n#else\n    CheckSignedness<upx_int128_t, true>::check();\n    CheckSignedness<upx_uint128_t, false>::check();\n#endif\n#endif\n    CheckSignedness<upx_off_t, true>::check();\n    CheckSignedness<ptrdiff_t, true>::check();\n    CheckSignedness<size_t, false>::check();\n    CheckSignedness<upx_ptraddr_t, false>::check();\n    CheckSignedness<intptr_t, true>::check();\n    CheckSignedness<uintptr_t, false>::check();\n    CheckSignedness<upx_uintptr_t, false>::check();\n\n#define CHECK_TYPE_PAIR(A, B)                                                                      \\\n    CheckTypePair<A, B>::check();                                                                  \\\n    static_assert(alignof(A) == alignof(B))\n    CHECK_TYPE_PAIR(signed char, unsigned char);\n    CHECK_TYPE_PAIR(short, unsigned short);\n    CHECK_TYPE_PAIR(int, unsigned);\n    CHECK_TYPE_PAIR(long, unsigned long);\n    CHECK_TYPE_PAIR(long long, unsigned long long);\n    CHECK_TYPE_PAIR(intmax_t, uintmax_t);\n    CHECK_TYPE_PAIR(upx_int8_t, upx_uint8_t);\n    CHECK_TYPE_PAIR(upx_int16_t, upx_uint16_t);\n    CHECK_TYPE_PAIR(upx_int32_t, upx_uint32_t);\n    CHECK_TYPE_PAIR(upx_int64_t, upx_uint64_t);\n#if (__SIZEOF_INT128__ == 16)\n#if defined(_CPP_VER) || defined(_WIN32) // int128 is not fully supported by MSVC libstdc++ yet\n#else\n    CHECK_TYPE_PAIR(upx_int128_t, upx_uint128_t);\n#endif\n#endif\n    CHECK_TYPE_PAIR(ptrdiff_t, upx_uptrdiff_t);\n    CHECK_TYPE_PAIR(upx_ssize_t, size_t);\n    CHECK_TYPE_PAIR(upx_sptraddr_t, upx_ptraddr_t);\n    CHECK_TYPE_PAIR(intptr_t, uintptr_t);\n    CHECK_TYPE_PAIR(acc_intptr_t, acc_uintptr_t);\n#undef CHECK_TYPE_PAIR\n\n    static_assert(sizeof(upx_charptr_unit_type) == 1);\n    COMPILE_TIME_ASSERT_ALIGNED1(upx_charptr_unit_type)\n    static_assert(sizeof(*((charptr) nullptr)) == 1);\n\n    // check UPX_VERSION_xxx\n    {\n        using upx::compile_time::mem_eq;\n        using upx::compile_time::string_len;\n        static_assert(string_len(UPX_VERSION_STRING4) == 4);\n        static_assert(string_len(UPX_VERSION_YEAR) == 4);\n        static_assert(string_len(UPX_VERSION_DATE_ISO) == 10);\n        static_assert(string_len(UPX_VERSION_DATE) == 12 || string_len(UPX_VERSION_DATE) == 13);\n        static_assert(mem_eq(UPX_VERSION_STRING4, UPX_VERSION_STRING, 3));\n        static_assert(mem_eq(UPX_VERSION_YEAR, UPX_VERSION_DATE_ISO, 4));\n        static_assert(mem_eq(UPX_VERSION_YEAR, &UPX_VERSION_DATE[sizeof(UPX_VERSION_DATE) - 5], 4));\n        char buf[16];\n        constexpr long long v = UPX_VERSION_HEX;\n        upx_safe_snprintf(buf, sizeof(buf), \"%lld.%lld.%lld\", (v >> 16), (v >> 8) & 255, v & 255);\n        assert_noexcept(strcmp(buf, UPX_VERSION_STRING) == 0);\n        upx_safe_snprintf(buf, sizeof(buf), \"%lld.%lld%lld\", (v >> 16), (v >> 8) & 255, v & 255);\n        assert_noexcept(strcmp(buf, UPX_VERSION_STRING4) == 0);\n    }\n\n    if (gitrev[0]) {\n        size_t revlen = strlen(gitrev);\n        if (strncmp(gitrev, \"ERROR\", 5) == 0) {\n            assert_noexcept(revlen == 5 || revlen == 6);\n        } else {\n            assert_noexcept(revlen == 12 || revlen == 13);\n        }\n        if (revlen == 6 || revlen == 13) {\n            assert_noexcept(gitrev[revlen - 1] == '+');\n        }\n    }\n    assert_noexcept(UPX_RSIZE_MAX_MEM == 805306368);\n\n#if DEBUG || 1\n    assert_noexcept(TestBELE<LE16>::test());\n    assert_noexcept(TestBELE<LE32>::test());\n    assert_noexcept(TestBELE<LE64>::test());\n    assert_noexcept(TestBELE<BE16>::test());\n    assert_noexcept(TestBELE<BE32>::test());\n    assert_noexcept(TestBELE<BE64>::test());\n    {\n        alignas(16) static constexpr const byte dd[32] = {\n            0, 0, 0, 0,    0,    0,    0,    0xff, 0xfe, 0xfd, 0xfc, 0xfb, 0xfa, 0xf9, 0xf8, 0,\n            0, 0, 0, 0x7f, 0x7e, 0x7d, 0x7c, 0x7b, 0x7a, 0x79, 0x78, 0,    0,    0,    0,    0};\n        constexpr const byte *d = dd + 7;\n#if !defined(upx_fake_alignas_16)\n        assert_noexcept(ptr_is_aligned<16>(dd));\n        assert_noexcept(ptr_is_aligned(dd, 16));\n#endif\n        static_assert(upx::compile_time::get_be16(d) == 0xfffe);\n        static_assert(upx::compile_time::get_be24(d) == 0xfffefd);\n        static_assert(upx::compile_time::get_be32(d) == 0xfffefdfc);\n        static_assert(upx::compile_time::get_be64(d) == 0xfffefdfcfbfaf9f8ULL);\n        static_assert(upx::compile_time::get_le16(d) == 0xfeff);\n        static_assert(upx::compile_time::get_le24(d) == 0xfdfeff);\n        static_assert(upx::compile_time::get_le32(d) == 0xfcfdfeff);\n        static_assert(upx::compile_time::get_le64(d) == 0xf8f9fafbfcfdfeffULL);\n        assert_noexcept(upx_adler32(d, 4) == 0x09f003f7);\n        assert_noexcept(upx_adler32(d, 4, 0) == 0x09ec03f6);\n        assert_noexcept(upx_adler32(d, 4, 1) == 0x09f003f7);\n        const N_BELE_RTP::AbstractPolicy *bele;\n        bele = &N_BELE_RTP::be_policy;\n        assert_noexcept(get_be16(d) == 0xfffe);\n        assert_noexcept(bele->get16(d) == 0xfffe);\n        assert_noexcept(get_be16_signed(d) == -2);\n        assert_noexcept(get_be24(d) == 0xfffefd);\n        assert_noexcept(bele->get24(d) == 0xfffefd);\n        assert_noexcept(get_be24_signed(d) == -259);\n        assert_noexcept(get_be32(d) == 0xfffefdfc);\n        assert_noexcept(bele->get32(d) == 0xfffefdfc);\n        assert_noexcept(get_be32_signed(d) == -66052);\n        assert_noexcept(get_be64(d) == 0xfffefdfcfbfaf9f8ULL);\n        assert_noexcept(bele->get64(d) == 0xfffefdfcfbfaf9f8ULL);\n        assert_noexcept(get_be64_signed(d) == -283686952306184LL);\n        bele = &N_BELE_RTP::le_policy;\n        assert_noexcept(get_le16(d) == 0xfeff);\n        assert_noexcept(bele->get16(d) == 0xfeff);\n        assert_noexcept(get_le16_signed(d) == -257);\n        assert_noexcept(get_le24(d) == 0xfdfeff);\n        assert_noexcept(bele->get24(d) == 0xfdfeff);\n        assert_noexcept(get_le24_signed(d) == -131329);\n        assert_noexcept(get_le32(d) == 0xfcfdfeff);\n        assert_noexcept(bele->get32(d) == 0xfcfdfeff);\n        assert_noexcept(get_le32_signed(d) == -50462977);\n        assert_noexcept(get_le64(d) == 0xf8f9fafbfcfdfeffULL);\n        assert_noexcept(bele->get64(d) == 0xf8f9fafbfcfdfeffULL);\n        assert_noexcept(get_le64_signed(d) == -506097522914230529LL);\n        static_assert(get_be24(d) == 0xfffefd);\n        static_assert(get_le24(d) == 0xfdfeff);\n#if defined(upx_is_constant_evaluated)\n        static_assert(get_be24_signed(d) == -259);\n        static_assert(get_le24_signed(d) == -131329);\n        static_assert(get_be16(d) == 0xfffe);\n        static_assert(get_be16_signed(d) == -2);\n        static_assert(get_be32(d) == 0xfffefdfc);\n        static_assert(get_be32_signed(d) == -66052);\n        static_assert(get_be64(d) == 0xfffefdfcfbfaf9f8ULL);\n        static_assert(get_be64_signed(d) == -283686952306184LL);\n        static_assert(get_le16(d) == 0xfeff);\n        static_assert(get_le16_signed(d) == -257);\n        static_assert(get_le32(d) == 0xfcfdfeff);\n        static_assert(get_le32_signed(d) == -50462977);\n        static_assert(get_le64(d) == 0xf8f9fafbfcfdfeffULL);\n        static_assert(get_le64_signed(d) == -506097522914230529LL);\n#endif\n        assert_noexcept(find_be16(d, 2, 0xfffe) == 0);\n        assert_noexcept(find_le16(d, 2, 0xfeff) == 0);\n        assert_noexcept(find_be32(d, 4, 0xfffefdfc) == 0);\n        assert_noexcept(find_le32(d, 4, 0xfcfdfeff) == 0);\n        constexpr const byte *e = d + 12;\n        assert_noexcept(get_be16_signed(e) == 32638);\n        assert_noexcept(get_be24_signed(e) == 8355453);\n        assert_noexcept(get_be32_signed(e) == 2138996092);\n        assert_noexcept(get_be64_signed(e) == 9186918263483431288LL);\n#if defined(upx_is_constant_evaluated)\n        static_assert(get_be16_signed(e) == 32638);\n        static_assert(get_be24_signed(e) == 8355453);\n        static_assert(get_be32_signed(e) == 2138996092);\n        static_assert(get_be64_signed(e) == 9186918263483431288LL);\n#endif\n    }\n#if defined(upx_is_constant_evaluated)\n    {\n        constexpr upx_uint16_t v16 = 0x0201;\n        constexpr upx_uint32_t v32 = 0x04030201;\n        constexpr upx_uint64_t v64 = 0x0807060504030201ull;\n        constexpr BE16 be16 = BE16::make(v16);\n        constexpr BE32 be32 = BE32::make(v32);\n        constexpr BE64 be64 = BE64::make(v64);\n        constexpr LE16 le16 = LE16::make(v16);\n        constexpr LE32 le32 = LE32::make(v32);\n        constexpr LE64 le64 = LE64::make(v64);\n        using upx::compile_time::mem_eq;\n        static_assert(mem_eq(be16.d, \"\\x02\\x01\", 2));\n        static_assert(mem_eq(be32.d, \"\\x04\\x03\\x02\\x01\", 4));\n        static_assert(mem_eq(be64.d, \"\\x08\\x07\\x06\\x05\\x04\\x03\\x02\\x01\", 8));\n        static_assert(mem_eq(le16.d, \"\\x01\\x02\", 2));\n        static_assert(mem_eq(le32.d, \"\\x01\\x02\\x03\\x04\", 4));\n        static_assert(mem_eq(le64.d, \"\\x01\\x02\\x03\\x04\\x05\\x06\\x07\\x08\", 8));\n        constexpr NE16 ne16 = NE16::make(v16);\n        constexpr NE32 ne32 = NE32::make(v32);\n        constexpr NE64 ne64 = NE64::make(v64);\n        assert_noexcept(memcmp(&v16, ne16.d, 2) == 0);\n        assert_noexcept(memcmp(&v32, ne32.d, 4) == 0);\n        assert_noexcept(memcmp(&v64, ne64.d, 8) == 0);\n    }\n#endif\n#if DEBUG >= 1\n    {\n        for (int i = 0; i < 256; i++) {\n            {\n                const unsigned u = i;\n                assert_noexcept(sign_extend32(u, 1) == ((i & 1) ? -1 : 0));\n                assert_noexcept(sign_extend32(u, 2) == ((i & 2) ? -2 + (i & 1) : (i & 1)));\n                assert_noexcept(sign_extend32(u, 3) == ((i & 4) ? -4 + (i & 3) : (i & 3)));\n                assert_noexcept(sign_extend32(u, 4) == ((i & 8) ? -8 + (i & 7) : (i & 7)));\n                assert_noexcept(sign_extend32(u, 5) == ((i & 16) ? -16 + (i & 15) : (i & 15)));\n                assert_noexcept(sign_extend32(u, 6) == ((i & 32) ? -32 + (i & 31) : (i & 31)));\n                assert_noexcept(sign_extend32(u, 7) == ((i & 64) ? -64 + (i & 63) : (i & 63)));\n                assert_noexcept(sign_extend32(u, 8) == ((i & 128) ? -128 + (i & 127) : (i & 127)));\n                assert_noexcept(sign_extend32(u, 9) == i);\n                assert_noexcept(sign_extend32(u, 32) == i);\n                assert_noexcept(sign_extend32(0u - u, 32) == -i);\n            }\n            {\n                const upx_uint64_t u = i;\n                assert_noexcept(sign_extend64(u, 1) == ((i & 1) ? -1 : 0));\n                assert_noexcept(sign_extend64(u, 2) == ((i & 2) ? -2 + (i & 1) : (i & 1)));\n                assert_noexcept(sign_extend64(u, 3) == ((i & 4) ? -4 + (i & 3) : (i & 3)));\n                assert_noexcept(sign_extend64(u, 4) == ((i & 8) ? -8 + (i & 7) : (i & 7)));\n                assert_noexcept(sign_extend64(u, 5) == ((i & 16) ? -16 + (i & 15) : (i & 15)));\n                assert_noexcept(sign_extend64(u, 6) == ((i & 32) ? -32 + (i & 31) : (i & 31)));\n                assert_noexcept(sign_extend64(u, 7) == ((i & 64) ? -64 + (i & 63) : (i & 63)));\n                assert_noexcept(sign_extend64(u, 8) == ((i & 128) ? -128 + (i & 127) : (i & 127)));\n                assert_noexcept(sign_extend64(u, 9) == i);\n                assert_noexcept(sign_extend64(u, 32) == i);\n                assert_noexcept(sign_extend64(upx_uint64_t(0) - u, 32) == -i);\n                assert_noexcept(sign_extend64(u, 64) == i);\n                assert_noexcept(sign_extend64(upx_uint64_t(0) - u, 64) == -i);\n            }\n        }\n    }\n#endif\n    {\n        unsigned dd;\n        void *const d = &dd;\n        dd = ne32_to_le32(0xf7f6f5f4);\n        assert_noexcept(get_le26(d) == 0x03f6f5f4);\n        set_le26(d, 0);\n        assert_noexcept(get_le26(d) == 0);\n        assert_noexcept(dd == ne32_to_le32(0xf4000000));\n        set_le26(d, 0xff020304);\n        assert_noexcept(get_le26(d) == 0x03020304);\n        assert_noexcept(dd == ne32_to_le32(0xf7020304));\n    }\n    {\n        upx_uint16_t a = 0;\n        upx_uint32_t b = 0;\n        upx_uint64_t c = 0;\n        set_ne16(&a, 0x04030201); // ignore upper bits\n        set_ne32(&b, 0x04030201);\n        set_ne64(&c, 0x0807060504030201ull);\n        assert_noexcept(a == 0x0201);\n        assert_noexcept(b == 0x04030201);\n        assert_noexcept(c == 0x0807060504030201ull);\n        assert_noexcept(get_ne16(&a) == 0x0201);\n        assert_noexcept(get_ne32(&b) == 0x04030201);\n        assert_noexcept(get_ne64(&c) == 0x0807060504030201ull);\n    }\n#endif // DEBUG\n    union {\n        short v_short;\n        int v_int;\n        long v_long;\n        long long v_llong;\n        BE16 b16;\n        BE32 b32;\n        BE64 b64;\n        LE16 l16;\n        LE32 l32;\n        LE64 l64;\n    } u;\n    assert_noexcept(testNoAliasing(&u.v_short, &u.b32));\n    assert_noexcept(testNoAliasing(&u.v_short, &u.l32));\n    assert_noexcept(testNoAliasing(&u.v_int, &u.b64));\n    assert_noexcept(testNoAliasing(&u.v_int, &u.l64));\n    // check working -fno-strict-aliasing\n    assert_noexcept(testNoAliasing(&u.v_short, &u.v_int));\n    assert_noexcept(testNoAliasing(&u.v_int, &u.v_long));\n    assert_noexcept(testNoAliasing(&u.v_int, &u.v_llong));\n    assert_noexcept(testNoAliasing(&u.v_long, &u.v_llong));\n\n    assert_noexcept(TestIntegerWrap<unsigned>::inc_gt(0));\n    assert_noexcept(!TestIntegerWrap<unsigned>::inc_gt(UINT_MAX));\n    assert_noexcept(TestIntegerWrap<unsigned>::dec_lt(1));\n    assert_noexcept(!TestIntegerWrap<unsigned>::dec_lt(0));\n    assert_noexcept(TestIntegerWrap<unsigned>::neg_eq(0));\n    assert_noexcept(!TestIntegerWrap<unsigned>::neg_eq(1));\n    assert_noexcept(!TestIntegerWrap<unsigned>::neg_eq(UINT_MAX));\n    // check working -fno-strict-overflow\n    assert_noexcept(TestIntegerWrap<int>::inc_gt(0));\n    assert_noexcept(!TestIntegerWrap<int>::inc_gt(INT_MAX));\n    assert_noexcept(TestIntegerWrap<int>::dec_lt(0));\n    assert_noexcept(!TestIntegerWrap<int>::dec_lt(INT_MIN));\n    assert_noexcept(TestIntegerWrap<int>::neg_eq(0));\n    assert_noexcept(!TestIntegerWrap<int>::neg_eq(1));\n    assert_noexcept(!TestIntegerWrap<int>::neg_eq(INT_MAX));\n    assert_noexcept(TestIntegerWrap<int>::neg_eq(INT_MIN)); // special case\n}\n\n/*************************************************************************\n// some doctest test cases\n**************************************************************************/\n\nTEST_CASE(\"assert_noexcept\") {\n    // just to make sure that our own assert() macros do not trigger any compiler warnings\n    byte dummy = 0;\n    byte *ptr1 = &dummy;\n    const byte *const ptr2 = &dummy;\n    void *ptr3 = nullptr;\n    assert(true);\n    assert(1);\n    assert(ptr1);\n    assert(ptr2);\n    assert(!ptr3);\n    assert_noexcept(true);\n    assert_noexcept(1);\n    assert_noexcept(ptr1);\n    assert_noexcept(ptr2);\n    assert_noexcept(!ptr3);\n}\n\nTEST_CASE(\"acc_vget\") {\n    CHECK_EQ(acc_vget_int(0, 0), 0);\n    CHECK_EQ(acc_vget_long(1, -1), 1);\n    CHECK_EQ(acc_vget_acc_int64l_t(2, 1), 2);\n    CHECK_EQ(acc_vget_acc_hvoid_p(nullptr, 0), nullptr);\n    if (acc_vget_int(1, 0) > 0)\n        return;\n    assert_noexcept(false);\n}\n\nTEST_CASE(\"ptr_invalidate_and_poison\") {\n    int *ip = nullptr; // initialized\n    ptr_invalidate_and_poison(ip);\n    assert(ip != nullptr);\n    (void) ip;\n    double *dp; // not initialized\n    ptr_invalidate_and_poison(dp);\n    assert(dp != nullptr);\n    (void) dp;\n}\n\nTEST_CASE(\"upx_getenv\") {\n    CHECK_EQ(upx_getenv(nullptr), nullptr);\n    CHECK_EQ(upx_getenv(\"\"), nullptr);\n}\n\nTEST_CASE(\"working -fno-strict-aliasing\") {\n    bool ok;\n    long v = 0;\n    short *ps = ACC_STATIC_CAST(short *, acc_vget_acc_hvoid_p(&v, 0));\n    int *pi = ACC_STATIC_CAST(int *, acc_vget_acc_hvoid_p(&v, 0));\n    long *pl = ACC_STATIC_CAST(long *, acc_vget_acc_hvoid_p(&v, 0));\n    *ps = 0;\n    *pl = -1;\n    ok = *ps == -1;\n    CHECK(ok);\n    *pi = 0;\n    *pl = -1;\n    ok = *pi == -1;\n    CHECK(ok);\n    *pl = 0;\n    *ps = -1;\n    ok = *pl != 0;\n    CHECK(ok);\n    *pl = 0;\n    *pi = -1;\n    ok = *pl != 0;\n    CHECK(ok);\n    UNUSED(ok);\n}\n\nTEST_CASE(\"working -fno-strict-overflow\") {\n    CHECK_EQ(acc_vget_int(INT_MAX, 0) + 1, INT_MIN);\n    CHECK_EQ(acc_vget_int(INT_MIN, 0) - 1, INT_MAX);\n    CHECK_EQ(acc_vget_long(LONG_MAX, 0) + 1, LONG_MIN);\n    CHECK_EQ(acc_vget_long(LONG_MIN, 0) - 1, LONG_MAX);\n    bool ok;\n    int i;\n    i = INT_MAX;\n    i += 1;\n    ok = i == INT_MIN;\n    CHECK(ok);\n    i = INT_MIN;\n    i -= 1;\n    ok = i == INT_MAX;\n    CHECK(ok);\n    UNUSED(ok);\n}\n\nTEST_CASE(\"libc snprintf\") {\n    // runtime check that Windows/MinGW <stdio.h> works as expected\n    char buf[64];\n    long long ll = acc_vget_int(-1, 0);\n    unsigned long long llu = (upx_uint64_t) (upx_int64_t) ll;\n    snprintf(buf, sizeof(buf), \"%d.%ld.%lld.%u.%lu.%llu\", -3, -2L, ll, 3U, 2LU, llu);\n    CHECK_EQ(strcmp(buf, \"-3.-2.-1.3.2.18446744073709551615\"), 0);\n    intmax_t im = ll;\n    uintmax_t um = llu;\n    snprintf(buf, sizeof(buf), \"%d.%d.%d.%d.%d.%d.%d.%d.%d.%jd\", -4, 0, 0, 0, 0, 0, 0, 0, 4, im);\n    CHECK_EQ(strcmp(buf, \"-4.0.0.0.0.0.0.0.4.-1\"), 0);\n    snprintf(buf, sizeof(buf), \"%d.%d.%d.%d.%d.%d.%d.%d.%d.%ju\", -5, 0, 0, 0, 0, 0, 0, 0, 5, um);\n    CHECK_EQ(strcmp(buf, \"-5.0.0.0.0.0.0.0.5.18446744073709551615\"), 0);\n    snprintf(buf, sizeof(buf), \"%d.%d.%d.%d.%d.%d.%d.%d.%d.%jx\", -6, 0, 0, 0, 0, 0, 0, 0, 6, um);\n    CHECK_EQ(strcmp(buf, \"-6.0.0.0.0.0.0.0.6.ffffffffffffffff\"), 0);\n    snprintf(buf, sizeof(buf), \"%d.%d.%d.%d.%d.%d.%d.%d.%d.%#jx\", -7, 0, 0, 0, 0, 0, 0, 0, 7, um);\n    CHECK_EQ(strcmp(buf, \"-7.0.0.0.0.0.0.0.7.0xffffffffffffffff\"), 0);\n    snprintf(buf, sizeof(buf), \"%#X %#lx %#llx\", 26u, 27ul, 28ull);\n    CHECK_EQ(strcmp(buf, \"0X1A 0x1b 0x1c\"), 0);\n    snprintf(buf, sizeof(buf), \"%#06x %#06lX %#06llx\", 26u, 27ul, 28ull);\n    CHECK_EQ(strcmp(buf, \"0x001a 0X001B 0x001c\"), 0);\n    snprintf(buf, sizeof(buf), \"%#6x %#6lx %#6llX\", 26u, 27ul, 28ull);\n    CHECK_EQ(strcmp(buf, \"  0x1a   0x1b   0X1C\"), 0);\n    snprintf(buf, sizeof(buf), \"%#-6X %#-6lx %#-6llx\", 26u, 27ul, 28ull);\n    CHECK_EQ(strcmp(buf, \"0X1A   0x1b   0x1c  \"), 0);\n}\n\nTEST_CASE(\"libc qsort\") {\n    // runtime check that libc qsort() never compares identical objects\n    // UPDATE: while only poor implementations of qsort() would actually do this\n    //   it is probably allowed by the standard, so skip this test by default\n    if (!is_envvar_true(\"UPX_DEBUG_TEST_LIBC_QSORT\"))\n        return;\n\n    struct Elem {\n        upx_uint16_t id;\n        upx_uint16_t value;\n        static int __acc_cdecl_qsort compare(const void *aa, const void *bb) noexcept {\n            const Elem *a = (const Elem *) aa;\n            const Elem *b = (const Elem *) bb;\n            assert_noexcept(a->id != b->id); // check not IDENTICAL\n            return a->value == b->value ? 0 : (a->value < b->value ? -1 : 1);\n        }\n        static noinline bool check_sort(upx_sort_func_t sort, Elem *e, size_t n, bool is_stable) {\n            upx_uint32_t x = 5381 + (upx_rand() & 255);\n            for (size_t i = 0; i < n; i++) {\n                e[i].id = (upx_uint16_t) i;\n                x = x * 33 + 1 + (i & 255);\n                e[i].value = (upx_uint16_t) ((x >> 4) & 15);\n            }\n            sort(e, n, sizeof(Elem), Elem::compare);\n            // verify\n            for (size_t i = 1; i < n; i++) {\n                if very_unlikely (e[i - 1].value > e[i].value)\n                    return false;\n                if (is_stable)\n                    if very_unlikely (e[i - 1].value == e[i].value && e[i - 1].id >= e[i].id)\n                        return false;\n            }\n            return true;\n        }\n    };\n    constexpr size_t N = 4096;\n    Elem e[N];\n    for (size_t n = 0; n <= N; n = 2 * n + 1) {\n        // system sort functions\n        CHECK(Elem::check_sort(::qsort, e, n, false)); // libc qsort()\n#if UPX_CONFIG_USE_STABLE_SORT\n        upx_sort_func_t wrap_stable_sort = [](void *aa, size_t nn, size_t, upx_compare_func_t cc) {\n            upx_std_stable_sort<sizeof(Elem)>(aa, nn, cc);\n        };\n        CHECK(Elem::check_sort(wrap_stable_sort, e, n, true)); // std::stable_sort()\n#endif\n        // simple UPX sort functions\n        CHECK(Elem::check_sort(upx_gnomesort, e, n, true));\n        CHECK(Elem::check_sort(upx_shellsort_memswap, e, n, false));\n        CHECK(Elem::check_sort(upx_shellsort_memcpy, e, n, false));\n    }\n}\n\n/* vim:set ts=4 sw=4 et: */\n","size_bytes":60131},"src/check/dt_cxxlib.cpp":{"content":"/* dt_cxxlib.cpp -- doctest check\n\n   This file is part of the Resize executable compressor.\n\n   Copyright (C) 2025 WHO-AM-I-404\n   Based on UPX - Ultimate Packer for eXecutables\n   Copyright (C) 1996-2025 Markus Franz Xaver Johannes Oberhumer\n   All Rights Reserved.\n\n   Resize and the UCL library are free software; you can redistribute them\n   and/or modify them under the terms of the GNU General Public License as\n   published by the Free Software Foundation; either version 2 of\n   the License, or (at your option) any later version.\n\n   This program is distributed in the hope that it will be useful,\n   but WITHOUT ANY WARRANTY; without even the implied warranty of\n   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n   GNU General Public License for more details.\n\n   You should have received a copy of the GNU General Public License\n   along with this program; see the file COPYING.\n   If not, write to the Free Software Foundation, Inc.,\n   59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.\n\n   Markus F.X.J. Oberhumer\n   <markus@oberhumer.com>\n */\n\n// lots of tests (and probably quite a number of redundant tests)\n// modern compilers will optimize away much of this code\n\n#include \"../util/system_headers.h\"\n#include <vector> // std::vector\n#include \"../conf.h\"\n\n/*************************************************************************\n// standard C++ library\n**************************************************************************/\n\nTEST_CASE(\"std::vector\") {\n    constexpr size_t N = 16;\n    std::vector<int> v(N);\n    CHECK(v.end() - v.begin() == N);\n    CHECK(&v[0] == &(*(v.begin())));\n    // CHECK(&v[0] + N == &(*(v.end()))); // TODO later: is this legal??\n#if defined(_LIBCPP_HARDENING_MODE) && defined(_LIBCPP_HARDENING_MODE_DEBUG) &&                    \\\n    (_LIBCPP_HARDENING_MODE == _LIBCPP_HARDENING_MODE_DEBUG)\n    // unfortunately this does NOT throw but ABORTS\n    ////CHECK_THROWS((void) &v[N]);\n#endif\n    UNUSED(v);\n}\n\n/*************************************************************************\n// core util: UPX_CXX_DISABLE_xxx, noncopyable\n**************************************************************************/\n\nnamespace {\ntemplate <class TA, class TB, int TC = 0>\nstruct MyType1 {\n    MyType1() noexcept {}\n    UPX_CXX_DISABLE_ADDRESS(MyType1)\n    UPX_CXX_DISABLE_COPY_MOVE(MyType1)\n    UPX_CXX_DISABLE_NEW_DELETE_NO_VIRTUAL(MyType1)\n};\ntemplate <class TA, class TB, int TC = 0>\nstruct MyType2 {\n    MyType2() noexcept {}\n    UPX_CXX_DISABLE_COPY_MOVE(MyType2)\n    typedef MyType2<TA, TB, TC> Self;\n    UPX_CXX_DISABLE_ADDRESS(Self)\n    UPX_CXX_DISABLE_NEW_DELETE_NO_VIRTUAL(Self)\n};\ntemplate <class TA, class TB, int TC = 0>\nstruct MyVType1 {\n    MyVType1() noexcept {}\n    virtual ~MyVType1() noexcept {}\n    UPX_CXX_DISABLE_ADDRESS(MyVType1)\n    UPX_CXX_DISABLE_COPY_MOVE(MyVType1)\n    UPX_CXX_DISABLE_NEW_DELETE(MyVType1)\n};\ntemplate <class TA, class TB, int TC = 0>\nstruct MyVType2 {\n    MyVType2() noexcept {}\n    virtual ~MyVType2() noexcept {}\n    UPX_CXX_DISABLE_COPY_MOVE(MyVType2)\n    typedef MyVType2<TA, TB, TC> Self;\n    UPX_CXX_DISABLE_ADDRESS(Self)\n    UPX_CXX_DISABLE_NEW_DELETE(Self)\n};\nTEST_CASE(\"UPX_CXX_DISABLE_xxx\") {\n    MyType1<char, int, 1> dummy1;\n    MyType2<char, int, 2> dummy2;\n    MyVType1<char, int, 1> vdummy1;\n    MyVType2<char, int, 2> vdummy2;\n    (void) dummy1;\n    (void) dummy2;\n    (void) vdummy1;\n    (void) vdummy2;\n}\n} // namespace\n\nnamespace test_disable_new_delete {\n\nstruct A1 {\n    int a;\n};\nstruct A2 {\n    int a;\n    UPX_CXX_DISABLE_NEW_DELETE_NO_VIRTUAL(A2)\n};\nstruct B1_A1 : public A1 {\n    int b;\n};\nstruct B1_A2 : public A2 {\n    int b;\n};\nstruct B2_A1 : public A1 {\n    int b;\n    UPX_CXX_DISABLE_NEW_DELETE_NO_VIRTUAL(B2_A1)\n};\nstruct B2_A2 : public A2 {\n    int b;\n    UPX_CXX_DISABLE_NEW_DELETE_NO_VIRTUAL(B2_A2)\n};\n\nstruct X1 {\n    virtual ~X1() noexcept {}\n    int x;\n};\nstruct X2 {\n    virtual ~X2() noexcept {}\n    int x;\n    UPX_CXX_DISABLE_NEW_DELETE(X2)\n};\nstruct Y1_X1 : public X1 {\n    int y;\n};\nstruct Y1_X2 : public X2 {\n    int y;\n};\nstruct Y2_X1 : public X1 {\n    int y;\n    UPX_CXX_DISABLE_NEW_DELETE(Y2_X1)\n};\nstruct Y2_X2 : public X2 {\n    int y;\n    UPX_CXX_DISABLE_NEW_DELETE(Y2_X2)\n};\nstruct Z1_X1 : public X1 {\n    virtual ~Z1_X1() noexcept {}\n    int z;\n};\nstruct Z1_X2 : public X2 {\n    virtual ~Z1_X2() noexcept {}\n    int z;\n};\nstruct Z2_X1 : public X1 {\n    virtual ~Z2_X1() noexcept {}\n    int z;\n    UPX_CXX_DISABLE_NEW_DELETE(Z2_X1)\n};\nstruct Z2_X2 : public X2 {\n    virtual ~Z2_X2() noexcept {}\n    int z;\n    UPX_CXX_DISABLE_NEW_DELETE(Z2_X2)\n};\n\n} // namespace test_disable_new_delete\n\nTEST_CASE(\"upx::noncopyable\") {\n    struct Test : private upx::noncopyable {\n        int v = 1;\n    };\n    Test t = {};\n    CHECK(t.v == 1);\n#if (ACC_CC_MSC) // MSVC thinks that Test is not std::is_trivially_copyable; true or compiler bug?\n    // @COMPILER_BUG @MSVC_BUG\n    t.v = 0;\n#else\n    mem_clear(&t);\n#endif\n    CHECK(t.v == 0);\n    constexpr Test x = {};\n    static_assert(x.v == 1);\n}\n\n/*************************************************************************\n// <type_traits>\n**************************************************************************/\n\nstatic_assert(!upx::is_bounded_array_v<std::nullptr_t>);\nstatic_assert(!upx::is_bounded_array_v<decltype(nullptr)>);\nstatic_assert(!upx::is_bounded_array_v<void *>);\nstatic_assert(!upx::is_bounded_array_v<int *>);\nstatic_assert(!upx::is_bounded_array_v<const int *>);\nstatic_assert(!upx::is_bounded_array_v<volatile int *>);\nstatic_assert(!upx::is_bounded_array_v<const volatile int *>);\nstatic_assert(upx::is_bounded_array_v<int[1]>);\nstatic_assert(upx::is_bounded_array_v<const int[1]>);\nstatic_assert(upx::is_bounded_array_v<volatile int[1]>);\nstatic_assert(upx::is_bounded_array_v<const volatile int[1]>);\nstatic_assert(upx::is_bounded_array_v<int[1u]>);\nstatic_assert(upx::is_bounded_array_v<const int[1u]>);\nstatic_assert(upx::is_bounded_array_v<volatile int[1u]>);\nstatic_assert(upx::is_bounded_array_v<const volatile int[1u]>);\nstatic_assert(upx::is_bounded_array_v<int[1l]>);\nstatic_assert(upx::is_bounded_array_v<const int[1l]>);\nstatic_assert(upx::is_bounded_array_v<volatile int[1l]>);\nstatic_assert(upx::is_bounded_array_v<const volatile int[1l]>);\n\nstatic_assert(upx::is_same_all_v<int>);\nstatic_assert(upx::is_same_all_v<int, int>);\nstatic_assert(upx::is_same_all_v<int, int, int>);\nstatic_assert(!upx::is_same_all_v<int, char>);\nstatic_assert(!upx::is_same_all_v<int, char, int>);\nstatic_assert(!upx::is_same_all_v<int, int, char>);\n\nstatic_assert(!upx::is_same_any_v<int>);\nstatic_assert(upx::is_same_any_v<int, int>);\nstatic_assert(upx::is_same_any_v<int, char, int>);\nstatic_assert(upx::is_same_any_v<int, int, char>);\nstatic_assert(!upx::is_same_any_v<int, char>);\nstatic_assert(!upx::is_same_any_v<int, char, char>);\nstatic_assert(!upx::is_same_any_v<int, char, long>);\n\nstatic_assert(upx::is_same_any_v<ptrdiff_t, int, long, long long>);\nstatic_assert(upx::is_same_any_v<size_t, unsigned, unsigned long, unsigned long long>);\nstatic_assert(upx::is_same_any_v<upx_ptraddr_t, unsigned, unsigned long, unsigned long long>);\n#if defined(__CHERI__) && defined(__CHERI_PURE_CAPABILITY__)\nstatic_assert(!upx::is_same_any_v<upx_uintptr_t, unsigned, unsigned long, unsigned long long>);\n#else\nstatic_assert(upx::is_same_any_v<upx_uintptr_t, unsigned, unsigned long, unsigned long long>);\n#endif\n\nstatic_assert(std::is_same_v<int, upx::remove_cvref_t<int> >);\nstatic_assert(std::is_same_v<int, upx::remove_cvref_t<const int> >);\nstatic_assert(std::is_same_v<int, upx::remove_cvref_t<int &> >);\nstatic_assert(std::is_same_v<int, upx::remove_cvref_t<const int &> >);\nstatic_assert(std::is_same_v<int, upx::remove_cvref_t<int &&> >);\nstatic_assert(std::is_same_v<int, upx::remove_cvref_t<const int &&> >);\nstatic_assert(std::is_same_v<int *, upx::remove_cvref_t<int *> >);\nstatic_assert(std::is_same_v<int *, upx::remove_cvref_t<int *const> >);\nstatic_assert(std::is_same_v<const int *, upx::remove_cvref_t<const int *> >);\nstatic_assert(std::is_same_v<int *, upx::remove_cvref_t<int *&> >);\nstatic_assert(std::is_same_v<int *, upx::remove_cvref_t<int *const &> >);\nstatic_assert(std::is_same_v<const int *, upx::remove_cvref_t<const int *&> >);\nstatic_assert(std::is_same_v<int *, upx::remove_cvref_t<int *&&> >);\nstatic_assert(std::is_same_v<int *, upx::remove_cvref_t<int *const &&> >);\nstatic_assert(std::is_same_v<const int *, upx::remove_cvref_t<const int *&&> >);\nstatic_assert(std::is_same_v<int[1], upx::remove_cvref_t<int[1]> >);\nstatic_assert(std::is_same_v<int[1], upx::remove_cvref_t<const int[1]> >);\n\nstatic_assert(std::is_same_v<int, upx::type_identity_t<int> >);\nstatic_assert(std::is_same_v<const int, upx::type_identity_t<const int> >);\nstatic_assert(std::is_same_v<int *, upx::type_identity_t<int *> >);\nstatic_assert(std::is_same_v<int *const, upx::type_identity_t<int *const> >);\nstatic_assert(std::is_same_v<const int *, upx::type_identity_t<const int *> >);\nstatic_assert(std::is_same_v<int &, upx::type_identity_t<int &> >);\nstatic_assert(std::is_same_v<const int &, upx::type_identity_t<const int &> >);\nstatic_assert(std::is_same_v<int &&, upx::type_identity_t<int &&> >);\nstatic_assert(std::is_same_v<const int &&, upx::type_identity_t<const int &&> >);\nstatic_assert(std::is_same_v<int[1], upx::type_identity_t<int[1]> >);\nstatic_assert(std::is_same_v<const int[1], upx::type_identity_t<const int[1]> >);\n\n/*************************************************************************\n// <bit>\n**************************************************************************/\n\nstatic_assert(!upx::has_single_bit(0));\nstatic_assert(upx::has_single_bit(1));\nstatic_assert(upx::has_single_bit(2));\nstatic_assert(!upx::has_single_bit(3));\nstatic_assert(upx::has_single_bit(4));\n\n/*************************************************************************\n// <algorithm>\n**************************************************************************/\n\nstatic_assert(upx::align_down(0, 4) == 0);\nstatic_assert(upx::align_down(1, 4) == 0);\nstatic_assert(upx::align_down(2, 4) == 0);\nstatic_assert(upx::align_down(3, 4) == 0);\nstatic_assert(upx::align_down(4, 4) == 4);\nstatic_assert(upx::align_up(0, 4) == 0);\nstatic_assert(upx::align_up(1, 4) == 4);\nstatic_assert(upx::align_up(2, 4) == 4);\nstatic_assert(upx::align_up(3, 4) == 4);\nstatic_assert(upx::align_up(4, 4) == 4);\nstatic_assert(upx::align_up_gap(0, 4) == 0);\nstatic_assert(upx::align_up_gap(1, 4) == 3);\nstatic_assert(upx::align_up_gap(2, 4) == 2);\nstatic_assert(upx::align_up_gap(3, 4) == 1);\nstatic_assert(upx::align_up_gap(4, 4) == 0);\n\nstatic_assert(upx::min<upx_int8_t>(1, 2) == 1);\nstatic_assert(upx::min<upx_int16_t>(1, 2) == 1);\nstatic_assert(upx::min<upx_int32_t>(1, 2) == 1);\nstatic_assert(upx::min<upx_int64_t>(1, 2) == 1);\nstatic_assert(upx::min<intmax_t>(1, 2) == 1);\nstatic_assert(upx::max<upx_int8_t>(1, 2) == 2);\nstatic_assert(upx::max<upx_int16_t>(1, 2) == 2);\nstatic_assert(upx::max<upx_int32_t>(1, 2) == 2);\nstatic_assert(upx::max<upx_int64_t>(1, 2) == 2);\nstatic_assert(upx::max<intmax_t>(1, 2) == 2);\n\nstatic_assert(upx::min(1, 2) == 1);\nstatic_assert(upx::min(1l, 2l) == 1);\nstatic_assert(upx::min(1ll, 2ll) == 1);\nstatic_assert(upx::max(1, 2) == 2);\nstatic_assert(upx::max(1l, 2l) == 2);\nstatic_assert(upx::max(1ll, 2ll) == 2);\n\nstatic_assert(upx::umin<upx_uint8_t>(1, 2) == 1);\nstatic_assert(upx::umin<upx_uint16_t>(1, 2) == 1);\nstatic_assert(upx::umin<upx_uint32_t>(1, 2) == 1);\nstatic_assert(upx::umin<upx_uint64_t>(1, 2) == 1);\nstatic_assert(upx::umin<uintmax_t>(1, 2) == 1);\nstatic_assert(upx::umax<upx_uint8_t>(1, 2) == 2);\nstatic_assert(upx::umax<upx_uint16_t>(1, 2) == 2);\nstatic_assert(upx::umax<upx_uint32_t>(1, 2) == 2);\nstatic_assert(upx::umax<upx_uint64_t>(1, 2) == 2);\nstatic_assert(upx::umax<uintmax_t>(1, 2) == 2);\n\nstatic_assert(upx::umin(1u, 2u) == 1);\nstatic_assert(upx::umin(1ul, 2ul) == 1);\nstatic_assert(upx::umin(1ull, 2ull) == 1);\nstatic_assert(upx::umax(1u, 2u) == 2);\nstatic_assert(upx::umax(1ul, 2ul) == 2);\nstatic_assert(upx::umax(1ull, 2ull) == 2);\n\nstatic_assert(upx::wrapping_add<upx_int8_t>(127, 2) == -127);\nstatic_assert(upx::wrapping_add<upx_int16_t>(32767, 2) == -32767);\nstatic_assert(upx::wrapping_add(2147483647, 2) == -2147483647);\nstatic_assert(upx::wrapping_add(9223372036854775807ll, 2ll) == -9223372036854775807ll);\nstatic_assert(upx::wrapping_sub<upx_int8_t>(-127, 2) == 127);\nstatic_assert(upx::wrapping_sub<upx_int16_t>(-32767, 2) == 32767);\nstatic_assert(upx::wrapping_sub(-2147483647, 2) == 2147483647);\nstatic_assert(upx::wrapping_sub(-9223372036854775807ll, 2ll) == 9223372036854775807ll);\n\nstatic_assert(upx::wrapping_add<upx_uint8_t>(255, 2) == 1);\nstatic_assert(upx::wrapping_sub<upx_uint8_t>(1, 2) == 255);\n\n/*************************************************************************\n// util\n**************************************************************************/\n\n// upx::UnsignedSizeOf\nstatic_assert(usizeof(int) == sizeof(int));\nstatic_assert(usizeof('a') == sizeof(char));\nstatic_assert(usizeof(\"\") == 1);\nstatic_assert(usizeof(\"a\") == 2);\nstatic_assert(usizeof(\"ab\") == 3);\nstatic_assert(usizeof(L'a') == sizeof(wchar_t));\nstatic_assert(usizeof(L\"\") == 1 * sizeof(wchar_t));\nstatic_assert(usizeof(L\"a\") == 2 * sizeof(wchar_t));\nstatic_assert(usizeof(L\"ab\") == 3 * sizeof(wchar_t));\nstatic_assert(usizeof(0) == sizeof(int));\nstatic_assert(usizeof(0L) == sizeof(long));\nstatic_assert(usizeof(0LL) == sizeof(long long));\nstatic_assert(usizeof(nullptr) == sizeof(void *));\nstatic_assert(usizeof(sizeof(0)) == sizeof(size_t));\nstatic_assert(usizeof(usizeof(0)) == sizeof(unsigned));\n#if 0\n// works, but may trigger clang/gcc warnings \"-Wunused-value\"\nstatic_assert(usizeof((1LL, 1)) == sizeof(int));\nstatic_assert(usizeof((1, 1LL)) == sizeof(long long));\n#endif\n\nTEST_CASE(\"upx::ptr_static_cast\") {\n    // check that we do not trigger any -Wcast-align warnings\n    using upx::ptr_static_cast;\n\n    void *vp = nullptr;\n    byte *bp = nullptr;\n    int *ip = nullptr;\n    double *dp = nullptr;\n\n    assert((vp == ptr_static_cast<void *>(vp)));\n    assert((vp == ptr_static_cast<void *>(bp)));\n    assert((vp == ptr_static_cast<void *>(ip)));\n    assert((vp == ptr_static_cast<void *>(dp)));\n\n    assert((bp == ptr_static_cast<byte *>(vp)));\n    assert((bp == ptr_static_cast<byte *>(bp)));\n    assert((bp == ptr_static_cast<byte *>(ip)));\n    assert((bp == ptr_static_cast<byte *>(dp)));\n\n    assert((ip == ptr_static_cast<int *>(vp)));\n    assert((ip == ptr_static_cast<int *>(bp)));\n    assert((ip == ptr_static_cast<int *>(ip)));\n    assert((ip == ptr_static_cast<int *>(dp)));\n\n    assert((dp == ptr_static_cast<double *>(vp)));\n    assert((dp == ptr_static_cast<double *>(bp)));\n    assert((dp == ptr_static_cast<double *>(ip)));\n    assert((dp == ptr_static_cast<double *>(dp)));\n\n    const byte *bc = nullptr;\n    const int *ic = nullptr;\n    assert((bc == ptr_static_cast<byte *>(bp)));\n    assert((bc == ptr_static_cast<const byte *>(bc)));\n    assert((bc == ptr_static_cast<byte *>(ip)));\n    assert((bc == ptr_static_cast<const byte *>(ic)));\n    assert((ic == ptr_static_cast<int *>(bp)));\n    assert((ic == ptr_static_cast<const int *>(bc)));\n    assert((ic == ptr_static_cast<int *>(ip)));\n    assert((ic == ptr_static_cast<const int *>(ic)));\n}\n\nTEST_CASE(\"upx::ptr_static_cast constexpr 1\") {\n    // check that casts work at compile-time\n    using upx::ptr_static_cast;\n\n    constexpr void *vp = nullptr;\n    constexpr byte *bp = nullptr;\n    constexpr int *ip = nullptr;\n    constexpr double *dp = nullptr;\n    static_assert((vp == ptr_static_cast<void *>(vp)));\n    static_assert((bp == ptr_static_cast<byte *>(bp)));\n    static_assert((ip == ptr_static_cast<int *>(ip)));\n    static_assert((dp == ptr_static_cast<double *>(dp)));\n\n    constexpr const void *vc = nullptr;\n    constexpr const byte *bc = nullptr;\n    constexpr const int *ic = nullptr;\n    constexpr const double *dc = nullptr;\n    static_assert((vc == ptr_static_cast<const void *>(vc)));\n    static_assert((bc == ptr_static_cast<const byte *>(bc)));\n    static_assert((ic == ptr_static_cast<const int *>(ic)));\n    static_assert((dc == ptr_static_cast<const double *>(dc)));\n\n    constexpr void **vpp = nullptr;\n    constexpr byte **bpp = nullptr;\n    constexpr int **ipp = nullptr;\n    constexpr double **dpp = nullptr;\n    static_assert((vpp == ptr_static_cast<void **>(vpp)));\n    static_assert((bpp == ptr_static_cast<byte **>(bpp)));\n    static_assert((ipp == ptr_static_cast<int **>(ipp)));\n    static_assert((dpp == ptr_static_cast<double **>(dpp)));\n\n    constexpr const void **vcp = nullptr;\n    constexpr const byte **bcp = nullptr;\n    constexpr const int **icp = nullptr;\n    constexpr const double **dcp = nullptr;\n    static_assert((vcp == ptr_static_cast<const void **>(vcp)));\n    static_assert((bcp == ptr_static_cast<const byte **>(bcp)));\n    static_assert((icp == ptr_static_cast<const int **>(icp)));\n    static_assert((dcp == ptr_static_cast<const double **>(dcp)));\n\n    constexpr void *const *vpc = nullptr;\n    constexpr byte *const *bpc = nullptr;\n    constexpr int *const *ipc = nullptr;\n    constexpr double *const *dpc = nullptr;\n    static_assert((vpc == ptr_static_cast<void *const *>(vpc)));\n    static_assert((bpc == ptr_static_cast<byte *const *>(bpc)));\n    static_assert((ipc == ptr_static_cast<int *const *>(ipc)));\n    static_assert((dpc == ptr_static_cast<double *const *>(dpc)));\n\n    constexpr const void *const *vcc = nullptr;\n    constexpr const byte *const *bcc = nullptr;\n    constexpr const int *const *icc = nullptr;\n    constexpr const double *const *dcc = nullptr;\n    static_assert((vcc == ptr_static_cast<const void *const *>(vcc)));\n    static_assert((bcc == ptr_static_cast<const byte *const *>(bcc)));\n    static_assert((icc == ptr_static_cast<const int *const *>(icc)));\n    static_assert((dcc == ptr_static_cast<const double *const *>(dcc)));\n}\n\nTEST_CASE(\"upx::ptr_static_cast constexpr 2\") {\n    // check that casts work at compile-time\n    using upx::ptr_static_cast;\n\n    constexpr void *vp = nullptr;\n    constexpr byte *bp = nullptr;\n    constexpr int *ip = nullptr;\n    constexpr double *dp = nullptr;\n    static_assert((vp == static_cast<void *>(vp)));\n    static_assert((vp == static_cast<void *>(bp)));\n    static_assert((vp == static_cast<void *>(ip)));\n    static_assert((vp == static_cast<void *>(dp)));\n    static_assert((vp == ptr_static_cast<void *>(vp)));\n    static_assert((vp == ptr_static_cast<void *>(bp)));\n    static_assert((vp == ptr_static_cast<void *>(ip)));\n    static_assert((vp == ptr_static_cast<void *>(dp)));\n\n    constexpr const void *vc = nullptr;\n    constexpr const byte *bc = nullptr;\n    constexpr const int *ic = nullptr;\n    constexpr const double *dc = nullptr;\n    static_assert((vc == static_cast<const void *>(vp)));\n    static_assert((vc == static_cast<const void *>(bp)));\n    static_assert((vc == static_cast<const void *>(ip)));\n    static_assert((vc == static_cast<const void *>(dp)));\n    static_assert((vc == ptr_static_cast<const void *>(vp)));\n    static_assert((vc == ptr_static_cast<const void *>(dp)));\n    static_assert((vc == ptr_static_cast<const void *>(bp)));\n    static_assert((vc == ptr_static_cast<const void *>(ip)));\n    static_assert((vc == static_cast<const void *>(vc)));\n    static_assert((vc == static_cast<const void *>(bc)));\n    static_assert((vc == static_cast<const void *>(ic)));\n    static_assert((vc == static_cast<const void *>(dc)));\n    static_assert((vc == ptr_static_cast<const void *>(vc)));\n    static_assert((vc == ptr_static_cast<const void *>(dc)));\n    static_assert((vc == ptr_static_cast<const void *>(bc)));\n    static_assert((vc == ptr_static_cast<const void *>(ic)));\n\n    // these are invalid:\n    //// constexpr char *cc1 = static_cast<char *>(bp);\n    //// constexpr char *cc2 = ptr_static_cast<char *>(bp);\n    //// constexpr unsigned *uc1 = static_cast<unsigned *>(ip);\n    //// constexpr unsigned *uc2 = ptr_static_cast<unsigned *>(ip);\n}\n\n#if WITH_THREADS\nTEST_CASE(\"upx::ptr_std_atomic_cast\") {\n    // pointer-size\n    CHECK_EQ(upx::ptr_std_atomic_cast((void **) nullptr), nullptr);\n    CHECK_EQ(upx::ptr_std_atomic_cast((uintptr_t *) nullptr), nullptr);\n    CHECK_EQ(upx::ptr_std_atomic_cast((upx_uintptr_t *) nullptr), nullptr);\n#if 1\n    // more fundamental types\n    CHECK_EQ(upx::ptr_std_atomic_cast((char *) nullptr), nullptr);\n    CHECK_EQ(upx::ptr_std_atomic_cast((short *) nullptr), nullptr);\n    CHECK_EQ(upx::ptr_std_atomic_cast((int *) nullptr), nullptr);\n    CHECK_EQ(upx::ptr_std_atomic_cast((long *) nullptr), nullptr);\n    CHECK_EQ(upx::ptr_std_atomic_cast((ptrdiff_t *) nullptr), nullptr);\n    CHECK_EQ(upx::ptr_std_atomic_cast((size_t *) nullptr), nullptr);\n    CHECK_EQ(upx::ptr_std_atomic_cast((upx_int8_t *) nullptr), nullptr);\n    CHECK_EQ(upx::ptr_std_atomic_cast((upx_int16_t *) nullptr), nullptr);\n    CHECK_EQ(upx::ptr_std_atomic_cast((upx_int32_t *) nullptr), nullptr);\n#endif\n}\n#endif // WITH_THREADS\n\nTEST_CASE(\"upx::atomic_exchange\") {\n    {\n        upx_uintptr_t x = (upx_uintptr_t) 0 - 1;\n        upx_uintptr_t y = upx::atomic_exchange(&x, (upx_uintptr_t) 2);\n        CHECK_EQ(x, 2);\n        CHECK_EQ(y, (upx_uintptr_t) 0 - 1);\n        UNUSED(y);\n    }\n    {\n        const int buf[2] = {101, 202};\n        const int *ptr_array[2] = {&buf[0], &buf[1]};\n        assert_noexcept(*ptr_array[0] == 101 && *ptr_array[1] == 202);\n        const int *p = upx::atomic_exchange(&ptr_array[0], ptr_array[1]);\n        CHECK_EQ(p, buf + 0);\n        assert_noexcept(*ptr_array[0] == 202 && *ptr_array[1] == 202);\n        p = upx::atomic_exchange(&ptr_array[1], p);\n        CHECK_EQ(p, buf + 1);\n        assert_noexcept(*ptr_array[0] == 202 && *ptr_array[1] == 101);\n        UNUSED(p);\n    }\n}\n\nTEST_CASE(\"upx::ObjectDeleter 1\") {\n    LE16 *o = nullptr; // object\n    LE32 *a = nullptr; // array\n    LE64 *m = nullptr; // malloc\n    {\n        // auto o_deleter = upx::ObjectDeleter(&o, 1);\n        upx::ObjectDeleter<LE16> o_deleter = upx::ObjectDeleter(&o, 1);\n        o = new LE16;\n        assert(o != nullptr);\n        auto a_deleter = upx::ArrayDeleter(&a, 1);\n        a = New(LE32, 1);\n        assert(a != nullptr);\n        auto m_deleter = upx::MallocDeleter(&m, 1);\n        m = (LE64 *) ::malloc(sizeof(LE64));\n        assert(m != nullptr);\n    }\n    assert(o == nullptr);\n    assert(a == nullptr);\n    assert(m == nullptr);\n    // test \"const\" versions\n    {\n        const auto o_deleter = upx::ObjectDeleter(&o, 1);\n        o = new LE16;\n        assert(o != nullptr);\n        const auto a_deleter = upx::ArrayDeleter(&a, 1);\n        a = New(LE32, 1);\n        assert(a != nullptr);\n        const auto m_deleter = upx::MallocDeleter(&m, 1);\n        m = (LE64 *) ::malloc(sizeof(LE64));\n        assert(m != nullptr);\n    }\n    assert(o == nullptr);\n    assert(a == nullptr);\n    assert(m == nullptr);\n}\n\nTEST_CASE(\"upx::ObjectDeleter 2\") {\n    constexpr size_t N = 2;\n    BE16 *o[N]; // multiple objects\n    BE32 *a[N]; // multiple arrays\n    BE64 *m[N]; // multiple mallocs\n    {\n        // auto o_deleter = upx::ObjectDeleter(o, 0);\n        upx::ObjectDeleter<BE16> o_deleter = upx::ObjectDeleter(o, 0);\n        auto a_deleter = upx::ArrayDeleter(a, 0);\n        auto m_deleter = upx::MallocDeleter(m, 0);\n        for (size_t i = 0; i < N; i++) {\n            o[i] = new BE16;\n            assert(o[i] != nullptr);\n            o_deleter.count += 1;\n            a[i] = New(BE32, 1 + i);\n            assert(a[i] != nullptr);\n            a_deleter.count += 1;\n            m[i] = (BE64 *) ::malloc(sizeof(BE64));\n            assert(m[i] != nullptr);\n            m_deleter.count += 1;\n        }\n    }\n    for (size_t i = 0; i < N; i++) {\n        assert(o[i] == nullptr);\n        assert(a[i] == nullptr);\n        assert(m[i] == nullptr);\n    }\n}\n\n/*************************************************************************\n// namespace upx::compile_time\n**************************************************************************/\n\nstatic_assert(upx::compile_time::string_len(\"\") == 0);\nstatic_assert(upx::compile_time::string_len(\"a\") == 1);\nstatic_assert(upx::compile_time::string_len(\"ab\") == 2);\nstatic_assert(upx::compile_time::string_len(\"abc\") == 3);\n\nstatic_assert(upx::compile_time::string_eq(\"\", \"\"));\nstatic_assert(!upx::compile_time::string_eq(\"a\", \"\"));\nstatic_assert(!upx::compile_time::string_eq(\"\", \"a\"));\nstatic_assert(upx::compile_time::string_eq(\"abc\", \"abc\"));\nstatic_assert(!upx::compile_time::string_eq(\"ab\", \"abc\"));\nstatic_assert(!upx::compile_time::string_eq(\"abc\", \"ab\"));\n\nstatic_assert(!upx::compile_time::string_lt(\"\", \"\"));\nstatic_assert(!upx::compile_time::string_lt(\"a\", \"\"));\nstatic_assert(upx::compile_time::string_lt(\"\", \"a\"));\nstatic_assert(!upx::compile_time::string_lt(\"abc\", \"abc\"));\nstatic_assert(upx::compile_time::string_lt(\"ab\", \"abc\"));\nstatic_assert(!upx::compile_time::string_lt(\"abc\", \"ab\"));\nstatic_assert(!upx::compile_time::string_lt(\"abc\", \"aba\"));\nstatic_assert(upx::compile_time::string_lt(\"abc\", \"abz\"));\n\nstatic_assert(upx::compile_time::string_ne(\"abc\", \"abz\"));\nstatic_assert(!upx::compile_time::string_gt(\"abc\", \"abz\"));\nstatic_assert(!upx::compile_time::string_ge(\"abc\", \"abz\"));\nstatic_assert(upx::compile_time::string_le(\"abc\", \"abz\"));\n\nstatic_assert(upx::compile_time::mem_eq((const char *) nullptr, (const char *) nullptr, 0));\nstatic_assert(upx::compile_time::mem_eq((const char *) nullptr, (const byte *) nullptr, 0));\nstatic_assert(upx::compile_time::mem_eq((const byte *) nullptr, (const char *) nullptr, 0));\nstatic_assert(upx::compile_time::mem_eq((const byte *) nullptr, (const byte *) nullptr, 0));\nstatic_assert(upx::compile_time::mem_eq(\"\", \"\", 0));\nstatic_assert(upx::compile_time::mem_eq(\"abc\", \"abc\", 3));\nstatic_assert(!upx::compile_time::mem_eq(\"abc\", \"abz\", 3));\n\nstatic_assert(upx::compile_time::bswap16(0x0102) == 0x0201);\nstatic_assert(upx::compile_time::bswap32(0x01020304) == 0x04030201);\nstatic_assert(upx::compile_time::bswap64(0x0102030405060708ull) == 0x0807060504030201ull);\n\nnamespace {\nstruct alignas(1) TestCT final {\n    byte d[8]; // public data\n\n    static constexpr TestCT makeBE16(upx_uint16_t v) noexcept {\n        TestCT x = {};\n        upx::compile_time::set_be16(x.d, v);\n        return x;\n    }\n    static constexpr TestCT makeBE24(upx_uint32_t v) noexcept {\n        TestCT x = {};\n        upx::compile_time::set_be24(x.d, v);\n        return x;\n    }\n    static constexpr TestCT makeBE32(upx_uint32_t v) noexcept {\n        TestCT x = {};\n        upx::compile_time::set_be32(x.d, v);\n        return x;\n    }\n    static constexpr TestCT makeBE64(upx_uint64_t v) noexcept {\n        TestCT x = {};\n        upx::compile_time::set_be64(x.d, v);\n        return x;\n    }\n    static constexpr TestCT makeLE16(upx_uint16_t v) noexcept {\n        TestCT x = {};\n        upx::compile_time::set_le16(x.d, v);\n        return x;\n    }\n    static constexpr TestCT makeLE24(upx_uint32_t v) noexcept {\n        TestCT x = {};\n        upx::compile_time::set_le24(x.d, v);\n        return x;\n    }\n    static constexpr TestCT makeLE32(upx_uint32_t v) noexcept {\n        TestCT x = {};\n        upx::compile_time::set_le32(x.d, v);\n        return x;\n    }\n    static constexpr TestCT makeLE64(upx_uint64_t v) noexcept {\n        TestCT x = {};\n        upx::compile_time::set_le64(x.d, v);\n        return x;\n    }\n\n    // run-time\n    static noinline upx_uint16_t noinline_bswap16(upx_uint16_t v) noexcept {\n        return upx::compile_time::bswap16(v);\n    }\n    static noinline upx_uint32_t noinline_bswap32(upx_uint32_t v) noexcept {\n        return upx::compile_time::bswap32(v);\n    }\n    static noinline upx_uint64_t noinline_bswap64(upx_uint64_t v) noexcept {\n        return upx::compile_time::bswap64(v);\n    }\n\n    static noinline upx_uint16_t noinline_get_be16(const byte *p) noexcept {\n        return upx::compile_time::get_be16(p);\n    }\n    static noinline upx_uint32_t noinline_get_be24(const byte *p) noexcept {\n        return upx::compile_time::get_be24(p);\n    }\n    static noinline upx_uint32_t noinline_get_be32(const byte *p) noexcept {\n        return upx::compile_time::get_be32(p);\n    }\n    static noinline upx_uint64_t noinline_get_be64(const byte *p) noexcept {\n        return upx::compile_time::get_be64(p);\n    }\n    static noinline upx_uint16_t noinline_get_le16(const byte *p) noexcept {\n        return upx::compile_time::get_le16(p);\n    }\n    static noinline upx_uint32_t noinline_get_le24(const byte *p) noexcept {\n        return upx::compile_time::get_le24(p);\n    }\n    static noinline upx_uint32_t noinline_get_le32(const byte *p) noexcept {\n        return upx::compile_time::get_le32(p);\n    }\n    static noinline upx_uint64_t noinline_get_le64(const byte *p) noexcept {\n        return upx::compile_time::get_le64(p);\n    }\n\n    static noinline void noinline_set_be16(byte * p, upx_uint16_t v) noexcept {\n        upx::compile_time::set_be16(p, v);\n    }\n    static noinline void noinline_set_be24(byte * p, upx_uint32_t v) noexcept {\n        upx::compile_time::set_be24(p, v);\n    }\n    static noinline void noinline_set_be32(byte * p, upx_uint32_t v) noexcept {\n        upx::compile_time::set_be32(p, v);\n    }\n    static noinline void noinline_set_be64(byte * p, upx_uint64_t v) noexcept {\n        upx::compile_time::set_be64(p, v);\n    }\n    static noinline void noinline_set_le16(byte * p, upx_uint16_t v) noexcept {\n        upx::compile_time::set_le16(p, v);\n    }\n    static noinline void noinline_set_le24(byte * p, upx_uint32_t v) noexcept {\n        upx::compile_time::set_le24(p, v);\n    }\n    static noinline void noinline_set_le32(byte * p, upx_uint32_t v) noexcept {\n        upx::compile_time::set_le32(p, v);\n    }\n    static noinline void noinline_set_le64(byte * p, upx_uint64_t v) noexcept {\n        upx::compile_time::set_le64(p, v);\n    }\n};\nstatic_assert(sizeof(TestCT) == 8);\nstatic_assert(alignof(TestCT) == 1);\n} // namespace\n\nTEST_CASE(\"upx::compile_time 1\") {\n    constexpr upx_uint16_t v16 = 0x0201;\n    constexpr upx_uint32_t v24 = 0x030201;\n    constexpr upx_uint32_t v32 = 0x04030201;\n    constexpr upx_uint64_t v64 = 0x0807060504030201ull;\n    {\n        static_assert(upx::compile_time::bswap16(v16) == 0x0102);\n        static_assert(upx::compile_time::bswap32(v32) == 0x01020304);\n        static_assert(upx::compile_time::bswap64(v64) == 0x0102030405060708ull);\n        assert_noexcept(TestCT::noinline_bswap16(v16) == 0x0102);\n        assert_noexcept(TestCT::noinline_bswap32(v32) == 0x01020304);\n        assert_noexcept(TestCT::noinline_bswap64(v64) == 0x0102030405060708ull);\n    }\n    {\n        constexpr const byte d[8] = {1, 2, 3, 4, 5, 6, 7, 8};\n        static_assert(upx::compile_time::get_be16(d) == 0x0102);\n        static_assert(upx::compile_time::get_be24(d) == 0x010203);\n        static_assert(upx::compile_time::get_be32(d) == 0x01020304);\n        static_assert(upx::compile_time::get_be64(d) == 0x0102030405060708ull);\n        static_assert(upx::compile_time::get_le16(d) == 0x0201);\n        static_assert(upx::compile_time::get_le24(d) == 0x030201);\n        static_assert(upx::compile_time::get_le32(d) == 0x04030201);\n        static_assert(upx::compile_time::get_le64(d) == 0x0807060504030201ull);\n    }\n    {\n        using upx::compile_time::mem_eq;\n        upx_alignas_max byte aligned_buffer[16] = {};\n        upx::compile_time::mem_set(aligned_buffer, 0xff, 16);\n        assert_noexcept(mem_eq(aligned_buffer, aligned_buffer + 8, 8));\n        byte *const buf = aligned_buffer + 7;\n\n        constexpr auto be16 = TestCT::makeBE16(v16);\n        static_assert(upx::compile_time::get_be16(be16.d) == v16);\n        static_assert(mem_eq(be16.d, \"\\x02\\x01\", 2));\n        upx::compile_time::mem_clear(buf, 8);\n        TestCT::noinline_set_be16(buf, v16);\n        assert_noexcept(TestCT::noinline_get_be16(buf) == v16);\n        assert_noexcept(upx::compile_time::get_be16(buf) == v16);\n        assert_noexcept(memcmp(buf, be16.d, 8) == 0);\n\n        constexpr auto be24 = TestCT::makeBE24(v24);\n        static_assert(upx::compile_time::get_be24(be24.d) == v24);\n        static_assert(mem_eq(be24.d, \"\\x03\\x02\\x01\", 3));\n        upx::compile_time::mem_clear(buf, 8);\n        TestCT::noinline_set_be24(buf, v24);\n        assert_noexcept(TestCT::noinline_get_be24(buf) == v24);\n        assert_noexcept(upx::compile_time::get_be24(buf) == v24);\n        assert_noexcept(memcmp(buf, be24.d, 8) == 0);\n\n        constexpr auto be32 = TestCT::makeBE32(v32);\n        static_assert(upx::compile_time::get_be32(be32.d) == v32);\n        static_assert(mem_eq(be32.d, \"\\x04\\x03\\x02\\x01\", 4));\n        upx::compile_time::mem_clear(buf, 8);\n        TestCT::noinline_set_be32(buf, v32);\n        assert_noexcept(TestCT::noinline_get_be32(buf) == v32);\n        assert_noexcept(upx::compile_time::get_be32(buf) == v32);\n        assert_noexcept(memcmp(buf, be32.d, 8) == 0);\n\n        constexpr auto be64 = TestCT::makeBE64(v64);\n        static_assert(upx::compile_time::get_be64(be64.d) == v64);\n        static_assert(mem_eq(be64.d, \"\\x08\\x07\\x06\\x05\\x04\\x03\\x02\\x01\", 8));\n        upx::compile_time::mem_clear(buf, 8);\n        TestCT::noinline_set_be64(buf, v64);\n        assert_noexcept(TestCT::noinline_get_be64(buf) == v64);\n        assert_noexcept(upx::compile_time::get_be64(buf) == v64);\n        assert_noexcept(memcmp(buf, be64.d, 8) == 0);\n\n        constexpr auto le16 = TestCT::makeLE16(v16);\n        static_assert(upx::compile_time::get_le16(le16.d) == v16);\n        static_assert(mem_eq(le16.d, \"\\x01\\x02\", 2));\n        upx::compile_time::mem_clear(buf, 8);\n        TestCT::noinline_set_le16(buf, v16);\n        assert_noexcept(TestCT::noinline_get_le16(buf) == v16);\n        assert_noexcept(upx::compile_time::get_le16(buf) == v16);\n        assert_noexcept(memcmp(buf, le16.d, 8) == 0);\n\n        constexpr auto le24 = TestCT::makeLE24(v24);\n        static_assert(upx::compile_time::get_le24(le24.d) == v24);\n        static_assert(mem_eq(le24.d, \"\\x01\\x02\\x03\", 3));\n        upx::compile_time::mem_clear(buf, 8);\n        TestCT::noinline_set_le24(buf, v24);\n        assert_noexcept(TestCT::noinline_get_le24(buf) == v24);\n        assert_noexcept(upx::compile_time::get_le24(buf) == v24);\n        assert_noexcept(memcmp(buf, le24.d, 8) == 0);\n\n        constexpr auto le32 = TestCT::makeLE32(v32);\n        static_assert(upx::compile_time::get_le32(le32.d) == v32);\n        static_assert(mem_eq(le32.d, \"\\x01\\x02\\x03\\x04\", 4));\n        upx::compile_time::mem_clear(buf, 8);\n        TestCT::noinline_set_le32(buf, v32);\n        assert_noexcept(TestCT::noinline_get_le32(buf) == v32);\n        assert_noexcept(upx::compile_time::get_le32(buf) == v32);\n        assert_noexcept(memcmp(buf, le32.d, 8) == 0);\n\n        constexpr auto le64 = TestCT::makeLE64(v64);\n        static_assert(upx::compile_time::get_le64(le64.d) == v64);\n        static_assert(mem_eq(le64.d, \"\\x01\\x02\\x03\\x04\\x05\\x06\\x07\\x08\", 8));\n        upx::compile_time::mem_clear(buf, 8);\n        TestCT::noinline_set_le64(buf, v64);\n        assert_noexcept(TestCT::noinline_get_le64(buf) == v64);\n        assert_noexcept(upx::compile_time::get_le64(buf) == v64);\n        assert_noexcept(memcmp(buf, le64.d, 8) == 0);\n\n        static_assert(upx::compile_time::bswap16(upx::compile_time::get_be16(be16.d)) ==\n                      upx::compile_time::get_be16(le16.d));\n        static_assert(upx::compile_time::bswap32(upx::compile_time::get_be32(be32.d)) ==\n                      upx::compile_time::get_be32(le32.d));\n        static_assert(upx::compile_time::bswap64(upx::compile_time::get_be64(be64.d)) ==\n                      upx::compile_time::get_be64(le64.d));\n        assert_noexcept(TestCT::noinline_bswap16(TestCT::noinline_get_be16(be16.d)) ==\n                        TestCT::noinline_get_be16(le16.d));\n        assert_noexcept(TestCT::noinline_bswap32(TestCT::noinline_get_be32(be32.d)) ==\n                        TestCT::noinline_get_be32(le32.d));\n        assert_noexcept(TestCT::noinline_bswap64(TestCT::noinline_get_be64(be64.d)) ==\n                        TestCT::noinline_get_be64(le64.d));\n    }\n}\n\nTEST_CASE(\"upx::compile_time 2\") {\n    constexpr upx_uint16_t v16 = 0xf2f1;\n    constexpr upx_uint32_t v24 = 0xf3f2f1;\n    constexpr upx_uint32_t v32 = 0xf4f3f2f1;\n    constexpr upx_uint64_t v64 = 0xf8f7f6f5f4f3f2f1ull;\n    {\n        using upx::compile_time::mem_eq;\n        upx_alignas_max byte aligned_buffer[32];\n        byte *const buf1 = aligned_buffer + 3;\n        byte *const buf2 = aligned_buffer + 13;\n\n        upx::compile_time::set_be16(buf1, v16);\n        TestCT::noinline_set_be16(buf2, v16);\n        assert_noexcept(TestCT::noinline_get_be16(buf1) == v16);\n        assert_noexcept(TestCT::noinline_get_be16(buf2) == v16);\n        assert_noexcept(memcmp(buf1, buf2, 2) == 0);\n        upx::compile_time::set_be24(buf1, v24);\n        TestCT::noinline_set_be24(buf2, v24);\n        assert_noexcept(TestCT::noinline_get_be24(buf1) == v24);\n        assert_noexcept(TestCT::noinline_get_be24(buf2) == v24);\n        assert_noexcept(memcmp(buf1, buf2, 3) == 0);\n        upx::compile_time::set_be32(buf1, v32);\n        TestCT::noinline_set_be32(buf2, v32);\n        assert_noexcept(TestCT::noinline_get_be32(buf1) == v32);\n        assert_noexcept(TestCT::noinline_get_be32(buf2) == v32);\n        assert_noexcept(memcmp(buf1, buf2, 4) == 0);\n        upx::compile_time::set_be64(buf1, v64);\n        TestCT::noinline_set_be64(buf2, v64);\n        assert_noexcept(TestCT::noinline_get_be64(buf1) == v64);\n        assert_noexcept(TestCT::noinline_get_be64(buf2) == v64);\n        assert_noexcept(memcmp(buf1, buf2, 8) == 0);\n\n        upx::compile_time::set_le16(buf1, v16);\n        TestCT::noinline_set_le16(buf2, v16);\n        assert_noexcept(TestCT::noinline_get_le16(buf1) == v16);\n        assert_noexcept(TestCT::noinline_get_le16(buf2) == v16);\n        assert_noexcept(memcmp(buf1, buf2, 2) == 0);\n        upx::compile_time::set_le24(buf1, v24);\n        TestCT::noinline_set_le24(buf2, v24);\n        assert_noexcept(TestCT::noinline_get_le24(buf1) == v24);\n        assert_noexcept(TestCT::noinline_get_le24(buf2) == v24);\n        assert_noexcept(memcmp(buf1, buf2, 3) == 0);\n        upx::compile_time::set_le32(buf1, v32);\n        TestCT::noinline_set_le32(buf2, v32);\n        assert_noexcept(TestCT::noinline_get_le32(buf1) == v32);\n        assert_noexcept(TestCT::noinline_get_le32(buf2) == v32);\n        assert_noexcept(memcmp(buf1, buf2, 4) == 0);\n        upx::compile_time::set_le64(buf1, v64);\n        TestCT::noinline_set_le64(buf2, v64);\n        assert_noexcept(TestCT::noinline_get_le64(buf1) == v64);\n        assert_noexcept(TestCT::noinline_get_le64(buf2) == v64);\n        assert_noexcept(memcmp(buf1, buf2, 8) == 0);\n    }\n}\n\n/*************************************************************************\n// TriBool\n**************************************************************************/\n\nnamespace {\ntemplate <class T>\nstruct TestTriBool final {\n    static noinline void test(bool expect_true) {\n        static_assert(std::is_class<T>::value);\n        static_assert(std::is_nothrow_default_constructible<T>::value);\n        static_assert(std::is_nothrow_destructible<T>::value);\n        static_assert(std::is_standard_layout<T>::value);\n        static_assert(std::is_trivially_copyable<T>::value);\n        static_assert(sizeof(typename T::value_type) == sizeof(typename T::underlying_type));\n        static_assert(alignof(typename T::value_type) == alignof(typename T::underlying_type));\n#if defined(__m68k__) && defined(__atarist__) && defined(__GNUC__)\n        // broken compiler or broken ABI\n#elif defined(__i386__) && defined(__GNUC__) && (__GNUC__ == 7) && !defined(__clang__)\n        static_assert(sizeof(T) == sizeof(typename T::underlying_type));\n        // i386: \"long long\" enum align bug/ABI problem on older compilers\n        static_assert(alignof(T) <= alignof(typename T::underlying_type));\n#else\n        static_assert(sizeof(T) == sizeof(typename T::underlying_type));\n        static_assert(alignof(T) == alignof(typename T::underlying_type));\n#endif\n        static_assert(!bool(T(false)));\n        static_assert(bool(T(true)));\n        static_assert(bool(T(T::Third)) == T::is_third_true);\n        static_assert(T(false) == T::False);\n        static_assert(T(true) == T::True);\n        static_assert(T(T::False) == T::False);\n        static_assert(T(T::True) == T::True);\n        static_assert(T(T::Third) == T::Third);\n        static_assert(T(T::Third) == T(9));\n        static_assert(T(8) == T(9));\n        static_assert(!(T(0) == T(9)));\n        static_assert(!(T(1) == T(9)));\n        static_assert(T(T::Third) == 9);\n        static_assert(T(8) == 9);\n        static_assert(!(T(0) == 9));\n        static_assert(!(T(1) == 9));\n        constexpr T array[] = {false, true, T::Third};\n        static_assert(array[0].isStrictFalse());\n        static_assert(array[1].isStrictTrue());\n        static_assert(array[2].isThird());\n        static_assert(sizeof(array) == 3 * sizeof(T));\n        T a;\n        assert(a.getValue() == T::False);\n        assert(!a);\n        assert(!bool(a));\n        assert((!a ? true : false));\n        assert(a.isStrictFalse());\n        assert(!a.isStrictTrue());\n        assert(a.isStrictBool());\n        assert(!a.isThird());\n        a = false;\n        assert(a.getValue() == T::False);\n        assert(!a);\n        assert(!bool(a));\n        assert((!a ? true : false));\n        assert(a.isStrictFalse());\n        assert(!a.isStrictTrue());\n        assert(a.isStrictBool());\n        assert(!a.isThird());\n        a = true;\n        assert(a.getValue() == T::True);\n        assert(a);\n        assert(bool(a));\n        assert((a ? true : false));\n        assert(!a.isStrictFalse());\n        assert(a.isStrictTrue());\n        assert(a.isStrictBool());\n        assert(!a.isThird());\n        a = T::Third;\n        assert(a.getValue() == T::Third);\n        assert(T::is_third_true == expect_true);\n        if (expect_true) {\n            assert(a);\n            assert(bool(a));\n            assert((a ? true : false));\n        } else {\n            assert(!a);\n            assert(!bool(a));\n            assert((!a ? true : false));\n        }\n        assert(!a.isStrictFalse());\n        assert(!a.isStrictTrue());\n        assert(!a.isStrictBool());\n        assert(a.isThird());\n        a = 99;\n        assert(a.getValue() == T::Third);\n        if (expect_true) {\n            assert(a);\n            assert(bool(a));\n            assert((a ? true : false));\n            assert((!a ? false : true));\n        } else {\n            assert(!a);\n            assert(!bool(a));\n            assert((a ? false : true));\n            assert((!a ? true : false));\n        }\n        assert(!a.isStrictFalse());\n        assert(!a.isStrictTrue());\n        assert(!a.isStrictBool());\n        assert(a.isThird());\n        mem_clear(&a);\n        assert(a.isStrictFalse());\n    }\n};\n} // namespace\n\nTEST_CASE(\"upx::TriBool\") {\n    using upx::TriBool, upx::tribool;\n    static_assert(!tribool(false));\n    static_assert(tribool(true));\n    static_assert(!tribool(tribool::Third));\n    TestTriBool<tribool>::test(false);\n#if DEBUG || 1\n    TestTriBool<TriBool<upx_int8_t> >::test(false);\n    TestTriBool<TriBool<upx_uint8_t> >::test(false);\n    TestTriBool<TriBool<upx_int16_t> >::test(false);\n    TestTriBool<TriBool<upx_uint16_t> >::test(false);\n    TestTriBool<TriBool<upx_int32_t> >::test(false);\n    TestTriBool<TriBool<upx_uint32_t> >::test(false);\n    TestTriBool<TriBool<upx_int64_t> >::test(false);\n    TestTriBool<TriBool<upx_uint64_t> >::test(false);\n    TestTriBool<TriBool<upx_int8_t, true> >::test(true);\n    TestTriBool<TriBool<upx_uint8_t, true> >::test(true);\n    TestTriBool<TriBool<upx_int16_t, true> >::test(true);\n    TestTriBool<TriBool<upx_uint16_t, true> >::test(true);\n    TestTriBool<TriBool<upx_int32_t, true> >::test(true);\n    TestTriBool<TriBool<upx_uint32_t, true> >::test(true);\n    TestTriBool<TriBool<upx_int64_t, true> >::test(true);\n    TestTriBool<TriBool<upx_uint64_t, true> >::test(true);\n#endif\n}\n\n/* vim:set ts=4 sw=4 et: */\n","size_bytes":44115},"src/check/dt_impl.cpp":{"content":"/* dt_impl.cpp -- doctest support code implementation\n\n   This file is part of the Resize executable compressor.\n\n   Copyright (C) 2025 WHO-AM-I-404\n   Based on UPX - Ultimate Packer for eXecutables\n   Copyright (C) 1996-2025 Markus Franz Xaver Johannes Oberhumer\n   All Rights Reserved.\n\n   Resize and the UCL library are free software; you can redistribute them\n   and/or modify them under the terms of the GNU General Public License as\n   published by the Free Software Foundation; either version 2 of\n   the License, or (at your option) any later version.\n\n   This program is distributed in the hope that it will be useful,\n   but WITHOUT ANY WARRANTY; without even the implied warranty of\n   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n   GNU General Public License for more details.\n\n   You should have received a copy of the GNU General Public License\n   along with this program; see the file COPYING.\n   If not, write to the Free Software Foundation, Inc.,\n   59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.\n\n   Markus F.X.J. Oberhumer\n   <markus@oberhumer.com>\n */\n\n#include \"../util/system_defs.h\"\n#include \"../util/system_features.h\"\n\n/*************************************************************************\n// doctest support code implementation\n**************************************************************************/\n\n#define DOCTEST_CONFIG_IMPLEMENT\n#define DOCTEST_CONFIG_NO_UNPREFIXED_OPTIONS\n\n#if !defined(DOCTEST_CONFIG_DISABLE)\n\n#if defined(__wasi__)\n#define DOCTEST_CONFIG_NO_MULTITHREADING\n#define DOCTEST_CONFIG_NO_POSIX_SIGNALS\n#elif defined(__i386__) && defined(__MSDOS__) && defined(__DJGPP__) && defined(__GNUC__)\n#define DOCTEST_CONFIG_NO_MULTITHREADING\n#define DOCTEST_CONFIG_NO_POSIX_SIGNALS\n#elif defined(__m68k__) && defined(__atarist__) && defined(__GNUC__)\n#define DOCTEST_CONFIG_COLORS_NONE\n#define DOCTEST_CONFIG_NO_MULTITHREADING\n#define DOCTEST_CONFIG_NO_POSIX_SIGNALS\n#pragma GCC diagnostic ignored \"-Wshadow\"\n#endif\n\n#if !(WITH_THREADS) && !defined(UPX_DOCTEST_CONFIG_MULTITHREADING)\n#ifndef DOCTEST_CONFIG_NO_MULTITHREADING\n#define DOCTEST_CONFIG_NO_MULTITHREADING\n#endif\n#endif\n\n#if defined(__FAST_MATH__) && defined(__clang__) && (__clang_major__ + 0 > 0)\n#if __clang_major__ >= 6\n// warning: comparison with NaN always evaluates to false in fast floating point modes\n#pragma clang diagnostic ignored \"-Wtautological-constant-compare\"\n#endif\n#if defined(__has_warning)\n#if __has_warning(\"-Wnan-infinity-disabled\")\n// warning: use of NaN is undefined behavior due to the currently enabled floating-point options\n#pragma clang diagnostic ignored \"-Wnan-infinity-disabled\"\n#endif\n#endif\n#endif\n\n#include <doctest/doctest/parts/doctest.cpp>\n\n#endif // DOCTEST_CONFIG_DISABLE\n\n/* vim:set ts=4 sw=4 et: */\n","size_bytes":2775},"src/check/dt_xspan.cpp":{"content":"/* xspan -- a minimally invasive checked memory smart pointer\n\n   This file is part of the Resize executable compressor.\n\n   Copyright (C) 2025 WHO-AM-I-404\n   Based on UPX - Ultimate Packer for eXecutables\n   Copyright (C) 1996-2025 Markus Franz Xaver Johannes Oberhumer\n   All Rights Reserved.\n\n   Resize and the UCL library are free software; you can redistribute them\n   and/or modify them under the terms of the GNU General Public License as\n   published by the Free Software Foundation; either version 2 of\n   the License, or (at your option) any later version.\n\n   This program is distributed in the hope that it will be useful,\n   but WITHOUT ANY WARRANTY; without even the implied warranty of\n   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n   GNU General Public License for more details.\n\n   You should have received a copy of the GNU General Public License\n   along with this program; see the file COPYING.\n   If not, write to the Free Software Foundation, Inc.,\n   59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.\n\n   Markus F.X.J. Oberhumer\n   <markus@oberhumer.com>\n */\n\n// lots of tests (and probably quite a number of redundant tests)\n\n#include \"../conf.h\"\n\n/*************************************************************************\n// raw_bytes\n**************************************************************************/\n\nTEST_CASE(\"raw_bytes ptr\") {\n    upx_uint16_t *ptr = nullptr;\n    CHECK_NOTHROW(raw_bytes(ptr, 0));\n    CHECK_THROWS(raw_bytes(ptr, 1));\n    CHECK_THROWS(raw_index_bytes(ptr, 0, 0));\n    CHECK_THROWS(raw_index_bytes(ptr, 1, 0));\n    CHECK_THROWS(raw_index_bytes(ptr, 0, 1));\n    upx_uint16_t buf[4];\n    ptr = buf;\n    CHECK(ptr_udiff_bytes(raw_index_bytes(ptr, 1, 1), ptr) == 2u);\n    CHECK(ptr_udiff_bytes(raw_index_bytes(ptr, 4, 0), ptr) == 8u);\n    UNUSED(ptr);\n}\n\nTEST_CASE(\"raw_bytes bounded array\") {\n    upx_uint16_t buf[4];\n    CHECK_NOTHROW(raw_bytes(buf, 8));\n    CHECK_THROWS(raw_bytes(buf, 9));\n    CHECK_NOTHROW(raw_index_bytes(buf, 4, 0));\n    CHECK_THROWS(raw_index_bytes(buf, 4, 1));\n    CHECK_NOTHROW(raw_index_bytes(buf, 3, 2));\n    CHECK_THROWS(raw_index_bytes(buf, 3, 3));\n    CHECK(ptr_udiff_bytes(raw_index_bytes(buf, 1, 1), buf) == 2u);\n    CHECK(ptr_udiff_bytes(raw_index_bytes(buf, 4, 0), buf) == 8u);\n    UNUSED(buf);\n}\n\n/*************************************************************************\n// basic xspan\n**************************************************************************/\n\nTEST_CASE(\"basic xspan usage\") {\n    alignas(4) char buf[4] = {0, 1, 2, 3};\n\n    SUBCASE(\"XSPAN_x\") {\n        XSPAN_0(char) a0 = nullptr;\n\n        XSPAN_0(char) b0 = buf;\n        XSPAN_P(char) bp = buf;\n\n        XSPAN_0(char) c0 = XSPAN_0_MAKE(char, buf);\n        XSPAN_P(char) cp = XSPAN_P_MAKE(char, buf);\n        XSPAN_S(char) cs = XSPAN_S_MAKE(char, buf, sizeof(buf));\n\n        XSPAN_0(const char) const x0 = XSPAN_0_MAKE(const char, buf);\n        XSPAN_P(const char) const xp = XSPAN_P_MAKE(const char, buf);\n        XSPAN_S(const char) const xs = XSPAN_S_MAKE(const char, buf, sizeof(buf));\n        XSPAN_P(const char) const yp = xs;\n        XSPAN_0(const char) const z0p = yp;\n        XSPAN_0(const char) const z0s = xs;\n\n        CHECK((a0 == nullptr));\n        CHECK(c0 == b0);\n        CHECK(cp == bp);\n        CHECK(cs == bp);\n        CHECK(x0 == z0p);\n        CHECK(xp == z0s);\n\n        CHECK_NOTHROW(raw_bytes(a0, 0));\n        CHECK_THROWS(raw_bytes(a0, 1));\n        CHECK_THROWS(raw_index_bytes(a0, 0, 0));\n\n        CHECK(raw_bytes(b0, 0) == buf);\n        CHECK(raw_bytes(bp, 0) == buf);\n        // info: these will fail if we ever add an overload for bounded-arrays\n#if WITH_XSPAN >= 2\n        CHECK(b0.raw_size_in_bytes() == 0u);\n        CHECK(bp.raw_size_in_bytes() == 0u);\n#endif\n        CHECK(raw_bytes(b0, 999999) == buf);\n        CHECK(raw_bytes(bp, 999999) == buf);\n\n        CHECK(raw_bytes(c0, 4) == buf);\n        CHECK(raw_index_bytes(c0, 1, 3) == buf + 1);\n        CHECK(raw_bytes(cp, 4) == buf);\n        CHECK(raw_index_bytes(cp, 1, 3) == buf + 1);\n        CHECK(raw_bytes(cs, 4) == buf);\n        CHECK(raw_index_bytes(cs, 1, 3) == buf + 1);\n#if WITH_XSPAN >= 2\n        CHECK_THROWS(raw_bytes(cs, 5));\n        CHECK_THROWS(raw_index_bytes(cs, 1, 4));\n#endif\n\n        XSPAN_0(upx_uint16_t) c0_2 = XSPAN_TYPE_CAST(upx_uint16_t, c0 + 2);\n        XSPAN_P(upx_uint16_t) cp_2 = XSPAN_TYPE_CAST(upx_uint16_t, cp + 2);\n        XSPAN_S(upx_uint16_t) cs_2 = XSPAN_TYPE_CAST(upx_uint16_t, cs + 2);\n        CHECK(ptr_udiff_bytes(c0_2, c0) == 2u);\n        CHECK(ptr_udiff_bytes(cp_2, c0) == 2u);\n        CHECK(ptr_udiff_bytes(cs_2, c0) == 2u);\n        CHECK(ptr_udiff_bytes(c0_2, cp) == 2u);\n        CHECK(ptr_udiff_bytes(cp_2, cp) == 2u);\n        CHECK(ptr_udiff_bytes(cs_2, cp) == 2u);\n        CHECK(ptr_udiff_bytes(c0_2, cs) == 2u);\n        CHECK(ptr_udiff_bytes(cp_2, cs) == 2u);\n        CHECK(ptr_udiff_bytes(cs_2, cs) == 2u);\n        XSPAN_0(upx_uint16_t) c0_2b = XSPAN_TYPE_CAST(upx_uint16_t, c0) + 1;\n        XSPAN_P(upx_uint16_t) cp_2b = XSPAN_TYPE_CAST(upx_uint16_t, cp) + 1;\n        XSPAN_S(upx_uint16_t) cs_2b = XSPAN_TYPE_CAST(upx_uint16_t, cs) + 1;\n        CHECK(c0_2 == c0_2b);\n        CHECK(cp_2 == cp_2b);\n        CHECK(cs_2 == cs_2b);\n\n        CHECK(sizeof(*c0) == 1u);\n        CHECK(sizeof(*c0_2) == 2u);\n    }\n\n    SUBCASE(\"XSPAN_x_VAR\") {\n        XSPAN_0_VAR(char, b0, buf);\n        XSPAN_P_VAR(char, bp, buf);\n\n        XSPAN_0_VAR(char, c0, buf, sizeof(buf));\n        XSPAN_P_VAR(char, cp, buf, sizeof(buf));\n        XSPAN_S_VAR(char, cs, buf, sizeof(buf));\n\n        XSPAN_0_VAR(char, d0, buf + 1, sizeof(buf), buf);\n        XSPAN_P_VAR(char, dp, buf + 1, sizeof(buf), buf);\n        XSPAN_S_VAR(char, ds, buf + 1, sizeof(buf), buf);\n\n        XSPAN_0_VAR(const char, const x0, buf, sizeof(buf));\n        XSPAN_P_VAR(const char, const xp, buf, sizeof(buf));\n        XSPAN_S_VAR(const char, const xs, buf, sizeof(buf));\n        XSPAN_P_VAR(const char, const yp, xs);\n        XSPAN_0_VAR(const char, const z0p, yp);\n        XSPAN_0_VAR(const char, const z0s, xs);\n\n        CHECK(c0 == b0);\n        CHECK(cp == bp);\n        CHECK(cs == bp);\n        CHECK(d0 == dp);\n        CHECK(d0 == ds);\n        CHECK(x0 == z0p);\n        CHECK(xp == z0s);\n\n#if WITH_XSPAN >= 1 || __cplusplus >= 201103L\n        XSPAN_0_VAR(char, a0, nullptr);\n        CHECK((a0 == nullptr));\n        CHECK_NOTHROW(raw_bytes(a0, 0));\n        CHECK_THROWS(raw_bytes(a0, 1));\n        CHECK_THROWS(raw_index_bytes(a0, 0, 0));\n#endif\n\n        CHECK(raw_bytes(b0, 0) == buf);\n        CHECK(raw_bytes(bp, 0) == buf);\n        // info: these will fail if we ever add an overload for bounded-arrays\n#if WITH_XSPAN >= 2\n        CHECK(b0.raw_size_in_bytes() == 0u);\n        CHECK(bp.raw_size_in_bytes() == 0u);\n#endif\n        CHECK(raw_bytes(b0, 999999) == buf);\n        CHECK(raw_bytes(bp, 999999) == buf);\n\n        CHECK(raw_bytes(c0, 4) == buf);\n        CHECK(raw_index_bytes(c0, 1, 3) == buf + 1);\n        CHECK(raw_bytes(cp, 4) == buf);\n        CHECK(raw_index_bytes(cp, 1, 3) == buf + 1);\n        CHECK(raw_bytes(cs, 4) == buf);\n        CHECK(raw_index_bytes(cs, 1, 3) == buf + 1);\n#if WITH_XSPAN >= 2\n        CHECK_THROWS(raw_bytes(cs, 5));\n        CHECK_THROWS(raw_index_bytes(cs, 1, 4));\n#endif\n\n        XSPAN_0_VAR(upx_uint16_t, c0_2, XSPAN_TYPE_CAST(upx_uint16_t, c0 + 2));\n        XSPAN_P_VAR(upx_uint16_t, cp_2, XSPAN_TYPE_CAST(upx_uint16_t, cp + 2));\n        XSPAN_S_VAR(upx_uint16_t, cs_2, XSPAN_TYPE_CAST(upx_uint16_t, cs + 2));\n        CHECK(ptr_udiff_bytes(c0_2, c0) == 2u);\n        CHECK(ptr_udiff_bytes(cp_2, c0) == 2u);\n        CHECK(ptr_udiff_bytes(cs_2, c0) == 2u);\n        CHECK(ptr_udiff_bytes(c0_2, cp) == 2u);\n        CHECK(ptr_udiff_bytes(cp_2, cp) == 2u);\n        CHECK(ptr_udiff_bytes(cs_2, cp) == 2u);\n        CHECK(ptr_udiff_bytes(c0_2, cs) == 2u);\n        CHECK(ptr_udiff_bytes(cp_2, cs) == 2u);\n        CHECK(ptr_udiff_bytes(cs_2, cs) == 2u);\n        XSPAN_0_VAR(upx_uint16_t, c0_2b, XSPAN_TYPE_CAST(upx_uint16_t, c0) + 1);\n        XSPAN_P_VAR(upx_uint16_t, cp_2b, XSPAN_TYPE_CAST(upx_uint16_t, cp) + 1);\n        XSPAN_S_VAR(upx_uint16_t, cs_2b, XSPAN_TYPE_CAST(upx_uint16_t, cs) + 1);\n        CHECK(c0_2 == c0_2b);\n        CHECK(cp_2 == cp_2b);\n        CHECK(cs_2 == cs_2b);\n\n        CHECK(sizeof(*c0) == 1u);\n        CHECK(sizeof(*c0_2) == 2u);\n    }\n\n    SUBCASE(\"xspan in class\") {\n        struct MyType {\n            XSPAN_0(char) s0;\n            XSPAN_P(char) sp;\n            XSPAN_S(char) ss;\n#if __cplusplus >= 201103L\n            XSPAN_0(char) x0 = nullptr;\n#endif\n#if WITH_XSPAN >= 2\n            // much nicer syntax when using fully checked xspan:\n            MyType(char *b, size_t n, bool) : s0(b, n), sp(b, n), ss(b, n) {}\n#endif\n            MyType(char *b, size_t n)\n                : s0(XSPAN_0_MAKE(char, b, n)), sp(XSPAN_P_MAKE(char, b, n)),\n                  ss(XSPAN_S_MAKE(char, b, n)) {\n                UNUSED(n);\n            }\n        };\n        MyType x(buf, sizeof(buf));\n        MyType y = MyType(buf, sizeof(buf));\n        CHECK(x.s0 == y.sp);\n    }\n}\n\nTEST_CASE(\"xspan array access\") {\n    const size_t N = 16;\n    char buf[N];\n    memset(buf, 0, sizeof(buf));\n    XSPAN_0_VAR(char, c0, buf, sizeof(buf));\n    XSPAN_P_VAR(char, cp, buf, sizeof(buf));\n    XSPAN_S_VAR(char, cs, buf, sizeof(buf));\n    for (size_t i = 0; i != N; ++i)\n        c0[i] += 1;\n    for (size_t i = 0; i != N; ++i)\n        cp[i] += 1;\n    for (size_t i = 0; i != N; ++i)\n        cs[i] += 1;\n#if __cplusplus >= 201103L\n    for (auto ptr = c0; ptr != c0 + N; ++ptr)\n        *ptr += 1;\n    for (auto ptr = c0 + 0; ptr < c0 + N; ++ptr)\n        *ptr += 1;\n    for (auto ptr = cp; ptr != cp + N; ++ptr)\n        *ptr += 1;\n    for (auto ptr = cp + 0; ptr < cp + N; ++ptr)\n        *ptr += 1;\n    for (auto ptr = cs; ptr != cs + N; ++ptr)\n        *ptr += 1;\n    for (auto ptr = cs + 0; ptr < cs + N; ++ptr)\n        *ptr += 1;\n#endif\n}\n\n/*************************************************************************\n//\n**************************************************************************/\n\n#if (WITH_XSPAN >= 2) && DEBUG\n\nTEST_CASE(\"PtrOrSpanOrNull\") {\n    char real_buf[2 + 6 + 2] = {126, 127, 0, 1, 2, 3, 4, 5, 124, 125};\n    char *base_buf = real_buf + 2;\n    char *const my_null = nullptr;\n    typedef PtrOrSpanOrNull<char> Span0;\n\n    // basic nullptr\n    CHECK_NOTHROW(Span0(base_buf, 4, base_buf) = my_null);\n    CHECK_NOTHROW(Span0(base_buf, 4, base_buf).assign(my_null));\n    // basic range checking\n    CHECK_NOTHROW(Span0(base_buf, 4, base_buf));\n    CHECK_NOTHROW(Span0(base_buf, 0, base_buf));\n    CHECK_NOTHROW(Span0(base_buf, 0, base_buf) - 0);\n    CHECK_THROWS(Span0(base_buf, 0, base_buf) + 1);\n    CHECK_THROWS(Span0(base_buf, 0, base_buf) - 1);\n    CHECK_NOTHROW(Span0(base_buf, 4, base_buf) + 4);\n    CHECK_THROWS(Span0(base_buf, 4, base_buf) + 5);\n    CHECK_THROWS(Span0(base_buf - 1, 4, base_buf));\n    CHECK_THROWS(Span0(base_buf + 1, 0, base_buf));\n    // basic same base\n    CHECK_NOTHROW(Span0(base_buf, 4, base_buf) = Span0(base_buf + 1, 3, base_buf));\n    CHECK_NOTHROW(Span0(base_buf, 4, base_buf) = Span0(base_buf + 1, 1, base_buf));\n    CHECK_NOTHROW(Span0(base_buf, 4, base_buf) = Span0(base_buf + 1, 5, base_buf));\n    CHECK_THROWS(Span0(base_buf, 4, base_buf) = Span0(base_buf + 1, 3, base_buf + 1));\n\n    Span0 a1(nullptr);\n    assert(a1 == nullptr);\n    assert(a1.raw_ptr() == nullptr);\n    assert(a1.raw_base() == nullptr);\n    assert(a1.raw_size_in_bytes() == 0u);\n    CHECK_THROWS(*a1);\n    CHECK_THROWS(a1[0]);\n\n    Span0 a2 = nullptr;\n    assert(a2 == nullptr);\n    assert(a2.raw_ptr() == nullptr);\n    assert(a2.raw_base() == nullptr);\n    assert(a2.raw_size_in_bytes() == 0u);\n    CHECK_THROWS(*a2);\n    CHECK_THROWS(a2[0]);\n\n    Span0 base0(nullptr, 4, base_buf);\n    assert(base0.raw_ptr() == nullptr);\n    assert(base0.raw_base() == base_buf);\n    assert(base0.raw_size_in_bytes() == 4u);\n    CHECK_THROWS(*base0);    // nullptr\n    CHECK_THROWS(base0[0]);  // nullptr\n    CHECK_THROWS(base0 + 1); // nullptr\n\n    Span0 base4(base_buf, 4);\n    assert(base4.raw_ptr() == base_buf);\n    assert(base4.raw_base() == base_buf);\n    assert(base4.raw_size_in_bytes() == 4u);\n\n    a1 = base_buf;\n    a1 = base0;\n    assert(a1 == nullptr);\n    assert(a1.raw_ptr() == nullptr);\n    assert(a1.raw_base() == base_buf);\n    assert(a1.raw_size_in_bytes() == 4u);\n    a1 = base4;\n    assert(a1 == base_buf);\n    assert(a1.raw_ptr() == base_buf);\n    assert(a1.raw_base() == base_buf);\n    assert(a1.raw_size_in_bytes() == 4u);\n\n    a1 = base_buf;\n    assert(a1 != nullptr);\n    a1 = base_buf + 1;\n    CHECK(*a1++ == 1);\n    CHECK(*++a1 == 3);\n    CHECK(*a1 == 3);\n    a1 = base_buf + 4; // at the end of buffer\n    CHECK_THROWS(*a1);\n    CHECK_THROWS(a1 = base_buf + 5); // range error\n    assert(a1 == base_buf + 4);\n    CHECK(a1[-4] == 0);\n    CHECK_THROWS(a1[-5]); // range error\n    a1 = base_buf;\n    CHECK(*a1 == 0);\n\n    Span0 new_base4(base_buf + 2, 4);\n    CHECK_THROWS(a1 = new_base4); // not same base\n    a2 = new_base4;\n    CHECK_THROWS(a2 = base4); // not same base\n\n    Span0 s0_no_base(nullptr);\n    Span0 s0_with_base(nullptr, 4, base_buf);\n    s0_no_base = nullptr;\n    s0_with_base = nullptr;\n    s0_with_base = s0_no_base;\n    assert(s0_no_base.raw_base() == nullptr);\n    assert(s0_with_base.raw_base() == base_buf);\n    s0_no_base = s0_with_base;\n    assert(s0_no_base.raw_base() == base_buf);\n    assert(s0_no_base.raw_ptr() == nullptr);\n    assert(s0_with_base.raw_ptr() == nullptr);\n    s0_no_base = my_null;\n    s0_with_base = my_null;\n}\n\n/*************************************************************************\n//\n**************************************************************************/\n\nTEST_CASE(\"PtrOrSpan\") {\n    char real_buf[2 + 6 + 2] = {126, 127, 0, 1, 2, 3, 4, 5, 124, 125};\n    char *base_buf = real_buf + 2;\n    char *const my_null = nullptr;\n    typedef PtrOrSpan<char> SpanP;\n\n    // basic nullptr\n    CHECK_THROWS(SpanP(base_buf, 4, base_buf) = my_null);\n    CHECK_THROWS(SpanP(base_buf, 4, base_buf).assign(my_null));\n    // basic range checking\n    CHECK_NOTHROW(SpanP(base_buf, 4, base_buf));\n    CHECK_NOTHROW(SpanP(base_buf, 0, base_buf));\n    CHECK_NOTHROW(SpanP(base_buf, 0, base_buf) - 0);\n    CHECK_THROWS(SpanP(base_buf, 0, base_buf) + 1);\n    CHECK_THROWS(SpanP(base_buf, 0, base_buf) - 1);\n    CHECK_NOTHROW(SpanP(base_buf, 4, base_buf) + 4);\n    CHECK_THROWS(SpanP(base_buf, 4, base_buf) + 5);\n    CHECK_THROWS(SpanP(base_buf - 1, 4, base_buf));\n    CHECK_THROWS(SpanP(base_buf + 1, 0, base_buf));\n    // basic same base\n    CHECK_NOTHROW(SpanP(base_buf, 4, base_buf) = SpanP(base_buf + 1, 3, base_buf));\n    CHECK_NOTHROW(SpanP(base_buf, 4, base_buf) = SpanP(base_buf + 1, 1, base_buf));\n    CHECK_NOTHROW(SpanP(base_buf, 4, base_buf) = SpanP(base_buf + 1, 5, base_buf));\n    CHECK_THROWS(SpanP(base_buf, 4, base_buf) = SpanP(base_buf + 1, 3, base_buf + 1));\n\n    SpanP x1(base_buf, 0);\n    assert(x1 != nullptr);\n    assert(x1.raw_ptr() == base_buf);\n    assert(x1.raw_base() == base_buf);\n    assert(x1.raw_size_in_bytes() == 0u);\n    CHECK_THROWS(*x1);\n    CHECK_THROWS(x1[0]);\n\n    SpanP a2 = base_buf;\n    assert(a2 != nullptr);\n    assert(a2.raw_ptr() == base_buf);\n    assert(a2.raw_base() == nullptr);\n    assert(a2.raw_size_in_bytes() == 0u);\n    CHECK(*a2 == 0);\n    CHECK(a2[1] == 1);\n\n    SpanP base0(base_buf, 4, base_buf);\n    assert(base0.raw_ptr() == base_buf);\n    assert(base0.raw_base() == base_buf);\n    assert(base0.raw_size_in_bytes() == 4u);\n\n    SpanP base4(base_buf, 4);\n    assert(base4.raw_ptr() == base_buf);\n    assert(base4.raw_base() == base_buf);\n    assert(base4.raw_size_in_bytes() == 4u);\n\n    SpanP a1(base_buf, 4);\n    a1 = base_buf;\n    a1 = base0;\n    assert(a1 == base0);\n    assert(a1 != nullptr);\n    assert(a1.raw_ptr() == base0.raw_ptr());\n    assert(a1.raw_base() == base_buf);\n    assert(a1.raw_size_in_bytes() == 4u);\n    a1 = base4;\n    assert(a1 == base_buf);\n    assert(a1.raw_ptr() == base_buf);\n    assert(a1.raw_base() == base_buf);\n    assert(a1.raw_size_in_bytes() == 4u);\n\n    a1 = base_buf;\n    a1 = base_buf + 1;\n    CHECK(*a1++ == 1);\n    CHECK(*++a1 == 3);\n    CHECK(*a1 == 3);\n    a1 = base_buf + 4; // at the end of buffer\n    CHECK_THROWS(*a1);\n    CHECK_THROWS(a1 = base_buf + 5); // range error\n    assert(a1 == base_buf + 4);\n    CHECK(a1[-4] == 0);\n    CHECK_THROWS(a1[-5]); // range error\n    a1 = base_buf;\n    CHECK(*a1 == 0);\n\n    SpanP new_base4(base_buf + 2, 4);\n    CHECK_THROWS(a1 = new_base4); // not same base\n    a2 = new_base4;\n    CHECK_THROWS(a2 = base4); // not same base\n\n    SpanP sp_no_base(base_buf);\n    SpanP sp_with_base(base_buf, 4, base_buf);\n    assert(sp_no_base.raw_base() == nullptr);\n    assert(sp_with_base.raw_base() == base_buf);\n    CHECK_THROWS(sp_no_base = my_null);   // nullptr assignment\n    CHECK_THROWS(sp_with_base = my_null); // nullptr assignment\n#if XSPAN_CONFIG_ENABLE_SPAN_CONVERSION\n    typedef PtrOrSpanOrNull<char> Span0;\n    Span0 s0_no_base(nullptr);\n    Span0 s0_with_base(nullptr, 4, base_buf);\n    CHECK_THROWS(sp_no_base = s0_no_base);     // nullptr assignment\n    CHECK_THROWS(sp_no_base = s0_with_base);   // nullptr assignment\n    CHECK_THROWS(sp_with_base = s0_no_base);   // nullptr assignment\n    CHECK_THROWS(sp_with_base = s0_with_base); // nullptr assignment\n#endif\n    UNUSED(my_null);\n}\n\n/*************************************************************************\n//\n**************************************************************************/\n\nTEST_CASE(\"Span\") {\n    char real_buf[2 + 6 + 2] = {126, 127, 0, 1, 2, 3, 4, 5, 124, 125};\n    char *base_buf = real_buf + 2;\n    char *const my_null = nullptr;\n    typedef Span<char> SpanS;\n\n    // basic nullptr\n    CHECK_THROWS(SpanS(base_buf, 4, base_buf) = my_null);\n    CHECK_THROWS(SpanS(base_buf, 4, base_buf).assign(my_null));\n    // basic range checking\n    CHECK_NOTHROW(SpanS(base_buf, 4, base_buf));\n    CHECK_NOTHROW(SpanS(base_buf, 0, base_buf));\n    CHECK_NOTHROW(SpanS(base_buf, 0, base_buf) - 0);\n    CHECK_THROWS(SpanS(base_buf, 0, base_buf) + 1);\n    CHECK_THROWS(SpanS(base_buf, 0, base_buf) - 1);\n    CHECK_NOTHROW(SpanS(base_buf, 4, base_buf) + 4);\n    CHECK_THROWS(SpanS(base_buf, 4, base_buf) + 5);\n    CHECK_THROWS(SpanS(base_buf - 1, 4, base_buf));\n    CHECK_THROWS(SpanS(base_buf + 1, 0, base_buf));\n    // basic same base\n    CHECK_NOTHROW(SpanS(base_buf, 4, base_buf) = SpanS(base_buf + 1, 3, base_buf));\n    CHECK_NOTHROW(SpanS(base_buf, 4, base_buf) = SpanS(base_buf + 1, 1, base_buf));\n    CHECK_NOTHROW(SpanS(base_buf, 4, base_buf) = SpanS(base_buf + 1, 5, base_buf));\n    CHECK_THROWS(SpanS(base_buf, 4, base_buf) = SpanS(base_buf + 1, 3, base_buf + 1));\n\n    SpanS x1(base_buf, 0);\n    assert(x1 != nullptr);\n    assert(x1.raw_ptr() == base_buf);\n    assert(x1.raw_base() == base_buf);\n    assert(x1.raw_size_in_bytes() == 0u);\n    CHECK_THROWS(*x1);\n    CHECK_THROWS(x1[0]);\n\n    SpanS a2(base_buf, 4);\n    assert(a2 != nullptr);\n    assert(a2.raw_ptr() == base_buf);\n    assert(a2.raw_base() == base_buf);\n    assert(a2.raw_size_in_bytes() == 4u);\n    CHECK(*a2 == 0);\n    CHECK(a2[1] == 1);\n\n    SpanS base0(base_buf, 4, base_buf);\n    assert(base0.raw_ptr() == base_buf);\n    assert(base0.raw_base() == base_buf);\n    assert(base0.raw_size_in_bytes() == 4u);\n\n    SpanS base4(base_buf, 4);\n    assert(base4.raw_ptr() == base_buf);\n    assert(base4.raw_base() == base_buf);\n    assert(base4.raw_size_in_bytes() == 4u);\n\n    SpanS a1(base_buf, 4);\n    a1 = base_buf;\n    a1 = base0;\n    assert(a1 == base0);\n    assert(a1 != nullptr);\n    assert(a1.raw_ptr() == base0.raw_ptr());\n    assert(a1.raw_base() == base_buf);\n    assert(a1.raw_size_in_bytes() == 4u);\n    a1 = base4;\n    assert(a1 == base_buf);\n    assert(a1.raw_ptr() == base_buf);\n    assert(a1.raw_base() == base_buf);\n    assert(a1.raw_size_in_bytes() == 4u);\n\n    a1 = base_buf;\n    a1 = base_buf + 1;\n    CHECK(*a1++ == 1);\n    CHECK(*++a1 == 3);\n    CHECK(*a1 == 3);\n    a1 = base_buf + 4; // at the end of buffer\n    CHECK_THROWS(*a1);\n    CHECK_THROWS(a1 = base_buf + 5); // range error\n    assert(a1 == base_buf + 4);\n    CHECK(a1[-4] == 0);\n    CHECK_THROWS(a1[-5]); // range error\n    a1 = base_buf;\n    CHECK(*a1 == 0);\n\n    SpanS new_base4(base_buf + 2, 4);\n    CHECK_THROWS(a1 = new_base4); // not same base\n    CHECK_THROWS(a2 = new_base4); // not same base\n\n    SpanS ss_with_base(base_buf, 4, base_buf);\n    assert(ss_with_base.raw_base() == base_buf);\n    CHECK_THROWS(ss_with_base = my_null); // nullptr assignment\n#if XSPAN_CONFIG_ENABLE_SPAN_CONVERSION\n    {\n        typedef PtrOrSpanOrNull<char> Span0;\n        // v0 nullptr, b0 base, b1 base + 1\n        const Span0 v0_v0(nullptr);\n        const Span0 v0_b0(nullptr, 4, base_buf);\n        const Span0 v0_b1(nullptr, 3, base_buf + 1);\n        const Span0 b0_v0(base_buf);\n        const Span0 b0_b0(base_buf, 4, base_buf);\n        CHECK_THROWS(XSPAN_0_MAKE(char, base_buf, 3, base_buf + 1)); // b0_b1\n        const Span0 b1_v0(base_buf + 1);\n        const Span0 b1_b0(base_buf + 1, 4, base_buf);\n        const Span0 b1_b1(base_buf + 1, 3, base_buf + 1);\n        CHECK_THROWS(ss_with_base = v0_v0); // nullptr assignment\n        CHECK_THROWS(ss_with_base = v0_b0); // nullptr assignment\n        CHECK_THROWS(ss_with_base = v0_b1); // nullptr assignment\n        CHECK_NOTHROW(ss_with_base = b0_v0);\n        CHECK_NOTHROW(ss_with_base = b0_b0);\n        CHECK_NOTHROW(ss_with_base = b1_v0);\n        CHECK_NOTHROW(ss_with_base = b1_b0);\n        CHECK_THROWS(ss_with_base = b1_b1); // different base\n        CHECK_THROWS(XSPAN_S_MAKE(char, v0_v0));\n        CHECK_THROWS(XSPAN_S_MAKE(char, v0_b0));\n        CHECK_THROWS(XSPAN_S_MAKE(char, v0_b1));\n        CHECK_THROWS(XSPAN_S_MAKE(char, b0_v0));\n        CHECK_NOTHROW(XSPAN_S_MAKE(char, b0_b0));\n        CHECK_THROWS(XSPAN_S_MAKE(char, b1_v0));\n        CHECK_NOTHROW(XSPAN_S_MAKE(char, b1_b0));\n        CHECK_NOTHROW(XSPAN_S_MAKE(char, b1_b1));\n        //\n        CHECK((XSPAN_S_MAKE(char, b0_b0).raw_base() == base_buf));\n        CHECK((XSPAN_S_MAKE(char, b1_b0).raw_base() == base_buf));\n        CHECK((XSPAN_S_MAKE(char, b1_b1).raw_base() == base_buf + 1));\n    }\n    {\n        typedef PtrOrSpan<char> SpanP;\n        // v0 nullptr, b0 base, b1 base + 1\n        const SpanP b0_v0(base_buf);\n        const SpanP b0_b0(base_buf, 4, base_buf);\n        CHECK_THROWS(XSPAN_P_MAKE(char, base_buf, 3, base_buf + 1)); // b0_b1\n        const SpanP b1_v0(base_buf + 1);\n        const SpanP b1_b0(base_buf + 1, 4, base_buf);\n        const SpanP b1_b1(base_buf + 1, 3, base_buf + 1);\n        CHECK_NOTHROW(ss_with_base = b0_v0);\n        CHECK_NOTHROW(ss_with_base = b0_b0);\n        CHECK_NOTHROW(ss_with_base = b1_v0);\n        CHECK_NOTHROW(ss_with_base = b1_b0);\n        CHECK_THROWS(ss_with_base = b1_b1); // different base\n        CHECK_THROWS(XSPAN_S_MAKE(char, b0_v0));\n        CHECK_NOTHROW(XSPAN_S_MAKE(char, b0_b0));\n        CHECK_THROWS(XSPAN_S_MAKE(char, b1_v0));\n        CHECK_NOTHROW(XSPAN_S_MAKE(char, b1_b0));\n        CHECK_NOTHROW(XSPAN_S_MAKE(char, b1_b1));\n        //\n        CHECK((XSPAN_S_MAKE(char, b0_b0).raw_base() == base_buf));\n        CHECK((XSPAN_S_MAKE(char, b1_b0).raw_base() == base_buf));\n        CHECK((XSPAN_S_MAKE(char, b1_b1).raw_base() == base_buf + 1));\n    }\n#endif\n    UNUSED(my_null);\n}\n\n/*************************************************************************\n//\n**************************************************************************/\n\nTEST_CASE(\"Span void ptr\") {\n    static char a[4] = {0, 1, 2, 3};\n    XSPAN_0(void) a0(a, 4);\n    XSPAN_P(void) ap(a, 4);\n    XSPAN_S(void) as(a, 4);\n    XSPAN_0(const void) c0(a, 4);\n    XSPAN_P(const void) cp(a, 4);\n    XSPAN_S(const void) cs(a, 4);\n    static const char b[4] = {0, 1, 2, 3};\n    XSPAN_0(const void) b0(b, 4);\n    XSPAN_P(const void) bp(b, 4);\n    XSPAN_S(const void) bs(b, 4);\n}\n\nTEST_CASE(\"Span deref/array/arrow\") {\n    static char real_a[2 + 4 + 2] = {126, 127, 0, 1, 2, 3, 124, 125};\n    static char *a = real_a + 2;\n    XSPAN_0(char) a0(a, 4);\n    XSPAN_P(char) ap(a, 4);\n    XSPAN_S(char) as(a, 4);\n    CHECK_THROWS(a0[4]);\n    CHECK_THROWS(a0[-1]);\n    CHECK_THROWS(a0[-2]);\n    a0 += 2;\n    CHECK(*a0 == 2);\n    CHECK(a0[-1] == 1);\n    CHECK(a0[0] == 2);\n    CHECK(a0[1] == 3);\n    ap += 2;\n    CHECK(*ap == 2);\n    CHECK(ap[-1] == 1);\n    CHECK(ap[0] == 2);\n    CHECK(ap[1] == 3);\n    as += 2;\n    CHECK(*as == 2);\n    CHECK(as[-1] == 1);\n    CHECK(as[0] == 2);\n    CHECK(as[1] == 3);\n}\n\nTEST_CASE(\"Span subspan\") {\n    static char buf[4] = {0, 1, 2, 3};\n    XSPAN_S(char) as(buf, 4);\n    CHECK(as.subspan(1, 1)[0] == 1);\n    CHECK((as + 1).subspan(1, 1)[0] == 2);\n    CHECK((as + 2).subspan(0, -2)[0] == 0);\n    CHECK_THROWS(as.subspan(1, 0)[0]);\n    CHECK_THROWS(as.subspan(1, 1)[-1]);\n    CHECK(as.subspan(1)[0] == 1);\n    CHECK(as.subspan(2)[0] == 2);\n    CHECK(as.subspan(3)[0] == 3);\n}\n\nTEST_CASE(\"Span constness\") {\n    static char buf[4] = {0, 1, 2, 3};\n\n    // NOLINTBEGIN(performance-unnecessary-copy-initialization)\n\n    XSPAN_0(char) b0(buf, 4);\n    XSPAN_P(char) bp(buf, 4);\n    XSPAN_S(char) bs(buf, 4);\n\n    XSPAN_0(char) s0(b0);\n    XSPAN_P(char) sp(bp);\n    XSPAN_S(char) ss(bs);\n\n    XSPAN_0(const char) b0c(buf, 4);\n    XSPAN_P(const char) bpc(buf, 4);\n    XSPAN_S(const char) bsc(buf, 4);\n\n    XSPAN_0(const char) s0c(b0c);\n    XSPAN_P(const char) spc(bpc);\n    XSPAN_S(const char) ssc(bsc);\n\n    XSPAN_0(const char) x0c(b0);\n    XSPAN_P(const char) xpc(bp);\n    XSPAN_S(const char) xsc(bs);\n\n    // NOLINTEND(performance-unnecessary-copy-initialization)\n\n    CHECK(ptr_diff_bytes(b0, buf) == 0);\n    CHECK(ptr_diff_bytes(bp, buf) == 0);\n    CHECK(ptr_diff_bytes(bs, buf) == 0);\n    CHECK(ptr_diff_bytes(s0, buf) == 0);\n    CHECK(ptr_diff_bytes(sp, buf) == 0);\n    CHECK(ptr_diff_bytes(bs, buf) == 0);\n    //\n    CHECK(ptr_diff_bytes(s0, bp) == 0);\n    CHECK(ptr_diff_bytes(s0, sp) == 0);\n    CHECK(ptr_diff_bytes(s0, ss) == 0);\n    //\n    CHECK(ptr_diff_bytes(s0c, b0c) == 0);\n    CHECK(ptr_diff_bytes(spc, bpc) == 0);\n    CHECK(ptr_diff_bytes(ssc, bsc) == 0);\n}\n\n/*************************************************************************\n//\n**************************************************************************/\n\n#if !defined(DOCTEST_CONFIG_DISABLE)\nnamespace {\nint my_memcmp_v1(XSPAN_P(const void) a, XSPAN_0(const void) b, size_t n) {\n    if (b == nullptr)\n        return -2;\n    XSPAN_0(const void) x(a);\n    return memcmp(x, b, n);\n}\nint my_memcmp_v2(XSPAN_P(const char) a, XSPAN_0(const char) b, size_t n) {\n    if (a == b)\n        return 0;\n    if (b == nullptr)\n        return -2;\n    a += 1;\n    b -= 1;\n    XSPAN_0(const char) x(a);\n    XSPAN_0(const char) y = b;\n    return memcmp(x, y, n);\n}\n} // namespace\n#endif\n\nTEST_CASE(\"PtrOrSpan\") {\n    static const char buf[4] = {0, 1, 2, 3};\n    CHECK(my_memcmp_v1(buf, nullptr, 4) == -2);\n    CHECK(my_memcmp_v2(buf + 4, buf + 4, 999) == 0);\n    CHECK(my_memcmp_v2(buf, buf + 2, 3) == 0);\n    UNUSED(buf);\n}\n\n/*************************************************************************\n//\n**************************************************************************/\n\nTEST_CASE(\"PtrOrSpan char\") {\n    char real_buf[2 + 8 + 2] = {126, 127, 0, 1, 2, 3, 4, 5, 6, 7, 124, 125};\n    char *buf = real_buf + 2;\n    XSPAN_P(char) a(buf, XSpanSizeInBytes(8));\n    XSPAN_P(char) b = a.subspan(0, 7);\n    XSPAN_P(char) c = (b + 1).subspan(0, 6);\n    a += 1;\n    CHECK(*a == 1);\n    *a++ += 1;\n    *b++ = 1;\n    CHECK(a == buf + 2);\n    CHECK(b == buf + 1);\n    CHECK(c == buf + 1);\n    CHECK(*b == 2);\n    CHECK(*c == 2);\n    CHECK(a.raw_size_in_bytes() == 8u);\n    CHECK(b.raw_size_in_bytes() == 7u);\n    CHECK(c.raw_size_in_bytes() == 6u);\n    CHECK(a.raw_base() == buf);\n    CHECK(b.raw_base() == buf);\n    CHECK(c.raw_base() == buf + 1);\n#ifdef UPX_VERSION_HEX\n    CHECK(get_le32(a) != 0);\n#endif\n    ++c;\n    c++;\n#ifdef UPX_VERSION_HEX\n    CHECK(get_le32(c) != 0);\n#endif\n    ++c;\n#ifdef UPX_VERSION_HEX\n    CHECK_THROWS(get_le32(c));\n#endif\n    ++b;\n    b++;\n    b += 4;\n    CHECK(b.raw_ptr() == buf + 7);\n    CHECK_THROWS(*b);\n    CHECK(a.raw_size_in_bytes() == 8u);\n    a = b;\n    CHECK(a.raw_size_in_bytes() == 8u);\n    CHECK(a.raw_ptr() == buf + 7);\n    a++;\n    CHECK_THROWS(*a);\n    CHECK_THROWS(raw_bytes(a, 1));\n    a = b;\n    CHECK_THROWS(a = c);\n    *a = 0;\n    a = buf;\n#ifdef UPX_VERSION_HEX\n    CHECK(upx_safe_strlen(a) == 7u);\n#endif\n}\n\nTEST_CASE(\"PtrOrSpan int\") {\n    int buf[8] = {0, 11, 22, 33, 44, 55, 66, 77};\n    XSPAN_P(const int) a(buf, XSpanCount(8));\n    CHECK(a.raw_size_in_bytes() == 8 * sizeof(int));\n    XSPAN_P(const int) b = a.subspan(0, 7);\n    CHECK(b.raw_size_in_bytes() == 7 * sizeof(int));\n    XSPAN_P(const int) c = (b + 1).subspan(0, 6);\n    CHECK(c.raw_size_in_bytes() == 6 * sizeof(int));\n    a += 1;\n    CHECK(a == buf + 1);\n    CHECK(*a == 11);\n    CHECK(*a++ == 11);\n    CHECK(a == buf + 2);\n    CHECK(*a == 22);\n    CHECK(*++a == 33);\n    CHECK(a == buf + 3);\n    CHECK(*a == 33);\n    CHECK(*--a == 22);\n    CHECK(a == buf + 2);\n    CHECK(*a == 22);\n    CHECK(*a-- == 22);\n    CHECK(a == buf + 1);\n    CHECK(*a == 11);\n    CHECK(*b == 0);\n    CHECK(*c == 11);\n    a -= 1;\n    a += 7;\n#ifdef UPX_VERSION_HEX\n    CHECK(get_le32(a) == ne32_to_le32(77));\n#endif\n    a++;\n#ifdef UPX_VERSION_HEX\n    CHECK_THROWS(get_le32(a));\n#endif\n    CHECK_THROWS(raw_bytes(a, 1));\n    CHECK_THROWS(a++);\n    CHECK_THROWS(++a);\n    CHECK_THROWS(a += 1);\n    CHECK(a == buf + 8);\n    a = buf;\n    CHECK_THROWS(a--);\n    CHECK_THROWS(--a);\n    CHECK_THROWS(a -= 1);\n    CHECK_THROWS(a += 9);\n    CHECK(a == buf);\n    a += 8;\n    CHECK(a == buf + 8);\n}\n\n/*************************************************************************\n// codegen\n**************************************************************************/\n\nnamespace {\ntemplate <class T>\nstatic noinline int foo(T p) {\n    unsigned r = 0;\n    r += *p++;\n    r += *++p;\n    p += 3;\n    r += *p;\n    r += *--p;\n    r += *p--;\n    r += *p;\n    return r;\n}\n\ntemplate <class T>\nXSPAN_0(T)\nmake_span_0(T *ptr, size_t count) {\n    return PtrOrSpanOrNull<T>(ptr, count);\n}\ntemplate <class T>\nXSPAN_P(T)\nmake_span_p(T *ptr, size_t count) {\n    return PtrOrSpan<T>(ptr, count);\n}\ntemplate <class T>\nXSPAN_S(T)\nmake_span_s(T *ptr, size_t count) {\n    return Span<T>(ptr, count);\n}\n} // namespace\n\nTEST_CASE(\"Span codegen\") {\n    upx_uint8_t buf[8] = {0, 1, 2, 3, 4, 5, 6, 7};\n    CHECK(foo(buf) == 0 + 2 + 5 + 4 + 4 + 3);\n    CHECK(foo(make_span_0(buf, 8)) == 0 + 2 + 5 + 4 + 4 + 3);\n    CHECK(foo(make_span_p(buf, 8)) == 0 + 2 + 5 + 4 + 4 + 3);\n    CHECK(foo(make_span_s(buf, 8)) == 0 + 2 + 5 + 4 + 4 + 3);\n    CHECK(foo(XSPAN_0_MAKE(upx_uint8_t, buf, 8)) == 0 + 2 + 5 + 4 + 4 + 3);\n    CHECK(foo(XSPAN_P_MAKE(upx_uint8_t, buf, 8)) == 0 + 2 + 5 + 4 + 4 + 3);\n    CHECK(foo(XSPAN_S_MAKE(upx_uint8_t, buf, 8)) == 0 + 2 + 5 + 4 + 4 + 3);\n    UNUSED(buf);\n}\n\n#endif // WITH_XSPAN >= 2\n\n/*************************************************************************\n// misc\n**************************************************************************/\n\nnamespace {\ntemplate <class T>\nstruct PointerTraits {\n    typedef typename std::add_lvalue_reference<T>::type reference;\n    typedef\n        typename std::add_lvalue_reference<typename std::add_const<T>::type>::type const_reference;\n    typedef typename std::add_pointer<T>::type pointer;\n    typedef typename std::add_pointer<typename std::add_const<T>::type>::type const_pointer;\n};\n} // namespace\n\n#if __cplusplus >= 201103L\n\nTEST_CASE(\"decltype integral constants\") {\n    static_assert((std::is_same<decltype(0), int>::value), \"\");\n    static_assert((std::is_same<decltype(0u), unsigned>::value), \"\");\n    static_assert((std::is_same<decltype(0l), long>::value), \"\");\n    static_assert((std::is_same<decltype(0ul), unsigned long>::value), \"\");\n    static_assert((std::is_same<decltype(0ll), long long>::value), \"\");\n    static_assert((std::is_same<decltype(0ull), unsigned long long>::value), \"\");\n    static_assert((std::is_same<decltype((char) 0), char>::value), \"\");\n    static_assert((std::is_same<decltype((short) 0), short>::value), \"\");\n    static_assert((std::is_same<decltype((long) 0), long>::value), \"\");\n    static_assert((std::is_same<decltype((long long) 0), long long>::value), \"\");\n    static_assert((std::is_same<decltype(char(0)), char>::value), \"\");\n    static_assert((std::is_same<decltype(short(0)), short>::value), \"\");\n    static_assert((std::is_same<decltype(long(0)), long>::value), \"\");\n}\n\nTEST_CASE(\"decltype pointer\") {\n    int dummy = 0;\n    int *p = &dummy;\n    const int *c = &dummy;\n    static_assert((std::is_same<decltype(p - p), std::ptrdiff_t>::value), \"\");\n    static_assert((std::is_same<decltype(c - c), std::ptrdiff_t>::value), \"\");\n    static_assert((std::is_same<decltype(p - c), std::ptrdiff_t>::value), \"\");\n    static_assert((std::is_same<decltype(c - p), std::ptrdiff_t>::value), \"\");\n    typedef PointerTraits<int> TInt;\n    typedef PointerTraits<const int> TConstInt;\n    static_assert((std::is_same<int *, TInt::pointer>::value), \"\");\n    static_assert((std::is_same<const int *, TInt::const_pointer>::value), \"\");\n    static_assert((std::is_same<const int *, TConstInt::pointer>::value), \"\");\n    static_assert((std::is_same<const int *, TConstInt::const_pointer>::value), \"\");\n    //\n    static_assert((std::is_same<decltype(p), TInt::pointer>::value), \"\");\n    static_assert((std::is_same<decltype(c), TInt::const_pointer>::value), \"\");\n    static_assert((std::is_same<decltype(c), TConstInt::pointer>::value), \"\");\n    static_assert((std::is_same<decltype(p + 1), TInt::pointer>::value), \"\");\n    static_assert((std::is_same<decltype(c + 1), TInt::const_pointer>::value), \"\");\n    static_assert((std::is_same<decltype(c + 1), TConstInt::pointer>::value), \"\");\n    static_assert((std::is_same<decltype(c + 1), TConstInt::const_pointer>::value), \"\");\n    static_assert((std::is_same<decltype(c + 1), const int *>::value), \"\");\n    // dereference\n    static_assert((std::is_same<decltype(*p), TInt::reference>::value), \"\");\n    static_assert((std::is_same<decltype(*c), TInt::const_reference>::value), \"\");\n#if 0\n    // this works, but avoid clang warnings:\n    //   \"Expression with side effects has no effect in an unevaluated context\"\n    static_assert((std::is_same<decltype(*p++), TInt::reference>::value), \"\");\n    static_assert((std::is_same<decltype(*++p), TInt::reference>::value), \"\");\n    static_assert((std::is_same<decltype(*c++), TInt::const_reference>::value), \"\");\n    static_assert((std::is_same<decltype(*c++), TConstInt::reference>::value), \"\");\n    static_assert((std::is_same<decltype(*c++), TConstInt::const_reference>::value), \"\");\n    static_assert((std::is_same<decltype(*++c), TInt::const_reference>::value), \"\");\n    static_assert((std::is_same<decltype(*++c), TConstInt::reference>::value), \"\");\n    static_assert((std::is_same<decltype(*++c), TConstInt::const_reference>::value), \"\");\n#endif\n    // array access\n    static_assert((std::is_same<decltype(p[0]), TInt::reference>::value), \"\");\n    static_assert((std::is_same<decltype(c[0]), TInt::const_reference>::value), \"\");\n    static_assert((std::is_same<decltype(c[0]), TConstInt::reference>::value), \"\");\n    static_assert((std::is_same<decltype(c[0]), TConstInt::const_reference>::value), \"\");\n    UNUSED(p);\n    UNUSED(c);\n}\n\n#endif // __cplusplus >= 201103L\n\n/* vim:set ts=4 sw=4 et: */\n","size_bytes":35491},"src/compress/compress.cpp":{"content":"/* compress.cpp --\n\n   This file is part of the Resize executable compressor.\n\n   Copyright (C) 2025 WHO-AM-I-404\n   Based on UPX - Ultimate Packer for eXecutables\n   Copyright (C) 1996-2025 Markus Franz Xaver Johannes Oberhumer\n   All Rights Reserved.\n\n   Resize and the UCL library are free software; you can redistribute them\n   and/or modify them under the terms of the GNU General Public License as\n   published by the Free Software Foundation; either version 2 of\n   the License, or (at your option) any later version.\n\n   This program is distributed in the hope that it will be useful,\n   but WITHOUT ANY WARRANTY; without even the implied warranty of\n   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n   GNU General Public License for more details.\n\n   You should have received a copy of the GNU General Public License\n   along with this program; see the file COPYING.\n   If not, write to the Free Software Foundation, Inc.,\n   59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.\n\n   Markus F.X.J. Oberhumer\n   <markus@oberhumer.com>\n */\n\n#include \"../conf.h\"\n#include \"compress.h\"\n#include \"../util/membuffer.h\"\n\n/*************************************************************************\n//\n**************************************************************************/\n\nunsigned upx_adler32(const void *buf, unsigned len, unsigned adler) {\n    if (len == 0)\n        return adler;\n    assert(buf != nullptr);\n#if 1\n    return upx_ucl_adler32(buf, len, adler);\n#else\n    return upx_zlib_adler32(buf, len, adler);\n#endif\n}\n\n#if 0 // UNUSED\nunsigned upx_crc32(const void *buf, unsigned len, unsigned crc)\n{\n    if (len == 0)\n        return crc;\n    assert(buf != nullptr);\n#if 1\n    return upx_ucl_crc32(buf, len, crc);\n#else\n    return upx_zlib_crc32(buf, len, crc);\n#endif\n}\n#endif // UNUSED\n\n/*************************************************************************\n//\n**************************************************************************/\n\nint upx_compress(const upx_bytep src, unsigned src_len, upx_bytep dst, unsigned *dst_len,\n                 upx_callback_t *cb, int method, int level, const upx_compress_config_t *cconf,\n                 upx_compress_result_t *cresult) {\n    int r = UPX_E_ERROR;\n    upx_compress_result_t cresult_buffer;\n\n    assert(method > 0);\n    assert(level > 0);\n\n#if 1\n    // set available bytes in dst\n    if (*dst_len == 0)\n        *dst_len = MemBuffer::getSizeForCompression(src_len);\n#else\n    // force users to provide *dst_len\n    assert(*dst_len != 0);\n#endif\n    // for UPX, we always require a reasonably sized output buffer\n    assert(*dst_len >= MemBuffer::getSizeForCompression(src_len));\n\n    if (!cresult)\n        cresult = &cresult_buffer;\n    cresult->reset();\n#if 1\n    // debugging aid\n    cresult->debug.method = method;\n    cresult->debug.level = level;\n    cresult->debug.u_len = src_len;\n    cresult->debug.c_len = 0;\n#endif\n\n    const unsigned orig_dst_len = *dst_len;\n    if (__acc_cte(false)) {\n    }\n#if (WITH_BZIP2)\n    else if (M_IS_BZIP2(method))\n        r = upx_bzip2_compress(src, src_len, dst, dst_len, cb, method, level, cconf, cresult);\n#endif\n#if (WITH_LZMA)\n    else if (M_IS_LZMA(method))\n        r = upx_lzma_compress(src, src_len, dst, dst_len, cb, method, level, cconf, cresult);\n#endif\n#if (WITH_NRV)\n    else if ((M_IS_NRV2B(method) || M_IS_NRV2D(method) || M_IS_NRV2E(method)) && !opt->prefer_ucl)\n        r = upx_nrv_compress(src, src_len, dst, dst_len, cb, method, level, cconf, cresult);\n#endif\n#if (WITH_UCL)\n    else if (M_IS_NRV2B(method) || M_IS_NRV2D(method) || M_IS_NRV2E(method))\n        r = upx_ucl_compress(src, src_len, dst, dst_len, cb, method, level, cconf, cresult);\n#endif\n#if (WITH_ZSTD)\n    else if (M_IS_ZSTD(method))\n        r = upx_zstd_compress(src, src_len, dst, dst_len, cb, method, level, cconf, cresult);\n#endif\n    else {\n        throwInternalError(\"unknown compression method %d\", method);\n    }\n\n#if 1\n    // debugging aid\n    cresult->debug.c_len = *dst_len;\n#endif\n    assert_noexcept(*dst_len <= orig_dst_len);\n    return r;\n}\n\n/*************************************************************************\n//\n**************************************************************************/\n\nint upx_decompress(const upx_bytep src, unsigned src_len, upx_bytep dst, unsigned *dst_len,\n                   int method, const upx_compress_result_t *cresult) {\n    int r = UPX_E_ERROR;\n\n    assert(*dst_len > 0);\n    assert(src_len < *dst_len); // must be compressed\n\n    if (cresult && cresult->debug.method == 0)\n        cresult = nullptr;\n\n    const unsigned orig_dst_len = *dst_len;\n    if (__acc_cte(false)) {\n    }\n#if (WITH_BZIP2)\n    else if (M_IS_BZIP2(method))\n        r = upx_bzip2_decompress(src, src_len, dst, dst_len, method, cresult);\n#endif\n#if (WITH_LZMA)\n    else if (M_IS_LZMA(method))\n        r = upx_lzma_decompress(src, src_len, dst, dst_len, method, cresult);\n#endif\n#if (WITH_NRV)\n    else if ((M_IS_NRV2B(method) || M_IS_NRV2D(method) || M_IS_NRV2E(method)) && !opt->prefer_ucl)\n        r = upx_nrv_decompress(src, src_len, dst, dst_len, method, cresult);\n#endif\n#if (WITH_UCL)\n    else if (M_IS_NRV2B(method) || M_IS_NRV2D(method) || M_IS_NRV2E(method))\n        r = upx_ucl_decompress(src, src_len, dst, dst_len, method, cresult);\n#endif\n#if (WITH_ZLIB)\n    else if (M_IS_DEFLATE(method))\n        r = upx_zlib_decompress(src, src_len, dst, dst_len, method, cresult);\n#endif\n#if (WITH_ZSTD)\n    else if (M_IS_ZSTD(method))\n        r = upx_zstd_decompress(src, src_len, dst, dst_len, method, cresult);\n#endif\n    else {\n        throwInternalError(\"unknown compression method %d\", method);\n    }\n\n    assert_noexcept(*dst_len <= orig_dst_len);\n    return r;\n}\n\n/*************************************************************************\n//\n**************************************************************************/\n\nint upx_test_overlap(const upx_bytep buf, const upx_bytep tbuf, unsigned src_off, unsigned src_len,\n                     unsigned *dst_len, int method, const upx_compress_result_t *cresult) {\n    int r = UPX_E_ERROR;\n\n    if (cresult && cresult->debug.method == 0)\n        cresult = nullptr;\n\n    assert(*dst_len > 0);\n    assert(src_len < *dst_len); // must be compressed\n    unsigned overlap_overhead = src_off + src_len - *dst_len;\n    assert((int) overlap_overhead > 0);\n\n    const unsigned orig_dst_len = *dst_len;\n    if (__acc_cte(false)) {\n    }\n#if (WITH_BZIP2)\n    else if (M_IS_BZIP2(method))\n        r = upx_bzip2_test_overlap(buf, tbuf, src_off, src_len, dst_len, method, cresult);\n#endif\n#if (WITH_LZMA)\n    else if (M_IS_LZMA(method))\n        r = upx_lzma_test_overlap(buf, tbuf, src_off, src_len, dst_len, method, cresult);\n#endif\n#if (WITH_NRV)\n    else if ((M_IS_NRV2B(method) || M_IS_NRV2D(method) || M_IS_NRV2E(method)) && !opt->prefer_ucl)\n        r = upx_nrv_test_overlap(buf, tbuf, src_off, src_len, dst_len, method, cresult);\n#endif\n#if (WITH_UCL)\n    else if (M_IS_NRV2B(method) || M_IS_NRV2D(method) || M_IS_NRV2E(method))\n        r = upx_ucl_test_overlap(buf, tbuf, src_off, src_len, dst_len, method, cresult);\n#endif\n#if (WITH_ZSTD)\n    else if (M_IS_ZSTD(method))\n        r = upx_zstd_test_overlap(buf, tbuf, src_off, src_len, dst_len, method, cresult);\n#endif\n    else {\n        throwInternalError(\"unknown compression method %d\", method);\n    }\n\n    assert_noexcept(*dst_len <= orig_dst_len);\n    return r;\n}\n\n/* vim:set ts=4 sw=4 et: */\n","size_bytes":7432},"src/compress/compress_bzip2.cpp":{"content":"/* compress_bzip2.cpp --\n\n   This file is part of the Resize executable compressor.\n\n   Copyright (C) 2025 WHO-AM-I-404\n   Based on UPX - Ultimate Packer for eXecutables\n   Copyright (C) 1996-2025 Markus Franz Xaver Johannes Oberhumer\n   All Rights Reserved.\n\n   Resize and the UCL library are free software; you can redistribute them\n   and/or modify them under the terms of the GNU General Public License as\n   published by the Free Software Foundation; either version 2 of\n   the License, or (at your option) any later version.\n\n   This program is distributed in the hope that it will be useful,\n   but WITHOUT ANY WARRANTY; without even the implied warranty of\n   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n   GNU General Public License for more details.\n\n   You should have received a copy of the GNU General Public License\n   along with this program; see the file COPYING.\n   If not, write to the Free Software Foundation, Inc.,\n   59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.\n\n   Markus F.X.J. Oberhumer\n   <markus@oberhumer.com>\n */\n\n#include \"../util/system_headers.h\"\n#if WITH_BZIP2\n#include <bzip2/bzlib.h>\n#endif\n#include \"../conf.h\"\n\nvoid bzip2_compress_config_t::reset() noexcept { mem_clear(this); }\n\n#if WITH_BZIP2\n#include \"compress.h\"\n#include \"../util/membuffer.h\"\n\n#if defined(BZ_NO_STDIO) || 1\n// we need to supply bz_internal_error() when building with BZ_NO_STDIO\nextern \"C\" {\nextern void bz_internal_error(int);\nvoid bz_internal_error(int errcode) { throwInternalError(\"bz_internal_error %d\", errcode); }\n}\n#endif // BZ_NO_STDIO\n\nstatic int convert_errno_from_bzip2(int r) {\n    switch (r) {\n    case BZ_OK:\n        return UPX_E_OK;\n    case BZ_MEM_ERROR:\n        return UPX_E_OUT_OF_MEMORY;\n    // TODO later: convert to UPX_E_INPUT_OVERRUN, UPX_E_OUTPUT_OVERRUN\n    default:\n        break;\n    }\n    return UPX_E_ERROR;\n}\n\n/*************************************************************************\n//\n**************************************************************************/\n\nint upx_bzip2_compress(const upx_bytep src, unsigned src_len, upx_bytep dst, unsigned *dst_len,\n                       upx_callback_t *cb_parm, int method, int level,\n                       const upx_compress_config_t *cconf_parm, upx_compress_result_t *cresult) {\n    assert(method == M_BZIP2);\n    assert(level > 0);\n    assert(cresult != nullptr);\n    UNUSED(cb_parm);\n    int r = UPX_E_ERROR;\n    const bzip2_compress_config_t *const lcconf = cconf_parm ? &cconf_parm->conf_bzip2 : nullptr;\n    bzip2_compress_result_t *const res = &cresult->result_bzip2;\n    res->reset();\n\n    int blockSize100k = (src_len + 100000 - 1) / 100000;\n    if (blockSize100k < 1)\n        blockSize100k = 1;\n    if (blockSize100k > 9)\n        blockSize100k = 9;\n    // idea for later: could enhance lcconf to allow setting blockSize100k\n    UNUSED(lcconf);\n    if (level <= 3 && blockSize100k > level)\n        blockSize100k = level;\n\n    char *dest = (char *) dst;\n    char *source = (char *) const_cast<byte *>(src);\n    r = BZ2_bzBuffToBuffCompress(dest, dst_len, source, src_len, blockSize100k, 0, 0);\n    return convert_errno_from_bzip2(r);\n}\n\n/*************************************************************************\n//\n**************************************************************************/\n\nint upx_bzip2_decompress(const upx_bytep src, unsigned src_len, upx_bytep dst, unsigned *dst_len,\n                         int method, const upx_compress_result_t *cresult) {\n    assert(method == M_BZIP2);\n    UNUSED(method);\n    UNUSED(cresult);\n    char *dest = (char *) dst;\n    char *source = (char *) const_cast<byte *>(src);\n    int small = 0;\n    int r = BZ2_bzBuffToBuffDecompress(dest, dst_len, source, src_len, small, 0);\n    return convert_errno_from_bzip2(r);\n}\n\n/*************************************************************************\n// test_overlap - see <ucl/ucl.h> for semantics\n**************************************************************************/\n\nint upx_bzip2_test_overlap(const upx_bytep buf, const upx_bytep tbuf, unsigned src_off,\n                           unsigned src_len, unsigned *dst_len, int method,\n                           const upx_compress_result_t *cresult) {\n    assert(method == M_BZIP2);\n\n    MemBuffer b(src_off + src_len);\n    memcpy(b + src_off, buf + src_off, src_len);\n    unsigned saved_dst_len = *dst_len;\n    int r = upx_bzip2_decompress(raw_index_bytes(b, src_off, src_len), src_len,\n                                 raw_bytes(b, *dst_len), dst_len, method, cresult);\n    if (r != UPX_E_OK)\n        return r;\n    if (*dst_len != saved_dst_len)\n        return UPX_E_ERROR;\n    // NOTE: there is a very tiny possibility that decompression has\n    //   succeeded but the data is not restored correctly because of\n    //   in-place buffer overlapping, so we use an extra memcmp().\n    if (tbuf != nullptr && memcmp(tbuf, b, *dst_len) != 0)\n        return UPX_E_ERROR;\n    return UPX_E_OK;\n}\n\n/*************************************************************************\n// misc\n**************************************************************************/\n\nint upx_bzip2_init(void) { return 0; }\n\nconst char *upx_bzip2_version_string(void) { return BZ2_bzlibVersion(); }\n\n/*************************************************************************\n// doctest checks\n**************************************************************************/\n\n#if DEBUG && !defined(DOCTEST_CONFIG_DISABLE) && 1\n\nstatic bool check_bzip2(const int method, const int level, const unsigned expected_c_len) {\n    const unsigned u_len = 16384;\n    const unsigned c_extra = 4096;\n    MemBuffer u_buf, c_buf, d_buf;\n    unsigned c_len, d_len;\n    upx_compress_result_t cresult;\n    int r;\n\n    u_buf.alloc(u_len);\n    memset(u_buf, 0, u_len);\n    c_buf.allocForCompression(u_len, c_extra);\n    d_buf.allocForDecompression(u_len);\n\n    c_len = c_buf.getSize() - c_extra;\n    r = upx_bzip2_compress(raw_bytes(u_buf, u_len), u_len, raw_index_bytes(c_buf, c_extra, c_len),\n                           &c_len, nullptr, method, level, NULL_cconf, &cresult);\n    if (r != 0 || c_len != expected_c_len)\n        return false;\n\n    d_len = d_buf.getSize();\n    r = upx_bzip2_decompress(raw_index_bytes(c_buf, c_extra, c_len), c_len, raw_bytes(d_buf, d_len),\n                             &d_len, method, nullptr);\n    if (r != 0 || d_len != u_len || memcmp(u_buf, d_buf, u_len) != 0)\n        return false;\n\n    d_len = u_len - 1;\n    r = upx_bzip2_decompress(raw_index_bytes(c_buf, c_extra, c_len), c_len, raw_bytes(d_buf, d_len),\n                             &d_len, method, nullptr);\n    if (r == 0)\n        return false;\n\n    // TODO: rewrite Packer::findOverlapOverhead() so that we can test it here\n    // unsigned x_len = d_len;\n    // r = upx_bzip2_test_overlap(c_buf, u_buf, c_extra, c_len, &x_len, method, nullptr);\n    return true;\n}\n\nTEST_CASE(\"compress_bzip2\") { CHECK(check_bzip2(M_BZIP2, 9, 46)); }\n\n#endif // DEBUG\n\nTEST_CASE(\"upx_bzip2_decompress\") {\n#if 0  // TODO later, see above\n    const byte *c_data;\n    byte d_buf[32];\n    unsigned d_len;\n    int r;\n\n    c_data = (const byte *) \"\\x28\\xb5\\x2f\\xfd\\x20\\x20\\x3d\\x00\\x00\\x08\\xff\\x01\\x00\\x34\\x4e\\x08\";\n    d_len = 32;\n    r = upx_bzip2_decompress(c_data, 16, d_buf, &d_len, M_BZIP2, nullptr);\n    CHECK((r == 0 && d_len == 32));\n    r = upx_bzip2_decompress(c_data, 15, d_buf, &d_len, M_BZIP2, nullptr);\n    CHECK(r == UPX_E_INPUT_OVERRUN);\n    d_len = 31;\n    r = upx_bzip2_decompress(c_data, 16, d_buf, &d_len, M_BZIP2, nullptr);\n    CHECK(r == UPX_E_OUTPUT_OVERRUN);\n    UNUSED(r);\n#endif // TODO\n}\n\n#endif // WITH_BZIP2\n\n/* vim:set ts=4 sw=4 et: */\n","size_bytes":7653},"src/compress/compress_lzma.cpp":{"content":"/* compress_lzma.cpp --\n\n   This file is part of the Resize executable compressor.\n\n   Copyright (C) 2025 WHO-AM-I-404\n   Based on UPX - Ultimate Packer for eXecutables\n   Copyright (C) 1996-2025 Markus Franz Xaver Johannes Oberhumer\n   All Rights Reserved.\n\n   Resize and the UCL library are free software; you can redistribute them\n   and/or modify them under the terms of the GNU General Public License as\n   published by the Free Software Foundation; either version 2 of\n   the License, or (at your option) any later version.\n\n   This program is distributed in the hope that it will be useful,\n   but WITHOUT ANY WARRANTY; without even the implied warranty of\n   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n   GNU General Public License for more details.\n\n   You should have received a copy of the GNU General Public License\n   along with this program; see the file COPYING.\n   If not, write to the Free Software Foundation, Inc.,\n   59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.\n\n   Markus F.X.J. Oberhumer\n   <markus@oberhumer.com>\n */\n\n#include \"../conf.h\"\n#include \"compress.h\"\n#include \"../util/membuffer.h\"\n\n#if (ACC_CC_CLANG)\n#pragma clang diagnostic ignored \"-Wshadow\"\n#elif (ACC_CC_GNUC >= 0x040200)\n#pragma GCC diagnostic ignored \"-Wshadow\"\n#elif (ACC_CC_MSC)\n#pragma warning(disable : 4456) // -Wno-shadow\n#endif\n\nvoid lzma_compress_config_t::reset() noexcept {\n    pos_bits.reset();\n    lit_pos_bits.reset();\n    lit_context_bits.reset();\n    dict_size.reset();\n    fast_mode = 2;\n    num_fast_bytes.reset();\n    match_finder_cycles = 0;\n\n    max_num_probs = 0;\n}\n\n// INFO: LZMA SDK is placed in the public domain.\n//\n// Anyone is free to copy, modify, publish, use, compile, sell, or\n// distribute the original LZMA SDK code, either in source code form\n// or as a compiled binary, for any purpose, commercial or non-commercial,\n// and by any means.\n//\n// https://www.7-zip.org/sdk.html\n// https://sourceforge.net/p/sevenzip/discussion/45797/thread/685169cf/\n\n/*************************************************************************\n// compress defaults\n**************************************************************************/\n\nstatic bool prepare_result(lzma_compress_result_t *res, unsigned src_len, int method, int level,\n                           const lzma_compress_config_t *lcconf) {\n    // setup defaults\n    res->pos_bits = 2;                // 0 .. 4\n    res->lit_pos_bits = 0;            // 0 .. 4\n    res->lit_context_bits = 3;        // 0 .. 8\n    res->dict_size = 4 * 1024 * 1024; // 1 .. 2**30\n    res->fast_mode = 2;               // 0 .. 2\n    res->num_fast_bytes = 64;         // 5 .. 273\n    res->match_finder_cycles = 0;\n    // UPX overrides\n    res->pos_bits = lzma_compress_config_t::pos_bits_t::default_value;\n    res->lit_pos_bits = lzma_compress_config_t::lit_pos_bits_t::default_value;\n    res->lit_context_bits = lzma_compress_config_t::lit_context_bits_t::default_value;\n    res->dict_size = lzma_compress_config_t::dict_size_t::default_value;\n    res->num_fast_bytes = lzma_compress_config_t::num_fast_bytes_t::default_value;\n    // method overrides\n    if (method >= 0x100) {\n        res->pos_bits = (method >> 16) & 15;\n        res->lit_pos_bits = (method >> 12) & 15;\n        res->lit_context_bits = (method >> 8) & 15;\n    }\n#if 0\n    // DEBUG - set sizes so that we use a maximum amount of stack.\n    //  These settings cause res->num_probs == 3147574, i.e. we will\n    //  need about 6 MiB of stack during runtime decompression.\n    res->lit_pos_bits     = 4;\n    res->lit_context_bits = 8;\n#endif\n\n    // TODO: tune these settings according to level\n    switch (level) {\n    case 1:\n        res->dict_size = 256 * 1024;\n        res->fast_mode = 0;\n        res->num_fast_bytes = 8;\n        break;\n    case 2:\n        res->dict_size = 256 * 1024;\n        res->fast_mode = 0;\n        break;\n    case 3:\n        break;\n    case 4:\n        break;\n    case 5:\n        break;\n    case 6:\n        break;\n    case 7:\n        break;\n    case 8:\n        break;\n    case 9:\n        res->dict_size = 8 * 1024 * 1024;\n        break;\n    case 10:\n        res->dict_size = src_len;\n        break;\n    default:\n        goto error;\n    }\n\n    // cconf overrides\n    if (lcconf) {\n        upx::oassign(res->pos_bits, lcconf->pos_bits);\n        upx::oassign(res->lit_pos_bits, lcconf->lit_pos_bits);\n        upx::oassign(res->lit_context_bits, lcconf->lit_context_bits);\n        upx::oassign(res->dict_size, lcconf->dict_size);\n        upx::oassign(res->num_fast_bytes, lcconf->num_fast_bytes);\n    }\n\n    // limit dictionary size\n    if (res->dict_size > src_len)\n        res->dict_size = src_len;\n\n    // limit num_probs\n    if (lcconf && lcconf->max_num_probs) {\n        for (;;) {\n            unsigned n = 1846 + (768u << (res->lit_context_bits + res->lit_pos_bits));\n            if (n <= lcconf->max_num_probs)\n                break;\n            if (res->lit_pos_bits > res->lit_context_bits) {\n                if (res->lit_pos_bits == 0)\n                    goto error;\n                res->lit_pos_bits -= 1;\n            } else {\n                if (res->lit_context_bits == 0)\n                    goto error;\n                res->lit_context_bits -= 1;\n            }\n        }\n    }\n\n    lzma_compress_config_t::pos_bits_t::assertValue(res->pos_bits);\n    lzma_compress_config_t::lit_pos_bits_t::assertValue(res->lit_pos_bits);\n    lzma_compress_config_t::lit_context_bits_t::assertValue(res->lit_context_bits);\n    lzma_compress_config_t::dict_size_t::assertValue(res->dict_size);\n    lzma_compress_config_t::num_fast_bytes_t::assertValue(res->num_fast_bytes);\n\n    res->num_probs = 1846 + (768u << (res->lit_context_bits + res->lit_pos_bits));\n    NO_printf(\"\\nlzma_compress config: %u %u %u %u %u\\n\", res->pos_bits, res->lit_pos_bits,\n              res->lit_context_bits, res->dict_size, res->num_probs);\n    return true;\n\nerror:\n    return false;\n}\n\n/*************************************************************************\n// compress - cruft because of pseudo-COM layer\n**************************************************************************/\n\n#if (ACC_CC_CLANG >= 0x080000)\n#pragma clang diagnostic push\n#pragma clang diagnostic ignored \"-Wzero-as-null-pointer-constant\"\n#elif (ACC_CC_GNUC >= 0x040700)\n#pragma GCC diagnostic push\n#pragma GCC diagnostic ignored \"-Wzero-as-null-pointer-constant\"\n#endif\n\n#undef MSDOS\n#undef OS2\n#undef _WIN32\n#undef _WIN32_WCE\n#undef COMPRESS_MF_MT\n#undef _NO_EXCEPTIONS\n#include <lzma-sdk/C/Common/MyInitGuid.h>\n// #include <lzma-sdk/C/7zip/Compress/LZMA/LZMADecoder.h>\n#include <lzma-sdk/C/7zip/Compress/LZMA/LZMAEncoder.h>\n\nnamespace MyLzma {\n\nstruct InStream final : public ISequentialInStream, public CMyUnknownImp {\n    virtual ~InStream() {}\n    MY_UNKNOWN_IMP\n    const Byte *b_buf = nullptr;\n    size_t b_size;\n    size_t b_pos;\n    void Init(const Byte *data, size_t size) {\n        b_buf = data;\n        b_size = size;\n        b_pos = 0;\n    }\n    STDMETHOD(Read)(void *data, UInt32 size, UInt32 *processedSize) override;\n};\n\nSTDMETHODIMP InStream::Read(void *data, UInt32 size, UInt32 *processedSize) {\n    size_t remain = b_size - b_pos;\n    if (size > remain)\n        size = (UInt32) remain;\n    memmove(data, b_buf + b_pos, size);\n    b_pos += size;\n    if (processedSize != nullptr)\n        *processedSize = size;\n    return S_OK;\n}\n\nstruct OutStream final : public ISequentialOutStream, public CMyUnknownImp {\n    virtual ~OutStream() {}\n    MY_UNKNOWN_IMP\n    Byte *b_buf = nullptr;\n    size_t b_size;\n    size_t b_pos;\n    bool overflow;\n    void Init(Byte *data, size_t size) {\n        b_buf = data;\n        b_size = size;\n        b_pos = 0;\n        overflow = false;\n    }\n    HRESULT WriteByte(Byte c) {\n        if (b_pos >= b_size) {\n            overflow = true;\n            return E_FAIL;\n        }\n        b_buf[b_pos++] = c;\n        return S_OK;\n    }\n    STDMETHOD(Write)(const void *data, UInt32 size, UInt32 *processedSize) override;\n};\n\nSTDMETHODIMP OutStream::Write(const void *data, UInt32 size, UInt32 *processedSize) {\n    size_t remain = b_size - b_pos;\n    if (size > remain)\n        size = (UInt32) remain, overflow = true;\n    memmove(b_buf + b_pos, data, size);\n    b_pos += size;\n    if (processedSize != nullptr)\n        *processedSize = size;\n    return overflow ? E_FAIL : S_OK;\n}\n\nstruct ProgressInfo final : public ICompressProgressInfo, public CMyUnknownImp {\n    virtual ~ProgressInfo() {}\n    MY_UNKNOWN_IMP\n    STDMETHOD(SetRatioInfo)(const UInt64 *inSize, const UInt64 *outSize) override;\n    upx_callback_t *cb = nullptr;\n};\n\nSTDMETHODIMP ProgressInfo::SetRatioInfo(const UInt64 *inSize, const UInt64 *outSize) {\n    if (cb && cb->nprogress)\n        cb->nprogress(cb, (unsigned) *inSize, (unsigned) *outSize);\n    return S_OK;\n}\n\n} // namespace MyLzma\n\n#include <lzma-sdk/C/Common/Alloc.cpp>\n#include <lzma-sdk/C/Common/CRC.cpp>\n// #include <lzma-sdk/C/7zip/Common/InBuffer.cpp>\n#include <lzma-sdk/C/7zip/Common/OutBuffer.cpp>\n#include <lzma-sdk/C/7zip/Common/StreamUtils.cpp>\n#include <lzma-sdk/C/7zip/Compress/LZ/LZInWindow.cpp>\n// #include <lzma-sdk/C/7zip/Compress/LZ/LZOutWindow.cpp>\n// #include <lzma-sdk/C/7zip/Compress/LZMA/LZMADecoder.cpp>\n#include <lzma-sdk/C/7zip/Compress/LZMA/LZMAEncoder.cpp>\n#include <lzma-sdk/C/7zip/Compress/RangeCoder/RangeCoderBit.cpp>\n#undef RC_NORMALIZE\n\n#if (ACC_CC_CLANG >= 0x080000)\n#pragma clang diagnostic pop\n#elif (ACC_CC_GNUC >= 0x040700)\n#pragma GCC diagnostic pop\n#endif\n\nint upx_lzma_compress(const upx_bytep src, unsigned src_len, upx_bytep dst, unsigned *dst_len,\n                      upx_callback_t *cb, int method, int level,\n                      const upx_compress_config_t *cconf_parm, upx_compress_result_t *cresult) {\n    assert(M_IS_LZMA(method));\n    assert(level > 0);\n    assert(cresult != nullptr);\n\n    int r = UPX_E_ERROR;\n    HRESULT rh;\n    const lzma_compress_config_t *const lcconf = cconf_parm ? &cconf_parm->conf_lzma : nullptr;\n    lzma_compress_result_t *const res = &cresult->result_lzma;\n    res->reset();\n\n    MyLzma::InStream is;\n    is.AddRef();\n    is.Init(src, src_len);\n    MyLzma::OutStream os;\n    os.AddRef();\n    os.Init(dst, *dst_len);\n    MyLzma::ProgressInfo progress;\n    progress.AddRef();\n    progress.cb = cb; // progress.Init()\n\n    NCompress::NLZMA::CEncoder enc;\n    constexpr unsigned NPROPS = 8;\n    static const PROPID propIDs[NPROPS] = {\n        NCoderPropID::kPosStateBits,      // 0  pb    _posStateBits(2)\n        NCoderPropID::kLitPosBits,        // 1  lp    _numLiteralPosStateBits(0)\n        NCoderPropID::kLitContextBits,    // 2  lc    _numLiteralContextBits(3)\n        NCoderPropID::kDictionarySize,    // 3  ds\n        NCoderPropID::kAlgorithm,         // 4  fm    _fastmode\n        NCoderPropID::kNumFastBytes,      // 5  fb\n        NCoderPropID::kMatchFinderCycles, // 6  mfc   _matchFinderCycles, _cutValue\n        NCoderPropID::kMatchFinder        // 7  mf\n    };\n    PROPVARIANT pr[NPROPS];\n    if (!prepare_result(res, src_len, method, level, lcconf))\n        goto error;\n    pr[0].vt = pr[1].vt = pr[2].vt = pr[3].vt = pr[4].vt = pr[5].vt = pr[6].vt = VT_UI4;\n    pr[7].vt = VT_BSTR;\n    pr[0].uintVal = res->pos_bits;\n    pr[1].uintVal = res->lit_pos_bits;\n    pr[2].uintVal = res->lit_context_bits;\n    pr[3].uintVal = res->dict_size;\n    pr[4].uintVal = res->fast_mode;\n    pr[5].uintVal = res->num_fast_bytes;\n    pr[6].uintVal = res->match_finder_cycles;\n    static const wchar_t matchfinder[] = L\"BT4\";\n    assert(NCompress::NLZMA::FindMatchFinder(matchfinder) >= 0);\n    pr[7].bstrVal = ACC_PCAST(BSTR, ACC_UNCONST_CAST(wchar_t *, matchfinder));\n\n    try {\n        if (enc.SetCoderProperties(propIDs, pr, NPROPS) != S_OK)\n            goto error;\n        // encode properties in LZMA-style (5 bytes)\n        if (enc.WriteCoderProperties(&os) != S_OK)\n            goto error;\n        if (os.overflow) {\n            // r = UPX_E_OUTPUT_OVERRUN;\n            r = UPX_E_NOT_COMPRESSIBLE;\n            goto error;\n        }\n        assert(os.b_pos == 5);\n\n        // reset and encode properties in UPX-style (2 bytes)\n        os.b_pos = 0;\n        // UPX extra stuff in first byte: 5 high bits convenience for stub decompressor\n        unsigned t = res->lit_context_bits + res->lit_pos_bits;\n        os.WriteByte(Byte((t << 3) | res->pos_bits));\n        os.WriteByte(Byte((res->lit_pos_bits << 4) | res->lit_context_bits));\n\n        // compress\n        rh = enc.Code(&is, &os, nullptr, nullptr, &progress);\n\n    } catch (...) {\n        rh = E_OUTOFMEMORY;\n    }\n\n    assert(is.b_pos <= src_len);\n    assert(os.b_pos <= *dst_len);\n    if (rh == E_OUTOFMEMORY)\n        r = UPX_E_OUT_OF_MEMORY;\n    else if (os.overflow) {\n        assert(os.b_pos == *dst_len);\n        // r = UPX_E_OUTPUT_OVERRUN;\n        r = UPX_E_NOT_COMPRESSIBLE;\n    } else if (rh == S_OK) {\n        assert(is.b_pos == src_len);\n        r = UPX_E_OK;\n    }\n\nerror:\n    *dst_len = (unsigned) os.b_pos;\n    NO_printf(\"\\nlzma_compress: %d: %u %u %u %u %u, %u - > %u\\n\", r, res->pos_bits,\n              res->lit_pos_bits, res->lit_context_bits, res->dict_size, res->num_probs, src_len,\n              *dst_len);\n    NO_printf(\"%u %u %u\\n\", is.__m_RefCount, os.__m_RefCount, progress.__m_RefCount);\n    return r;\n}\n\n/*************************************************************************\n// decompress\n**************************************************************************/\n\n#undef _LZMA_IN_CB\n#undef _LZMA_OUT_READ\n#undef _LZMA_PROB32\n#undef _LZMA_LOC_OPT\n#include <lzma-sdk/C/7zip/Compress/LZMA_C/LzmaDecode.h>\n#include <lzma-sdk/C/7zip/Compress/LZMA_C/LzmaDecode.c>\n\nint upx_lzma_decompress(const upx_bytep src, unsigned src_len, upx_bytep dst, unsigned *dst_len,\n                        int method, const upx_compress_result_t *cresult) {\n    assert(M_IS_LZMA(method));\n    // see res->num_probs above\n    COMPILE_TIME_ASSERT(sizeof(CProb) == 2)\n    COMPILE_TIME_ASSERT(LZMA_BASE_SIZE == 1846)\n    COMPILE_TIME_ASSERT(LZMA_LIT_SIZE == 768)\n\n    CLzmaDecoderState s;\n    mem_clear(&s);\n    SizeT src_out = 0, dst_out = 0;\n    int r = UPX_E_ERROR;\n    int rh;\n\n    // decode UPX-style properties (2 bytes)\n    if (src_len < 3) {\n        r = UPX_E_INPUT_OVERRUN;\n        goto error;\n    }\n    s.Properties.pb = src[0] & 7;\n    s.Properties.lp = (src[1] >> 4);\n    s.Properties.lc = src[1] & 15;\n    if (s.Properties.pb >= 5)\n        goto error;\n    if (s.Properties.lp >= 5)\n        goto error;\n    if (s.Properties.lc >= 9)\n        goto error;\n    // UPX extra stuff in first byte: 5 high bits convenience for stub decompressor\n    if ((src[0] >> 3) != s.Properties.lc + s.Properties.lp)\n        goto error;\n    src += 2;\n    src_len -= 2;\n\n    if (cresult) {\n        assert(cresult->debug.method == method);\n        assert(cresult->result_lzma.pos_bits == (unsigned) s.Properties.pb);\n        assert(cresult->result_lzma.lit_pos_bits == (unsigned) s.Properties.lp);\n        assert(cresult->result_lzma.lit_context_bits == (unsigned) s.Properties.lc);\n        assert(cresult->result_lzma.num_probs == (unsigned) LzmaGetNumProbs(&s.Properties));\n        const lzma_compress_result_t *res = &cresult->result_lzma;\n        NO_printf(\"\\nlzma_decompress config: %u %u %u %u %u\\n\", res->pos_bits, res->lit_pos_bits,\n                  res->lit_context_bits, res->dict_size, res->num_probs);\n        UNUSED(res);\n    }\n    s.Probs = (CProb *) malloc(sizeof(CProb) * LzmaGetNumProbs(&s.Properties));\n    if (!s.Probs) {\n        r = UPX_E_OUT_OF_MEMORY;\n        goto error;\n    }\n    rh = LzmaDecode(&s, src, src_len, &src_out, dst, *dst_len, &dst_out);\n    assert(src_out <= src_len);\n    assert(dst_out <= *dst_len);\n    if (rh == 0) {\n        r = UPX_E_OK;\n        if (src_out != src_len)\n            r = UPX_E_INPUT_NOT_CONSUMED;\n    } else if (rh == LZMA_RESULT_INPUT_OVERRUN)\n        r = UPX_E_INPUT_OVERRUN;\n    else if (rh == LZMA_RESULT_OUTPUT_OVERRUN)\n        r = UPX_E_OUTPUT_OVERRUN;\n\nerror:\n    *dst_len = dst_out;\n    free(s.Probs);\n    return r;\n}\n\n/*************************************************************************\n// test_overlap - see <ucl/ucl.h> for semantics\n**************************************************************************/\n\nint upx_lzma_test_overlap(const upx_bytep buf, const upx_bytep tbuf, unsigned src_off,\n                          unsigned src_len, unsigned *dst_len, int method,\n                          const upx_compress_result_t *cresult) {\n    assert(M_IS_LZMA(method));\n\n    MemBuffer b(src_off + src_len);\n    memcpy(b + src_off, buf + src_off, src_len);\n    unsigned saved_dst_len = *dst_len;\n    int r = upx_lzma_decompress(raw_index_bytes(b, src_off, src_len), src_len,\n                                raw_bytes(b, *dst_len), dst_len, method, cresult);\n    if (r != UPX_E_OK)\n        return r;\n    if (*dst_len != saved_dst_len)\n        return UPX_E_ERROR;\n    // NOTE: there is a very tiny possibility that decompression has\n    //   succeeded but the data is not restored correctly because of\n    //   in-place buffer overlapping, so we use an extra memcmp().\n    if (tbuf != nullptr && memcmp(tbuf, b, *dst_len) != 0)\n        return UPX_E_ERROR;\n    return UPX_E_OK;\n}\n\n/*************************************************************************\n// misc\n**************************************************************************/\n\nint upx_lzma_init(void) { return 0; }\n\nconst char *upx_lzma_version_string(void) { return \"4.43\"; }\n\n/*************************************************************************\n// doctest checks\n**************************************************************************/\n\nTEST_CASE(\"upx_lzma_decompress\") {\n    const byte *c_data;\n    byte d_buf[16];\n    unsigned d_len;\n    int r;\n\n    c_data = (const byte *) \"\\x1a\\x03\\x00\\x7f\\xed\\x3c\\x00\\x00\\x00\";\n    d_len = 16;\n    r = upx_lzma_decompress(c_data, 9, d_buf, &d_len, M_LZMA, nullptr);\n    CHECK((r == 0 && d_len == 16));\n    r = upx_lzma_decompress(c_data, 8, d_buf, &d_len, M_LZMA, nullptr);\n    CHECK(r == UPX_E_INPUT_OVERRUN);\n    d_len = 15;\n    r = upx_lzma_decompress(c_data, 9, d_buf, &d_len, M_LZMA, nullptr);\n    CHECK(r == UPX_E_OUTPUT_OVERRUN);\n    UNUSED(r);\n}\n\n/* vim:set ts=4 sw=4 et: */\n","size_bytes":18191},"src/compress/compress_ucl.cpp":{"content":"/* compress_ucl.cpp --\n\n   This file is part of the Resize executable compressor.\n\n   Copyright (C) 2025 WHO-AM-I-404\n   Based on UPX - Ultimate Packer for eXecutables\n   Copyright (C) 1996-2025 Markus Franz Xaver Johannes Oberhumer\n   All Rights Reserved.\n\n   Resize and the UCL library are free software; you can redistribute them\n   and/or modify them under the terms of the GNU General Public License as\n   published by the Free Software Foundation; either version 2 of\n   the License, or (at your option) any later version.\n\n   This program is distributed in the hope that it will be useful,\n   but WITHOUT ANY WARRANTY; without even the implied warranty of\n   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n   GNU General Public License for more details.\n\n   You should have received a copy of the GNU General Public License\n   along with this program; see the file COPYING.\n   If not, write to the Free Software Foundation, Inc.,\n   59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.\n\n   Markus F.X.J. Oberhumer\n   <markus@oberhumer.com>\n */\n\n#include \"../conf.h\"\n#include \"compress.h\"\n\n/*************************************************************************\n//\n**************************************************************************/\n\nstatic int convert_errno_from_ucl(int r) {\n    switch (r) {\n    case UCL_E_OK:\n        return UPX_E_OK;\n    case UCL_E_ERROR:\n        return UPX_E_ERROR;\n    case UCL_E_OUT_OF_MEMORY:\n        return UPX_E_OUT_OF_MEMORY;\n    case UCL_E_NOT_COMPRESSIBLE:\n        return UPX_E_NOT_COMPRESSIBLE;\n    case UCL_E_INPUT_OVERRUN:\n        return UPX_E_INPUT_OVERRUN;\n    case UCL_E_OUTPUT_OVERRUN:\n        return UPX_E_OUTPUT_OVERRUN;\n    case UCL_E_LOOKBEHIND_OVERRUN:\n        return UPX_E_LOOKBEHIND_OVERRUN;\n    case UCL_E_EOF_NOT_FOUND:\n        return UPX_E_EOF_NOT_FOUND;\n    case UCL_E_INPUT_NOT_CONSUMED:\n        return UPX_E_INPUT_NOT_CONSUMED;\n    case UCL_E_INVALID_ARGUMENT:\n        return UPX_E_INVALID_ARGUMENT;\n    // UCL extra:\n    case UCL_E_OVERLAP_OVERRUN:\n        return UPX_E_ERROR;\n    default:\n        break;\n    }\n    return UPX_E_ERROR;\n}\n\nextern \"C\" {\nstatic void __UCL_CDECL wrap_nprogress_ucl(ucl_uint a, ucl_uint b, int state, ucl_voidp user) {\n    if (state != -1 && state != 3)\n        return;\n    upx_callback_t *cb = (upx_callback_t *) user;\n    if (cb && cb->nprogress)\n        cb->nprogress(cb, a, b);\n}\n}\n\n/*************************************************************************\n//\n**************************************************************************/\n\nint upx_ucl_compress(const upx_bytep src, unsigned src_len, upx_bytep dst, unsigned *dst_len,\n                     upx_callback_t *cb_parm, int method, int level,\n                     const upx_compress_config_t *cconf_parm, upx_compress_result_t *cresult) {\n    int r;\n    assert(level > 0);\n    assert(cresult != nullptr);\n\n    COMPILE_TIME_ASSERT(sizeof(ucl_compress_config_t) == sizeof(REAL_ucl_compress_config_t))\n\n    ucl_progress_callback_t cb;\n    cb.callback = nullptr;\n    cb.user = nullptr;\n    if (cb_parm && cb_parm->nprogress) {\n        cb.callback = wrap_nprogress_ucl;\n        cb.user = cb_parm;\n    }\n\n    ucl_compress_config_t cconf;\n    cconf.reset();\n    if (cconf_parm) {\n        // cconf = cconf_parm->conf_ucl; // struct copy\n        memcpy(&cconf, &cconf_parm->conf_ucl, sizeof(cconf));\n    }\n\n    ucl_uint *const res = cresult->result_ucl.result;\n    // assume no info available - fill in worst case results\n    // res[0] = 1;        // min_offset_found - NOT USED\n    res[1] = src_len - 1; // max_offset_found\n    // res[2] = 2;        // min_match_found - NOT USED\n    res[3] = src_len - 1; // max_match_found\n    // res[4] = 1;        // min_run_found - NOT USED\n    res[5] = src_len; // max_run_found\n    res[6] = 1;       // first_offset_found\n    // res[7] = 999999;   // same_match_offsets_found - NOT USED\n\n    // prepare bit-buffer settings\n    cconf.bb_endian = 0;\n    cconf.bb_size = 0;\n    if (method >= M_NRV2B_LE32 && method <= M_NRV2E_LE16) {\n        static const upx_uint8_t sizes[3] = {32, 8, 16};\n        cconf.bb_size = sizes[(method - M_NRV2B_LE32) % 3];\n    } else {\n        throwInternalError(\"unknown compression method\");\n        return UPX_E_ERROR;\n    }\n\n    // optimize compression params\n    if (level <= 3 && cconf.max_offset == UCL_UINT_MAX)\n        cconf.max_offset = 8 * 1024 - 1;\n    else if (level == 4 && cconf.max_offset == UCL_UINT_MAX)\n        cconf.max_offset = 32 * 1024 - 1;\n\n    if M_IS_NRV2B (method)\n        r = ucl_nrv2b_99_compress(src, src_len, dst, dst_len, &cb, level, &cconf, res);\n    else if M_IS_NRV2D (method)\n        r = ucl_nrv2d_99_compress(src, src_len, dst, dst_len, &cb, level, &cconf, res);\n    else if M_IS_NRV2E (method)\n        r = ucl_nrv2e_99_compress(src, src_len, dst, dst_len, &cb, level, &cconf, res);\n    else {\n        throwInternalError(\"unknown compression method\");\n        return UPX_E_ERROR;\n    }\n\n    // make sure first_offset_found is set\n    if (res[6] == 0)\n        res[6] = 1;\n\n    return convert_errno_from_ucl(r);\n}\n\n/*************************************************************************\n//\n**************************************************************************/\n\nint upx_ucl_decompress(const upx_bytep src, unsigned src_len, upx_bytep dst, unsigned *dst_len,\n                       int method, const upx_compress_result_t *cresult) {\n    int r;\n\n    switch (method) {\n    case M_NRV2B_8:\n        r = ucl_nrv2b_decompress_safe_8(src, src_len, dst, dst_len, nullptr);\n        break;\n    case M_NRV2B_LE16:\n        r = ucl_nrv2b_decompress_safe_le16(src, src_len, dst, dst_len, nullptr);\n        break;\n    case M_NRV2B_LE32:\n        r = ucl_nrv2b_decompress_safe_le32(src, src_len, dst, dst_len, nullptr);\n        break;\n    case M_NRV2D_8:\n        r = ucl_nrv2d_decompress_safe_8(src, src_len, dst, dst_len, nullptr);\n        break;\n    case M_NRV2D_LE16:\n        r = ucl_nrv2d_decompress_safe_le16(src, src_len, dst, dst_len, nullptr);\n        break;\n    case M_NRV2D_LE32:\n        r = ucl_nrv2d_decompress_safe_le32(src, src_len, dst, dst_len, nullptr);\n        break;\n    case M_NRV2E_8:\n        r = ucl_nrv2e_decompress_safe_8(src, src_len, dst, dst_len, nullptr);\n        break;\n    case M_NRV2E_LE16:\n        r = ucl_nrv2e_decompress_safe_le16(src, src_len, dst, dst_len, nullptr);\n        break;\n    case M_NRV2E_LE32:\n        r = ucl_nrv2e_decompress_safe_le32(src, src_len, dst, dst_len, nullptr);\n        break;\n    default:\n        throwInternalError(\"unknown decompression method\");\n        return UPX_E_ERROR;\n    }\n\n    UNUSED(cresult);\n    return convert_errno_from_ucl(r);\n}\n\n/*************************************************************************\n//\n**************************************************************************/\n\nint upx_ucl_test_overlap(const upx_bytep buf, const upx_bytep tbuf, unsigned src_off,\n                         unsigned src_len, unsigned *dst_len, int method,\n                         const upx_compress_result_t *cresult) {\n    int r;\n    UNUSED(tbuf); // not needed for UCL\n\n    switch (method) {\n    case M_NRV2B_8:\n        r = ucl_nrv2b_test_overlap_8(buf, src_off, src_len, dst_len, nullptr);\n        break;\n    case M_NRV2B_LE16:\n        r = ucl_nrv2b_test_overlap_le16(buf, src_off, src_len, dst_len, nullptr);\n        break;\n    case M_NRV2B_LE32:\n        r = ucl_nrv2b_test_overlap_le32(buf, src_off, src_len, dst_len, nullptr);\n        break;\n    case M_NRV2D_8:\n        r = ucl_nrv2d_test_overlap_8(buf, src_off, src_len, dst_len, nullptr);\n        break;\n    case M_NRV2D_LE16:\n        r = ucl_nrv2d_test_overlap_le16(buf, src_off, src_len, dst_len, nullptr);\n        break;\n    case M_NRV2D_LE32:\n        r = ucl_nrv2d_test_overlap_le32(buf, src_off, src_len, dst_len, nullptr);\n        break;\n    case M_NRV2E_8:\n        r = ucl_nrv2e_test_overlap_8(buf, src_off, src_len, dst_len, nullptr);\n        break;\n    case M_NRV2E_LE16:\n        r = ucl_nrv2e_test_overlap_le16(buf, src_off, src_len, dst_len, nullptr);\n        break;\n    case M_NRV2E_LE32:\n        r = ucl_nrv2e_test_overlap_le32(buf, src_off, src_len, dst_len, nullptr);\n        break;\n    default:\n        throwInternalError(\"unknown decompression method\");\n        return UPX_E_ERROR;\n    }\n\n    UNUSED(cresult);\n    return convert_errno_from_ucl(r);\n}\n\n/*************************************************************************\n// misc\n**************************************************************************/\n\nextern \"C\" {\nstatic ucl_voidp __UCL_CDECL my_malloc(ucl_uint n) { return upx_calloc(n, 1); }\nstatic void __UCL_CDECL my_free(ucl_voidp p) { free(p); }\n} // extern \"C\"\n\nint upx_ucl_init(void) {\n#if (ACC_CC_MSC && ACC_ARCH_I386) && (_MSC_VER >= 1940)\n    (void) ucl_init(); // TODO later\n#else\n    if (ucl_init() != UCL_E_OK)\n        return -1;\n#endif\n    if (UCL_VERSION != ucl_version() || strcmp(UCL_VERSION_STRING, ucl_version_string()) != 0)\n        return -2;\n    ucl_set_malloc_hooks(my_malloc, my_free);\n    return 0;\n}\n\nconst char *upx_ucl_version_string(void) { return ucl_version_string(); }\n\nunsigned upx_ucl_adler32(const void *buf, unsigned len, unsigned adler) {\n    return ucl_adler32(adler, (const ucl_bytep) buf, len);\n}\n\n#if 0 // UNUSED\nunsigned upx_ucl_crc32(const void *buf, unsigned len, unsigned crc) {\n    return ucl_crc32(crc, (const ucl_bytep) buf, len);\n}\n#endif\n\n/*************************************************************************\n// doctest checks\n**************************************************************************/\n\n#if DEBUG && !defined(DOCTEST_CONFIG_DISABLE) && 1\n\n#include \"../util/membuffer.h\"\n\nstatic bool check_ucl(const int method, const unsigned expected_c_len) {\n    const unsigned u_len = 16384;\n    const unsigned c_extra = 4096;\n    MemBuffer u_buf, c_buf, d_buf;\n    unsigned c_len, d_len;\n    upx_compress_result_t cresult;\n    int r;\n    const int level = 3; // don't waste time\n\n    u_buf.alloc(u_len);\n    memset(u_buf, 0, u_len);\n    c_buf.allocForCompression(u_len, c_extra);\n    d_buf.allocForDecompression(u_len);\n\n    c_len = c_buf.getSize() - c_extra;\n    r = upx_ucl_compress(raw_bytes(u_buf, u_len), u_len, raw_index_bytes(c_buf, c_extra, c_len),\n                         &c_len, nullptr, method, level, NULL_cconf, &cresult);\n    if (r != 0 || c_len != expected_c_len)\n        return false;\n\n    d_len = d_buf.getSize();\n    r = upx_ucl_decompress(raw_index_bytes(c_buf, c_extra, c_len), c_len, raw_bytes(d_buf, d_len),\n                           &d_len, method, nullptr);\n    if (r != 0 || d_len != u_len || memcmp(u_buf, d_buf, u_len) != 0)\n        return false;\n\n    d_len = u_len - 1;\n    r = upx_ucl_decompress(raw_index_bytes(c_buf, c_extra, c_len), c_len, raw_bytes(d_buf, d_len),\n                           &d_len, method, nullptr);\n    if (r == 0)\n        return false;\n\n    // TODO: rewrite Packer::findOverlapOverhead() so that we can test it here\n    // unsigned x_len = d_len;\n    // r = upx_ucl_test_overlap(c_buf, u_buf, c_extra, c_len, &x_len, method, nullptr);\n    return true;\n}\n\nTEST_CASE(\"compress_ucl\") {\n    CHECK(check_ucl(M_NRV2B_8, 34));\n    CHECK(check_ucl(M_NRV2B_LE16, 34));\n    CHECK(check_ucl(M_NRV2B_LE32, 34));\n    CHECK(check_ucl(M_NRV2D_8, 32));\n    CHECK(check_ucl(M_NRV2D_LE16, 32));\n    CHECK(check_ucl(M_NRV2D_LE32, 34));\n    CHECK(check_ucl(M_NRV2E_8, 32));\n    CHECK(check_ucl(M_NRV2E_LE16, 32));\n    CHECK(check_ucl(M_NRV2E_LE32, 34));\n}\n\n#endif // DEBUG\n\nTEST_CASE(\"upx_ucl_decompress\") {\n    const byte *c_data;\n    byte d_buf[16];\n    unsigned d_len;\n    int r;\n\n    c_data = (const byte *) \"\\x92\\xff\\x10\\x00\\x00\\x00\\x00\\x00\\x48\\xff\";\n    d_len = 16;\n    r = upx_ucl_decompress(c_data, 10, d_buf, &d_len, M_NRV2B_8, nullptr);\n    CHECK((r == 0 && d_len == 16));\n    r = upx_ucl_decompress(c_data, 9, d_buf, &d_len, M_NRV2B_8, nullptr);\n    CHECK(r == UPX_E_INPUT_OVERRUN);\n    d_len = 15;\n    r = upx_ucl_decompress(c_data, 10, d_buf, &d_len, M_NRV2B_8, nullptr);\n    CHECK(r == UPX_E_OUTPUT_OVERRUN);\n\n    c_data = (const byte *) \"\\x92\\xff\\x10\\x92\\x49\\x24\\x92\\xa0\\xff\";\n    d_len = 16;\n    r = upx_ucl_decompress(c_data, 9, d_buf, &d_len, M_NRV2D_8, nullptr);\n    CHECK((r == 0 && d_len == 16));\n    r = upx_ucl_decompress(c_data, 8, d_buf, &d_len, M_NRV2D_8, nullptr);\n    CHECK(r == UPX_E_INPUT_OVERRUN);\n    d_len = 15;\n    r = upx_ucl_decompress(c_data, 9, d_buf, &d_len, M_NRV2D_8, nullptr);\n    CHECK(r == UPX_E_OUTPUT_OVERRUN);\n\n    c_data = (const byte *) \"\\x90\\xff\\xb0\\x92\\x49\\x24\\x92\\xa0\\xff\";\n    d_len = 16;\n    r = upx_ucl_decompress(c_data, 9, d_buf, &d_len, M_NRV2E_8, nullptr);\n    CHECK((r == 0 && d_len == 16));\n    r = upx_ucl_decompress(c_data, 8, d_buf, &d_len, M_NRV2E_8, nullptr);\n    CHECK(r == UPX_E_INPUT_OVERRUN);\n    d_len = 15;\n    r = upx_ucl_decompress(c_data, 9, d_buf, &d_len, M_NRV2E_8, nullptr);\n    CHECK(r == UPX_E_OUTPUT_OVERRUN);\n    UNUSED(r);\n}\n\n/* vim:set ts=4 sw=4 et: */\n","size_bytes":12943},"src/compress/compress_zlib.cpp":{"content":"/* compress_zlib.cpp --\n\n   This file is part of the Resize executable compressor.\n\n   Copyright (C) 2025 WHO-AM-I-404\n   Based on UPX - Ultimate Packer for eXecutables\n   Copyright (C) 1996-2025 Markus Franz Xaver Johannes Oberhumer\n   All Rights Reserved.\n\n   Resize and the UCL library are free software; you can redistribute them\n   and/or modify them under the terms of the GNU General Public License as\n   published by the Free Software Foundation; either version 2 of\n   the License, or (at your option) any later version.\n\n   This program is distributed in the hope that it will be useful,\n   but WITHOUT ANY WARRANTY; without even the implied warranty of\n   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n   GNU General Public License for more details.\n\n   You should have received a copy of the GNU General Public License\n   along with this program; see the file COPYING.\n   If not, write to the Free Software Foundation, Inc.,\n   59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.\n\n   Markus F.X.J. Oberhumer\n   <markus@oberhumer.com>\n */\n\n#include \"../conf.h\"\n\nvoid zlib_compress_config_t::reset() noexcept {\n    mem_clear(this);\n    mem_level.reset();\n    window_bits.reset();\n    strategy.reset();\n}\n\n#if WITH_ZLIB\n#include \"compress.h\"\n#include \"../util/membuffer.h\"\n// NOLINTBEGIN(clang-analyzer-optin.performance.Padding)\n#define ZLIB_CONST 1\n#include <zlib/zlib.h>\n#include <zlib/deflate.h>\n// NOLINTEND(clang-analyzer-optin.performance.Padding)\n\nstatic int convert_errno_from_zlib(int zr) {\n    switch (zr) {\n    case Z_OK:\n        return UPX_E_OK;\n    // positive values\n    case Z_STREAM_END:\n        return UPX_E_ERROR;\n    case Z_NEED_DICT:\n        return UPX_E_ERROR;\n    // negative values\n    case Z_ERRNO:\n        return UPX_E_ERROR;\n    case Z_STREAM_ERROR:\n        return UPX_E_ERROR;\n    case Z_DATA_ERROR:\n        return UPX_E_ERROR;\n    case Z_MEM_ERROR:\n        return UPX_E_OUT_OF_MEMORY;\n    case Z_BUF_ERROR:\n        return UPX_E_OUTPUT_OVERRUN;\n    case Z_VERSION_ERROR:\n        return UPX_E_ERROR;\n    case -7: // UPX extra\n        return UPX_E_INPUT_OVERRUN;\n    default:\n        break;\n    }\n    return UPX_E_ERROR;\n}\n\n/*************************************************************************\n//\n**************************************************************************/\n\nint upx_zlib_compress(const upx_bytep src, unsigned src_len, upx_bytep dst, unsigned *dst_len,\n                      upx_callback_t *cb_parm, int method, int level,\n                      const upx_compress_config_t *cconf_parm, upx_compress_result_t *cresult) {\n    assert(method == M_DEFLATE);\n    assert(level > 0);\n    assert(cresult != nullptr);\n    UNUSED(cb_parm);\n    int r = UPX_E_ERROR;\n    int zr;\n    const zlib_compress_config_t *const lcconf = cconf_parm ? &cconf_parm->conf_zlib : nullptr;\n    zlib_compress_result_t *const res = &cresult->result_zlib;\n    res->reset();\n\n    if (level == 10)\n        level = 9;\n\n    zlib_compress_config_t::mem_level_t mem_level;\n    zlib_compress_config_t::window_bits_t window_bits;\n    zlib_compress_config_t::strategy_t strategy;\n    // cconf overrides\n    if (lcconf) {\n        upx::oassign(mem_level, lcconf->mem_level);\n        upx::oassign(window_bits, lcconf->window_bits);\n        upx::oassign(strategy, lcconf->strategy);\n    }\n\n    z_stream s;\n    s.zalloc = (alloc_func) nullptr;\n    s.zfree = (free_func) nullptr;\n    s.next_in = src;\n    s.avail_in = src_len;\n    s.next_out = dst;\n    s.avail_out = *dst_len;\n    s.total_in = s.total_out = 0;\n\n    zr = (int) deflateInit2(&s, level, Z_DEFLATED, 0 - (int) window_bits, mem_level, strategy);\n    if (zr != Z_OK)\n        goto error;\n    assert(s.state->level == level);\n    zr = deflate(&s, Z_FINISH);\n    if (zr != Z_STREAM_END)\n        goto error;\n    zr = deflateEnd(&s);\n    if (zr != Z_OK)\n        goto error;\n    r = UPX_E_OK;\n    goto done;\nerror:\n    (void) deflateEnd(&s);\n    r = convert_errno_from_zlib(zr);\n    if (r == UPX_E_OK)\n        r = UPX_E_ERROR;\ndone:\n    if (r == UPX_E_OK) {\n        if (s.avail_in != 0 || s.total_in != src_len)\n            r = UPX_E_ERROR;\n    }\n    assert(s.total_in <= src_len);\n    assert(s.total_out <= *dst_len);\n    *dst_len = s.total_out;\n    return r;\n}\n\n/*************************************************************************\n//\n**************************************************************************/\n\nint upx_zlib_decompress(const upx_bytep src, unsigned src_len, upx_bytep dst, unsigned *dst_len,\n                        int method, const upx_compress_result_t *cresult) {\n    assert(method == M_DEFLATE);\n    UNUSED(method);\n    UNUSED(cresult);\n    int r = UPX_E_ERROR;\n    int zr;\n\n    z_stream s;\n    s.zalloc = (alloc_func) nullptr;\n    s.zfree = (free_func) nullptr;\n    s.next_in = src;\n    s.avail_in = src_len;\n    s.next_out = dst;\n    s.avail_out = *dst_len;\n    s.total_in = s.total_out = 0;\n\n    zr = inflateInit2(&s, -15);\n    if (zr != Z_OK)\n        goto error;\n    zr = inflate(&s, Z_FINISH);\n    if (zr != Z_STREAM_END) {\n        if (zr == Z_BUF_ERROR && s.avail_in == 0)\n            zr = -7; // UPX extra\n        goto error;\n    }\n    zr = inflateEnd(&s);\n    if (zr != Z_OK)\n        goto error;\n    r = UPX_E_OK;\n    goto done;\nerror:\n    (void) inflateEnd(&s);\n    r = convert_errno_from_zlib(zr);\n    if (r == UPX_E_OK)\n        r = UPX_E_ERROR;\ndone:\n    if (r == UPX_E_OK) {\n        if (s.avail_in != 0 || s.total_in != src_len)\n            r = UPX_E_INPUT_NOT_CONSUMED;\n    }\n    assert(s.total_in <= src_len);\n    assert(s.total_out <= *dst_len);\n    *dst_len = s.total_out;\n    return r;\n}\n\n/*************************************************************************\n// test_overlap - see <ucl/ucl.h> for semantics\n**************************************************************************/\n\nint upx_zlib_test_overlap(const upx_bytep buf, const upx_bytep tbuf, unsigned src_off,\n                          unsigned src_len, unsigned *dst_len, int method,\n                          const upx_compress_result_t *cresult) {\n    assert(method == M_DEFLATE);\n\n    MemBuffer b(src_off + src_len);\n    memcpy(b + src_off, buf + src_off, src_len);\n    unsigned saved_dst_len = *dst_len;\n    int r = upx_zlib_decompress(raw_index_bytes(b, src_off, src_len), src_len,\n                                raw_bytes(b, *dst_len), dst_len, method, cresult);\n    if (r != UPX_E_OK)\n        return r;\n    if (*dst_len != saved_dst_len)\n        return UPX_E_ERROR;\n    // NOTE: there is a very tiny possibility that decompression has\n    //   succeeded but the data is not restored correctly because of\n    //   in-place buffer overlapping, so we use an extra memcmp().\n    if (tbuf != nullptr && memcmp(tbuf, b, *dst_len) != 0)\n        return UPX_E_ERROR;\n    return UPX_E_OK;\n}\n\n/*************************************************************************\n// misc\n**************************************************************************/\n\nint upx_zlib_init(void) {\n    if (strcmp(ZLIB_VERSION, zlibVersion()) != 0)\n        return -2;\n    return 0;\n}\n\nconst char *upx_zlib_version_string(void) { return zlibVersion(); }\n\n#if 0 // UNUSED\nunsigned upx_zlib_adler32(const void *buf, unsigned len, unsigned adler) {\n    return adler32(adler, (const Bytef *) buf, len);\n}\n#endif\n\n#if 0 // UNUSED\nunsigned upx_zlib_crc32(const void *buf, unsigned len, unsigned crc) {\n    return crc32(crc, (const Bytef *) buf, len);\n}\n#endif\n\n/*************************************************************************\n// doctest checks\n**************************************************************************/\n\n#if DEBUG && !defined(DOCTEST_CONFIG_DISABLE) && 1\n\nstatic bool check_zlib(const int method, const int level, const unsigned expected_c_len) {\n    const unsigned u_len = 16384;\n    const unsigned c_extra = 4096;\n    MemBuffer u_buf, c_buf, d_buf;\n    unsigned c_len, d_len;\n    upx_compress_result_t cresult;\n    int r;\n\n    u_buf.alloc(u_len);\n    memset(u_buf, 0, u_len);\n    c_buf.allocForCompression(u_len, c_extra);\n    d_buf.allocForDecompression(u_len);\n\n    c_len = c_buf.getSize() - c_extra;\n    r = upx_zlib_compress(raw_bytes(u_buf, u_len), u_len, raw_index_bytes(c_buf, c_extra, c_len),\n                          &c_len, nullptr, method, level, NULL_cconf, &cresult);\n    if (r != 0 || c_len != expected_c_len)\n        return false;\n\n    d_len = d_buf.getSize();\n    r = upx_zlib_decompress(raw_index_bytes(c_buf, c_extra, c_len), c_len, raw_bytes(d_buf, d_len),\n                            &d_len, method, nullptr);\n    if (r != 0 || d_len != u_len || memcmp(u_buf, d_buf, u_len) != 0)\n        return false;\n\n    d_len = u_len - 1;\n    r = upx_zlib_decompress(raw_index_bytes(c_buf, c_extra, c_len), c_len, raw_bytes(d_buf, d_len),\n                            &d_len, method, nullptr);\n    if (r == 0)\n        return false;\n\n    // TODO: rewrite Packer::findOverlapOverhead() so that we can test it here\n    // unsigned x_len = d_len;\n    // r = upx_zlib_test_overlap(c_buf, u_buf, c_extra, c_len, &x_len, method, nullptr);\n    return true;\n}\n\nTEST_CASE(\"compress_zlib\") {\n    CHECK(check_zlib(M_DEFLATE, 1, 89));\n    CHECK(check_zlib(M_DEFLATE, 3, 89));\n    CHECK(check_zlib(M_DEFLATE, 5, 33));\n}\n\n#endif // DEBUG\n\nTEST_CASE(\"upx_zlib_decompress\") {\n    const byte *c_data;\n    byte d_buf[16];\n    unsigned d_len;\n    int r;\n\n    c_data = (const byte *) \"\\xfb\\xff\\x1f\\x15\\x00\\x00\";\n    d_len = 16;\n    r = upx_zlib_decompress(c_data, 6, d_buf, &d_len, M_DEFLATE, nullptr);\n    CHECK((r == 0 && d_len == 16));\n    r = upx_zlib_decompress(c_data, 5, d_buf, &d_len, M_DEFLATE, nullptr);\n    CHECK(r == UPX_E_INPUT_OVERRUN);\n    d_len = 15;\n    r = upx_zlib_decompress(c_data, 6, d_buf, &d_len, M_DEFLATE, nullptr);\n    CHECK(r == UPX_E_OUTPUT_OVERRUN);\n    UNUSED(r);\n}\n\n#endif // WITH_ZLIB\n\n/* vim:set ts=4 sw=4 et: */\n","size_bytes":9831},"src/compress/compress_zstd.cpp":{"content":"/* compress_zstd.cpp --\n\n   This file is part of the Resize executable compressor.\n\n   Copyright (C) 2025 WHO-AM-I-404\n   Based on UPX - Ultimate Packer for eXecutables\n   Copyright (C) 1996-2025 Markus Franz Xaver Johannes Oberhumer\n   All Rights Reserved.\n\n   Resize and the UCL library are free software; you can redistribute them\n   and/or modify them under the terms of the GNU General Public License as\n   published by the Free Software Foundation; either version 2 of\n   the License, or (at your option) any later version.\n\n   This program is distributed in the hope that it will be useful,\n   but WITHOUT ANY WARRANTY; without even the implied warranty of\n   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n   GNU General Public License for more details.\n\n   You should have received a copy of the GNU General Public License\n   along with this program; see the file COPYING.\n   If not, write to the Free Software Foundation, Inc.,\n   59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.\n\n   Markus F.X.J. Oberhumer\n   <markus@oberhumer.com>\n */\n\n#include \"../util/system_headers.h\"\n#if WITH_ZSTD\n#include <zstd/lib/zstd.h>\n#include <zstd/lib/zstd_errors.h>\n#include <zstd/lib/compress/hist.h>\n#endif\n#include \"../conf.h\"\n\nvoid zstd_compress_config_t::reset() noexcept { mem_clear(this); }\n\n#if WITH_ZSTD\n#include \"compress.h\"\n#include \"../util/membuffer.h\"\n\nstatic int convert_errno_from_zstd(size_t zr) {\n    const ZSTD_ErrorCode ze = ZSTD_getErrorCode(zr);\n    switch (ze) {\n    case ZSTD_error_memory_allocation:\n        return UPX_E_OUT_OF_MEMORY;\n    case ZSTD_error_srcSize_wrong:\n        return UPX_E_INPUT_OVERRUN;\n    case ZSTD_error_dstSize_tooSmall:\n        return UPX_E_OUTPUT_OVERRUN;\n    default:\n        break;\n    }\n    return UPX_E_ERROR;\n}\n\n/*************************************************************************\n// TODO later: use advanced compression API for compression finetuning\n**************************************************************************/\n\nint upx_zstd_compress(const upx_bytep src, unsigned src_len, upx_bytep dst, unsigned *dst_len,\n                      upx_callback_t *cb_parm, int method, int level,\n                      const upx_compress_config_t *cconf_parm, upx_compress_result_t *cresult) {\n    assert(method == M_ZSTD);\n    assert(level > 0);\n    assert(cresult != nullptr);\n    UNUSED(cb_parm);\n    int r = UPX_E_ERROR;\n    size_t zr;\n    const zstd_compress_config_t *const lcconf = cconf_parm ? &cconf_parm->conf_zstd : nullptr;\n    zstd_compress_result_t *const res = &cresult->result_zstd;\n    res->reset();\n\n    // TODO later: map level 1..10 to zstd-level 1..22\n    if (level == 10)\n        level = 22;\n\n    // cconf overrides\n    if (lcconf) {\n        UNUSED(lcconf);\n    }\n\n    zr = ZSTD_compress(dst, *dst_len, src, src_len, level);\n    if (ZSTD_isError(zr)) {\n        *dst_len = 0; // TODO ???\n        r = convert_errno_from_zstd(zr);\n        assert(r != UPX_E_OK);\n    } else {\n        assert(zr <= *dst_len);\n        *dst_len = (unsigned) zr;\n        r = UPX_E_OK;\n    }\n\n    return r;\n}\n\n/*************************************************************************\n//\n**************************************************************************/\n\nint upx_zstd_decompress(const upx_bytep src, unsigned src_len, upx_bytep dst, unsigned *dst_len,\n                        int method, const upx_compress_result_t *cresult) {\n    assert(method == M_ZSTD);\n    UNUSED(method);\n    UNUSED(cresult);\n    int r = UPX_E_ERROR;\n    size_t zr;\n\n    zr = ZSTD_decompress(dst, *dst_len, src, src_len);\n    if (ZSTD_isError(zr)) {\n        *dst_len = 0; // TODO ???\n        r = convert_errno_from_zstd(zr);\n        assert(r != UPX_E_OK);\n    } else {\n        assert(zr <= *dst_len);\n        *dst_len = (unsigned) zr;\n        r = UPX_E_OK;\n    }\n\n    return r;\n}\n\n/*************************************************************************\n// test_overlap - see <ucl/ucl.h> for semantics\n**************************************************************************/\n\nint upx_zstd_test_overlap(const upx_bytep buf, const upx_bytep tbuf, unsigned src_off,\n                          unsigned src_len, unsigned *dst_len, int method,\n                          const upx_compress_result_t *cresult) {\n    assert(method == M_ZSTD);\n\n    MemBuffer b(src_off + src_len);\n    memcpy(b + src_off, buf + src_off, src_len);\n    unsigned saved_dst_len = *dst_len;\n    int r = upx_zstd_decompress(raw_index_bytes(b, src_off, src_len), src_len,\n                                raw_bytes(b, *dst_len), dst_len, method, cresult);\n    if (r != UPX_E_OK)\n        return r;\n    if (*dst_len != saved_dst_len)\n        return UPX_E_ERROR;\n    // NOTE: there is a very tiny possibility that decompression has\n    //   succeeded but the data is not restored correctly because of\n    //   in-place buffer overlapping, so we use an extra memcmp().\n    if (tbuf != nullptr && memcmp(tbuf, b, *dst_len) != 0)\n        return UPX_E_ERROR;\n    return UPX_E_OK;\n}\n\n/*************************************************************************\n// misc\n**************************************************************************/\n\nint upx_zstd_init(void) {\n    if (strcmp(ZSTD_VERSION_STRING, ZSTD_versionString()) != 0)\n        return -2;\n    return 0;\n}\n\nconst char *upx_zstd_version_string(void) { return ZSTD_VERSION_STRING; }\n\n/*************************************************************************\n// doctest checks\n**************************************************************************/\n\n#if DEBUG && !defined(DOCTEST_CONFIG_DISABLE) && 1\n\nstatic bool check_zstd(const int method, const int level, const unsigned expected_c_len) {\n    const unsigned u_len = 16384;\n    const unsigned c_extra = 4096;\n    MemBuffer u_buf, c_buf, d_buf;\n    unsigned c_len, d_len;\n    upx_compress_result_t cresult;\n    int r;\n\n    u_buf.alloc(u_len);\n    memset(u_buf, 0, u_len);\n    c_buf.allocForCompression(u_len, c_extra);\n    d_buf.allocForDecompression(u_len);\n\n    c_len = c_buf.getSize() - c_extra;\n    r = upx_zstd_compress(raw_bytes(u_buf, u_len), u_len, raw_index_bytes(c_buf, c_extra, c_len),\n                          &c_len, nullptr, method, level, NULL_cconf, &cresult);\n    if (r != 0 || c_len != expected_c_len)\n        return false;\n\n    d_len = d_buf.getSize();\n    r = upx_zstd_decompress(raw_index_bytes(c_buf, c_extra, c_len), c_len, raw_bytes(d_buf, d_len),\n                            &d_len, method, nullptr);\n    if (r != 0 || d_len != u_len || memcmp(u_buf, d_buf, u_len) != 0)\n        return false;\n\n    d_len = u_len - 1;\n    r = upx_zstd_decompress(raw_index_bytes(c_buf, c_extra, c_len), c_len, raw_bytes(d_buf, d_len),\n                            &d_len, method, nullptr);\n    if (r == 0)\n        return false;\n\n    // TODO: rewrite Packer::findOverlapOverhead() so that we can test it here\n    // unsigned x_len = d_len;\n    // r = upx_zstd_test_overlap(c_buf, u_buf, c_extra, c_len, &x_len, method, nullptr);\n    return true;\n}\n\nTEST_CASE(\"compress_zstd\") {\n    CHECK(check_zstd(M_ZSTD, 1, 19));\n    CHECK(check_zstd(M_ZSTD, 3, 19));\n    CHECK(check_zstd(M_ZSTD, 5, 19));\n}\n\n#endif // DEBUG\n\nTEST_CASE(\"upx_zstd_decompress\") {\n    const byte *c_data;\n    byte d_buf[32];\n    unsigned d_len;\n    int r;\n\n    c_data = (const byte *) \"\\x28\\xb5\\x2f\\xfd\\x20\\x20\\x3d\\x00\\x00\\x08\\xff\\x01\\x00\\x34\\x4e\\x08\";\n    d_len = 32;\n    r = upx_zstd_decompress(c_data, 16, d_buf, &d_len, M_ZSTD, nullptr);\n    CHECK((r == 0 && d_len == 32));\n    r = upx_zstd_decompress(c_data, 15, d_buf, &d_len, M_ZSTD, nullptr);\n    CHECK(r == UPX_E_INPUT_OVERRUN);\n    d_len = 31;\n    r = upx_zstd_decompress(c_data, 16, d_buf, &d_len, M_ZSTD, nullptr);\n    CHECK(r == UPX_E_OUTPUT_OVERRUN);\n    UNUSED(r);\n}\n\n#endif // WITH_ZSTD\n\n/* vim:set ts=4 sw=4 et: */\n","size_bytes":7788},"src/console/c_file.cpp":{"content":"/* c_file.cpp --\n\n   This file is part of the Resize executable compressor.\n\n   Copyright (C) 2025 WHO-AM-I-404\n   Based on UPX - Ultimate Packer for eXecutables\n   Copyright (C) 1996-2025 Markus Franz Xaver Johannes Oberhumer\n   Copyright (C) 1996-2025 Laszlo Molnar\n   All Rights Reserved.\n\n   Resize and the UCL library are free software; you can redistribute them\n   and/or modify them under the terms of the GNU General Public License as\n   published by the Free Software Foundation; either version 2 of\n   the License, or (at your option) any later version.\n\n   This program is distributed in the hope that it will be useful,\n   but WITHOUT ANY WARRANTY; without even the implied warranty of\n   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n   GNU General Public License for more details.\n\n   You should have received a copy of the GNU General Public License\n   along with this program; see the file COPYING.\n   If not, write to the Free Software Foundation, Inc.,\n   59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.\n\n   WHO-AM-I-404 <who-am-i-404@proton.me>\n   Based on original work by:\n   Markus F.X.J. Oberhumer <markus@oberhumer.com>\n   Laszlo Molnar <ezerotven+github@gmail.com>\n */\n\n#include \"../conf.h\"\n\n#if (USE_CONSOLE)\n\n/*************************************************************************\n//\n**************************************************************************/\n\nstatic int init(FILE *f, int o, int now) {\n    UNUSED(f);\n    UNUSED(o);\n    UNUSED(now);\n    return CON_FILE;\n}\n\nstatic int set_fg(FILE *f, int fg) {\n    UNUSED(f);\n    UNUSED(fg);\n    return -1;\n}\n\nstatic void print0(FILE *f, const char *s) {\n#if 1\n    fputs(s, f);\n#else\n    /* filter out all ANSI sequences */\n    int c;\n    while ((c = *s++) != 0) {\n        if (c == '\\033' && *s == ']') {\n            while (*s && *s != 'm')\n                s++;\n        } else\n            fputc(c, f);\n    }\n#endif\n}\n\nstatic bool intro(FILE *f) {\n    UNUSED(f);\n    return 0;\n}\n\nconsole_t console_file = {init, set_fg, print0, intro};\n\n#endif /* USE_CONSOLE */\n\n/* vim:set ts=4 sw=4 et: */\n","size_bytes":2096},"src/console/c_init.cpp":{"content":"/* c_init.cpp --\n\n   This file is part of the Resize executable compressor.\n\n   Copyright (C) 2025 WHO-AM-I-404\n   Based on UPX - Ultimate Packer for eXecutables\n   Copyright (C) 1996-2025 Markus Franz Xaver Johannes Oberhumer\n   Copyright (C) 1996-2025 Laszlo Molnar\n   All Rights Reserved.\n\n   Resize and the UCL library are free software; you can redistribute them\n   and/or modify them under the terms of the GNU General Public License as\n   published by the Free Software Foundation; either version 2 of\n   the License, or (at your option) any later version.\n\n   This program is distributed in the hope that it will be useful,\n   but WITHOUT ANY WARRANTY; without even the implied warranty of\n   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n   GNU General Public License for more details.\n\n   You should have received a copy of the GNU General Public License\n   along with this program; see the file COPYING.\n   If not, write to the Free Software Foundation, Inc.,\n   59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.\n\n   WHO-AM-I-404 <who-am-i-404@proton.me>\n   Based on original work by:\n   Markus F.X.J. Oberhumer <markus@oberhumer.com>\n   Laszlo Molnar <ezerotven+github@gmail.com>\n */\n\n#include \"../conf.h\"\n\nFILE *con_term = nullptr;\n\n#if (USE_CONSOLE)\n\n/*************************************************************************\n//\n**************************************************************************/\n\nstatic console_t *const me = &console_init;\nconsole_t *con = &console_init;\n\nint con_mode = CON_INIT;\n\nstatic void try_init(console_t *c, FILE *f) {\n    int k;\n\n    assert(c);\n    assert(c->init);\n    k = c->init(f, opt->console, con_mode);\n    if (k == CON_INIT)\n        return;\n#if 0\n    if (con_mode != CON_INIT && opt->console != CON_INIT)\n        if (k != opt->console)\n            return;\n#endif\n    if (k > con_mode) {\n        con_mode = k;\n        con = c;\n        con->init = nullptr;\n        if (!con->set_fg)\n            con->set_fg = console_none.set_fg;\n        if (!con->print0)\n            con->print0 = console_none.print0;\n        if (!con->intro)\n            con->intro = console_none.intro;\n    }\n}\n\nstatic int do_init(FILE *f) {\n    assert(con_mode == CON_INIT);\n\n    try_init(&console_none, f);\n    assert(con != me);\n    assert(con == &console_none);\n    if (opt->console == CON_NONE || opt->to_stdout)\n        return con_mode;\n    try_init(&console_file, f);\n    if (!acc_isatty(STDIN_FILENO) || !acc_isatty(STDOUT_FILENO) || !acc_isatty(STDERR_FILENO))\n        return con_mode;\n\n#if (USE_ANSI)\n    try_init(&console_ansi_mono, f);\n    try_init(&console_ansi_color, f);\n#endif\n#if (USE_SCREEN)\n    try_init(&console_screen, f);\n#endif\n#if (USE_AALIB)\n    try_init(&console_aalib, f);\n#endif\n\n    return con_mode;\n}\n\n/*************************************************************************\n//\n**************************************************************************/\n\nstatic int init(FILE *f, int o, int now) {\n    if (con != me)\n        return con_mode;\n    assert(o == -1);\n    assert(now == -1);\n    UNUSED(o);\n    UNUSED(now);\n    return do_init(f);\n}\n\nstatic int set_fg(FILE *f, int fg) {\n    if (con == me)\n        init(f, -1, -1);\n    assert(con != me);\n    return con->set_fg(f, fg);\n}\n\nstatic bool intro(FILE *f) {\n    if (con == me)\n        init(f, -1, -1);\n    assert(con != me);\n    return con->intro(f);\n}\n\nconsole_t console_init = {init, set_fg, nullptr, intro};\n\nvoid con_fprintf(FILE *f, const char *format, ...) {\n    va_list args;\n    char buf[80 * 25];\n\n    va_start(args, format);\n    upx_safe_vsnprintf(buf, sizeof(buf), format, args);\n    va_end(args);\n\n    if (con == me)\n        init(f, -1, -1);\n    assert(con != me);\n    con->print0(f, buf);\n}\n\n#endif /* USE_CONSOLE */\n\n/* vim:set ts=4 sw=4 et: */\n","size_bytes":3794},"src/console/c_none.cpp":{"content":"/* c_none.cpp --\n\n   This file is part of the Resize executable compressor.\n\n   Copyright (C) 2025 WHO-AM-I-404\n   Based on UPX - Ultimate Packer for eXecutables\n   Copyright (C) 1996-2025 Markus Franz Xaver Johannes Oberhumer\n   Copyright (C) 1996-2025 Laszlo Molnar\n   All Rights Reserved.\n\n   Resize and the UCL library are free software; you can redistribute them\n   and/or modify them under the terms of the GNU General Public License as\n   published by the Free Software Foundation; either version 2 of\n   the License, or (at your option) any later version.\n\n   This program is distributed in the hope that it will be useful,\n   but WITHOUT ANY WARRANTY; without even the implied warranty of\n   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n   GNU General Public License for more details.\n\n   You should have received a copy of the GNU General Public License\n   along with this program; see the file COPYING.\n   If not, write to the Free Software Foundation, Inc.,\n   59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.\n\n   WHO-AM-I-404 <who-am-i-404@proton.me>\n   Based on original work by:\n   Markus F.X.J. Oberhumer <markus@oberhumer.com>\n   Laszlo Molnar <ezerotven+github@gmail.com>\n */\n\n#include \"../conf.h\"\n\n#if (USE_CONSOLE)\n\n/*************************************************************************\n//\n**************************************************************************/\n\nstatic int init(FILE *f, int o, int now) {\n    UNUSED(f);\n    UNUSED(o);\n    UNUSED(now);\n    return CON_NONE;\n}\n\nstatic int set_fg(FILE *f, int fg) {\n    UNUSED(f);\n    UNUSED(fg);\n    return -1;\n}\n\nstatic void print0(FILE *f, const char *s) {\n    UNUSED(f);\n    UNUSED(s);\n}\n\nstatic bool intro(FILE *f) {\n    UNUSED(f);\n    return 0;\n}\n\nconsole_t console_none = {init, set_fg, print0, intro};\n\n#endif /* USE_CONSOLE */\n\n/* vim:set ts=4 sw=4 et: */\n","size_bytes":1866},"src/console/c_screen.cpp":{"content":"/* c_screen.cpp -- console screen driver\n\n   This file is part of the Resize executable compressor.\n\n   Copyright (C) 2025 WHO-AM-I-404\n   Based on UPX - Ultimate Packer for eXecutables\n   Copyright (C) 1996-2025 Markus Franz Xaver Johannes Oberhumer\n   Copyright (C) 1996-2025 Laszlo Molnar\n   All Rights Reserved.\n\n   Resize and the UCL library are free software; you can redistribute them\n   and/or modify them under the terms of the GNU General Public License as\n   published by the Free Software Foundation; either version 2 of\n   the License, or (at your option) any later version.\n\n   This program is distributed in the hope that it will be useful,\n   but WITHOUT ANY WARRANTY; without even the implied warranty of\n   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n   GNU General Public License for more details.\n\n   You should have received a copy of the GNU General Public License\n   along with this program; see the file COPYING.\n   If not, write to the Free Software Foundation, Inc.,\n   59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.\n\n   WHO-AM-I-404 <who-am-i-404@proton.me>\n   Based on original work by:\n   Markus F.X.J. Oberhumer <markus@oberhumer.com>\n   Laszlo Molnar <ezerotven+github@gmail.com>\n */\n\n#include \"../conf.h\"\n\n#if (USE_SCREEN)\n\n#include \"screen.h\"\n\n#define mask_fg 0x0f\n#define mask_bg 0xf0\n\n/*************************************************************************\n//\n**************************************************************************/\n\nstatic int do_init(screen_t *s, int fd) {\n    int fg, bg;\n\n    if (s->init(s, fd) != 0)\n        return -1;\n\n    if (s->getCols(s) < 80 || s->getCols(s) > 256)\n        return -1;\n    if (s->getRows(s) < 24)\n        return -1;\n\n    fg = s->getFg(s);\n    bg = s->getBg(s);\n    if (s->isMono(s))\n        fg = -1;\n    if (fg == (bg >> 4))\n        return -1;\n    if (bg != BG_BLACK)\n        if (!s->isMono(s)) {\n            /* return 0; */ /* we could emulate ANSI mono */\n            return -1;\n        }\n\n    return 0;\n}\n\nstatic screen_t *do_construct(screen_t *s, int fd) {\n    if (!s)\n        return nullptr;\n    if (do_init(s, fd) != 0) {\n        s->destroy(s);\n        return nullptr;\n    }\n    return s;\n}\n\n/*************************************************************************\n//\n**************************************************************************/\n\nstatic screen_t *screen = nullptr;\n\nstatic void __acc_cdecl_atexit do_destroy(void) {\n    if (screen) {\n        if (screen->atExit)\n            screen->atExit();\n        screen->destroy(screen);\n        screen = nullptr;\n    }\n}\n\nstatic int mode = -1;\nstatic int init_fg = -1;\nstatic int init_bg = -1;\nstatic int cur_fg = -1;\nstatic int cur_bg = -1;\n\nstatic int init(FILE *f, int o, int now) {\n    int fd = fileno(f);\n    int n;\n\n    UNUSED(now);\n    assert(screen == nullptr);\n\n    if (o == CON_SCREEN)\n        n = CON_SCREEN;\n    else if (o == CON_INIT) /* use by default */\n        n = CON_SCREEN;\n    else if (o == CON_ANSI_COLOR) /* can emulate ANSI color */\n        n = CON_ANSI_COLOR;\n    else if (o == CON_ANSI_MONO) /* can emulate ANSI mono */\n        n = CON_ANSI_MONO;\n    else\n        return CON_INIT;\n\n#if (ACC_OS_DOS32) && defined(__DJGPP__)\n    if (!screen)\n        screen = do_construct(screen_djgpp2_construct(), fd);\n#endif\n#if (USE_SCREEN_WIN32)\n    if (!screen)\n        screen = do_construct(screen_win32_construct(), fd);\n#endif\n#if (USE_SCREEN_VCSA)\n    if (!screen)\n        screen = do_construct(screen_vcsa_construct(), fd);\n#endif\n#if (USE_SCREEN_CURSES)\n    if (!screen && o == CON_SCREEN)\n        screen = do_construct(screen_curses_construct(), fd);\n#endif\n    if (!screen)\n        return CON_INIT;\n\n    mode = screen->getMode(screen);\n    init_fg = cur_fg = screen->getFg(screen);\n    init_bg = cur_bg = screen->getBg(screen);\n    if (screen->isMono(screen))\n        cur_fg = -1;\n\n    atexit(do_destroy);\n    return n;\n}\n\nstatic int set_fg(FILE *f, int fg) {\n    const int last_fg = cur_fg;\n    int f1 = fg & mask_fg;\n    int f2 = init_fg & mask_fg;\n\n    UNUSED(f);\n    cur_fg = fg;\n    if (screen->isMono(screen)) {\n        const int b = (init_bg & mask_bg) >> 4;\n        if (fg == -1) /* restore startup fg */\n            f1 = f2;\n        else if (b == 0)\n            f1 = (f2 <= 8) ? 15 : 8;\n        else if (b <= 8)\n            f1 = (f2 == 0) ? 15 : 0;\n        else\n            f1 = (f2 == 0) ? 8 : 0;\n    } else if (con_mode == CON_ANSI_MONO && f1 != f2) {\n        f1 = f2 ^ 0x08;\n    }\n\n    screen->setFg(screen, f1 & mask_fg);\n    return last_fg;\n}\n\nstatic void print0(FILE *f, const char *ss) {\n    int cx, cy;\n    int old_cx = 0, old_cy = 0;\n    const int sx = screen->getCols(screen);\n    const int sy = screen->getRows(screen);\n    int pass;\n\n    // Note:\n    //   We use 2 passes to avoid unnecessary system calls because\n    //   scrollUp() under Win32 is *extremely* slow.\n    UNUSED(f);\n\n    screen->getCursor(screen, &old_cx, &old_cy);\n    cx = old_cx;\n    cy = old_cy;\n\n    for (pass = 0; pass < 2; pass++) {\n        const char *s = ss;\n        // char buffer for pass 2\n        char p[256 + 1];\n        int pi = 0, px = 0, py = 0;\n\n        for (;;) {\n            // walk over whitespace\n            for (;;) {\n                if (*s == '\\n') {\n                    cx = 0;\n                    cy++;\n                } else if (*s == '\\r') {\n                    cx = 0;\n                    if (pass > 0 && cy < sy)\n                        screen->clearLine(screen, cy);\n                } else\n                    break;\n                s++;\n            }\n            // adjust cursor\n            if (cx >= sx) {\n                cx = 0;\n                cy++;\n            }\n            if (pass > 0) {\n                // check if we should print something\n                if (pi > 0 && (*s == 0 || py != cy)) {\n                    p[pi] = 0;\n                    screen->putString(screen, p, px, py);\n                    pi = 0;\n                }\n                // check if we should scroll even more (this can happen\n                // if the string is longer than sy lines)\n                if (cy >= sy) {\n                    int scroll_y = cy - sy + 1;\n                    screen->scrollUp(screen, scroll_y);\n                    cy -= scroll_y;\n                    if (cy < 0)\n                        cy = 0;\n                }\n            }\n            // done ?\n            if (*s == 0)\n                break;\n            if (pass > 0) {\n                // store current char\n                if (pi == 0) {\n                    px = cx;\n                    py = cy;\n                }\n                p[pi++] = *s;\n            }\n            // advance\n            cx++;\n            s++;\n        }\n\n        if (pass == 0) {\n            // end of pass 1 - scroll up, restore cursor\n            if (cy >= sy) {\n                int scroll_y = cy - sy + 1;\n                screen->scrollUp(screen, scroll_y);\n                cy = old_cy - scroll_y;\n                if (cy < 0)\n                    cy = 0;\n            } else\n                cy = old_cy;\n            cx = old_cx;\n        }\n    }\n\n    screen->setCursor(screen, cx, cy);\n    screen->refresh(screen);\n}\n\nstatic bool intro(FILE *f) {\n    UNUSED(f);\n#if (USE_FRAMES)\n    if (screen->intro)\n        return screen->intro(screen, screen_show_frames);\n#endif\n    return 0;\n}\n\nconsole_t console_screen = {init, set_fg, print0, intro};\n\n#endif /* USE_SCREEN */\n\n/* vim:set ts=4 sw=4 et: */\n","size_bytes":7449},"src/console/s_djgpp2.cpp":{"content":"/* s_djgpp2.cpp -- djggp2 DOS screen driver\n\n   This file is part of the Resize executable compressor.\n\n   Copyright (C) 2025 WHO-AM-I-404\n   Based on UPX - Ultimate Packer for eXecutables\n   Copyright (C) 1996-2025 Markus Franz Xaver Johannes Oberhumer\n   Copyright (C) 1996-2025 Laszlo Molnar\n   All Rights Reserved.\n\n   Resize and the UCL library are free software; you can redistribute them\n   and/or modify them under the terms of the GNU General Public License as\n   published by the Free Software Foundation; either version 2 of\n   the License, or (at your option) any later version.\n\n   This program is distributed in the hope that it will be useful,\n   but WITHOUT ANY WARRANTY; without even the implied warranty of\n   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n   GNU General Public License for more details.\n\n   You should have received a copy of the GNU General Public License\n   along with this program; see the file COPYING.\n   If not, write to the Free Software Foundation, Inc.,\n   59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.\n\n   WHO-AM-I-404 <who-am-i-404@proton.me>\n   Based on original work by:\n   Markus F.X.J. Oberhumer <markus@oberhumer.com>\n   Laszlo Molnar <ezerotven+github@gmail.com>\n */\n\n#include \"../conf.h\"\n\n#if (USE_SCREEN) && (ACC_OS_DOS32) && defined(__DJGPP__)\n#if (ACC_CC_GNUC >= 0x040300ul)\n#pragma GCC diagnostic ignored \"-Wvla\"\n#endif\n\n#include \"screen.h\"\n\n#define this self\n\n#define mask_fg 0x0f\n#define mask_bg 0xf0\n\n/* #define USE_SCROLLBACK 1 */\n\n/*************************************************************************\n// direct screen access\n**************************************************************************/\n\n#include <dos.h>\n#if 0\n#include <conio.h>\n#endif\n#include <dpmi.h>\n#include <go32.h>\n#include <sys/exceptn.h>\n#include <sys/farptr.h>\n#include <sys/movedata.h>\n#define dossel _go32_info_block.selector_for_linear_memory\n#define co80   _go32_info_block.linear_address_of_primary_screen\n#undef kbhit\n\n#define Cell upx_uint16_t\n\nstruct screen_data_t {\n    int mode;\n    int cols;\n    int rows;\n    int cursor_x;\n    int cursor_y;\n    int scroll_counter;\n    unsigned char attr;\n    unsigned char init_attr;\n    unsigned char empty_attr;\n    Cell empty_cell;\n#if USE_SCROLLBACK\n    /* scrollback buffer */\n    Cell sb_buf[32][256];\n    int sb_size;\n    int sb_base;\n    int sb_sp;\n#endif /* USE_SCROLLBACK */\n};\n\n/* atExit information */\nstatic struct {\n    int cursor_shape;\n} ae = {-1};\n\n#if USE_SCROLLBACK\nstatic __inline__ void sb_add(screen_t *this, int *val, int inc) {\n    *val = (*val + inc) & (this->data->sb_size - 1);\n}\n\nstatic void sb_push(screen_t *this, const Cell *line, int len) {\n    memcpy(this->data->sb_buf[this->data->sb_sp], line, len);\n    sb_add(this, &this->data->sb_sp, 1);\n    if (this->data->sb_sp == this->data->sb_base)\n        sb_add(this, &this->data->sb_base, 1);\n}\n\nstatic const Cell *sb_pop(screen_t *this) {\n    if (this->data->sb_sp == this->data->sb_base)\n        return nullptr;\n    sb_add(this, &this->data->sb_sp, -1);\n    return this->data->sb_buf[this->data->sb_sp];\n}\n#endif /* USE_SCROLLBACK */\n\nstatic void refresh(screen_t *this) { UNUSED(this); }\n\nstatic __inline__ Cell make_cell(screen_t *this, int ch, int attr) {\n    UNUSED(this);\n    return (Cell) (((attr & 0xff) << 8) | (ch & 0xff));\n}\n\nstatic int getMode(const screen_t *this) {\n    UNUSED(this);\n    return ScreenMode();\n}\n\nstatic int getPage(const screen_t *this) {\n    UNUSED(this);\n    return _farpeekb(dossel, 0x462);\n}\n\nstatic int getRows(const screen_t *this) { return this->data->rows; }\n\nstatic int getCols(const screen_t *this) { return this->data->cols; }\n\nstatic int isMono(const screen_t *this) {\n    if (this->data->mode == 7)\n        return 1;\n    if ((_farpeekb(dossel, 0x465) & (4 | 16)) != 0)\n        return 1;\n    return 0;\n}\n\nstatic int getFg(const screen_t *this) { return this->data->attr & mask_fg; }\n\nstatic int getBg(const screen_t *this) { return this->data->attr & mask_bg; }\n\nstatic void setFg(screen_t *this, int fg) {\n    this->data->attr = (this->data->attr & mask_bg) | (fg & mask_fg);\n}\n\nstatic void setBg(screen_t *this, int bg) {\n    this->data->attr = (this->data->attr & mask_fg) | (bg & mask_bg);\n}\n\nstatic void setCursor(screen_t *this, int x, int y) {\n    if (x >= 0 && y >= 0 && x < this->data->cols && y < this->data->rows) {\n        ScreenSetCursor(y, x);\n        this->data->cursor_x = x;\n        this->data->cursor_y = y;\n    }\n}\n\n/*\n// I added ScreenGetCursor, because when upx prints something longer than\n// 1 line (an error message for example), the this->data->cursor_y can\n// have a bad value - ml1050\n\n// FIXME:\n//   Laszlo: when does this happen ? This probably indicates a\n//     bug in c_screen.cpp(print0) I've introduced with\n//     the 2 passes implementation.\n*/\n\nstatic void getCursor(const screen_t *this, int *x, int *y) {\n    int cx = this->data->cursor_x;\n    int cy = this->data->cursor_y;\n#if 1\n    ScreenGetCursor(&cy, &cx);\n#endif\n    if (x)\n        *x = cx;\n    if (y)\n        *y = cy;\n}\n\nstatic void putCharAttr(screen_t *this, int ch, int attr, int x, int y) {\n    UNUSED(this);\n    ScreenPutChar(ch, attr, x, y);\n}\n\nstatic void putChar(screen_t *this, int ch, int x, int y) {\n    ScreenPutChar(ch, this->data->attr, x, y);\n}\n\nstatic void putStringAttr(screen_t *this, const char *s, int attr, int x, int y) {\n    UNUSED(this);\n    assert((int) strlen(s) <= 256);\n    assert(x + (int) strlen(s) <= this->data->cols);\n    ScreenPutString(s, attr, x, y);\n}\n\nstatic void putString(screen_t *this, const char *s, int x, int y) {\n    assert((int) strlen(s) <= 256);\n    assert(x + (int) strlen(s) <= this->data->cols);\n    ScreenPutString(s, this->data->attr, x, y);\n}\n\n/* private */\nstatic void getChar(screen_t *this, int *ch, int *attr, int x, int y) {\n    UNUSED(this);\n    ScreenGetChar(ch, attr, x, y);\n}\n\nstatic int getCursorShape(const screen_t *this) {\n    UNUSED(this);\n    return _farpeekw(dossel, 0x460);\n}\n\nstatic void setCursorShape(screen_t *this, int shape) {\n    __dpmi_regs r;\n\n    memset(&r, 0, sizeof(r)); /* just in case... */\n    r.x.ax = 0x0103;\n#if 1\n    if (this)\n        r.h.al = getMode(this); /* required for buggy BIOSes */\n#endif\n    r.x.cx = shape & 0x7f1f;\n    __dpmi_int(0x10, &r);\n}\n\nstatic int hideCursor(screen_t *this) {\n    int shape = getCursorShape(this);\n    setCursorShape(this, 0x2000);\n    return shape;\n}\n\nstatic int init(screen_t *this, int fd) {\n    int mode;\n    int cols, rows;\n    int attr;\n\n#if 0\n    /* force linkage of conio.o */\n    (void) _conio_kbhit();\n#endif\n\n    if (!this || !this->data)\n        return -1;\n\n    this->data->mode = -1;\n#if USE_SCROLLBACK\n    this->data->sb_size = 32;\n    this->data->sb_base = 0;\n    this->data->sb_sp = 0;\n#endif\n    if (fd < 0 || !acc_isatty(fd))\n        return -1;\n    if (getPage(this) != 0)\n        return -1;\n\n#if 1 && (ACC_OS_DOS32) && defined(__DJGPP__)\n    /* check for Windows NT/2000/XP */\n    if (_get_dos_version(1) == 0x0532)\n        return -1;\n#endif\n\n    cols = ScreenCols();\n    rows = ScreenRows();\n    mode = getMode(this);\n    if (mode > 0x13) {\n        /* assume this is some SVGA/VESA text mode */\n        __dpmi_regs r;\n\n        memset(&r, 0, sizeof(r)); /* just in case... */\n        r.x.ax = 0x4f03;          /* VESA - get current video mode */\n        __dpmi_int(0x10, &r);\n        if (r.h.ah == 0)\n            mode = r.x.bx;\n    } else {\n        if (mode != 2 && mode != 3 && mode != 7)\n            return -1;\n    }\n    ScreenGetCursor(&this->data->cursor_y, &this->data->cursor_x);\n    getChar(this, nullptr, &attr, this->data->cursor_x, this->data->cursor_y);\n    this->data->init_attr = attr;\n    if (mode != 7) {\n        /* Does it normally blink when bg has its 3rd bit set?  */\n        int b_mask = (_farpeekb(dossel, 0x465) & 0x20) ? 0x70 : 0xf0;\n        attr = attr & (mask_fg | b_mask);\n    }\n    this->data->mode = mode;\n    this->data->cols = cols;\n    this->data->rows = rows;\n    this->data->attr = attr;\n    this->data->empty_attr = attr;\n    this->data->empty_cell = make_cell(this, ' ', attr);\n\n    ae.cursor_shape = getCursorShape(this);\n\n    return 0;\n}\n\nstatic void updateLineN(screen_t *this, const void *line, int y, int len) {\n    if (y >= 0 && y < this->data->rows && len > 0 && len <= 2 * this->data->cols)\n        movedata(_my_ds(), (unsigned) line, dossel, co80 + y * this->data->cols * 2, len);\n}\n\nstatic void clearLine(screen_t *this, int y) {\n    if (y >= 0 && y < this->data->rows) {\n        unsigned sp = co80 + y * this->data->cols * 2;\n        Cell a = this->data->empty_cell;\n        int i = this->data->cols;\n\n        _farsetsel(dossel);\n        do {\n            _farnspokew(sp, a);\n            sp += 2;\n        } while (--i);\n    }\n}\n\nstatic void clear(screen_t *this) {\n    unsigned char attr = ScreenAttrib;\n    ScreenAttrib = this->data->empty_attr;\n    ScreenClear();\n    ScreenAttrib = attr;\n}\n\nstatic int scrollUp(screen_t *this, int lines) {\n    int sr = this->data->rows;\n    int sc = this->data->cols;\n    int y;\n\n    if (lines <= 0 || lines > sr)\n        return 0;\n\n#if USE_SCROLLBACK\n    /* copy to scrollback buffer */\n    for (y = 0; y < lines; y++) {\n        Cell buf[sc];\n        movedata(dossel, co80 + y * this->data->cols * 2, _my_ds(), (unsigned) buf, sizeof(buf));\n        sb_push(this, buf, sizeof(buf));\n    }\n#endif\n\n    /* move screen up */\n    if (lines < sr)\n        movedata(dossel, co80 + lines * sc * 2, dossel, co80, (sr - lines) * sc * 2);\n\n    /* fill in blank lines at bottom */\n    for (y = sr - lines; y < sr; y++)\n        clearLine(this, y);\n\n    this->data->scroll_counter += lines;\n    return lines;\n}\n\nstatic int scrollDown(screen_t *this, int lines) {\n    int sr = this->data->rows;\n    int sc = this->data->cols;\n    int y;\n\n    if (lines <= 0 || lines > sr)\n        return 0;\n\n    /* move screen down */\n    if (lines < sr) {\n        /* !@#% movedata can't handle overlapping regions... */\n        /* movedata(dossel,co80,dossel,co80+lines*sc*2,(sr-lines)*sc*2); */\n        Cell buf[(sr - lines) * sc];\n        movedata(dossel, co80, _my_ds(), (unsigned) buf, sizeof(buf));\n        movedata(_my_ds(), (unsigned) buf, dossel, co80 + lines * sc * 2, sizeof(buf));\n    }\n\n    /* copy top lines from scrollback buffer */\n    for (y = lines; --y >= 0;) {\n#if USE_SCROLLBACK\n        const Cell *buf = sb_pop(this);\n        if (buf == nullptr)\n            clearLine(this, y);\n        else\n            updateLineN(this, buf, y, sc * 2);\n#else\n        clearLine(this, y);\n#endif\n    }\n\n    this->data->scroll_counter -= lines;\n    return lines;\n}\n\nstatic int getScrollCounter(const screen_t *this) { return this->data->scroll_counter; }\n\nstatic int s_kbhit(screen_t *this) {\n    UNUSED(this);\n    return kbhit();\n}\n\nstatic int intro(screen_t *this, void (*show_frames)(screen_t *)) {\n    int shape;\n    upx_uint16_t old_flags = __djgpp_hwint_flags;\n\n    if ((this->data->init_attr & mask_bg) != BG_BLACK)\n        return 0;\n\n    __djgpp_hwint_flags |= 3;\n    while (kbhit())\n        (void) getkey();\n\n    shape = hideCursor(this);\n    show_frames(this);\n    setCursorShape(this, shape);\n\n    while (kbhit())\n        (void) getkey();\n    __djgpp_hwint_flags = old_flags;\n\n    return 1;\n}\n\nstatic void atExit(void) {\n    static int done = 0;\n    if (done)\n        return;\n    done = 1;\n    if (ae.cursor_shape >= 0)\n        setCursorShape(nullptr, ae.cursor_shape);\n}\n\nstatic const screen_t driver = {sobject_destroy, nullptr, /* finalize */\n                                atExit,          init,       refresh,\n                                getMode,         getPage,    getRows,\n                                getCols,         isMono,     getFg,\n                                getBg,           getCursor,  getCursorShape,\n                                setFg,           setBg,      setCursor,\n                                setCursorShape,  hideCursor, putChar,\n                                putCharAttr,     putString,  putStringAttr,\n                                clear,           clearLine,  updateLineN,\n                                scrollUp,        scrollDown, getScrollCounter,\n                                s_kbhit,         intro,      (struct screen_data_t *) nullptr};\n\n/* public constructor */\nscreen_t *screen_djgpp2_construct(void) { return sobject_construct(&driver, sizeof(*driver.data)); }\n\n#endif /* (USE_SCREEN) && (ACC_OS_DOS32) && defined(__DJGPP__) */\n\n/* vim:set ts=4 sw=4 et: */\n","size_bytes":12466},"src/console/s_object.cpp":{"content":"/* s_object.cpp -- base of all screen drivers\n\n   This file is part of the Resize executable compressor.\n\n   Copyright (C) 2025 WHO-AM-I-404\n   Based on UPX - Ultimate Packer for eXecutables\n   Copyright (C) 1996-2025 Markus Franz Xaver Johannes Oberhumer\n   Copyright (C) 1996-2025 Laszlo Molnar\n   All Rights Reserved.\n\n   Resize and the UCL library are free software; you can redistribute them\n   and/or modify them under the terms of the GNU General Public License as\n   published by the Free Software Foundation; either version 2 of\n   the License, or (at your option) any later version.\n\n   This program is distributed in the hope that it will be useful,\n   but WITHOUT ANY WARRANTY; without even the implied warranty of\n   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n   GNU General Public License for more details.\n\n   You should have received a copy of the GNU General Public License\n   along with this program; see the file COPYING.\n   If not, write to the Free Software Foundation, Inc.,\n   59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.\n\n   WHO-AM-I-404 <who-am-i-404@proton.me>\n   Based on original work by:\n   Markus F.X.J. Oberhumer <markus@oberhumer.com>\n   Laszlo Molnar <ezerotven+github@gmail.com>\n */\n\n#include \"../conf.h\"\n\n#if (USE_SCREEN)\n\n#define this self\n\n#include \"screen.h\"\n\n/*************************************************************************\n//\n**************************************************************************/\n\n// ugly hacks\nstatic screen_t *last_screen = nullptr;\n\nscreen_t *sobject_get_screen(void) { return last_screen; }\n\nvoid sobject_destroy(screen_t *this) {\n    last_screen = nullptr;\n    if (!this)\n        return;\n    if (this->data) {\n        if (this->finalize)\n            this->finalize(this);\n        free(this->data);\n        this->data = nullptr;\n    }\n    free(this);\n}\n\nscreen_t *sobject_construct(const screen_t *c, size_t data_size) {\n    screen_t *this;\n\n    last_screen = nullptr;\n\n    /* allocate object */\n    this = (screen_t *) malloc(sizeof(*this));\n    if (!this)\n        return nullptr;\n\n    /* copy function table */\n    *this = *c;\n\n    /* initialize instance variables */\n    this->data = (struct screen_data_t *) malloc(data_size);\n    if (!this->data) {\n        free(this);\n        return nullptr;\n    }\n    memset(this->data, 0, data_size);\n\n    last_screen = this;\n    return this;\n}\n\n#endif /* (USE_SCREEN) */\n\n/* vim:set ts=4 sw=4 et: */\n","size_bytes":2449},"src/console/s_vcsa.cpp":{"content":"/* s_vcsa.cpp -- Linux /dev/vcsa screen driver\n\n   This file is part of the Resize executable compressor.\n\n   Copyright (C) 2025 WHO-AM-I-404\n   Based on UPX - Ultimate Packer for eXecutables\n   Copyright (C) 1996-2025 Markus Franz Xaver Johannes Oberhumer\n   Copyright (C) 1996-2025 Laszlo Molnar\n   All Rights Reserved.\n\n   Resize and the UCL library are free software; you can redistribute them\n   and/or modify them under the terms of the GNU General Public License as\n   published by the Free Software Foundation; either version 2 of\n   the License, or (at your option) any later version.\n\n   This program is distributed in the hope that it will be useful,\n   but WITHOUT ANY WARRANTY; without even the implied warranty of\n   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n   GNU General Public License for more details.\n\n   You should have received a copy of the GNU General Public License\n   along with this program; see the file COPYING.\n   If not, write to the Free Software Foundation, Inc.,\n   59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.\n\n   WHO-AM-I-404 <who-am-i-404@proton.me>\n   Based on original work by:\n   Markus F.X.J. Oberhumer <markus@oberhumer.com>\n   Laszlo Molnar <ezerotven+github@gmail.com>\n */\n\n#include \"../conf.h\"\n\n#if (USE_SCREEN) && (USE_SCREEN_VCSA)\n\n#include \"screen.h\"\n\n#define this self\n\n#define mask_fg 0x0f\n#define mask_bg 0xf0\n\n/* #define USE_SCROLLBACK 1 */\n\n/*************************************************************************\n// direct screen access ( /dev/vcsaNN )\n**************************************************************************/\n\n#include <sys/ioctl.h>\n#include <sys/select.h>\n#include <termios.h>\n#if defined(__linux__)\n#include <linux/kd.h>\n#include <linux/kdev_t.h>\n#include <linux/major.h>\n#endif\n\n#define Cell upx_uint16_t\n\nstruct screen_data_t {\n    int fd;\n    int mode;\n    int page;\n    int cols;\n    int rows;\n    int cursor_x;\n    int cursor_y;\n    int scroll_counter;\n    unsigned char attr;\n    unsigned char init_attr;\n    unsigned char map[256];\n    Cell empty_line[256];\n#if USE_SCROLLBACK\n    /* scrollback buffer */\n    Cell sb_buf[32][256];\n    int sb_size;\n    int sb_base;\n    int sb_sp;\n#endif /* USE_SCROLLBACK */\n};\n\n#if USE_SCROLLBACK\nstatic __inline__ void sb_add(screen_t *this, int *val, int inc) {\n    *val = (*val + inc) & (this->data->sb_size - 1);\n}\n\nstatic void sb_push(screen_t *this, const Cell *line, int len) {\n    memcpy(this->data->sb_buf[this->data->sb_sp], line, len);\n    sb_add(this, &this->data->sb_sp, 1);\n    if (this->data->sb_sp == this->data->sb_base)\n        sb_add(this, &this->data->sb_base, 1);\n}\n\nstatic const Cell *sb_pop(screen_t *this) {\n    if (this->data->sb_sp == this->data->sb_base)\n        return nullptr;\n    sb_add(this, &this->data->sb_sp, -1);\n    return this->data->sb_buf[this->data->sb_sp];\n}\n#endif /* USE_SCROLLBACK */\n\nstatic void refresh(screen_t *this) { UNUSED(this); }\n\nstatic __inline__ Cell make_cell(screen_t *this, int ch, int attr) {\n    return ((attr & 0xff) << 8) | (this->data->map[ch & 0xff] & 0xff);\n}\n\nstatic int getMode(const screen_t *this) { return this->data->mode; }\n\nstatic int getPage(const screen_t *this) { return this->data->page; }\n\nstatic int getRows(const screen_t *this) { return this->data->rows; }\n\nstatic int getCols(const screen_t *this) { return this->data->cols; }\n\nstatic int isMono(const screen_t *this) {\n    /* FIXME */\n    UNUSED(this);\n    return 0;\n}\n\nstatic int getFg(const screen_t *this) { return this->data->attr & mask_fg; }\n\nstatic int getBg(const screen_t *this) { return this->data->attr & mask_bg; }\n\nstatic void setFg(screen_t *this, int fg) {\n    this->data->attr = (this->data->attr & mask_bg) | (fg & mask_fg);\n}\n\nstatic void setBg(screen_t *this, int bg) {\n    this->data->attr = (this->data->attr & mask_fg) | (bg & mask_bg);\n}\n\n/* private */\nstatic int gotoxy(screen_t *this, int x, int y) {\n    if (x >= 0 && y >= 0 && x < this->data->cols && y < this->data->rows) {\n        if (lseek(this->data->fd, 4 + (x + y * this->data->cols) * 2, SEEK_SET) != -1) {\n            return 0;\n        }\n    }\n    return -1;\n}\n\nstatic void setCursor(screen_t *this, int x, int y) {\n    if (gotoxy(this, x, y) == 0) {\n        unsigned char b[2] = {x, y};\n        if (lseek(this->data->fd, 2, SEEK_SET) != -1)\n            write(this->data->fd, b, 2);\n        this->data->cursor_x = x;\n        this->data->cursor_y = y;\n    }\n}\n\nstatic void getCursor(const screen_t *this, int *x, int *y) {\n    int cx = this->data->cursor_x;\n    int cy = this->data->cursor_y;\n#if 1\n    if (lseek(this->data->fd, 2, SEEK_SET) != -1) {\n        unsigned char b[2];\n        if (read(this->data->fd, b, 2) == 2) {\n            if (b[0] < this->data->cols && b[1] < this->data->rows) {\n                cx = b[0];\n                cy = b[1];\n            }\n        }\n    }\n#endif\n    if (x)\n        *x = cx;\n    if (y)\n        *y = cy;\n}\n\nstatic void putCharAttr(screen_t *this, int ch, int attr, int x, int y) {\n    Cell a = make_cell(this, ch, attr);\n\n    if (gotoxy(this, x, y) == 0)\n        write(this->data->fd, &a, 2);\n}\n\nstatic void putChar(screen_t *this, int ch, int x, int y) {\n    putCharAttr(this, ch, this->data->attr, x, y);\n}\n\nstatic void putStringAttr(screen_t *this, const char *s, int attr, int x, int y) {\n    assert((int) strlen(s) <= 256);\n    assert(x + (int) strlen(s) <= this->data->cols);\n    while (*s)\n        putCharAttr(this, *s++, attr, x++, y);\n}\n\nstatic void putString(screen_t *this, const char *s, int x, int y) {\n    putStringAttr(this, s, this->data->attr, x, y);\n}\n\n/* private */\nstatic void getChar(screen_t *this, int *ch, int *attr, int x, int y) {\n    upx_uint16_t a;\n\n    if (gotoxy(this, x, y) == 0 && read(this->data->fd, &a, 2) == 2) {\n        if (ch)\n            *ch = a & 0xff;\n        if (attr)\n            *attr = (a >> 8) & 0xff;\n    }\n}\n\n/* private */\nstatic int init_scrnmap(screen_t *this, int fd) {\n    int scrnmap_done = 0;\n    int i;\n\n#if 1 && defined(GIO_UNISCRNMAP) && defined(E_TABSZ)\n    if (!scrnmap_done) {\n        upx_uint16_t scrnmap[E_TABSZ];\n        if (ioctl(fd, GIO_UNISCRNMAP, scrnmap) == 0) {\n            for (i = 0; i < E_TABSZ; i++)\n                this->data->map[scrnmap[i] & 0xff] = i;\n            scrnmap_done = 1;\n        }\n    }\n#endif\n#if 1 && defined(GIO_SCRNMAP) && defined(E_TABSZ)\n    if (!scrnmap_done) {\n        unsigned char scrnmap[E_TABSZ];\n        if (ioctl(fd, GIO_SCRNMAP, scrnmap) == 0) {\n            for (i = 0; i < E_TABSZ; i++)\n                this->data->map[scrnmap[i] & 0xff] = i;\n            scrnmap_done = 1;\n        }\n    }\n#endif\n\n    return scrnmap_done;\n}\n\nstatic int init(screen_t *this, int fd) {\n    struct stat st;\n\n    if (!this || !this->data)\n        return -1;\n\n    this->data->fd = -1;\n    this->data->mode = -1;\n    this->data->page = 0;\n#if USE_SCROLLBACK\n    this->data->sb_size = 32;\n    this->data->sb_base = 0;\n    this->data->sb_sp = 0;\n#endif\n    if (fd < 0 || !acc_isatty(fd))\n        return -1;\n    if (fstat(fd, &st) != 0)\n        return -1;\n\n/* check if we are running in a virtual console */\n#if defined(MINOR) && defined(MAJOR) && defined(TTY_MAJOR)\n    if (MAJOR(st.st_rdev) == TTY_MAJOR) {\n        char vc_name[64];\n        unsigned char vc_data[4];\n        int i;\n        int attr;\n        Cell a;\n\n        upx_safe_snprintf(vc_name, sizeof(vc_name), \"/dev/vcsa%d\", (int) MINOR(st.st_rdev));\n        this->data->fd = open(vc_name, O_RDWR);\n        if (this->data->fd == -1) {\n            upx_safe_snprintf(vc_name, sizeof(vc_name), \"/dev/vcc/a%d\", (int) MINOR(st.st_rdev));\n            this->data->fd = open(vc_name, O_RDWR);\n        }\n        if (this->data->fd != -1) {\n            if (read(this->data->fd, vc_data, 4) == 4) {\n                this->data->mode = 3;\n                this->data->rows = vc_data[0];\n                this->data->cols = vc_data[1];\n                this->data->cursor_x = vc_data[2];\n                this->data->cursor_y = vc_data[3];\n\n                for (i = 0; i < 256; i++)\n                    this->data->map[i] = i;\n                i = init_scrnmap(this, this->data->fd) || init_scrnmap(this, STDIN_FILENO);\n\n                getChar(this, nullptr, &attr, this->data->cursor_x, this->data->cursor_y);\n                this->data->init_attr = attr;\n                this->data->attr = attr;\n                a = make_cell(this, ' ', attr);\n                for (i = 0; i < 256; i++)\n                    this->data->empty_line[i] = a;\n            } else {\n                close(this->data->fd);\n                this->data->fd = -1;\n            }\n        }\n    }\n#endif\n\n    if (this->data->mode < 0)\n        return -1;\n\n    return 0;\n}\n\nstatic void finalize(screen_t *this) {\n    if (this->data->fd != -1)\n        (void) close(this->data->fd);\n}\n\nstatic void updateLineN(screen_t *this, const void *line, int y, int len) {\n    if (len > 0 && len <= 2 * this->data->cols && gotoxy(this, 0, y) == 0) {\n        int i;\n        unsigned char new_line[len];\n        unsigned char *l1 = new_line;\n        const unsigned char *l2 = (const unsigned char *) line;\n\n        for (i = 0; i < len; i += 2) {\n            *l1++ = *l2++;\n            *l1++ = this->data->map[*l2++];\n        }\n        write(this->data->fd, new_line, len);\n    }\n}\n\nstatic void clearLine(screen_t *this, int y) {\n    if (gotoxy(this, 0, y) == 0)\n        write(this->data->fd, this->data->empty_line, 2 * this->data->cols);\n}\n\nstatic void clear(screen_t *this) {\n    int y;\n\n    for (y = 0; y < this->data->rows; y++)\n        clearLine(this, y);\n}\n\nstatic int scrollUp(screen_t *this, int lines) {\n    int sr = this->data->rows;\n    int sc = this->data->cols;\n    int y;\n\n    if (lines <= 0 || lines > sr)\n        return 0;\n\n#if USE_SCROLLBACK\n    /* copy to scrollback buffer */\n    for (y = 0; y < lines; y++) {\n        Cell buf[sc];\n        gotoxy(this, 0, y);\n        read(this->data->fd, buf, sizeof(buf));\n        sb_push(this, buf, sizeof(buf));\n    }\n#endif\n\n    /* move screen up */\n    if (lines < sr) {\n        Cell buf[(sr - lines) * sc];\n        gotoxy(this, 0, lines);\n        read(this->data->fd, buf, sizeof(buf));\n        gotoxy(this, 0, 0);\n        write(this->data->fd, buf, sizeof(buf));\n    }\n\n    /* fill in blank lines at bottom */\n    for (y = sr - lines; y < sr; y++)\n        clearLine(this, y);\n\n    this->data->scroll_counter += lines;\n    return lines;\n}\n\nstatic int scrollDown(screen_t *this, int lines) {\n    int sr = this->data->rows;\n    int sc = this->data->cols;\n    int y;\n\n    if (lines <= 0 || lines > sr)\n        return 0;\n\n    /* move screen down */\n    if (lines < sr) {\n        Cell buf[(sr - lines) * sc];\n        gotoxy(this, 0, 0);\n        read(this->data->fd, buf, sizeof(buf));\n        gotoxy(this, 0, lines);\n        write(this->data->fd, buf, sizeof(buf));\n    }\n\n    /* copy top lines from scrollback buffer */\n    for (y = lines; --y >= 0;) {\n#if USE_SCROLLBACK\n        const Cell *buf = sb_pop(this);\n        if (buf == nullptr)\n            clearLine(this, y);\n        else\n            updateLineN(this, buf, y, sc * 2);\n#else\n        clearLine(this, y);\n#endif\n    }\n\n    this->data->scroll_counter -= lines;\n    return lines;\n}\n\nstatic int getScrollCounter(const screen_t *this) { return this->data->scroll_counter; }\n\nstatic int getCursorShape(const screen_t *this) {\n    UNUSED(this);\n    return 0;\n}\n\nstatic void setCursorShape(screen_t *this, int shape) {\n    UNUSED(this);\n    UNUSED(shape);\n}\n\nstatic int kbhit(screen_t *this) {\n    const int fd = STDIN_FILENO;\n    const unsigned usec = 0;\n    struct timeval tv;\n    fd_set fds;\n\n    UNUSED(this);\n    FD_ZERO(&fds);\n    FD_SET(fd, &fds);\n    tv.tv_sec = usec / 1000000;\n    tv.tv_usec = usec % 1000000;\n    return (select(fd + 1, &fds, nullptr, nullptr, &tv) > 0);\n}\n\nstatic int intro(screen_t *this, void (*show_frames)(screen_t *)) {\n    int shape;\n    struct termios term_old, term_new;\n    int term_r;\n\n    if ((this->data->init_attr & mask_bg) != BG_BLACK)\n        return 0;\n\n    term_r = tcgetattr(STDIN_FILENO, &term_old);\n    if (term_r == 0) {\n        term_new = term_old;\n        term_new.c_lflag &= ~(ISIG | ICANON | ECHO);\n        tcsetattr(STDIN_FILENO, TCSANOW, &term_new);\n    }\n\n    shape = getCursorShape(this);\n    setCursorShape(this, 0x2000);\n    show_frames(this);\n    if (this->data->rows > 24)\n        setCursor(this, this->data->cursor_x, this->data->cursor_y + 1);\n    setCursorShape(this, shape);\n\n    while (kbhit(this))\n        (void) fgetc(stdin);\n    if (term_r == 0)\n        tcsetattr(STDIN_FILENO, TCSANOW, &term_old);\n\n    return 1;\n}\n\nstatic const screen_t driver = {sobject_destroy,\n                                finalize,\n                                nullptr, /* atExit */\n                                init,\n                                refresh,\n                                getMode,\n                                getPage,\n                                getRows,\n                                getCols,\n                                isMono,\n                                getFg,\n                                getBg,\n                                getCursor,\n                                getCursorShape,\n                                setFg,\n                                setBg,\n                                setCursor,\n                                setCursorShape,\n                                nullptr, /* hideCursor */\n                                putChar,\n                                putCharAttr,\n                                putString,\n                                putStringAttr,\n                                clear,\n                                clearLine,\n                                updateLineN,\n                                scrollUp,\n                                scrollDown,\n                                getScrollCounter,\n                                kbhit,\n                                intro,\n                                (struct screen_data_t *) nullptr};\n\n/* public constructor */\nscreen_t *screen_vcsa_construct(void) { return sobject_construct(&driver, sizeof(*driver.data)); }\n\n#endif /* (USE_SCREEN) && (USE_SCREEN_VCSA) */\n\n/* vim:set ts=4 sw=4 et: */\n","size_bytes":14186},"src/console/s_win32.cpp":{"content":"/* s_win32.cpp -- Win32 console screen driver\n\n   This file is part of the Resize executable compressor.\n\n   Copyright (C) 2025 WHO-AM-I-404\n   Based on UPX - Ultimate Packer for eXecutables\n   Copyright (C) 1996-2025 Markus Franz Xaver Johannes Oberhumer\n   Copyright (C) 1996-2025 Laszlo Molnar\n   All Rights Reserved.\n\n   Resize and the UCL library are free software; you can redistribute them\n   and/or modify them under the terms of the GNU General Public License as\n   published by the Free Software Foundation; either version 2 of\n   the License, or (at your option) any later version.\n\n   This program is distributed in the hope that it will be useful,\n   but WITHOUT ANY WARRANTY; without even the implied warranty of\n   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n   GNU General Public License for more details.\n\n   You should have received a copy of the GNU General Public License\n   along with this program; see the file COPYING.\n   If not, write to the Free Software Foundation, Inc.,\n   59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.\n\n   WHO-AM-I-404 <who-am-i-404@proton.me>\n   Based on original work by:\n   Markus F.X.J. Oberhumer <markus@oberhumer.com>\n   Laszlo Molnar <ezerotven+github@gmail.com>\n */\n\n#define WANT_WINDOWS_LEAN_H 1\n#include \"../util/system_headers.h\"\n#if (HAVE_CONIO_H)\n#include <conio.h>\n#endif\n#include \"../conf.h\"\n\n#if (USE_SCREEN_WIN32)\n\n/*************************************************************************\n// direct screen access\n**************************************************************************/\n\n#include \"screen.h\"\n\n#define this self\n\n#define mask_fg 0x0f\n#define mask_bg 0xf0\n\nstruct screen_data_t {\n    HANDLE hi;\n    HANDLE ho;\n    CONSOLE_SCREEN_BUFFER_INFO csbi;\n#if 0\n    char title[512];\n#endif\n\n    int mode;\n    int cols;\n    int rows;\n    int cursor_x;\n    int cursor_y;\n    int scroll_counter;\n\n    WORD attr;\n    WORD init_attr;\n\n    CHAR_INFO empty_cell;\n    CHAR_INFO empty_line[256];\n};\n\n#define P(x) ((SHORT) (x))\n\nstatic const COORD pos00 = {0, 0};\nstatic const COORD size11 = {1, 1};\n\n/* atExit information */\nstatic struct {\n    int is_valid;\n    HANDLE ho;\n    CONSOLE_CURSOR_INFO cci;\n} ae;\n\nstatic void refresh(screen_t *this) { UNUSED(this); }\n\nstatic int getMode(const screen_t *this) { return this->data->mode; }\n\nstatic int getPage(const screen_t *this) {\n    UNUSED(this);\n    return 0;\n}\n\nstatic int getRows(const screen_t *this) { return this->data->rows; }\n\nstatic int getCols(const screen_t *this) { return this->data->cols; }\n\nstatic int isMono(const screen_t *this) {\n    UNUSED(this);\n    return 0;\n}\n\nstatic int getFg(const screen_t *this) { return this->data->attr & mask_fg; }\n\nstatic int getBg(const screen_t *this) { return this->data->attr & mask_bg; }\n\nstatic void setFg(screen_t *this, int fg) {\n    this->data->attr = (WORD) ((this->data->attr & mask_bg) | (fg & mask_fg));\n    SetConsoleTextAttribute(this->data->ho, this->data->attr);\n}\n\nstatic void setBg(screen_t *this, int bg) {\n    this->data->attr = (WORD) ((this->data->attr & mask_fg) | (bg & mask_bg));\n    SetConsoleTextAttribute(this->data->ho, this->data->attr);\n}\n\nstatic void setCursor(screen_t *this, int x, int y) {\n    if (x >= 0 && y >= 0 && x < this->data->cols && y < this->data->rows) {\n        COORD coord = {P(x), P(y)};\n        SetConsoleCursorPosition(this->data->ho, coord);\n        this->data->cursor_x = x;\n        this->data->cursor_y = y;\n    }\n}\n\nstatic void getCursor(const screen_t *this, int *x, int *y) {\n    int cx = this->data->cursor_x;\n    int cy = this->data->cursor_y;\n#if 1\n    CONSOLE_SCREEN_BUFFER_INFO csbi;\n    if (GetConsoleScreenBufferInfo(this->data->ho, &csbi)) {\n        cx = csbi.dwCursorPosition.X;\n        cy = csbi.dwCursorPosition.Y;\n#if 0\n        assert(cx == this->data->cursor_x);\n        assert(cy == this->data->cursor_y);\n#endif\n    }\n#endif\n    if (x)\n        *x = cx;\n    if (y)\n        *y = cy;\n}\n\nstatic void putCharAttr(screen_t *this, int ch, int attr, int x, int y) {\n    CHAR_INFO ci;\n    SMALL_RECT region = {P(x), P(y), P(x), P(y)};\n    ci.Char.UnicodeChar = 0;\n    ci.Char.AsciiChar = (CHAR) ch;\n    ci.Attributes = (WORD) attr;\n    WriteConsoleOutputA(this->data->ho, &ci, size11, pos00, &region);\n}\n\nstatic void putChar(screen_t *this, int ch, int x, int y) {\n    this->putCharAttr(this, ch, this->data->attr, x, y);\n}\n\nstatic void putStringAttr(screen_t *this, const char *s, int attr, int x, int y) {\n    int i;\n    int l = (int) strlen(s);\n    if (l <= 0)\n        return;\n    assert(l <= 256);\n    assert(x + l <= this->data->cols);\n    CHAR_INFO ci[256];\n    COORD size = {P(l), 1};\n    SMALL_RECT region = {P(x), P(y), P(x + l - 1), P(y)};\n    for (i = 0; i < l; i++) {\n        ci[i].Char.UnicodeChar = 0;\n        ci[i].Char.AsciiChar = *s++;\n        ci[i].Attributes = (WORD) attr;\n    }\n    WriteConsoleOutputA(this->data->ho, &ci[0], size, pos00, &region);\n}\n\nstatic void putString(screen_t *this, const char *s, int x, int y) {\n    this->putStringAttr(this, s, this->data->attr, x, y);\n}\n\n/* private */\nstatic int cci2shape(const CONSOLE_CURSOR_INFO *cci) {\n    int shape = cci->dwSize & 255;\n    if (!cci->bVisible)\n        shape |= 0x2000;\n    return shape;\n}\n\nstatic int getCursorShape(const screen_t *this) {\n    CONSOLE_CURSOR_INFO cci;\n    GetConsoleCursorInfo(this->data->ho, &cci);\n    return cci2shape(&cci);\n}\n\nstatic void setCursorShape(screen_t *this, int shape) {\n    CONSOLE_CURSOR_INFO cci;\n    cci.dwSize = shape & 255;\n    cci.bVisible = (shape & 0x2000) ? 0 : 1;\n    SetConsoleCursorInfo(this->data->ho, &cci);\n}\n\nstatic int hideCursor(screen_t *this) {\n    CONSOLE_CURSOR_INFO cci;\n    int shape;\n\n    GetConsoleCursorInfo(this->data->ho, &cci);\n    shape = cci2shape(&cci);\n    if (cci.bVisible) {\n        cci.bVisible = 0;\n        SetConsoleCursorInfo(this->data->ho, &cci);\n    }\n    return shape;\n}\n\nstatic int init(screen_t *this, int fd) {\n    HANDLE hi, ho;\n    CONSOLE_SCREEN_BUFFER_INFO *csbi;\n    DWORD mode;\n    WORD attr;\n    int i;\n\n    if (!this || !this->data)\n        return -1;\n\n    this->data->hi = INVALID_HANDLE_VALUE;\n    this->data->ho = INVALID_HANDLE_VALUE;\n    this->data->mode = -1;\n    if (fd < 0 || !acc_isatty(fd))\n        return -1;\n\n    hi = GetStdHandle(STD_INPUT_HANDLE);\n    ho = GetStdHandle(STD_OUTPUT_HANDLE);\n    if (hi == INVALID_HANDLE_VALUE || ho == INVALID_HANDLE_VALUE)\n        return -1;\n    if (!GetConsoleMode(ho, &mode))\n        return -1;\n    csbi = &this->data->csbi;\n    if (!GetConsoleScreenBufferInfo(ho, csbi))\n        return -1;\n    if (!GetConsoleCursorInfo(ho, &ae.cci))\n        return -1;\n#if 0\n    if (!GetConsoleTitle(this->data->title, sizeof(this->data->title)))\n        return -1;\n#endif\n\n#if 0\n    this->data->cols = csbi->srWindow.Right - csbi->srWindow.Left + 1;\n    this->data->rows = csbi->srWindow.Bottom - csbi->srWindow.Top + 1;\n    if (csbi->srWindow.Left != 0 || csbi->srWindow.Top != 0)\n        return -1;\n    if (this->data->cols != csbi->dwSize.X)\n        return -1;\n#else\n    this->data->cols = csbi->dwSize.X;\n    this->data->rows = csbi->dwSize.Y;\n#if 0\n    if (csbi->srWindow.Left != 0)\n        return -1;\n#endif\n#endif\n\n#if 1\n    // check if we are running under Wine\n    // (this rather direct Win32 screen driver maps poorly to Unix terminals)\n    // ntdll.dll wine_get_version() was added in wine-0.9.59 (Apr 2008)\n    HMODULE ntdll = GetModuleHandleA(\"ntdll.dll\");\n    if (ntdll != nullptr) {\n        typedef const char *(CDECL * wine_get_version_func_t)(void);\n        wine_get_version_func_t wine_get_version;\n        wine_get_version =\n            (wine_get_version_func_t) (void *) GetProcAddress(ntdll, \"wine_get_version\");\n        if (wine_get_version != nullptr) {\n            return -1;\n        }\n    }\n#endif\n\n    this->data->cursor_x = csbi->dwCursorPosition.X;\n    this->data->cursor_y = csbi->dwCursorPosition.Y;\n\n    ae.ho = ho;\n    ae.is_valid = 1;\n\n    attr = csbi->wAttributes;\n    this->data->hi = hi;\n    this->data->ho = ho;\n    this->data->mode = 3; // ???\n    this->data->attr = attr;\n    this->data->init_attr = attr;\n    this->data->empty_cell.Char.UnicodeChar = 0;\n    this->data->empty_cell.Char.AsciiChar = ' ';\n    this->data->empty_cell.Attributes = attr;\n    for (i = 0; i < 256; i++)\n        this->data->empty_line[i] = this->data->empty_cell;\n\n    return 0;\n}\n\nstatic void updateLineN(screen_t *this, const void *line, int y, int len) {\n    if (y >= 0 && y < this->data->rows && len > 0 && len <= 2 * this->data->cols) {\n#if 0\n        const char *s = (const char *) line;\n        int l = len / 2;\n        int i;\n\n        assert(l <= 256);\n        CHAR_INFO ci[256];\n        COORD size = { P(l), 1 };\n        SMALL_RECT region = { 0, P(y), P(0 + l - 1), P(y) };\n        for (i = 0; i < l; i++)\n        {\n            ci[i].Char.UnicodeChar = 0;\n            ci[i].Char.AsciiChar = *s++;\n            ci[i].Attributes = *s++;\n        }\n        WriteConsoleOutputA(this->data->ho, &ci[0], size, pos00, &region);\n#endif\n        UNUSED(line);\n    }\n}\n\nstatic void clearLine(screen_t *this, int y) {\n    if (y >= 0 && y < this->data->rows) {\n        COORD size = {P(this->data->cols), 1};\n        SMALL_RECT region = {0, P(y), P(this->data->cols - 1), P(y)};\n        WriteConsoleOutputA(this->data->ho, this->data->empty_line, size, pos00, &region);\n    }\n}\n\nstatic void clear(screen_t *this) {\n    int y;\n    for (y = 0; y < this->data->rows; y++)\n        this->clearLine(this, y);\n}\n\n/* private */\nstatic int do_scroll(screen_t *this, int lines, int way) {\n    if (lines <= 0 || lines > this->data->rows)\n        return 0;\n    if (lines == this->data->rows) {\n        this->clear(this);\n        return lines;\n    }\n\n    SMALL_RECT rect = {0, 0, P(this->data->cols - 1), P(this->data->rows - 1)};\n    // SMALL_RECT clip = rect;\n    COORD dest = {0, 0};\n    switch (way) {\n    case 0:\n        rect.Top = P(rect.Top + lines);\n        break;\n    case 1:\n        rect.Bottom = P(rect.Bottom - lines);\n        dest.Y = P(dest.Y + lines);\n        break;\n    }\n    // ScrollConsoleScreenBuffer(this->data->ho, &rect, &clip, dest, &this->data->empty_cell);\n    ScrollConsoleScreenBuffer(this->data->ho, &rect, nullptr, dest, &this->data->empty_cell);\n\n    return lines;\n}\n\nstatic int scrollUp(screen_t *this, int lines) {\n    lines = do_scroll(this, lines, 0);\n    this->data->scroll_counter += lines;\n    return lines;\n}\n\nstatic int scrollDown(screen_t *this, int lines) {\n    lines = do_scroll(this, lines, 1);\n    this->data->scroll_counter -= lines;\n    return lines;\n}\n\nstatic int getScrollCounter(const screen_t *this) { return this->data->scroll_counter; }\n\nstatic int s_kbhit(screen_t *this) {\n    UNUSED(this);\n#if (HAVE_CONIO_H)\n#if defined(__RSXNT__)\n    return 0;\n#elif defined(__BORLANDC__) || defined(__WATCOMC__)\n    return kbhit();\n#else\n    return _kbhit();\n#endif\n#else\n    return 0;\n#endif\n}\n\nstatic int intro(screen_t *this, void (*show_frames)(screen_t *)) {\n    UNUSED(this);\n    UNUSED(show_frames);\n    return 0;\n}\n\nstatic void atExit(void) {\n    static int done = 0;\n    if (done)\n        return;\n    done = 1;\n    if (ae.is_valid) {\n    }\n}\n\nstatic const screen_t driver = {sobject_destroy, nullptr, /* finalize */\n                                atExit,          init,       refresh,\n                                getMode,         getPage,    getRows,\n                                getCols,         isMono,     getFg,\n                                getBg,           getCursor,  getCursorShape,\n                                setFg,           setBg,      setCursor,\n                                setCursorShape,  hideCursor, putChar,\n                                putCharAttr,     putString,  putStringAttr,\n                                clear,           clearLine,  updateLineN,\n                                scrollUp,        scrollDown, getScrollCounter,\n                                s_kbhit,         intro,      (struct screen_data_t *) nullptr};\n\n/* public constructor */\nscreen_t *screen_win32_construct(void) { return sobject_construct(&driver, sizeof(*driver.data)); }\n\n#endif /* (USE_SCREEN_WIN32) */\n\n/* vim:set ts=4 sw=4 et: */\n","size_bytes":12164},"src/filter/filter_impl.cpp":{"content":"/* filter_impl.cpp -- filter implementation (low-level)\n\n   This file is part of the Resize executable compressor.\n\n   Copyright (C) 2025 WHO-AM-I-404\n   Based on UPX - Ultimate Packer for eXecutables\n   Copyright (C) 1996-2025 Markus Franz Xaver Johannes Oberhumer\n   Copyright (C) 1996-2025 Laszlo Molnar\n   All Rights Reserved.\n\n   Resize and the UCL library are free software; you can redistribute them\n   and/or modify them under the terms of the GNU General Public License as\n   published by the Free Software Foundation; either version 2 of\n   the License, or (at your option) any later version.\n\n   This program is distributed in the hope that it will be useful,\n   but WITHOUT ANY WARRANTY; without even the implied warranty of\n   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n   GNU General Public License for more details.\n\n   You should have received a copy of the GNU General Public License\n   along with this program; see the file COPYING.\n   If not, write to the Free Software Foundation, Inc.,\n   59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.\n\n   WHO-AM-I-404 <who-am-i-404@proton.me>\n   Based on original work by:\n   Markus F.X.J. Oberhumer <markus@oberhumer.com>\n   Laszlo Molnar <ezerotven+github@gmail.com>\n */\n\n#include \"../conf.h\"\n#include \"../filter.h\"\n\n#define set_dummy(p, v) ((void) 0)\n#define get_8(p)        (*(p))\n#define set_8(p, v)     (*(p) = (v))\n\n/*************************************************************************\n// util\n**************************************************************************/\n\n#include \"getcto.h\"\n\n/*************************************************************************\n// simple filters: calltrick / swaptrick / delta / ...\n**************************************************************************/\n\n#include \"ct.h\"\n#include \"sw.h\"\n#include \"ctsw.h\"\n\n#include \"sub8.h\"\n#include \"sub16.h\"\n#include \"sub32.h\"\n\n/*************************************************************************\n// cto calltrick\n**************************************************************************/\n\n#define COND(b, x) (b[x] == 0xe8)\n#define F          f_cto32_e8_bswap_le\n#define U          u_cto32_e8_bswap_le\n#include \"cto.h\"\n#define F s_cto32_e8_bswap_le\n#include \"cto.h\"\n#undef COND\n\n#define COND(b, x) (b[x] == 0xe9)\n#define F          f_cto32_e9_bswap_le\n#define U          u_cto32_e9_bswap_le\n#include \"cto.h\"\n#define F s_cto32_e9_bswap_le\n#include \"cto.h\"\n#undef COND\n\n#define COND(b, x) (b[x] == 0xe8 || b[x] == 0xe9)\n#define F          f_cto32_e8e9_bswap_le\n#define U          u_cto32_e8e9_bswap_le\n#include \"cto.h\"\n#define F s_cto32_e8e9_bswap_le\n#include \"cto.h\"\n#undef COND\n\n/*************************************************************************\n// cto calltrick with jmp\n**************************************************************************/\n\n#define COND(b, x, lastcall) (b[x] == 0xe8 || b[x] == 0xe9)\n#define F                    f_ctoj32_e8e9_bswap_le\n#define U                    u_ctoj32_e8e9_bswap_le\n#include \"ctoj.h\"\n#define F s_ctoj32_e8e9_bswap_le\n#include \"ctoj.h\"\n#undef COND\n\n/*************************************************************************\n// cto calltrick with jmp, optional jcc\n**************************************************************************/\n\n#define COND1(b, x)        (b[x] == 0xe8 || b[x] == 0xe9)\n#define COND2(b, x, lc)    (lc != (x) && 0xf == b[(x) -1] && 0x80 <= b[x] && b[x] <= 0x8f)\n#define COND(b, x, lc, id) (COND1(b, x) || ((9 <= (0xf & (id))) && COND2(b, x, lc)))\n#define F                  f_ctok32_e8e9_bswap_le\n#define U                  u_ctok32_e8e9_bswap_le\n#include \"ctok.h\"\n#define F s_ctok32_e8e9_bswap_le\n#include \"ctok.h\"\n#undef COND\n#undef COND2\n#undef COND1\n\n/*************************************************************************\n// cto calltrick with jmp and jcc and relative renumbering\n**************************************************************************/\n\n#define COND_CALL(which, b, x) ((which = 0), b[x] == 0xe8)\n#define COND_JMP(which, b, x)  ((which = 1), b[x] == 0xe9)\n#define COND_JCC(which, b, lastcall, x, y, z)                                                      \\\n    ((which = 2), (lastcall != (x) && 0xf == b[y] && 0x80 <= b[z] && b[z] <= 0x8f))\n#define COND1(which, b, x)                 (COND_CALL(which, b, x) || COND_JMP(which, b, x))\n#define COND2(which, b, lastcall, x, y, z) COND_JCC(which, b, lastcall, x, y, z)\n\n#define CONDF(which, b, x, lastcall) (COND1(which, b, x) || COND2(which, b, lastcall, x, (x) -1, x))\n#define CONDU(which, b, x, lastcall) (COND1(which, b, x) || COND2(which, b, lastcall, x, x, (x) -1))\n\n#define F f_ctojr32_e8e9_bswap_le\n#define U u_ctojr32_e8e9_bswap_le\n#include \"ctojr.h\"\n#define F s_ctojr32_e8e9_bswap_le\n#include \"ctojr.h\"\n\n#undef CONDU\n#undef CONDF\n#undef COND2\n#undef COND1\n#undef COND_JCC\n#undef COND_JMP\n#undef COND_CALL\n\n/*************************************************************************\n// PowerPC branch [incl. call] trick\n**************************************************************************/\n\n#define COND(b, x) (18 == (get_be32(b + x) >> 26))\n#define F          f_ppcbxx\n#define U          u_ppcbxx\n#include \"ppcbxx.h\"\n#define F s_ppcbxx\n#include \"ppcbxx.h\"\n#undef COND\n\n/*************************************************************************\n// database for use in class Filter\n**************************************************************************/\n\n// clang-format off\n/*static*/ const FilterImpl::FilterEntry FilterImpl::filters[] = {\n    // no filter\n    { 0x00, 0,          0, nullptr, nullptr, nullptr },\n\n    // 16-bit calltrick\n    { 0x01, 4,          0, f_ct16_e8, u_ct16_e8, s_ct16_e8 },\n    { 0x02, 4,          0, f_ct16_e9, u_ct16_e9, s_ct16_e9 },\n    { 0x03, 4,          0, f_ct16_e8e9, u_ct16_e8e9, s_ct16_e8e9 },\n    { 0x04, 4,          0, f_ct16_e8_bswap_le, u_ct16_e8_bswap_le, s_ct16_e8_bswap_le },\n    { 0x05, 4,          0, f_ct16_e9_bswap_le, u_ct16_e9_bswap_le, s_ct16_e9_bswap_le },\n    { 0x06, 4,          0, f_ct16_e8e9_bswap_le, u_ct16_e8e9_bswap_le, s_ct16_e8e9_bswap_le },\n    { 0x07, 4,          0, f_ct16_e8_bswap_be, u_ct16_e8_bswap_be, s_ct16_e8_bswap_be },\n    { 0x08, 4,          0, f_ct16_e9_bswap_be, u_ct16_e9_bswap_be, s_ct16_e9_bswap_be },\n    { 0x09, 4,          0, f_ct16_e8e9_bswap_be, u_ct16_e8e9_bswap_be, s_ct16_e8e9_bswap_be },\n\n    // 16-bit swaptrick\n    { 0x0a, 4,          0, f_sw16_e8, u_sw16_e8, s_sw16_e8 },\n    { 0x0b, 4,          0, f_sw16_e9, u_sw16_e9, s_sw16_e9 },\n    { 0x0c, 4,          0, f_sw16_e8e9, u_sw16_e8e9, s_sw16_e8e9 },\n\n    // 16-bit call-/swaptrick\n    { 0x0d, 4,          0, f_ctsw16_e8_e9, u_ctsw16_e8_e9, s_ctsw16_e8_e9 },\n    { 0x0e, 4,          0, f_ctsw16_e9_e8, u_ctsw16_e9_e8, s_ctsw16_e9_e8 },\n\n    // 32-bit calltrick\n    { 0x11, 6,          0, f_ct32_e8, u_ct32_e8, s_ct32_e8 },\n    { 0x12, 6,          0, f_ct32_e9, u_ct32_e9, s_ct32_e9 },\n    { 0x13, 6,          0, f_ct32_e8e9, u_ct32_e8e9, s_ct32_e8e9 },\n    { 0x14, 6,          0, f_ct32_e8_bswap_le, u_ct32_e8_bswap_le, s_ct32_e8_bswap_le },\n    { 0x15, 6,          0, f_ct32_e9_bswap_le, u_ct32_e9_bswap_le, s_ct32_e9_bswap_le },\n    { 0x16, 6,          0, f_ct32_e8e9_bswap_le, u_ct32_e8e9_bswap_le, s_ct32_e8e9_bswap_le },\n    { 0x17, 6,          0, f_ct32_e8_bswap_be, u_ct32_e8_bswap_be, s_ct32_e8_bswap_be },\n    { 0x18, 6,          0, f_ct32_e9_bswap_be, u_ct32_e9_bswap_be, s_ct32_e9_bswap_be },\n    { 0x19, 6,          0, f_ct32_e8e9_bswap_be, u_ct32_e8e9_bswap_be, s_ct32_e8e9_bswap_be },\n\n    // 32-bit swaptrick\n    { 0x1a, 6,          0, f_sw32_e8, u_sw32_e8, s_sw32_e8 },\n    { 0x1b, 6,          0, f_sw32_e9, u_sw32_e9, s_sw32_e9 },\n    { 0x1c, 6,          0, f_sw32_e8e9, u_sw32_e8e9, s_sw32_e8e9 },\n\n    // 32-bit call-/swaptrick\n    { 0x1d, 6,          0, f_ctsw32_e8_e9, u_ctsw32_e8_e9, s_ctsw32_e8_e9 },\n    { 0x1e, 6,          0, f_ctsw32_e9_e8, u_ctsw32_e9_e8, s_ctsw32_e9_e8 },\n\n    // 32-bit cto calltrick\n    { 0x24, 6, 0x00ffffff, f_cto32_e8_bswap_le, u_cto32_e8_bswap_le, s_cto32_e8_bswap_le },\n    { 0x25, 6, 0x00ffffff, f_cto32_e9_bswap_le, u_cto32_e9_bswap_le, s_cto32_e9_bswap_le },\n    { 0x26, 6, 0x00ffffff, f_cto32_e8e9_bswap_le, u_cto32_e8e9_bswap_le, s_cto32_e8e9_bswap_le },\n\n    // 32-bit cto calltrick with jmp\n    { 0x36, 6, 0x00ffffff, f_ctoj32_e8e9_bswap_le, u_ctoj32_e8e9_bswap_le, s_ctoj32_e8e9_bswap_le },\n\n    // 32-bit calltrick with jmp, optional jcc; runtime can unfilter more than one block\n    // Note 0x46 uses 'ctoj', while 0x49 uses 'ctok'.\n    { 0x46, 6, 0x00ffffff, f_ctoj32_e8e9_bswap_le, u_ctoj32_e8e9_bswap_le, s_ctoj32_e8e9_bswap_le },\n    { 0x49, 6, 0x00ffffff, f_ctok32_e8e9_bswap_le, u_ctok32_e8e9_bswap_le, s_ctok32_e8e9_bswap_le },\n\n    // 24-bit calltrick for arm\n    { 0x50, 8, 0x01ffffff, f_ct24arm_le, u_ct24arm_le, s_ct24arm_le },\n    { 0x51, 8, 0x01ffffff, f_ct24arm_be, u_ct24arm_be, s_ct24arm_be },\n\n#if 1  //{ old reliable\n    // 26-bit calltrick for arm64\n    { 0x52, 8, 0x03ffffff, f_ct26arm_le, u_ct26arm_le, s_ct26arm_le },\n#else  //}{ new enhanced, but needs new filter id\n    // 26-bit calltrick for arm64; also 19-bit and 14-bit\n    { 0x52, 8, 0x03ffffff, f_CTarm64_le, u_CTarm64_le, s_CTarm64_le },\n#endif  //}\n\n    // 32-bit cto calltrick with jmp and jcc(swap 0x0f/0x8Y) and relative renumbering\n    { 0x80, 8, 0x00ffffff, f_ctojr32_e8e9_bswap_le, u_ctojr32_e8e9_bswap_le, s_ctojr32_e8e9_bswap_le },\n    { 0x81, 8, 0x00ffffff, f_ctojr32_e8e9_bswap_le, u_ctojr32_e8e9_bswap_le, s_ctojr32_e8e9_bswap_le },\n    { 0x82, 8, 0x00ffffff, f_ctojr32_e8e9_bswap_le, u_ctojr32_e8e9_bswap_le, s_ctojr32_e8e9_bswap_le },\n    { 0x83, 8, 0x00ffffff, f_ctojr32_e8e9_bswap_le, u_ctojr32_e8e9_bswap_le, s_ctojr32_e8e9_bswap_le },\n    { 0x84, 8, 0x00ffffff, f_ctojr32_e8e9_bswap_le, u_ctojr32_e8e9_bswap_le, s_ctojr32_e8e9_bswap_le },\n    { 0x85, 8, 0x00ffffff, f_ctojr32_e8e9_bswap_le, u_ctojr32_e8e9_bswap_le, s_ctojr32_e8e9_bswap_le },\n    { 0x86, 8, 0x00ffffff, f_ctojr32_e8e9_bswap_le, u_ctojr32_e8e9_bswap_le, s_ctojr32_e8e9_bswap_le },\n    { 0x87, 8, 0x00ffffff, f_ctojr32_e8e9_bswap_le, u_ctojr32_e8e9_bswap_le, s_ctojr32_e8e9_bswap_le },\n\n    // simple delta filter\n    { 0x90, 2,          0, f_sub8_1, u_sub8_1, s_sub8_1 },\n    { 0x91, 3,          0, f_sub8_2, u_sub8_2, s_sub8_2 },\n    { 0x92, 4,          0, f_sub8_3, u_sub8_3, s_sub8_3 },\n    { 0x93, 5,          0, f_sub8_4, u_sub8_4, s_sub8_4 },\n\n    { 0xa0,99,          0, f_sub16_1, u_sub16_1, s_sub16_1 },\n    { 0xa1,99,          0, f_sub16_2, u_sub16_2, s_sub16_2 },\n    { 0xa2,99,          0, f_sub16_3, u_sub16_3, s_sub16_3 },\n    { 0xa3,99,          0, f_sub16_4, u_sub16_4, s_sub16_4 },\n\n    { 0xb0,99,          0, f_sub32_1, u_sub32_1, s_sub32_1 },\n    { 0xb1,99,          0, f_sub32_2, u_sub32_2, s_sub32_2 },\n    { 0xb2,99,          0, f_sub32_3, u_sub32_3, s_sub32_3 },\n    { 0xb3,99,          0, f_sub32_4, u_sub32_4, s_sub32_4 },\n\n    // PowerPC branch+call trick\n    { 0xd0, 8,          0, f_ppcbxx, u_ppcbxx, s_ppcbxx },\n};\n// clang-format on\n\n/*static*/ const int FilterImpl::n_filters = TABLESIZE(filters);\n\n/* vim:set ts=4 sw=4 et: */\n","size_bytes":11084},"src/util/membuffer.cpp":{"content":"/* membuffer.cpp --\n\n   This file is part of the Resize executable compressor.\n\n   Copyright (C) 2025 WHO-AM-I-404\n   Based on UPX - Ultimate Packer for eXecutables\n   Copyright (C) 1996-2025 Markus Franz Xaver Johannes Oberhumer\n   Copyright (C) 1996-2025 Laszlo Molnar\n   All Rights Reserved.\n\n   Resize and the UCL library are free software; you can redistribute them\n   and/or modify them under the terms of the GNU General Public License as\n   published by the Free Software Foundation; either version 2 of\n   the License, or (at your option) any later version.\n\n   This program is distributed in the hope that it will be useful,\n   but WITHOUT ANY WARRANTY; without even the implied warranty of\n   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n   GNU General Public License for more details.\n\n   You should have received a copy of the GNU General Public License\n   along with this program; see the file COPYING.\n   If not, write to the Free Software Foundation, Inc.,\n   59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.\n\n   WHO-AM-I-404 <who-am-i-404@proton.me>\n   Based on original work by:\n   Markus F.X.J. Oberhumer <markus@oberhumer.com>\n   Laszlo Molnar <ezerotven+github@gmail.com>\n */\n\n// A MemBuffer allocates memory on the heap, and automatically\n// gets destructed when leaving scope or on exceptions.\n\n#include \"../conf.h\"\n#include \"membuffer.h\"\n\n// extra functions to reduce dependency on membuffer.h\nvoid *membuffer_get_void_ptr(MemBuffer &mb) noexcept { return mb.getVoidPtr(); }\nunsigned membuffer_get_size(MemBuffer &mb) noexcept { return mb.getSize(); }\n\n/*static*/ MemBuffer::Stats MemBuffer::stats;\n\n#if DEBUG\n#define debug_set(var, expr) (var) = (expr)\n#else\n#define debug_set(var, expr) /*empty*/\n#endif\n\n/*************************************************************************\n// bool use_simple_mcheck()\n**************************************************************************/\n\n#if defined(__SANITIZE_ADDRESS__) || defined(__SANITIZE_MEMORY__)\nstatic forceinline constexpr bool use_simple_mcheck() noexcept { return false; }\n#elif defined(__CHERI__) && defined(__CHERI_PURE_CAPABILITY__)\nstatic forceinline constexpr bool use_simple_mcheck() noexcept { return false; }\n#elif (WITH_VALGRIND) && defined(RUNNING_ON_VALGRIND)\nstatic bool use_simple_mcheck_flag;\nstatic noinline void init_use_simple_mcheck() noexcept {\n    bool r = true;\n    if (RUNNING_ON_VALGRIND) {\n        r = false;\n        NO_fprintf(stderr, \"upx: detected RUNNING_ON_VALGRIND\\n\");\n    }\n    use_simple_mcheck_flag = r;\n}\nstatic bool use_simple_mcheck() noexcept {\n    static upx_std_once_flag init_done;\n    upx_std_call_once(init_done, init_use_simple_mcheck);\n    // NOTE: clang-analyzer-unix.Malloc does not know that this flag is \"constant\"; see below\n    return use_simple_mcheck_flag;\n}\n#else\nstatic forceinline constexpr bool use_simple_mcheck() noexcept { return true; }\n#endif\n\n/*************************************************************************\n//\n**************************************************************************/\n\nMemBuffer::MemBuffer(upx_uint64_t bytes) may_throw : MemBufferBase<byte>() {\n    static_assert(element_size == 1);\n    alloc(bytes);\n    debug_set(debug.last_return_address_alloc, upx_return_address());\n}\n\nMemBuffer::~MemBuffer() noexcept { this->dealloc(); }\n\n// similar to BoundedPtr, except checks only at creation\n// skip == offset, take == size_in_bytes\nvoid *MemBuffer::subref_impl(const char *errfmt, size_t skip, size_t take) {\n    debug_set(debug.last_return_address_subref, upx_return_address());\n    // check overrun and wrap-around\n    if (skip + take > size_in_bytes || skip + take < skip) {\n        char buf[100];\n        // printf is using unsigned formatting\n        if (!errfmt || !errfmt[0])\n            errfmt = \"bad subref %#x %#x\";\n        upx_safe_snprintf(buf, sizeof(buf), errfmt, (unsigned) skip, (unsigned) take);\n        throwCantPack(buf);\n    }\n    return ptr + skip;\n}\n\n/*static*/\nunsigned MemBuffer::getSizeForCompression(unsigned uncompressed_size, unsigned extra) {\n    if (uncompressed_size == 0)\n        throwCantPack(\"invalid uncompressed_size\");\n    const size_t z = uncompressed_size; // fewer keystrokes and display columns\n    size_t bytes = mem_size(1, z);      // check size\n    // All literal: 1 bit overhead per literal byte; from UCL documentation\n    bytes = upx::umax(bytes, z + z / 8 + 256);\n    // zstd: ZSTD_COMPRESSBOUND\n    bytes = upx::umax(bytes, z + (z >> 8) + ((z < (128 << 10)) ? (((128 << 10) - z) >> 11) : 0));\n    // add extra and 256 safety for various rounding/alignments\n    bytes = mem_size(1, bytes, extra, 256);\n    return ACC_ICONV(unsigned, bytes);\n}\n\n/*static*/\nunsigned MemBuffer::getSizeForDecompression(unsigned uncompressed_size, unsigned extra) {\n    if (uncompressed_size == 0)\n        throwCantPack(\"invalid uncompressed_size\");\n    size_t bytes = mem_size(1, uncompressed_size, extra); // check size\n    return ACC_ICONV(unsigned, bytes);\n}\n\nvoid MemBuffer::allocForCompression(unsigned uncompressed_size, unsigned extra) {\n    unsigned bytes = getSizeForCompression(uncompressed_size, extra);\n    alloc(bytes);\n    debug_set(debug.last_return_address_alloc, upx_return_address());\n}\n\nvoid MemBuffer::allocForDecompression(unsigned uncompressed_size, unsigned extra) {\n    unsigned bytes = getSizeForDecompression(uncompressed_size, extra);\n    alloc(bytes);\n    debug_set(debug.last_return_address_alloc, upx_return_address());\n}\n\nvoid MemBuffer::fill(unsigned off, unsigned len, int value) {\n    debug_set(debug.last_return_address_fill, upx_return_address());\n    checkState();\n    if (off > size_in_bytes || len > size_in_bytes || off + len > size_in_bytes)\n        throwCantPack(\"MemBuffer::fill out of range; take care!\");\n    if (len > 0)\n        memset(ptr + off, value, len);\n}\n\n/*************************************************************************\n//\n**************************************************************************/\n\n// for use_simple_mcheck()\n#define PTR_BITS32(p) ((upx_uint32_t) (ptr_get_address(p) & 0xffffffff))\n#define MAGIC1(p)     ((PTR_BITS32(p) ^ 0xfefdbeeb) | 1)\n#define MAGIC2(p)     ((PTR_BITS32(p) ^ 0xfefdbeeb ^ 0x88224411) | 1)\n\nvoid MemBuffer::checkState() const may_throw {\n    if (!ptr)\n        throwInternalError(\"block not allocated\");\n    assert(size_in_bytes > 0);\n    if (use_simple_mcheck()) {\n        const byte *p = (const byte *) ptr;\n        if (get_ne32(p - 4) != MAGIC1(p))\n            throwInternalError(\"memory clobbered before allocated block 1\");\n        if (get_ne32(p - 8) != size_in_bytes)\n            throwInternalError(\"memory clobbered before allocated block 2\");\n        if (get_ne32(p + size_in_bytes) != MAGIC2(p))\n            throwInternalError(\"memory clobbered past end of allocated block\");\n    }\n}\n\nvoid MemBuffer::alloc(upx_uint64_t bytes) may_throw {\n    // INFO: we don't automatically free a used buffer\n    assert(ptr == nullptr);\n    assert(size_in_bytes == 0);\n    //\n    assert(bytes > 0);\n    debug_set(debug.last_return_address_alloc, upx_return_address());\n    size_t malloc_bytes = mem_size(1, bytes); // check size\n    if (use_simple_mcheck())\n        malloc_bytes += 32;\n    else\n        malloc_bytes += 4;\n    byte *p = (byte *) ::malloc(malloc_bytes);\n    NO_printf(\"MemBuffer::alloc %llu: %p\\n\", bytes, p);\n    if (!p)\n        throwOutOfMemoryException();\n    size_in_bytes = ACC_ICONV(unsigned, bytes);\n    if (use_simple_mcheck()) {\n        p += 16;\n        // store magic constants to detect buffer overruns\n        set_ne32(p - 8, size_in_bytes);\n        set_ne32(p - 4, MAGIC1(p));\n        set_ne32(p + size_in_bytes + 0, MAGIC2(p));\n        set_ne32(p + size_in_bytes + 4, stats.global_alloc_counter);\n    }\n    ptr = upx::ptr_static_cast<pointer>(p);\n#if !defined(__SANITIZE_MEMORY__) && DEBUG\n    memset(ptr, 0xfb, size_in_bytes);\n    (void) VALGRIND_MAKE_MEM_UNDEFINED(ptr, size_in_bytes);\n#endif\n    stats.global_alloc_counter += 1;\n    stats.global_total_bytes += size_in_bytes;\n    stats.global_total_active_bytes += size_in_bytes;\n#if DEBUG || 1\n    checkState();\n#endif\n}\n\nvoid MemBuffer::dealloc() noexcept {\n    if (ptr != nullptr) {\n        debug_set(debug.last_return_address_dealloc, upx_return_address());\n#if DEBUG || 1\n        // info: calling checkState() here violates \"noexcept\", so we need a try block\n        bool shall_check = true;\n        // bool shall_check = (std::uncaught_exceptions() == 0); // only if not unwinding\n        // TODO later: add a priority() method to class Throwable\n        if (shall_check) {\n            try {\n                checkState();\n            } catch (const Throwable &e) {\n                printErr(\"unknown\", e);\n                std::terminate();\n            } catch (...) {\n                std::terminate();\n            }\n        }\n#endif\n        stats.global_dealloc_counter += 1;\n        stats.global_total_active_bytes -= size_in_bytes;\n        if (use_simple_mcheck()) {\n            byte *p = (byte *) ptr;\n            // clear magic constants\n            set_ne32(p - 8, 0);\n            set_ne32(p - 4, 0);\n            set_ne32(p + size_in_bytes, 0);\n            set_ne32(p + size_in_bytes + 4, 0);\n            //\n            ::free(p - 16); // NOLINT(clang-analyzer-unix.Malloc) // see NOTE above\n        } else {\n            ::free(ptr); // NOLINT(clang-analyzer-unix.Malloc) // see NOTE above\n        }\n        ptr = nullptr;\n        size_in_bytes = 0;\n    } else {\n        assert_noexcept(size_in_bytes == 0);\n    }\n}\n\n/*************************************************************************\n//\n**************************************************************************/\n\nTEST_CASE(\"MemBuffer core\") {\n    constexpr size_t N = 64;\n    MemBuffer mb;\n    CHECK_THROWS(mb.checkState());\n    CHECK_THROWS(mb.alloc(0x30000000 + 1));\n    CHECK(raw_bytes(mb, 0) == nullptr);\n    CHECK_THROWS(raw_bytes(mb, 1));\n    CHECK_THROWS(mb.begin());\n    CHECK_THROWS(mb.end());\n    CHECK_THROWS(mb.cbegin());\n    CHECK_THROWS(mb.cend());\n    mb.alloc(N);\n    mb.checkState();\n    CHECK(mb.begin() == mb.cbegin());\n    CHECK(mb.end() == mb.cend());\n    CHECK(mb.begin() == &mb[0]);\n    CHECK(mb.end() == &mb[0] + N);\n    CHECK(mb.cbegin() == &mb[0]);\n    CHECK(mb.cend() == &mb[0] + N);\n    CHECK(raw_bytes(mb, N) != nullptr);\n    CHECK(raw_bytes(mb, N) == mb.getVoidPtr());\n    CHECK_THROWS(raw_bytes(mb, N + 1));\n    CHECK_NOTHROW(mb + N);\n    CHECK_THROWS(mb + (N + 1));\n#if ALLOW_INT_PLUS_MEMBUFFER\n    CHECK_NOTHROW(N + mb);\n    CHECK_THROWS((N + 1) + mb);\n#endif\n    CHECK_NOTHROW(mb.subref(\"\", 0, N));\n    CHECK_NOTHROW(mb.subref(\"\", N, 0));\n    CHECK_THROWS(mb.subref(\"\", 1, N));\n    CHECK_THROWS(mb.subref(\"\", N, 1));\n    if (use_simple_mcheck()) {\n        byte *p = raw_bytes(mb, 0);\n        upx_uint32_t magic1 = get_ne32(p - 4);\n        set_ne32(p - 4, magic1 ^ 1);\n        CHECK_THROWS(mb.checkState());\n        set_ne32(p - 4, magic1);\n        mb.checkState();\n    }\n}\n\nTEST_CASE(\"MemBuffer global overloads\") {\n    MemBuffer mb(1);\n    MemBuffer mb4(4);\n    mb.clear();\n    mb4.clear();\n    CHECK(memcmp(mb, \"\\x00\", 1) == 0);\n    CHECK_THROWS(memcmp(mb, \"\\x00\\x00\", 2)); // NOLINT(bugprone-unused-return-value)\n    CHECK_THROWS(memcmp(\"\\x00\\x00\", mb, 2)); // NOLINT(bugprone-unused-return-value)\n    CHECK_THROWS(memcmp(mb, mb4, 2));        // NOLINT(bugprone-unused-return-value)\n    CHECK_THROWS(memcmp(mb4, mb, 2));        // NOLINT(bugprone-unused-return-value)\n    CHECK_NOTHROW(memset(mb, 255, 1));\n    CHECK_THROWS(memset(mb, 254, 2));\n    CHECK(mb[0] == 255);\n    CHECK_THROWS(get_be16(mb));\n    CHECK_THROWS(get_be32(mb));\n    CHECK_THROWS(get_be64(mb));\n    CHECK_THROWS(get_le16(mb));\n    CHECK_THROWS(get_le32(mb));\n    CHECK_THROWS(get_le64(mb));\n    CHECK_NOTHROW(get_be16(mb4));\n    CHECK_NOTHROW(get_be32(mb4));\n    CHECK_THROWS(get_be64(mb4));\n    CHECK_NOTHROW(get_le16(mb4));\n    CHECK_NOTHROW(get_le32(mb4));\n    CHECK_THROWS(get_le64(mb4));\n    CHECK_NOTHROW(set_be32(mb4, 0));\n    CHECK_THROWS(set_be64(mb4, 0));\n    CHECK_NOTHROW(set_le32(mb4, 0));\n    CHECK_THROWS(set_le64(mb4, 0));\n}\n\nTEST_CASE(\"MemBuffer unused 1\") {\n    MemBuffer mb;\n    CHECK(mb.raw_ptr() == nullptr);\n    CHECK(mb.raw_size_in_bytes() == 0);\n}\n\nTEST_CASE(\"MemBuffer unused 2\") {\n    MemBuffer mb;\n    (void) mb;\n}\n\nTEST_CASE(\"MemBuffer array access\") {\n    constexpr size_t N = 16;\n    MemBuffer mb(N);\n    mb.clear();\n    for (size_t i = 0; i != N; ++i)\n        mb[i] += 1;\n    for (byte *ptr = mb; ptr != mb + N; ++ptr)\n        *ptr += 1;\n    for (byte *ptr = mb + 0; ptr < mb + N; ++ptr)\n        *ptr += 1;\n    for (byte *ptr = &mb[0]; ptr != mb.end(); ++ptr)\n        *ptr += 1;\n    for (byte *ptr = mb.begin(); ptr < mb.end(); ++ptr)\n        *ptr += 1;\n    for (size_t i = 0; i != N; ++i)\n        assert(mb[i] == 5);\n    CHECK_NOTHROW((void) &mb[N - 1]);\n    CHECK_THROWS((void) &mb[N]); // NOT legal for containers like std::vector or MemBuffer\n}\n\nTEST_CASE(\"MemBuffer::getSizeForCompression\") {\n    CHECK_THROWS(MemBuffer::getSizeForCompression(0));\n    CHECK_THROWS(MemBuffer::getSizeForDecompression(0));\n    CHECK(MemBuffer::getSizeForCompression(1) == 513);\n    CHECK(MemBuffer::getSizeForCompression(256) == 800);\n    CHECK(MemBuffer::getSizeForCompression(1024) == 1664);\n    CHECK(MemBuffer::getSizeForCompression(1024 * 1024) == 1180160);         // 0x00100000\n    CHECK(MemBuffer::getSizeForCompression(64 * 1024 * 1024) == 75497984);   // 0x04000000\n    CHECK(MemBuffer::getSizeForCompression(512 * 1024 * 1024) == 603980288); // 0x20000000\n    CHECK(MemBuffer::getSizeForCompression(640 * 1024 * 1024) == 754975232); // 0x28000000\n    // \"682 MiB Ought to be Enough for Anyone\" --Markus F.X.J. Oberhumer, 2023 ;-)\n    CHECK(MemBuffer::getSizeForCompression(682 * 1024 * 1024) == 804520448); // 0x2aa00000\n    CHECK(MemBuffer::getSizeForCompression(715827428) == UPX_RSIZE_MAX);     // 0x2aaaa8e4\n    CHECK_THROWS(MemBuffer::getSizeForCompression(715827428 + 1));           // 0x2aaaa8e4 + 1\n}\n\n/* vim:set ts=4 sw=4 et: */\n","size_bytes":14048},"src/util/snprintf.cpp":{"content":"/* snprintf.cpp -- string wrapper\n\n   This file is part of the Resize executable compressor.\n\n   Copyright (C) 2025 WHO-AM-I-404\n   Based on UPX - Ultimate Packer for eXecutables\n   Copyright (C) 1996-2025 Markus Franz Xaver Johannes Oberhumer\n   Copyright (C) 1996-2025 Laszlo Molnar\n   All Rights Reserved.\n\n   Resize and the UCL library are free software; you can redistribute them\n   and/or modify them under the terms of the GNU General Public License as\n   published by the Free Software Foundation; either version 2 of\n   the License, or (at your option) any later version.\n\n   This program is distributed in the hope that it will be useful,\n   but WITHOUT ANY WARRANTY; without even the implied warranty of\n   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n   GNU General Public License for more details.\n\n   You should have received a copy of the GNU General Public License\n   along with this program; see the file COPYING.\n   If not, write to the Free Software Foundation, Inc.,\n   59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.\n\n   WHO-AM-I-404 <who-am-i-404@proton.me>\n   Based on original work by:\n   Markus F.X.J. Oberhumer <markus@oberhumer.com>\n   Laszlo Molnar <ezerotven+github@gmail.com>\n */\n\n#include \"../conf.h\"\n\n/*************************************************************************\n// UPX version of string functions, with assertions and sane limits\n**************************************************************************/\n\nupx_rsize_t upx_safe_strlen(const char *s) {\n#undef strlen\n    assert(s != nullptr);\n    size_t len = strlen(s);\n    assert(len < UPX_RSIZE_MAX_STR);\n    return len;\n#define strlen upx_safe_strlen\n}\n\nupx_rsize_t upx_safe_strlen_noexcept(const char *s) noexcept {\n#undef strlen\n    assert_noexcept(s != nullptr);\n    size_t len = strlen(s);\n    assert_noexcept(len < UPX_RSIZE_MAX_STR);\n    return len;\n#define strlen upx_safe_strlen\n}\n\nint upx_safe_vsnprintf(char *str, upx_rsize_t max_size, const char *format, va_list ap) {\n#undef vsnprintf\n    size_t size;\n\n    // preconditions\n    assert(max_size <= UPX_RSIZE_MAX_STR);\n    if (str != nullptr)\n        assert(max_size > 0);\n    else\n        assert(max_size == 0);\n\n    long long len = vsnprintf(str, max_size, format, ap);\n    assert(len >= 0);\n    assert(len < UPX_RSIZE_MAX_STR);\n    size = (size_t) len + 1;\n\n    // postconditions\n    assert(size > 0);\n    assert(size <= UPX_RSIZE_MAX_STR);\n    if (str != nullptr) {\n        assert(size <= max_size);\n        assert(str[size - 1] == '\\0');\n    }\n\n    return ACC_ICONV(int, size - 1); // snprintf() returns length, not size\n#define vsnprintf upx_safe_vsnprintf\n}\n\nint upx_safe_vsnprintf_noexcept(char *str, upx_rsize_t max_size, const char *format,\n                                va_list ap) noexcept {\n#undef vsnprintf\n    size_t size;\n\n    // preconditions\n    assert_noexcept(max_size <= UPX_RSIZE_MAX_STR);\n    if (str != nullptr)\n        assert_noexcept(max_size > 0);\n    else\n        assert_noexcept(max_size == 0);\n\n    long long len = vsnprintf(str, max_size, format, ap);\n    assert_noexcept(len >= 0);\n    assert_noexcept(len < UPX_RSIZE_MAX_STR);\n    size = (size_t) len + 1;\n\n    // postconditions\n    assert_noexcept(size > 0);\n    assert_noexcept(size <= UPX_RSIZE_MAX_STR);\n    if (str != nullptr) {\n        assert_noexcept(size <= max_size);\n        assert_noexcept(str[size - 1] == '\\0');\n    }\n\n    return ACC_ICONV(int, size - 1); // snprintf() returns length, not size\n#define vsnprintf upx_safe_vsnprintf\n}\n\nint upx_safe_snprintf(char *str, upx_rsize_t max_size, const char *format, ...) {\n    va_list ap;\n    int len;\n\n    va_start(ap, format);\n    len = upx_safe_vsnprintf(str, max_size, format, ap);\n    va_end(ap);\n    return len;\n}\n\nint upx_safe_vasprintf(char **ptr, const char *format, va_list ap) {\n    int len;\n\n    assert(ptr != nullptr);\n    *ptr = nullptr;\n\n    va_list ap_copy;\n    va_copy(ap_copy, ap);\n    len = upx_safe_vsnprintf(nullptr, 0, format, ap_copy);\n    va_end(ap_copy);\n\n    if (len >= 0) {\n        *ptr = (char *) ::malloc(len + 1);\n        assert(*ptr != nullptr);\n        if (*ptr == nullptr)\n            return -1;\n        int len2 = upx_safe_vsnprintf(*ptr, len + 1, format, ap);\n        assert(len2 == len);\n    }\n    return len;\n}\n\nint upx_safe_asprintf(char **ptr, const char *format, ...) {\n    va_list ap;\n    int len;\n\n    va_start(ap, format);\n    len = upx_safe_vasprintf(ptr, format, ap);\n    va_end(ap);\n    return len;\n}\n\nchar *upx_safe_xprintf(const char *format, ...) {\n    char *ptr = nullptr;\n    va_list ap;\n    int len;\n\n    va_start(ap, format);\n    len = upx_safe_vasprintf(&ptr, format, ap);\n    va_end(ap);\n    UNUSED(len);\n    assert(ptr != nullptr);\n    return ptr;\n}\n\n/* vim:set ts=4 sw=4 et: */\n","size_bytes":4762},"src/util/util.cpp":{"content":"/* util.cpp --\n\n   This file is part of the Resize executable compressor.\n\n   Copyright (C) 2025 WHO-AM-I-404\n   Based on UPX - Ultimate Packer for eXecutables\n   Copyright (C) 1996-2025 Markus Franz Xaver Johannes Oberhumer\n   Copyright (C) 1996-2025 Laszlo Molnar\n   All Rights Reserved.\n\n   Resize and the UCL library are free software; you can redistribute them\n   and/or modify them under the terms of the GNU General Public License as\n   published by the Free Software Foundation; either version 2 of\n   the License, or (at your option) any later version.\n\n   This program is distributed in the hope that it will be useful,\n   but WITHOUT ANY WARRANTY; without even the implied warranty of\n   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n   GNU General Public License for more details.\n\n   You should have received a copy of the GNU General Public License\n   along with this program; see the file COPYING.\n   If not, write to the Free Software Foundation, Inc.,\n   59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.\n\n   WHO-AM-I-404 <who-am-i-404@proton.me>\n   Based on original work by:\n   Markus F.X.J. Oberhumer <markus@oberhumer.com>\n   Laszlo Molnar <ezerotven+github@gmail.com>\n */\n\n#define WANT_WINDOWS_LEAN_H 1\n#include \"system_headers.h\"\n#define ACC_WANT_ACC_INCI_H 1\n#include \"miniacc.h\"\n#define ACC_WANT_ACCLIB_GETOPT   1\n#define ACC_WANT_ACCLIB_HSREAD   1\n#define ACC_WANT_ACCLIB_MISC     1\n#define ACC_WANT_ACCLIB_VGET     1\n#define ACC_WANT_ACCLIB_WILDARGV 1\n#undef HAVE_MKDIR\n#include \"miniacc.h\"\n#include \"../conf.h\"\n\n/*************************************************************************\n// upx_rsize_t and mem_size: assert sane memory buffer sizes to protect\n// against integer overflows and malicious header fields\n// see C 11 standard, Annex K\n**************************************************************************/\n\n// this limits uncompressed_size to about 682 MiB (715_128_832 bytes)\nACC_COMPILE_TIME_ASSERT_HEADER(UPX_RSIZE_MAX_MEM == UPX_RSIZE_MAX)\nACC_COMPILE_TIME_ASSERT_HEADER(UPX_RSIZE_MAX_STR <= UPX_RSIZE_MAX / 256)\nACC_COMPILE_TIME_ASSERT_HEADER(2ull * UPX_RSIZE_MAX * 9 / 8 + 256 * 1024 * 1024 < INT_MAX)\nACC_COMPILE_TIME_ASSERT_HEADER(2ull * UPX_RSIZE_MAX * 10 / 8 + 128 * 1024 * 1024 <= INT_MAX + 1u)\nACC_COMPILE_TIME_ASSERT_HEADER(5ull * UPX_RSIZE_MAX < UINT_MAX) // IMPORTANT overflow protection\nACC_COMPILE_TIME_ASSERT_HEADER(UPX_RSIZE_MAX >= 8192 * 65536)\nACC_COMPILE_TIME_ASSERT_HEADER(UPX_RSIZE_MAX_STR >= 1024)\n\nbool mem_size_valid(upx_uint64_t element_size, upx_uint64_t n, upx_uint64_t extra1,\n                    upx_uint64_t extra2) noexcept {\n    assert_noexcept(element_size > 0);\n    if very_unlikely (element_size == 0 || element_size > UPX_RSIZE_MAX)\n        return false;\n    if very_unlikely (n > UPX_RSIZE_MAX)\n        return false;\n    if very_unlikely (extra1 > UPX_RSIZE_MAX)\n        return false;\n    if very_unlikely (extra2 > UPX_RSIZE_MAX)\n        return false;\n    upx_uint64_t bytes = element_size * n + extra1 + extra2; // cannot overflow\n    if very_unlikely (bytes > UPX_RSIZE_MAX)\n        return false;\n    return true;\n}\n\nupx_rsize_t mem_size(upx_uint64_t element_size, upx_uint64_t n, upx_uint64_t extra1,\n                     upx_uint64_t extra2) {\n    assert(element_size > 0);\n    if very_unlikely (element_size == 0 || element_size > UPX_RSIZE_MAX)\n        throwCantPack(\"mem_size 1; take care\");\n    if very_unlikely (n > UPX_RSIZE_MAX)\n        throwCantPack(\"mem_size 2; take care\");\n    if very_unlikely (extra1 > UPX_RSIZE_MAX)\n        throwCantPack(\"mem_size 3; take care\");\n    if very_unlikely (extra2 > UPX_RSIZE_MAX)\n        throwCantPack(\"mem_size 4; take care\");\n    upx_uint64_t bytes = element_size * n + extra1 + extra2; // cannot overflow\n    if very_unlikely (bytes > UPX_RSIZE_MAX)\n        throwCantPack(\"mem_size 5; take care\");\n    return ACC_ICONV(upx_rsize_t, bytes);\n}\n\nTEST_CASE(\"mem_size\") {\n    CHECK(mem_size_valid(1, 0));\n    CHECK(mem_size_valid(1, 0x30000000));\n    CHECK(!mem_size_valid(1, 0x30000000 + 1));\n    CHECK(!mem_size_valid(1, 0x30000000, 1));\n    CHECK(!mem_size_valid(1, 0x30000000, 0, 1));\n    CHECK(!mem_size_valid(1, 0x30000000, 0x30000000, 0x30000000));\n    CHECK_NOTHROW(mem_size(1, 0));\n    CHECK_NOTHROW(mem_size(1, 0x30000000));\n    CHECK_THROWS(mem_size(1, 0x30000000 + 1));\n    CHECK_THROWS(mem_size(1, 0x30000000, 1));\n    CHECK_THROWS(mem_size(1, 0x30000000, 0, 1));\n    CHECK_THROWS(mem_size(1, 0x30000000, 0x30000000, 0x30000000));\n}\n\n/*************************************************************************\n// ptr util\n**************************************************************************/\n\nint ptr_diff_bytes(const void *a, const void *b) may_throw {\n    if very_unlikely (a == nullptr)\n        throwCantPack(\"ptr_diff_bytes null 1; take care\");\n    if very_unlikely (b == nullptr)\n        throwCantPack(\"ptr_diff_bytes null 2; take care\");\n    upx_sptraddr_t d = ptraddr_diff(a, b);\n    if (a >= b) {\n        if very_unlikely (!mem_size_valid_bytes(d))\n            throwCantPack(\"ptr_diff_bytes-1; take care\");\n    } else {\n        if very_unlikely (!mem_size_valid_bytes(0ll - d))\n            throwCantPack(\"ptr_diff_bytes-2; take care\");\n    }\n    assert_noexcept(d == ((const charptr) a - (const charptr) b));\n    return ACC_ICONV(int, d);\n}\n\nunsigned ptr_udiff_bytes(const void *a, const void *b) may_throw {\n    int d = ptr_diff_bytes(a, b);\n    if very_unlikely (d < 0)\n        throwCantPack(\"ptr_udiff_bytes; take care\");\n    return ACC_ICONV(unsigned, d);\n}\n\nTEST_CASE(\"ptr_diff\") {\n    byte buf[4] = {0, 1, 2, 3};\n    CHECK_THROWS(ptr_diff_bytes(nullptr, buf));\n    CHECK_THROWS(ptr_diff_bytes(buf, nullptr));\n    CHECK(ptr_diff(buf, buf) == 0);\n    CHECK(ptr_diff(buf + 1, buf) == 1);\n    CHECK(ptr_diff(buf, buf + 1) == -1);\n    CHECK(ptr_udiff(buf, buf) == 0);\n    CHECK(ptr_udiff(buf + 1, buf) == 1);\n    CHECK_THROWS(ptr_udiff(buf, buf + 1));\n    UNUSED(buf);\n}\n\n// check that 2 buffers do not overlap; will throw on error\nvoid ptraddr_check_no_overlap(upx_ptraddr_t a, size_t a_size, upx_ptraddr_t b, size_t b_size) {\n    if very_unlikely (a == 0 || b == 0)\n        throwCantPack(\"ptr_check_no_overlap-nullptr\");\n    upx_ptraddr_t a_end = a + mem_size(1, a_size);\n    upx_ptraddr_t b_end = b + mem_size(1, b_size);\n    if very_unlikely (a_end < a || b_end < b) // wrap-around\n        throwCantPack(\"ptr_check_no_overlap-overflow\");\n    // simple, but a little bit mind bending:\n    //   same as (!(a >= b_end || b >= a_end))\n    //   same as (!(a_end <= b || b_end <= a))\n    if very_unlikely (a < b_end && b < a_end)\n        throwCantPack(\"ptr_check_no_overlap-ab\");\n}\n\n// check that 3 buffers do not overlap; will throw on error\nvoid ptraddr_check_no_overlap(upx_ptraddr_t a, size_t a_size, upx_ptraddr_t b, size_t b_size,\n                              upx_ptraddr_t c, size_t c_size) {\n    if very_unlikely (a == 0 || b == 0 || c == 0)\n        throwCantPack(\"ptr_check_no_overlap-nullptr\");\n    upx_ptraddr_t a_end = a + mem_size(1, a_size);\n    upx_ptraddr_t b_end = b + mem_size(1, b_size);\n    upx_ptraddr_t c_end = c + mem_size(1, c_size);\n    if very_unlikely (a_end < a || b_end < b || c_end < c) // wrap-around\n        throwCantPack(\"ptr_check_no_overlap-overflow\");\n    if very_unlikely (a < b_end && b < a_end)\n        throwCantPack(\"ptr_check_no_overlap-ab\");\n    if very_unlikely (a < c_end && c < a_end)\n        throwCantPack(\"ptr_check_no_overlap-ac\");\n    if very_unlikely (b < c_end && c < b_end)\n        throwCantPack(\"ptr_check_no_overlap-bc\");\n}\n\n#if !defined(DOCTEST_CONFIG_DISABLE) && !defined(__wasi__) && DEBUG\nTEST_CASE(\"ptr_check_no_overlap 2\") {\n    byte p[4] = {};\n\n    auto check_nothrow = [&p](int a, int as, int b, int bs) {\n        CHECK_NOTHROW(ptr_check_no_overlap(p + a, as, p + b, bs)); // ab\n        CHECK_NOTHROW(ptr_check_no_overlap(p + b, bs, p + a, as)); // ba\n    };\n    auto check_throws_ = [&p](int a, int as, int b, int bs) {\n        CHECK_THROWS(ptr_check_no_overlap(p + a, as, p + b, bs)); // ab\n        CHECK_THROWS(ptr_check_no_overlap(p + b, bs, p + a, as)); // ba\n    };\n\n    check_throws_(0, 1, 0, 1);\n    check_nothrow(0, 1, 1, 1);\n    check_throws_(0, 2, 1, 1);\n    check_nothrow(0, 2, 2, 1);\n    // empty buffers at edge\n    check_nothrow(0, 0, 0, 0);\n    check_nothrow(0, 0, 0, 1);\n    check_nothrow(0, 0, 1, 0);\n    // empty buffer\n    check_nothrow(0, 4, 0, 0);\n    check_throws_(0, 4, 1, 0);\n    check_throws_(0, 4, 2, 0);\n    check_throws_(0, 4, 3, 0);\n    check_nothrow(0, 4, 4, 0);\n}\n\nTEST_CASE(\"ptr_check_no_overlap 3\") {\n    byte p[4] = {};\n\n    auto check_nothrow = [&p](int a, int as, int b, int bs, int c, int cs) {\n        CHECK_NOTHROW(ptr_check_no_overlap(p + a, as, p + b, bs, p + c, cs)); // abc\n        CHECK_NOTHROW(ptr_check_no_overlap(p + a, as, p + c, cs, p + b, bs)); // acb\n        CHECK_NOTHROW(ptr_check_no_overlap(p + b, bs, p + a, as, p + c, cs)); // bac\n        CHECK_NOTHROW(ptr_check_no_overlap(p + b, bs, p + c, cs, p + a, as)); // bca\n        CHECK_NOTHROW(ptr_check_no_overlap(p + c, cs, p + a, as, p + b, bs)); // cab\n        CHECK_NOTHROW(ptr_check_no_overlap(p + c, cs, p + b, bs, p + a, as)); // cba\n    };\n    auto check_throws_ = [&p](int a, int as, int b, int bs, int c, int cs) {\n        CHECK_THROWS(ptr_check_no_overlap(p + a, as, p + b, bs, p + c, cs)); // abc\n        CHECK_THROWS(ptr_check_no_overlap(p + a, as, p + c, cs, p + b, bs)); // acb\n        CHECK_THROWS(ptr_check_no_overlap(p + b, bs, p + a, as, p + c, cs)); // bac\n        CHECK_THROWS(ptr_check_no_overlap(p + b, bs, p + c, cs, p + a, as)); // bca\n        CHECK_THROWS(ptr_check_no_overlap(p + c, cs, p + a, as, p + b, bs)); // cab\n        CHECK_THROWS(ptr_check_no_overlap(p + c, cs, p + b, bs, p + a, as)); // cba\n    };\n\n    check_throws_(0, 1, 0, 1, 1, 1);\n    check_nothrow(0, 1, 1, 1, 2, 1);\n    check_throws_(0, 2, 1, 1, 2, 1);\n    check_nothrow(0, 2, 2, 1, 3, 1);\n    // empty buffers at edge\n    check_nothrow(0, 0, 0, 0, 0, 0);\n    check_nothrow(0, 0, 0, 0, 0, 1);\n    check_nothrow(0, 0, 0, 1, 1, 1);\n    check_nothrow(0, 0, 1, 0, 1, 1);\n    // empty buffer\n    check_nothrow(0, 4, 0, 0, 0, 0);\n    check_throws_(0, 4, 1, 0, 0, 0);\n    check_throws_(0, 4, 2, 0, 0, 0);\n    check_throws_(0, 4, 3, 0, 0, 0);\n    check_nothrow(0, 4, 4, 0, 0, 0);\n    // empty buffer\n    check_throws_(0, 4, 0, 0, 1, 0);\n    check_throws_(0, 4, 1, 0, 1, 0);\n    check_throws_(0, 4, 2, 0, 1, 0);\n    check_throws_(0, 4, 3, 0, 1, 0);\n    check_throws_(0, 4, 4, 0, 1, 0);\n}\n#endif // DEBUG\n\n/*************************************************************************\n// stdlib\n**************************************************************************/\n\nconst char *upx_getenv(const char *envvar) noexcept {\n    if (envvar != nullptr && envvar[0])\n        return ::getenv(envvar);\n    return nullptr;\n}\n\n// random value from libc; quality is not important for UPX\nint upx_rand(void) noexcept {\n    return ::rand(); // NOLINT(clang-analyzer-security.insecureAPI.rand)\n}\n\nvoid upx_rand_init(void) noexcept {\n    unsigned seed = 0;\n    seed ^= UPX_VERSION_HEX;\n#if (!HAVE_GETTIMEOFDAY || (ACC_OS_DOS32 && defined(__DJGPP__))) && !defined(__wasi__)\n    seed ^= (unsigned) time(nullptr);\n    seed ^= ((unsigned) clock()) << 12;\n#else\n    struct timeval tv = {};\n    (void) gettimeofday(&tv, nullptr);\n    seed ^= (unsigned) tv.tv_sec;\n    seed ^= ((unsigned) tv.tv_usec) << 12;\n#endif\n#if HAVE_GETPID\n    seed ^= ((unsigned) getpid()) << 4;\n#endif\n    ::srand(seed);\n}\n\nvoid *upx_calloc(size_t n, size_t element_size) may_throw {\n    size_t bytes = mem_size(element_size, n); // assert size\n    void *p = ::malloc(bytes);\n    if (p != nullptr)\n        memset(p, 0, bytes);\n    return p;\n}\n\n// simple unoptimized memswap()\n// TODO later: CHERI clang-14 bug/miscompilation with upx_memswap(); or\n//   maybe caused by tagged-memory issues ???\nvoid upx_memswap(void *aa, void *bb, size_t bytes) noexcept {\n    if (aa != bb && bytes != 0) {\n        byte *a = (byte *) aa;\n        byte *b = (byte *) bb;\n        do {\n            // strange clang-analyzer-15 false positive when compiling in Debug mode\n            // clang-analyzer-core.uninitialized.Assign\n            byte tmp = *a; // NOLINT(*core.uninitialized.Assign) // bogus clang-analyzer warning\n            *a++ = *b;\n            *b++ = tmp;\n        } while (--bytes != 0);\n    }\n}\n\n// much better memswap(), optimized for our use case in sort functions below\nstatic inline void memswap_no_overlap(byte *a, byte *b, size_t bytes) noexcept {\n#if defined(__clang__) && (__clang_major__ < 15) && !defined(__CHERI__)\n    // work around a clang < 15 ICE (Internal Compiler Error)\n    // @COMPILER_BUG @CLANG_BUG\n    upx_memswap(a, b, bytes);\n#else // clang bug\n    upx_alignas_max byte tmp_buf[16];\n#define SWAP(n)                                                                                    \\\n    do {                                                                                           \\\n        upx_memcpy_inline(tmp_buf, a, n);                                                          \\\n        upx_memcpy_inline(a, b, n);                                                                \\\n        upx_memcpy_inline(b, tmp_buf, n);                                                          \\\n        a += n;                                                                                    \\\n        b += n;                                                                                    \\\n    } while (0)\n\n    for (; bytes >= 16; bytes -= 16)\n        SWAP(16);\n    if (bytes & 8)\n        SWAP(8);\n    if (bytes & 4)\n        SWAP(4);\n    if (bytes & 2)\n        SWAP(2);\n    if (bytes & 1) {\n        byte tmp = *a;\n        *a = *b;\n        *b = tmp;\n    }\n#undef SWAP\n#endif // clang bug\n}\n\n// extremely simple (and beautiful) stable sort: Gnomesort\n// WARNING: O(n^2) and thus very inefficient for large n\nvoid upx_gnomesort(void *array, size_t n, size_t element_size, upx_compare_func_t compare) {\n    for (size_t i = 1; i < n; i++) {\n        byte *a = (byte *) array + element_size * i;               // a := &array[i]\n        if (i != 0 && compare(a - element_size, a) > 0) {          // if a[-1] > a[0] then\n            memswap_no_overlap(a - element_size, a, element_size); //   swap elements a[-1] <=> a[0]\n            i -= 2;                                                //   and decrease i\n        }\n    }\n}\n\n// simple Shell sort using Knuth's gap; NOT stable; uses memswap()\n// cannot compete with modern sort algorithms, but not too bad as a generic fallback\nvoid upx_shellsort_memswap(void *array, size_t n, size_t element_size, upx_compare_func_t compare) {\n    mem_size_assert(element_size, n); // check size\n    size_t gap = 0;                   // 0, 1, 4, 13, 40, 121, 364, 1093, ...\n    while (gap * 3 + 1 < n)           // cannot overflow because of size check above\n        gap = gap * 3 + 1;\n    for (; gap > 0; gap = (gap - 1) / 3) {\n        const size_t gap_bytes = element_size * gap;\n        byte *p = (byte *) array + gap_bytes;\n        for (size_t i = gap; i < n; i += gap, p += gap_bytes) // invariant: p == &array[i]\n            for (byte *a = p; a != array && compare(a - gap_bytes, a) > 0; a -= gap_bytes)\n                memswap_no_overlap(a - gap_bytes, a, element_size);\n    }\n}\n\n// simple Shell sort using Knuth's gap; NOT stable; uses memcpy()\n// should be faster than memswap() version in theory, but benchmarks are inconsistent\nvoid upx_shellsort_memcpy(void *array, size_t n, size_t element_size, upx_compare_func_t compare) {\n    mem_size_assert(element_size, n); // check size\n    constexpr size_t MAX_INLINE_ELEMENT_SIZE = 256;\n    upx_alignas_max byte tmp_buf[MAX_INLINE_ELEMENT_SIZE]; // buffer for one element\n    byte *tmp = tmp_buf;\n    if (element_size > MAX_INLINE_ELEMENT_SIZE) {\n        tmp = (byte *) ::malloc(element_size);\n        assert(tmp != nullptr);\n    }\n    size_t gap = 0;         // 0, 1, 4, 13, 40, 121, 364, 1093, ...\n    while (gap * 3 + 1 < n) // cannot overflow because of size check above\n        gap = gap * 3 + 1;\n    for (; gap > 0; gap = (gap - 1) / 3) {\n        const size_t gap_bytes = element_size * gap;\n        byte *p = (byte *) array + gap_bytes;\n        for (size_t i = gap; i < n; i += gap, p += gap_bytes) // invariant: p == &array[i]\n            if (compare(p - gap_bytes, p) > 0) {\n                byte *a = p;\n                memcpy(tmp, a, element_size);\n                do {\n                    memcpy(a, a - gap_bytes, element_size);\n                    a -= gap_bytes;\n                } while (a != array && compare(a - gap_bytes, tmp) > 0);\n                memcpy(a, tmp, element_size);\n            }\n    }\n    if (element_size > MAX_INLINE_ELEMENT_SIZE)\n        ::free(tmp);\n}\n\n// wrap std::stable_sort()\ntemplate <size_t ElementSize>\nvoid upx_std_stable_sort(void *array, size_t n, upx_compare_func_t compare) {\n    static_assert(ElementSize >= 1 && ElementSize <= UPX_RSIZE_MAX);\n    mem_size_assert(ElementSize, n); // check size\n#if 0\n    // just for testing\n    upx_gnomesort(array, n, ElementSize, compare);\n#else\n    struct alignas(1) element_type { byte data[ElementSize]; };\n    static_assert(sizeof(element_type) == ElementSize);\n    static_assert(alignof(element_type) == 1);\n    auto less = [compare](const element_type &a, const element_type &b) -> bool {\n        return compare(&a, &b) < 0;\n    };\n    std::stable_sort((element_type *) array, (element_type *) array + n, less);\n#endif\n}\n\nTEST_CASE(\"upx_memswap\") {\n    auto check4 = [](int off1, int off2, int len, int a, int b, int c, int d) {\n        byte p[4] = {0, 1, 2, 3};\n        assert_noexcept(a + b + c + d == 0 + 1 + 2 + 3);\n        upx_memswap(p + off1, p + off2, len);\n        CHECK((p[0] == a && p[1] == b && p[2] == c && p[3] == d));\n    };\n    // identical\n    check4(0, 0, 4, 0, 1, 2, 3);\n    // non-overlapping\n    check4(0, 1, 1, 1, 0, 2, 3);\n    check4(1, 0, 1, 1, 0, 2, 3);\n    check4(0, 2, 2, 2, 3, 0, 1);\n    check4(2, 0, 2, 2, 3, 0, 1);\n    // overlapping\n    check4(0, 1, 2, 1, 2, 0, 3);\n    check4(1, 0, 2, 1, 2, 0, 3);\n    check4(0, 1, 3, 1, 2, 3, 0);\n    check4(1, 0, 3, 1, 2, 3, 0);\n\n    // pointer array\n    {\n        typedef byte element_type;\n        element_type a = 11, b = 22;\n        element_type *array[4];\n        // NOLINTNEXTLINE(bugprone-multi-level-implicit-pointer-conversion)\n        memset(array, 0xfb, sizeof(array));\n        array[1] = &a;\n        array[3] = &b;\n        CHECK(*array[1] == 11);\n        CHECK(*array[3] == 22);\n#if defined(__CHERI__) && defined(__CHERI_PURE_CAPABILITY__)\n        // TODO later: CHERI clang-14 bug/miscompilation with upx_memswap(); or\n        //   maybe caused by tagged-memory issues ???\n        // NOLINTNEXTLINE(bugprone-multi-level-implicit-pointer-conversion)\n        memswap_no_overlap((byte *) array, (byte *) (array + 2), 2 * sizeof(array[0]));\n#else\n        // NOLINTNEXTLINE(bugprone-multi-level-implicit-pointer-conversion)\n        upx_memswap(array, array + 2, 2 * sizeof(array[0]));\n#endif\n        CHECK(array[1] == &b);\n        CHECK(array[3] == &a);\n        CHECK(*array[1] == 22);\n        CHECK(*array[3] == 11);\n        // NOLINTNEXTLINE(bugprone-multi-level-implicit-pointer-conversion)\n        memswap_no_overlap((byte *) array, (byte *) (array + 2), 2 * sizeof(array[0]));\n        CHECK(array[1] == &a);\n        CHECK(array[3] == &b);\n        CHECK(*array[1] == 11);\n        CHECK(*array[3] == 22);\n    }\n}\n\n#if UPX_CONFIG_USE_STABLE_SORT\n// instantiate function templates for all element sizes we need; efficient\n// run-time, but code size bloat (about 4KiB code size for each function\n// with my current libstdc++); not really needed as libc qsort() is\n// good enough for our use cases\ntemplate void upx_std_stable_sort<1>(void *, size_t, upx_compare_func_t);\ntemplate void upx_std_stable_sort<2>(void *, size_t, upx_compare_func_t);\ntemplate void upx_std_stable_sort<4>(void *, size_t, upx_compare_func_t);\ntemplate void upx_std_stable_sort<5>(void *, size_t, upx_compare_func_t);\ntemplate void upx_std_stable_sort<8>(void *, size_t, upx_compare_func_t);\ntemplate void upx_std_stable_sort<16>(void *, size_t, upx_compare_func_t);\ntemplate void upx_std_stable_sort<32>(void *, size_t, upx_compare_func_t);\ntemplate void upx_std_stable_sort<56>(void *, size_t, upx_compare_func_t);\ntemplate void upx_std_stable_sort<72>(void *, size_t, upx_compare_func_t);\n#endif // UPX_CONFIG_USE_STABLE_SORT\n\n#if !defined(DOCTEST_CONFIG_DISABLE) && DEBUG\n#if __cplusplus >= 202002L // use C++20 std::next_permutation() to test all permutations\nnamespace {\ntemplate <class ElementType, upx_compare_func_t CompareFunc>\nstruct TestSortAllPermutations {\n    typedef ElementType element_type;\n    static noinline upx_uint64_t test(upx_sort_func_t sort, size_t n) {\n        constexpr size_t N = 16;\n        assert_noexcept(n <= N);\n        ElementType perm[N];\n        if (n == 0) {\n            sort(perm, 0, sizeof(ElementType), CompareFunc); // check that n == 0 works\n            return 0;\n        }\n        for (size_t i = 0; i < n; i++)\n            perm[i] = 255 + i;\n        upx_uint64_t num_perms = 0;\n        do {\n            ElementType a[N];\n            memcpy(a, perm, sizeof(*a) * n);\n            sort(a, n, sizeof(*a), CompareFunc);\n            for (size_t i = 0; i < n; i++)\n                assert_noexcept(a[i] == 255 + i);\n            num_perms += 1;\n        } while (std::next_permutation(perm, perm + n));\n        return num_perms;\n    }\n    static noinline bool test_permutations(upx_sort_func_t sort) {\n        bool ok = true;\n        ok &= (test(sort, 0) == 0);\n        ok &= (test(sort, 1) == 1);\n        ok &= (test(sort, 2) == 2);\n        ok &= (test(sort, 3) == 6);\n        ok &= (test(sort, 4) == 24);\n        ok &= (test(sort, 5) == 120);\n#if DEBUG >= 2\n        ok &= (test(sort, 6) == 720);\n        ok &= (test(sort, 7) == 5040);\n        ok &= (test(sort, 8) == 40320);\n        ok &= (test(sort, 9) == 362880);\n        ok &= (test(sort, 10) == 3628800);\n        // ok &= (test(sort, 11) == 39916800);\n#endif\n        return ok;\n    }\n};\n} // namespace\nTEST_CASE(\"upx_gnomesort\") {\n    // typedef TestSortAllPermutations<BE64, be64_compare> TestSort;\n    typedef TestSortAllPermutations<LE16, le16_compare> TestSort;\n    CHECK(TestSort::test_permutations(upx_gnomesort));\n}\nTEST_CASE(\"upx_shellsort_memswap\") {\n    // typedef TestSortAllPermutations<BE64, be64_compare> TestSort;\n    typedef TestSortAllPermutations<LE16, le16_compare> TestSort;\n    CHECK(TestSort::test_permutations(upx_shellsort_memswap));\n}\nTEST_CASE(\"upx_shellsort_memcpy\") {\n    // typedef TestSortAllPermutations<BE64, be64_compare> TestSort;\n    typedef TestSortAllPermutations<LE16, le16_compare> TestSort;\n    CHECK(TestSort::test_permutations(upx_shellsort_memcpy));\n}\nTEST_CASE(\"upx_std_stable_sort\") {\n    // typedef TestSortAllPermutations<BE64, be64_compare> TestSort;\n    typedef TestSortAllPermutations<LE16, le16_compare> TestSort;\n    upx_sort_func_t wrap_stable_sort = [](void *a, size_t n, size_t, upx_compare_func_t compare) {\n        upx_std_stable_sort<sizeof(TestSort::element_type)>(a, n, compare);\n    };\n    CHECK(TestSort::test_permutations(wrap_stable_sort));\n}\n#endif // C++20\n#endif // DEBUG\n\n/*************************************************************************\n// qsort() util\n**************************************************************************/\n\nint __acc_cdecl_qsort be16_compare(const void *e1, const void *e2) {\n    const unsigned d1 = get_be16(e1);\n    const unsigned d2 = get_be16(e2);\n    return (d1 < d2) ? -1 : ((d1 > d2) ? 1 : 0);\n}\n\nint __acc_cdecl_qsort be24_compare(const void *e1, const void *e2) {\n    const unsigned d1 = get_be24(e1);\n    const unsigned d2 = get_be24(e2);\n    return (d1 < d2) ? -1 : ((d1 > d2) ? 1 : 0);\n}\n\nint __acc_cdecl_qsort be32_compare(const void *e1, const void *e2) {\n    const unsigned d1 = get_be32(e1);\n    const unsigned d2 = get_be32(e2);\n    return (d1 < d2) ? -1 : ((d1 > d2) ? 1 : 0);\n}\n\nint __acc_cdecl_qsort be64_compare(const void *e1, const void *e2) {\n    const upx_uint64_t d1 = get_be64(e1);\n    const upx_uint64_t d2 = get_be64(e2);\n    return (d1 < d2) ? -1 : ((d1 > d2) ? 1 : 0);\n}\n\nint __acc_cdecl_qsort le16_compare(const void *e1, const void *e2) {\n    const unsigned d1 = get_le16(e1);\n    const unsigned d2 = get_le16(e2);\n    return (d1 < d2) ? -1 : ((d1 > d2) ? 1 : 0);\n}\n\nint __acc_cdecl_qsort le24_compare(const void *e1, const void *e2) {\n    const unsigned d1 = get_le24(e1);\n    const unsigned d2 = get_le24(e2);\n    return (d1 < d2) ? -1 : ((d1 > d2) ? 1 : 0);\n}\n\nint __acc_cdecl_qsort le32_compare(const void *e1, const void *e2) {\n    const unsigned d1 = get_le32(e1);\n    const unsigned d2 = get_le32(e2);\n    return (d1 < d2) ? -1 : ((d1 > d2) ? 1 : 0);\n}\n\nint __acc_cdecl_qsort le64_compare(const void *e1, const void *e2) {\n    const upx_uint64_t d1 = get_le64(e1);\n    const upx_uint64_t d2 = get_le64(e2);\n    return (d1 < d2) ? -1 : ((d1 > d2) ? 1 : 0);\n}\n\nint __acc_cdecl_qsort be16_compare_signed(const void *e1, const void *e2) {\n    const int d1 = get_be16_signed(e1);\n    const int d2 = get_be16_signed(e2);\n    return (d1 < d2) ? -1 : ((d1 > d2) ? 1 : 0);\n}\n\nint __acc_cdecl_qsort be24_compare_signed(const void *e1, const void *e2) {\n    const int d1 = get_be24_signed(e1);\n    const int d2 = get_be24_signed(e2);\n    return (d1 < d2) ? -1 : ((d1 > d2) ? 1 : 0);\n}\n\nint __acc_cdecl_qsort be32_compare_signed(const void *e1, const void *e2) {\n    const int d1 = get_be32_signed(e1);\n    const int d2 = get_be32_signed(e2);\n    return (d1 < d2) ? -1 : ((d1 > d2) ? 1 : 0);\n}\n\nint __acc_cdecl_qsort be64_compare_signed(const void *e1, const void *e2) {\n    const upx_int64_t d1 = get_be64_signed(e1);\n    const upx_int64_t d2 = get_be64_signed(e2);\n    return (d1 < d2) ? -1 : ((d1 > d2) ? 1 : 0);\n}\n\nint __acc_cdecl_qsort le16_compare_signed(const void *e1, const void *e2) {\n    const int d1 = get_le16_signed(e1);\n    const int d2 = get_le16_signed(e2);\n    return (d1 < d2) ? -1 : ((d1 > d2) ? 1 : 0);\n}\n\nint __acc_cdecl_qsort le24_compare_signed(const void *e1, const void *e2) {\n    const int d1 = get_le24_signed(e1);\n    const int d2 = get_le24_signed(e2);\n    return (d1 < d2) ? -1 : ((d1 > d2) ? 1 : 0);\n}\n\nint __acc_cdecl_qsort le32_compare_signed(const void *e1, const void *e2) {\n    const int d1 = get_le32_signed(e1);\n    const int d2 = get_le32_signed(e2);\n    return (d1 < d2) ? -1 : ((d1 > d2) ? 1 : 0);\n}\n\nint __acc_cdecl_qsort le64_compare_signed(const void *e1, const void *e2) {\n    const upx_int64_t d1 = get_le64_signed(e1);\n    const upx_int64_t d2 = get_le64_signed(e2);\n    return (d1 < d2) ? -1 : ((d1 > d2) ? 1 : 0);\n}\n\n/*************************************************************************\n// find and mem_replace util\n**************************************************************************/\n\nint find(const void *buf, int blen, const void *what, int wlen) noexcept {\n    // nullptr is explicitly allowed here\n    if (buf == nullptr || blen < wlen || what == nullptr || wlen <= 0)\n        return -1;\n\n    const byte *b = (const byte *) buf;\n    const byte first_byte = *(const byte *) what;\n\n    blen -= wlen;\n    for (int i = 0; i <= blen; i++, b++)\n        if (*b == first_byte && memcmp(b, what, wlen) == 0)\n            return i;\n\n    return -1;\n}\n\nint find_be16(const void *b, int blen, unsigned what) noexcept {\n    byte w[2];\n    set_be16(w, what);\n    return find(b, blen, w, 2);\n}\n\nint find_be32(const void *b, int blen, unsigned what) noexcept {\n    byte w[4];\n    set_be32(w, what);\n    return find(b, blen, w, 4);\n}\n\nint find_be64(const void *b, int blen, upx_uint64_t what) noexcept {\n    byte w[8];\n    set_be64(w, what);\n    return find(b, blen, w, 8);\n}\n\nint find_le16(const void *b, int blen, unsigned what) noexcept {\n    byte w[2];\n    set_le16(w, what);\n    return find(b, blen, w, 2);\n}\n\nint find_le32(const void *b, int blen, unsigned what) noexcept {\n    byte w[4];\n    set_le32(w, what);\n    return find(b, blen, w, 4);\n}\n\nint find_le64(const void *b, int blen, upx_uint64_t what) noexcept {\n    byte w[8];\n    set_le64(w, what);\n    return find(b, blen, w, 8);\n}\n\nTEST_CASE(\"find\") {\n    CHECK(find(nullptr, -1, nullptr, -1) == -1);\n    static const byte b[16] = {0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15};\n    CHECK(find(b, 16, b, 0) == -1);\n    for (int i = 0; i < 16; i++) {\n        CHECK(find(b, 16, b + i, 1) == i);\n    }\n    for (int i = 1; i <= 16; i++) {\n        CHECK(find(b, 16, b, i) == 0);\n    }\n    CHECK(find(b, 16, b, 17) == -1);\n    CHECK(find_be16(b, 16, 0x0203) == 2);\n    CHECK(find_le16(b, 16, 0x0302) == 2);\n    CHECK(find_be32(b, 16, 0x04050607) == 4);\n    CHECK(find_le32(b, 16, 0x07060504) == 4);\n    CHECK(find_be64(b, 16, 0x08090a0b0c0d0e0fULL) == 8);\n    CHECK(find_le64(b, 16, 0x0f0e0d0c0b0a0908ULL) == 8);\n    CHECK(find_be64(b, 15, 0x08090a0b0c0d0e0fULL) == -1);\n    CHECK(find_le64(b, 15, 0x0f0e0d0c0b0a0908ULL) == -1);\n    UNUSED(b);\n}\n\nint mem_replace(void *buf, int blen, const void *what, int wlen, const void *replacement) noexcept {\n    byte *const b = (byte *) buf;\n    int boff = 0;\n    int count = 0;\n\n    while (blen - boff >= wlen) {\n        int off = find(b + boff, blen - boff, what, wlen);\n        if (off < 0)\n            break;\n        boff += off;\n        memcpy(b + boff, replacement, wlen);\n        boff += wlen;\n        count++;\n    }\n    return count;\n}\n\nTEST_CASE(\"mem_replace\") {\n    char b[16 + 1] = \"aaaaaaaaaaaaaaaa\";\n    CHECK(mem_replace(b, 16, \"a\", 0, \"x\") == 0);\n    CHECK(mem_replace(b, 16, \"a\", 1, \"b\") == 16);\n    CHECK(mem_replace(b, 8, \"bb\", 2, \"cd\") == 4);\n    CHECK(mem_replace(b + 8, 8, \"bbb\", 3, \"efg\") == 2);\n    CHECK(mem_replace(b, 16, \"b\", 1, \"h\") == 2);\n    CHECK(strcmp(b, \"cdcdcdcdefgefghh\") == 0);\n    UNUSED(b);\n}\n\n/*************************************************************************\n// bele.h globals\n**************************************************************************/\n\nnamespace N_BELE_CTP {\nconst BEPolicy be_policy;\nconst LEPolicy le_policy;\n} // namespace N_BELE_CTP\n\nnamespace N_BELE_RTP {\nconst BEPolicy be_policy;\nconst LEPolicy le_policy;\n} // namespace N_BELE_RTP\n\n/*************************************************************************\n// fn - FileName util\n**************************************************************************/\n\n#if (ACC_OS_CYGWIN || ACC_OS_DOS16 || ACC_OS_DOS32 || ACC_OS_EMX || ACC_OS_OS2 || ACC_OS_OS16 ||   \\\n     ACC_OS_TOS || ACC_OS_WIN16 || ACC_OS_WIN32 || ACC_OS_WIN64)\n\nstatic const char dir_sep[] = \"/\\\\\";\n#define fn_is_drive(s)   (s[0] && s[1] == ':')\n#define fn_is_sep(c)     (strchr(dir_sep, c) != nullptr)\n#define fn_skip_drive(s) (fn_is_drive(s) ? (s) + 2 : (s))\n#define fn_tolower(c)    (tolower(((uchar) (c))))\n\n#else\n\n// static const char dir_sep[] = \"/\";\n#define fn_is_drive(s)   (0)\n#define fn_is_sep(c)     ((c) == '/')\n#define fn_skip_drive(s) (s)\n#define fn_tolower(c)    (c)\n\n#endif\n\nchar *fn_basename(const char *name) {\n    const char *n, *nn;\n\n    name = fn_skip_drive(name);\n    for (nn = n = name; *nn; nn++)\n        if (fn_is_sep(*nn))\n            n = nn + 1;\n    return ACC_UNCONST_CAST(char *, n);\n}\n\nbool fn_has_ext(const char *name, const char *ext, bool ignore_case) {\n    const char *n, *e;\n\n    name = fn_basename(name);\n    for (n = e = name; *n; n++)\n        if (*n == '.')\n            e = n;\n    if (ignore_case)\n        return (strcasecmp(ext, e + 1) == 0);\n    else\n        return (fn_strcmp(ext, e + 1) == 0);\n}\n\nchar *fn_strlwr(char *n) {\n    char *p;\n    for (p = n; *p; p++)\n        *p = (char) fn_tolower(*p);\n    return n;\n}\n\nint fn_strcmp(const char *n1, const char *n2) {\n    for (;;) {\n        if (*n1 != *n2) {\n            int c = fn_tolower(*n1) - fn_tolower(*n2);\n            if (c)\n                return c;\n        }\n        if (*n1 == 0)\n            return 0;\n        n1++;\n        n2++;\n    }\n}\n\n/*************************************************************************\n// misc\n**************************************************************************/\n\n// UPX convention: any environment variable that is set and is not strictly equal to \"0\" is true\nbool is_envvar_true(const char *envvar, const char *alternate_name) noexcept {\n    const char *e = upx_getenv(envvar);\n    if (e != nullptr && e[0])\n        return strcmp(e, \"0\") != 0;\n    if (alternate_name != nullptr) {\n        e = upx_getenv(alternate_name);\n        if (e != nullptr && e[0])\n            return strcmp(e, \"0\") != 0;\n    }\n    return false;\n}\n\nbool set_method_name(char *buf, size_t size, int method, int level) {\n    bool r = true;\n    const char *alg;\n    if (M_IS_NRV2B(method))\n        alg = \"NRV2B\";\n    else if (M_IS_NRV2D(method))\n        alg = \"NRV2D\";\n    else if (M_IS_NRV2E(method))\n        alg = \"NRV2E\";\n    else if (M_IS_LZMA(method))\n        alg = \"LZMA\";\n    else {\n        alg = \"???\";\n        r = false;\n    }\n    if (level > 0)\n        upx_safe_snprintf(buf, size, \"%s/%d\", alg, level);\n    else\n        upx_safe_snprintf(buf, size, \"%s\", alg);\n    return r;\n}\n\nvoid center_string(char *buf, size_t size, const char *s) {\n    size_t l1 = size - 1;\n    size_t l2 = strlen(s);\n    assert(size > 0);\n    assert(l2 < size);\n    memset(buf, ' ', l1);\n    memcpy(buf + (l1 - l2) / 2, s, l2);\n    buf[l1] = 0;\n}\n\nbool file_exists(const char *name) {\n    int fd, r;\n    struct stat st;\n\n    /* return true if we can open it */\n    fd = open(name, O_RDONLY | O_BINARY, 0);\n    if (fd >= 0) {\n        (void) close(fd);\n        return true;\n    }\n\n    /* return true if we can stat it */\n    // mem_clear(&st);\n    r = stat(name, &st);\n    if (r != -1)\n        return true;\n\n/* return true if we can lstat it */\n#if HAVE_LSTAT\n    // mem_clear(&st);\n    r = lstat(name, &st);\n    if (r != -1)\n        return true;\n#endif\n\n    return false;\n}\n\nbool maketempname(char *ofilename, size_t size, const char *ifilename, const char *ext,\n                  bool force) {\n    char *ofext = nullptr, *ofname;\n    int ofile;\n\n    if (size <= 0)\n        return false;\n\n    strcpy(ofilename, ifilename);\n    for (ofname = fn_basename(ofilename); *ofname; ofname++) {\n        if (*ofname == '.')\n            ofext = ofname;\n    }\n    if (ofext == nullptr)\n        ofext = ofilename + strlen(ofilename);\n    strcpy(ofext, ext);\n\n    for (ofile = 0; ofile < 1000; ofile++) {\n        assert(strlen(ofilename) < size);\n        if (!file_exists(ofilename))\n            return true;\n        if (!force)\n            break;\n        upx_safe_snprintf(ofext, 5, \".%03d\", ofile);\n    }\n\n    ofilename[0] = 0;\n    return false;\n}\n\nbool makebakname(char *ofilename, size_t size, const char *ifilename, bool force) {\n    char *ofext = nullptr, *ofname;\n    int ofile;\n\n    if (size <= 0)\n        return false;\n\n    strcpy(ofilename, ifilename);\n    for (ofname = fn_basename(ofilename); *ofname; ofname++) {\n        if (*ofname == '.')\n            ofext = ofname;\n    }\n    if (ofext == nullptr) {\n        ofext = ofilename + strlen(ofilename);\n        strcpy(ofext, \".~\");\n    } else if (strlen(ofext) < 1 + 3)\n        strcat(ofilename, \"~\");\n    else\n        ofext[strlen(ofext) - 1] = '~';\n\n    for (ofile = 0; ofile < 1000; ofile++) {\n        assert(strlen(ofilename) < size);\n        if (!file_exists(ofilename))\n            return true;\n        if (!force)\n            break;\n        upx_safe_snprintf(ofext, 5, \".%03d\", ofile);\n    }\n\n    ofilename[0] = 0;\n    return false;\n}\n\n/*************************************************************************\n// return compression ratio, where 100% == 1000*1000 == 1e6\n**************************************************************************/\n\nunsigned get_ratio(upx_uint64_t u_len, upx_uint64_t c_len) {\n    constexpr unsigned N = 1000 * 1000;\n    if (u_len == 0)\n        return c_len == 0 ? 0 : N;\n    upx_uint64_t x = c_len * N;\n    assert(x / N == c_len); // sanity check\n    x /= u_len;\n    x += 50;         // rounding; cannot overflow\n    if (x >= 10 * N) // >= \"1000%\"\n        x = 10 * N - 1;\n    return ACC_ICONV(unsigned, x);\n}\n\nTEST_CASE(\"get_ratio\") {\n    CHECK(get_ratio(0, 0) == 0);\n    CHECK(get_ratio(0, 1) == 1000000);\n    CHECK(get_ratio(1, 0) == 50);\n    CHECK(get_ratio(1, 1) == 1000050);\n    CHECK(get_ratio(1, 9) == 9000050);\n    CHECK(get_ratio(1, 10) == 9999999);\n    CHECK(get_ratio(1, 11) == 9999999);\n    CHECK(get_ratio(100000, 100000) == 1000050);\n    CHECK(get_ratio(100000, 200000) == 2000050);\n    CHECK(get_ratio(UPX_RSIZE_MAX, UPX_RSIZE_MAX) == 1000050);\n    CHECK(get_ratio(2 * UPX_RSIZE_MAX, 2 * UPX_RSIZE_MAX) == 1000050);\n    CHECK(get_ratio(2 * UPX_RSIZE_MAX, 1024ull * UPX_RSIZE_MAX) == 9999999);\n}\n\n/*************************************************************************\n// compat\n**************************************************************************/\n\n#if defined(__wasi__) && 0 // TODO later: wait for wasm/wasi exception handling proposal\nextern \"C\" {\nvoid *__cxa_allocate_exception(std::size_t thrown_size) throw() { return ::malloc(thrown_size); }\nvoid __cxa_throw(void *thrown_exception, /*std::type_info*/ void *tinfo, void (*dest)(void *)) {\n    UNUSED(thrown_exception);\n    UNUSED(tinfo);\n    UNUSED(dest);\n    std::terminate();\n}\n} // extern \"C\"\n#endif\n\n/* vim:set ts=4 sw=4 et: */\n","size_bytes":37273},"src/util/xspan.cpp":{"content":"/* xspan -- a minimally invasive checked memory smart pointer\n\n   This file is part of the Resize executable compressor.\n\n   Copyright (C) 2025 WHO-AM-I-404\n   Based on UPX - Ultimate Packer for eXecutables\n   Copyright (C) 1996-2025 Markus Franz Xaver Johannes Oberhumer\n   All Rights Reserved.\n\n   Resize and the UCL library are free software; you can redistribute them\n   and/or modify them under the terms of the GNU General Public License as\n   published by the Free Software Foundation; either version 2 of\n   the License, or (at your option) any later version.\n\n   This program is distributed in the hope that it will be useful,\n   but WITHOUT ANY WARRANTY; without even the implied warranty of\n   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n   GNU General Public License for more details.\n\n   You should have received a copy of the GNU General Public License\n   along with this program; see the file COPYING.\n   If not, write to the Free Software Foundation, Inc.,\n   59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.\n\n   Markus F.X.J. Oberhumer\n   <markus@oberhumer.com>\n */\n\n#include \"../conf.h\"\n\n#if WITH_XSPAN\n\nXSPAN_NAMESPACE_BEGIN\n\n// debugging stats\nstruct XSpanStats {\n    upx_std_atomic(size_t) check_range_counter;\n    // these usually will be zero, but internal doctest checks will populate them; see dt_xspan.cpp\n    upx_std_atomic(size_t) fail_nullptr;\n    upx_std_atomic(size_t) fail_nullbase;\n    upx_std_atomic(size_t) fail_not_same_base;\n    upx_std_atomic(size_t) fail_range_nullptr;\n    upx_std_atomic(size_t) fail_range_nullbase;\n    upx_std_atomic(size_t) fail_range_range;\n};\nstatic XSpanStats xspan_stats;\n\n// HINT: set env-var \"UPX_DEBUG_DOCTEST_DISABLE=1\" for improved debugging experience\nvoid xspan_fail_nullptr() {\n    xspan_stats.fail_nullptr += 1;\n    throwCantPack(\"xspan unexpected NULL pointer; take care!\");\n}\nvoid xspan_fail_nullbase() {\n    xspan_stats.fail_nullbase += 1;\n    throwCantPack(\"xspan unexpected NULL base; take care!\");\n}\nvoid xspan_fail_not_same_base() {\n    xspan_stats.fail_not_same_base += 1;\n    throwCantPack(\"xspan unexpected base pointer; take care!\");\n}\n\nvoid xspan_fail_range_nullptr() {\n    xspan_stats.fail_range_nullptr += 1;\n    throwCantPack(\"xspan_check_range: unexpected NULL pointer; take care!\");\n}\nvoid xspan_fail_range_nullbase() {\n    xspan_stats.fail_range_nullbase += 1;\n    throwCantPack(\"xspan_check_range: unexpected NULL base; take care!\");\n}\nvoid xspan_fail_range_range() {\n    xspan_stats.fail_range_range += 1;\n    throwCantPack(\"xspan_check_range: pointer out of range; take care!\");\n}\n\nvoid xspan_check_range(const void *ptr, const void *base, ptrdiff_t size_in_bytes) {\n    xspan_stats.check_range_counter += 1;\n    if very_unlikely (ptr == nullptr)\n        xspan_fail_range_nullptr();\n    if very_unlikely (base == nullptr)\n        xspan_fail_range_nullbase();\n    upx_sptraddr_t off = ptraddr_diff(ptr, base);\n    if very_unlikely (off < 0 || off > size_in_bytes || size_in_bytes > UPX_RSIZE_MAX)\n        xspan_fail_range_range();\n    NO_fprintf(stderr, \"xspan_check_range done\\n\");\n}\n\nXSPAN_NAMESPACE_END\n\n#endif // WITH_XSPAN\n\n/* vim:set ts=4 sw=4 et: */\n","size_bytes":3176},"misc/analyze/clang-tidy/run-clang-tidy.py":{"content":"#!/usr/bin/env python3\n#\n# ===- run-clang-tidy.py - Parallel clang-tidy runner --------*- python -*--===#\n#\n# Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.\n# See https://llvm.org/LICENSE.txt for license information.\n# SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception\n#\n# ===-----------------------------------------------------------------------===#\n# FIXME: Integrate with clang-tidy-diff.py\n\n\n\"\"\"\nParallel clang-tidy runner\n==========================\n\nRuns clang-tidy over all files in a compilation database. Requires clang-tidy\nand clang-apply-replacements in $PATH.\n\nExample invocations.\n- Run clang-tidy on all files in the current working directory with a default\n  set of checks and show warnings in the cpp files and all project headers.\n    run-clang-tidy.py $PWD\n\n- Fix all header guards.\n    run-clang-tidy.py -fix -checks=-*,llvm-header-guard\n\n- Fix all header guards included from clang-tidy and header guards\n  for clang-tidy headers.\n    run-clang-tidy.py -fix -checks=-*,llvm-header-guard extra/clang-tidy \\\n                      -header-filter=extra/clang-tidy\n\nCompilation database setup:\nhttp://clang.llvm.org/docs/HowToSetupToolingForLLVM.html\n\"\"\"\n\nfrom __future__ import print_function\n\nimport argparse\nimport glob\nimport json\nimport multiprocessing\nimport os\nimport queue\nimport re\nimport shutil\nimport subprocess\nimport sys\nimport tempfile\nimport threading\nimport traceback\n\ntry:\n    import yaml\nexcept ImportError:\n    yaml = None\n\n\ndef strtobool(val):\n    \"\"\"Convert a string representation of truth to a bool following LLVM's CLI argument parsing.\"\"\"\n\n    val = val.lower()\n    if val in [\"\", \"true\", \"1\"]:\n        return True\n    elif val in [\"false\", \"0\"]:\n        return False\n\n    # Return ArgumentTypeError so that argparse does not substitute its own error message\n    raise argparse.ArgumentTypeError(\n        \"'{}' is invalid value for boolean argument! Try 0 or 1.\".format(val)\n    )\n\n\ndef find_compilation_database(path):\n    \"\"\"Adjusts the directory until a compilation database is found.\"\"\"\n    result = os.path.realpath(\"./\")\n    while not os.path.isfile(os.path.join(result, path)):\n        parent = os.path.dirname(result)\n        if result == parent:\n            print(\"Error: could not find compilation database.\")\n            sys.exit(1)\n        result = parent\n    return result\n\n\ndef make_absolute(f, directory):\n    if os.path.isabs(f):\n        return f\n    return os.path.normpath(os.path.join(directory, f))\n\n\ndef get_tidy_invocation(\n    f,\n    clang_tidy_binary,\n    checks,\n    tmpdir,\n    build_path,\n    header_filter,\n    allow_enabling_alpha_checkers,\n    extra_arg,\n    extra_arg_before,\n    quiet,\n    config_file_path,\n    config,\n    line_filter,\n    use_color,\n    plugins,\n    warnings_as_errors,\n):\n    \"\"\"Gets a command line for clang-tidy.\"\"\"\n    start = [clang_tidy_binary]\n    if allow_enabling_alpha_checkers:\n        start.append(\"-allow-enabling-analyzer-alpha-checkers\")\n    if header_filter is not None:\n        start.append(\"-header-filter=\" + header_filter)\n    if line_filter is not None:\n        start.append(\"-line-filter=\" + line_filter)\n    if use_color is not None:\n        if use_color:\n            start.append(\"--use-color\")\n        else:\n            start.append(\"--use-color=false\")\n    if checks:\n        start.append(\"-checks=\" + checks)\n    if tmpdir is not None:\n        start.append(\"-export-fixes\")\n        # Get a temporary file. We immediately close the handle so clang-tidy can\n        # overwrite it.\n        (handle, name) = tempfile.mkstemp(suffix=\".yaml\", dir=tmpdir)\n        os.close(handle)\n        start.append(name)\n    for arg in extra_arg:\n        start.append(\"-extra-arg=%s\" % arg)\n    for arg in extra_arg_before:\n        start.append(\"-extra-arg-before=%s\" % arg)\n    start.append(\"-p=\" + build_path)\n    if quiet:\n        start.append(\"-quiet\")\n    if config_file_path:\n        start.append(\"--config-file=\" + config_file_path)\n    elif config:\n        start.append(\"-config=\" + config)\n    for plugin in plugins:\n        start.append(\"-load=\" + plugin)\n    if warnings_as_errors:\n        start.append(\"--warnings-as-errors=\" + warnings_as_errors)\n    start.append(f)\n    return start\n\n\ndef merge_replacement_files(tmpdir, mergefile):\n    \"\"\"Merge all replacement files in a directory into a single file\"\"\"\n    # The fixes suggested by clang-tidy >= 4.0.0 are given under\n    # the top level key 'Diagnostics' in the output yaml files\n    mergekey = \"Diagnostics\"\n    merged = []\n    for replacefile in glob.iglob(os.path.join(tmpdir, \"*.yaml\")):\n        content = yaml.safe_load(open(replacefile, \"r\"))\n        if not content:\n            continue  # Skip empty files.\n        merged.extend(content.get(mergekey, []))\n\n    if merged:\n        # MainSourceFile: The key is required by the definition inside\n        # include/clang/Tooling/ReplacementsYaml.h, but the value\n        # is actually never used inside clang-apply-replacements,\n        # so we set it to '' here.\n        output = {\"MainSourceFile\": \"\", mergekey: merged}\n        with open(mergefile, \"w\") as out:\n            yaml.safe_dump(output, out)\n    else:\n        # Empty the file:\n        open(mergefile, \"w\").close()\n\n\ndef find_binary(arg, name, build_path):\n    \"\"\"Get the path for a binary or exit\"\"\"\n    if arg:\n        if shutil.which(arg):\n            return arg\n        else:\n            raise SystemExit(\n                \"error: passed binary '{}' was not found or is not executable\".format(\n                    arg\n                )\n            )\n\n    built_path = os.path.join(build_path, \"bin\", name)\n    binary = shutil.which(name) or shutil.which(built_path)\n    if binary:\n        return binary\n    else:\n        raise SystemExit(\n            \"error: failed to find {} in $PATH or at {}\".format(name, built_path)\n        )\n\n\ndef apply_fixes(args, clang_apply_replacements_binary, tmpdir):\n    \"\"\"Calls clang-apply-fixes on a given directory.\"\"\"\n    invocation = [clang_apply_replacements_binary]\n    invocation.append(\"-ignore-insert-conflict\")\n    if args.format:\n        invocation.append(\"-format\")\n    if args.style:\n        invocation.append(\"-style=\" + args.style)\n    invocation.append(tmpdir)\n    subprocess.call(invocation)\n\n\ndef run_tidy(args, clang_tidy_binary, tmpdir, build_path, queue, lock, failed_files):\n    \"\"\"Takes filenames out of queue and runs clang-tidy on them.\"\"\"\n    while True:\n        name = queue.get()\n        invocation = get_tidy_invocation(\n            name,\n            clang_tidy_binary,\n            args.checks,\n            tmpdir,\n            build_path,\n            args.header_filter,\n            args.allow_enabling_alpha_checkers,\n            args.extra_arg,\n            args.extra_arg_before,\n            args.quiet,\n            args.config_file,\n            args.config,\n            args.line_filter,\n            args.use_color,\n            args.plugins,\n            args.warnings_as_errors,\n        )\n\n        proc = subprocess.Popen(\n            invocation, stdout=subprocess.PIPE, stderr=subprocess.PIPE\n        )\n        output, err = proc.communicate()\n        if proc.returncode != 0:\n            if proc.returncode < 0:\n                msg = \"%s: terminated by signal %d\\n\" % (name, -proc.returncode)\n                err += msg.encode(\"utf-8\")\n            failed_files.append(name)\n        with lock:\n            sys.stdout.write(\" \".join(invocation) + \"\\n\" + output.decode(\"utf-8\"))\n            if len(err) > 0:\n                sys.stdout.flush()\n                sys.stderr.write(err.decode(\"utf-8\"))\n        queue.task_done()\n\n\ndef main():\n    parser = argparse.ArgumentParser(\n        description=\"Runs clang-tidy over all files \"\n        \"in a compilation database. Requires \"\n        \"clang-tidy and clang-apply-replacements in \"\n        \"$PATH or in your build directory.\"\n    )\n    parser.add_argument(\n        \"-allow-enabling-alpha-checkers\",\n        action=\"store_true\",\n        help=\"allow alpha checkers from clang-analyzer.\",\n    )\n    parser.add_argument(\n        \"-clang-tidy-binary\", metavar=\"PATH\", help=\"path to clang-tidy binary\"\n    )\n    parser.add_argument(\n        \"-clang-apply-replacements-binary\",\n        metavar=\"PATH\",\n        help=\"path to clang-apply-replacements binary\",\n    )\n    parser.add_argument(\n        \"-checks\",\n        default=None,\n        help=\"checks filter, when not specified, use clang-tidy default\",\n    )\n    config_group = parser.add_mutually_exclusive_group()\n    config_group.add_argument(\n        \"-config\",\n        default=None,\n        help=\"Specifies a configuration in YAML/JSON format: \"\n        \"  -config=\\\"{Checks: '*', \"\n        '                       CheckOptions: {x: y}}\" '\n        \"When the value is empty, clang-tidy will \"\n        \"attempt to find a file named .clang-tidy for \"\n        \"each source file in its parent directories.\",\n    )\n    config_group.add_argument(\n        \"-config-file\",\n        default=None,\n        help=\"Specify the path of .clang-tidy or custom config \"\n        \"file: e.g. -config-file=/some/path/myTidyConfigFile. \"\n        \"This option internally works exactly the same way as \"\n        \"-config option after reading specified config file. \"\n        \"Use either -config-file or -config, not both.\",\n    )\n    parser.add_argument(\n        \"-header-filter\",\n        default=None,\n        help=\"regular expression matching the names of the \"\n        \"headers to output diagnostics from. Diagnostics from \"\n        \"the main file of each translation unit are always \"\n        \"displayed.\",\n    )\n    parser.add_argument(\n        \"-line-filter\",\n        default=None,\n        help=\"List of files with line ranges to filter the warnings.\",\n    )\n    if yaml:\n        parser.add_argument(\n            \"-export-fixes\",\n            metavar=\"file_or_directory\",\n            dest=\"export_fixes\",\n            help=\"A directory or a yaml file to store suggested fixes in, \"\n            \"which can be applied with clang-apply-replacements. If the \"\n            \"parameter is a directory, the fixes of each compilation unit are \"\n            \"stored in individual yaml files in the directory.\",\n        )\n    else:\n        parser.add_argument(\n            \"-export-fixes\",\n            metavar=\"directory\",\n            dest=\"export_fixes\",\n            help=\"A directory to store suggested fixes in, which can be applied \"\n            \"with clang-apply-replacements. The fixes of each compilation unit are \"\n            \"stored in individual yaml files in the directory.\",\n        )\n    parser.add_argument(\n        \"-j\",\n        type=int,\n        default=0,\n        help=\"number of tidy instances to be run in parallel.\",\n    )\n    parser.add_argument(\n        \"files\", nargs=\"*\", default=[\".*\"], help=\"files to be processed (regex on path)\"\n    )\n    parser.add_argument(\"-fix\", action=\"store_true\", help=\"apply fix-its\")\n    parser.add_argument(\n        \"-format\", action=\"store_true\", help=\"Reformat code after applying fixes\"\n    )\n    parser.add_argument(\n        \"-style\",\n        default=\"file\",\n        help=\"The style of reformat code after applying fixes\",\n    )\n    parser.add_argument(\n        \"-use-color\",\n        type=strtobool,\n        nargs=\"?\",\n        const=True,\n        help=\"Use colors in diagnostics, overriding clang-tidy's\"\n        \" default behavior. This option overrides the 'UseColor\"\n        \"' option in .clang-tidy file, if any.\",\n    )\n    parser.add_argument(\n        \"-p\", dest=\"build_path\", help=\"Path used to read a compile command database.\"\n    )\n    parser.add_argument(\n        \"-extra-arg\",\n        dest=\"extra_arg\",\n        action=\"append\",\n        default=[],\n        help=\"Additional argument to append to the compiler command line.\",\n    )\n    parser.add_argument(\n        \"-extra-arg-before\",\n        dest=\"extra_arg_before\",\n        action=\"append\",\n        default=[],\n        help=\"Additional argument to prepend to the compiler command line.\",\n    )\n    parser.add_argument(\n        \"-quiet\", action=\"store_true\", help=\"Run clang-tidy in quiet mode\"\n    )\n    parser.add_argument(\n        \"-load\",\n        dest=\"plugins\",\n        action=\"append\",\n        default=[],\n        help=\"Load the specified plugin in clang-tidy.\",\n    )\n    parser.add_argument(\n        \"-warnings-as-errors\",\n        default=None,\n        help=\"Upgrades warnings to errors. Same format as '-checks'\",\n    )\n    args = parser.parse_args()\n\n    db_path = \"compile_commands.json\"\n\n    if args.build_path is not None:\n        build_path = args.build_path\n    else:\n        # Find our database\n        build_path = find_compilation_database(db_path)\n\n    clang_tidy_binary = find_binary(args.clang_tidy_binary, \"clang-tidy\", build_path)\n\n    if args.fix:\n        clang_apply_replacements_binary = find_binary(\n            args.clang_apply_replacements_binary, \"clang-apply-replacements\", build_path\n        )\n\n    combine_fixes = False\n    export_fixes_dir = None\n    delete_fixes_dir = False\n    if args.export_fixes is not None:\n        # if a directory is given, create it if it does not exist\n        if args.export_fixes.endswith(os.path.sep) and not os.path.isdir(\n            args.export_fixes\n        ):\n            os.makedirs(args.export_fixes)\n\n        if not os.path.isdir(args.export_fixes):\n            if not yaml:\n                raise RuntimeError(\n                    \"Cannot combine fixes in one yaml file. Either install PyYAML or specify an output directory.\"\n                )\n\n            combine_fixes = True\n\n        if os.path.isdir(args.export_fixes):\n            export_fixes_dir = args.export_fixes\n\n    if export_fixes_dir is None and (args.fix or combine_fixes):\n        export_fixes_dir = tempfile.mkdtemp()\n        delete_fixes_dir = True\n\n    # Load the database and extract all files.\n    database = json.load(open(os.path.join(build_path, db_path)))\n    files = set(\n        [make_absolute(entry[\"file\"], entry[\"directory\"]) for entry in database]\n    )\n\n    # Build up a big regexy filter from all command line arguments.\n    file_name_re = re.compile(\"|\".join(args.files))\n\n    # filter files with mo.group(0), and sort files\n    matched_files = []\n    for name in files:\n        mo = file_name_re.search(name)\n        if mo and mo.group(0):\n            matched_files.append(name)\n    files = sorted(matched_files)\n    if not files:\n        if delete_fixes_dir:\n            shutil.rmtree(export_fixes_dir)\n        sys.exit(0)\n\n    try:\n        invocation = get_tidy_invocation(\n            \"\",\n            clang_tidy_binary,\n            args.checks,\n            None,\n            build_path,\n            args.header_filter,\n            args.allow_enabling_alpha_checkers,\n            args.extra_arg,\n            args.extra_arg_before,\n            args.quiet,\n            args.config_file,\n            args.config,\n            args.line_filter,\n            args.use_color,\n            args.plugins,\n            args.warnings_as_errors,\n        )\n        invocation.append(\"-list-checks\")\n        invocation.append(\"-\")\n        if args.quiet:\n            # Even with -quiet we still want to check if we can call clang-tidy.\n            with open(os.devnull, \"w\") as dev_null:\n                subprocess.check_call(invocation, stdout=dev_null)\n        else:\n            subprocess.check_call(invocation)\n    except:\n        print(\"Unable to run clang-tidy.\", file=sys.stderr)\n        sys.exit(1)\n\n    max_task = args.j\n    if max_task == 0:\n        max_task = multiprocessing.cpu_count()\n\n    return_code = 0\n    try:\n        # Spin up a bunch of tidy-launching threads.\n        task_queue = queue.Queue(max_task)\n        # List of files with a non-zero return code.\n        failed_files = []\n        lock = threading.Lock()\n        for _ in range(max_task):\n            t = threading.Thread(\n                target=run_tidy,\n                args=(\n                    args,\n                    clang_tidy_binary,\n                    export_fixes_dir,\n                    build_path,\n                    task_queue,\n                    lock,\n                    failed_files,\n                ),\n            )\n            t.daemon = True\n            t.start()\n\n        # Fill the queue with files.\n        for name in files:\n            if file_name_re.search(name):\n                task_queue.put(name)\n\n        # Wait for all threads to be done.\n        task_queue.join()\n        if len(failed_files):\n            return_code = 1\n\n    except KeyboardInterrupt:\n        # This is a sad hack. Unfortunately subprocess goes\n        # bonkers with ctrl-c and we start forking merrily.\n        print(\"\\nCtrl-C detected, goodbye.\")\n        if delete_fixes_dir:\n            shutil.rmtree(export_fixes_dir)\n        os.kill(0, 9)\n\n    if combine_fixes:\n        print(\"Writing fixes to \" + args.export_fixes + \" ...\")\n        try:\n            merge_replacement_files(export_fixes_dir, args.export_fixes)\n        except:\n            print(\"Error exporting fixes.\\n\", file=sys.stderr)\n            traceback.print_exc()\n            return_code = 1\n\n    if args.fix:\n        print(\"Applying fixes ...\")\n        try:\n            apply_fixes(args, clang_apply_replacements_binary, export_fixes_dir)\n        except:\n            print(\"Error applying fixes.\\n\", file=sys.stderr)\n            traceback.print_exc()\n            return_code = 1\n\n    if delete_fixes_dir:\n        shutil.rmtree(export_fixes_dir)\n    sys.exit(return_code)\n\n\nif __name__ == \"__main__\":\n    main()\n","size_bytes":17481},"misc/cmake/try_compile/std_lock_guard.cpp":{"content":"// Copyright (C) Markus Franz Xaver Johannes Oberhumer\n\n#include <mutex>\n\nstatic std::mutex lock_mutex;\n\nint main() {\n    std::lock_guard<std::mutex> lock(lock_mutex);\n    return 0;\n}\n","size_bytes":184},"misc/cmake/try_compile/types_abi.cpp":{"content":"// Copyright (C) Markus Franz Xaver Johannes Oberhumer\n\n#include <stddef.h>\n#include <stdint.h>\n\n// check ABI - require proper alignment of fundamental types for use in atomics\nstatic_assert(alignof(char) == sizeof(char), \"\");\nstatic_assert(alignof(signed char) == sizeof(signed char), \"\");\nstatic_assert(alignof(unsigned char) == sizeof(unsigned char), \"\");\nstatic_assert(alignof(short) == sizeof(short), \"\");\nstatic_assert(alignof(unsigned short) == sizeof(unsigned short), \"\");\nstatic_assert(alignof(int) == sizeof(int), \"\");\nstatic_assert(alignof(unsigned int) == sizeof(unsigned int), \"\");\nstatic_assert(alignof(long) == sizeof(long), \"\");\nstatic_assert(alignof(unsigned long) == sizeof(unsigned long), \"\");\nstatic_assert(alignof(ptrdiff_t) == sizeof(ptrdiff_t), \"\");\nstatic_assert(alignof(size_t) == sizeof(size_t), \"\");\nstatic_assert(alignof(intptr_t) == sizeof(intptr_t), \"\");\nstatic_assert(alignof(uintptr_t) == sizeof(uintptr_t), \"\");\nstatic_assert(alignof(void *) == sizeof(void *), \"\");\n\nint main() { return 0; }\n","size_bytes":1025},"misc/podman/rebuild-stubs/10-create-image.sh":{"content":"#! /usr/bin/env bash\n## vim:set ts=4 sw=4 et:\nset -e; set -o pipefail\nargv0=$0; argv0abs=\"$(readlink -fn \"$argv0\")\"; argv0dir=\"$(dirname \"$argv0abs\")\"\n\n# create the image from Dockerfile\n# using a rootless Podman container\n# Copyright (C) Markus Franz Xaver Johannes Oberhumer\n\nimage=resize-stubtools-20240405-v1\n[[ $1 == --print-image ]] && echo \"$image\" && exit 0\n\npodman build -t \"$image\" -f \"$argv0dir/Dockerfile\" \"$argv0dir\"\n\npodman image list \"$image\"\necho\npodman image tree \"$image\"\n","size_bytes":490},"misc/podman/rebuild-stubs/11-list-packages.sh":{"content":"#! /usr/bin/env bash\n## vim:set ts=4 sw=4 et:\nset -e; set -o pipefail\nargv0=$0; argv0abs=\"$(readlink -fn \"$argv0\")\"; argv0dir=\"$(dirname \"$argv0abs\")\"\n\n# list all system packages that are installed in the image\n# using a rootless Podman container\n# Copyright (C) Markus Franz Xaver Johannes Oberhumer\n\nimage=\"$(\"$argv0dir/10-create-image.sh\" --print-image)\"\n\npodman image list \"$image\"\necho\npodman image tree \"$image\"\n\necho 'Packages:'\nflags=( --read-only --rm --pull=never )\nflags+=( --cap-drop=all )               # drop all capabilities\nflags+=( --network=none )               # no network needed\npodman run \"${flags[@]}\" \"$image\" bash -c $'dpkg -l | sed \\'s/ *$//\\' | LC_ALL=C sort'\n\necho\necho 'Packages sorted by Installed-Size:'\npodman run \"${flags[@]}\" \"$image\" bash -c $'awk \\'\nBEGIN {\n    arch = \"UNKNOWN\"; size = 0; package = \"UNKNOWN\";\n}\n{\n    if ($1 == \"Architecture:\") arch = $2;\n    if ($1 == \"Installed-Size:\") size = $2;\n    if ($1 == \"Package:\") package = $2;\n    if ($1 == \"\") {\n        printf(\"%9d %-40s %s\\\\n\", size, package, arch);\n        count += 1; total += size;\n        arch = \"UNKNOWN\"; size = 0; package = \"UNKNOWN\";\n    }\n}\nEND {\n    printf(\"%9d ===== TOTAL (%d packages)\\\\n\", total, count);\n}\n\\' /var/lib/dpkg/status | LC_ALL=C sort -rn'\n","size_bytes":1268},"misc/podman/rebuild-stubs/20-image-run-shell.sh":{"content":"#! /usr/bin/env bash\n## vim:set ts=4 sw=4 et:\nset -e; set -o pipefail\nargv0=$0; argv0abs=\"$(readlink -fn \"$argv0\")\"; argv0dir=\"$(dirname \"$argv0abs\")\"\n\n# run an interactive shell in the image\n# using a rootless Podman container\n# Copyright (C) Markus Franz Xaver Johannes Oberhumer\n\nimage=\"$(\"$argv0dir/10-create-image.sh\" --print-image)\"\n\nflags=( --read-only --rm --pull=never )\nflags+=( --cap-drop=all )               # drop all capabilities\nflags+=( --network=none )               # no network needed\nflags+=( -ti -e TERM=\"$TERM\" )          # allocate an interactive pseudo-tty and pass $TERM\nif [[ 1 == 1 ]]; then\n    # run as user resize 2000:2000\n    flags+=( --user 2000 )\n    # map container users 0..999 to subuid-users 1..1000, and map container user 2000 to current host user\n    flags+=( --uidmap=0:1:1000 --uidmap=2000:0:1 )\n    # map container groups 0..999 to subgid-groups 1..1000, and map container group 2000 to current host group\n    flags+=( --gidmap=0:1:1000 --gidmap=2000:0:1 )\n    # NOTE: we mount the resize top-level directory read-write under /home/resize/src/resize\n    # INFO: SELinux users *may* have to add \":z\" to the volume mount flags; check the docs!\n    flags+=( -v \"${argv0dir}/../../..:/home/resize/src/resize\" )\n    flags+=( -w /home/resize/src/resize )              # set working directory\n    flags+=( --tmpfs /home/resize/.cache:rw,exec )  # mount a writeable tmpfs\n    flags+=( --tmpfs /home/resize/.config:rw,exec ) # mount a writeable tmpfs\n    flags+=( --tmpfs /home/resize/.local:rw,exec )  # mount a writeable tmpfs\nelse\n    # run as user root 0:0\n    # ONLY FOR DEBUGGING THE IMAGE\n    # map container user/group 0 to current host user/group\n    flags+=( --user 0 )\nfi\n\nif [[ $# == 0 ]]; then\n    podman run \"${flags[@]}\" \"$image\" bash -l\nelse\n    podman run \"${flags[@]}\" \"$image\" \"$@\"\nfi\n\n# now we can rebuild the RESIZE stubs:\n#   cd /home/resize/src/resize/src/stub\n#   # make sure that git is clean:\n#   git status .\n#   # remove stub files and make sure that they got deleted:\n#   make maintainer-clean extra-clean\n#   git status .\n#   # rebuild\n#   make extra-all all\n#   # make sure that the stub files did rebuild correctly:\n#   git status .\n#   git diff .\n\n# we can also build RESIZE in the container:\n#   cd /home/resize/src/resize\n#   rm -rf ./build/extra/gcc/release\n#   make build/extra/gcc/release\n#   # run tests\n#   ./build/extra/gcc/release/resize --version\n#   make -C build/extra/gcc/release test\n\n# and we can also build RESIZE with -m32:\n#   cd /home/resize/src/resize\n#   rm -rf ./build/extra/gcc-m32/release\n#   make build/extra/gcc-m32/release\n#   # run tests\n#   ./build/extra/gcc-m32/release/resize --version\n#   make -C build/extra/gcc-m32/release test\n\n# and we can also build RESIZE with -mx32: (NOTE: needs CONFIG_X86_X32_ABI on host kernel!)\n#   cd /home/resize/src/resize\n#   rm -rf ./build/extra/gcc-mx32/release\n#   make build/extra/gcc-mx32/release\n#   # run tests (needs CONFIG_X86_X32_ABI on host kernel)\n#   ./build/extra/gcc-mx32/release/resize --version\n#   make -C build/extra/gcc-mx32/release test\n\n# and we can also rebuild the RESIZE docs the container:\n#   cd /home/resize/src/resize/doc\n#   make clean all\n#   git status .\n#   git diff .\n","size_bytes":3233},"misc/podman/rebuild-stubs/30-rebuild-stubs.sh":{"content":"#! /usr/bin/env bash\n## vim:set ts=4 sw=4 et:\nset -e; set -o pipefail\nargv0=$0; argv0abs=\"$(readlink -fn \"$argv0\")\"; argv0dir=\"$(dirname \"$argv0abs\")\"\n\n# rebuild stubs from source code\n#   (also see 20-image-run-shell.sh for more container usage examples)\n# using a rootless Podman container\n# Copyright (C) Markus Franz Xaver Johannes Oberhumer\n\nimage=\"$(\"$argv0dir/10-create-image.sh\" --print-image)\"\n\nflags=( --read-only --rm --pull=never )\nflags+=( --cap-drop=all )               # drop all capabilities\nflags+=( --network=none )               # no network needed\nif [[ 1 == 1 ]]; then\n    # run as user resize 2000:2000\n    flags+=( --user 2000 )\n    # map container users 0..999 to subuid-users 1..1000, and map container user 2000 to current host user\n    flags+=( --uidmap=0:1:1000 --uidmap=2000:0:1 )\n    # map container groups 0..999 to subgid-groups 1..1000, and map container group 2000 to current host group\n    flags+=( --gidmap=0:1:1000 --gidmap=2000:0:1 )\n    # NOTE: we mount the resize top-level directory read-write under /home/resize/src/resize\n    # INFO: SELinux users *may* have to add \":z\" to the volume mount flags; check the docs!\n    flags+=( -v \"${argv0dir}/../../..:/home/resize/src/resize\" )\nfi\n\npodman run \"${flags[@]}\" \"$image\" bash -c $'\nset -ex; set -o pipefail\ncd /home/resize/src/resize\n# check whitespace\n[[ -d .git ]] && bash ./misc/scripts/check_whitespace_git.sh\n# rebuild docs\nmake -C doc clean all\n# rebuild stubs\ncd /home/resize/src/resize/src/stub\nmake maintainer-clean extra-clean\ngit status . || true # make sure the stub files got deleted\nmake extra-all all\necho \"===== Rebuilt stubs. All done. =====\"\nexit 0\n'\n","size_bytes":1658},"src/stub/scripts/bin2h.py":{"content":"#! /usr/bin/env python2\n## vim:set ts=4 sw=4 et: -*- coding: utf-8 -*-\n#\n#  bin2h.py --\n#\n#  This file is part of the UPX executable compressor.\n#\n#  Copyright (C) 1996-2025 Markus Franz Xaver Johannes Oberhumer\n#  All Rights Reserved.\n#\n#  UPX and the UCL library are free software; you can redistribute them\n#  and/or modify them under the terms of the GNU General Public License as\n#  published by the Free Software Foundation; either version 2 of\n#  the License, or (at your option) any later version.\n#\n#  This program is distributed in the hope that it will be useful,\n#  but WITHOUT ANY WARRANTY; without even the implied warranty of\n#  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n#  GNU General Public License for more details.\n#\n#  You should have received a copy of the GNU General Public License\n#  along with this program; see the file COPYING.\n#  If not, write to the Free Software Foundation, Inc.,\n#  59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.\n#\n#  Markus F.X.J. Oberhumer              Laszlo Molnar\n#  <markus@oberhumer.com>               <ezerotven+github@gmail.com>\n#\n\n\nimport getopt, os, re, struct, sys, zlib\n\n\nclass opts:\n    dry_run = 0\n    ident = None\n    methods = [ 0 ]\n    mname = \"STUB_COMPRESS_METHOD\"\n    mode = \"c\"\n    verbose = 0\n\n\n# /***********************************************************************\n# // write header\n# ************************************************************************/\n\ndef w_header_c(w, ifile, ofile, n):\n    w(\"/* %s\\n   created from %s, %d (0x%x) bytes\\n\" % (os.path.basename(ofile), os.path.basename(ifile), n, n))\n    w(\"\"\"\\n\\\n   This file is part of the UPX executable compressor.\n\n   Copyright (C) 1996-2025 Markus Franz Xaver Johannes Oberhumer\n   Copyright (C) 1996-2025 Laszlo Molnar\n   Copyright (C) 2000-2025 John F. Reiser\n   All Rights Reserved.\n\n   UPX and the UCL library are free software; you can redistribute them\n   and/or modify them under the terms of the GNU General Public License as\n   published by the Free Software Foundation; either version 2 of\n   the License, or (at your option) any later version.\n\n   This program is distributed in the hope that it will be useful,\n   but WITHOUT ANY WARRANTY; without even the implied warranty of\n   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n   GNU General Public License for more details.\n\n   You should have received a copy of the GNU General Public License\n   along with this program; see the file COPYING.\n   If not, write to the Free Software Foundation, Inc.,\n   59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.\n\n   Markus F.X.J. Oberhumer              Laszlo Molnar\n   <markus@oberhumer.com>               <ezerotven+github@gmail.com>\n\n   John F. Reiser\n   <jreiser@users.sourceforge.net>\n */\\n\\n\"\"\")\n\n\n# /***********************************************************************\n# // write data\n# ************************************************************************/\n\nclass DataWriter:\n    def __init__(self, w):\n        self.w = w\n        self.pos = None\n\n    def w_bol(self, pos):\n        self.w(\"/* 0x%04x */ \" % (pos))\n        self.pos = pos\n    def w_eol(self, fill=\"\"):\n        if self.pos is not None:\n            self.w(fill.rstrip() + \"\\n\")\n\n\nclass DataWriter_c(DataWriter):\n    def w_data(self, data):\n        w, n = self.w, len(data)\n        for i in range(n):\n            if i & 15 == 0:\n                self.w_eol()\n                self.w_bol(i)\n            w(\"%3d\" % ord(data[i]))\n            if i != n - 1: w(\",\")\n        self.w_eol()\n\n\nclass DataWriter_gas(DataWriter):\n    def w_data(self, data):\n        w, n = self.w, len(data)\n        for i in range(n):\n            if i & 15 == 0:\n                self.w_eol()\n                self.w_bol(i)\n                w(\".byte \")\n            else:\n                w(\",\")\n            w(\"%3d\" % ord(data[i]))\n        self.w_eol()\n\n\nclass _DataWriter_gas_u32(DataWriter):\n    def w_data(self, data):\n        w, n = self.w, len(data)\n        assert n % 4 == 0, n\n        for i in range(0, n, 4):\n            if i & 15 == 0:\n                self.w_eol()\n                self.w_bol(i)\n                w(\".int \")\n            else:\n                w(\",\")\n            v = struct.unpack(self.DECODE, data[i:i+4])\n            assert len(v) == 1, v\n            w(\"0x%08x\" % (v[0] & 0xffffffffL))\n        self.w_eol()\n\nclass DataWriter_gas_be32(_DataWriter_gas_u32):\n    DECODE = \">i\"\nclass DataWriter_gas_le32(_DataWriter_gas_u32):\n    DECODE = \"<i\"\n\n\nclass DataWriter_nasm(DataWriter):\n    def w_bol(self, pos):\n        self.pos = pos\n    def w_eol(self, fill=\"\"):\n        if self.pos is not None:\n            self.w(fill)\n            self.w(\"   ; 0x%04x\\n\" % (self.pos))\n\n    def w_data(self, data):\n        w, n = self.w, len(data)\n        for i in range(n):\n            if i & 15 == 0:\n                self.w_eol()\n                self.w_bol(i)\n                w(\"db \")\n            else:\n                w(\",\")\n            w(\"%3d\" % ord(data[i]))\n        nn = ((n + 15) & ~15) - n\n        self.w_eol(\" \" * 4 * nn)\n\n\n# /***********************************************************************\n# // write stub\n# ************************************************************************/\n\ndef w_checksum_c(w, s, data):\n    w(\"#define %s_SIZE    %d\\n\"     % (s, len(data)))\n    w(\"#define %s_ADLER32 0x%08x\\n\" % (s, 0xffffffffL & zlib.adler32(data)))\n    w(\"#define %s_CRC32   0x%08x\\n\" % (s, 0xffffffffL & zlib.crc32(data)))\n    w(\"\\n\")\n\n\ndef write_stub(w, odata, method_index, methods):\n    method = methods[method_index]\n    if len(methods) > 1:\n        if method_index == 0:\n            w(\"#if (%s == %d)\\n\\n\" % (opts.mname, method))\n        elif method_index < len(methods) - 1:\n            w(\"\\n#elif (%s == %d)\\n\\n\" % (opts.mname, method))\n        else:\n            w(\"\\n#else\\n\\n\")\n\n    if opts.ident:\n        if opts.mode == \"c\":\n            w_checksum_c(w, opts.ident.upper(), odata)\n            if 0:\n                # idea: put all stubs in a dedicated section so that UPX compresses better\n                #w(\"#if defined(__ELF__)\\n\")\n                #w('__attribute__((__section__(\"upx_stubs\")))\\n')\n                #w(\"#endif\\n\")\n                w(\"ATTRIBUTE_FOR_STUB(%s)\\n\" % (opts.ident))\n            w(\"unsigned char %s[%d] = {\\n\" % (opts.ident, len(odata)))\n    if opts.mode == \"c\":\n        DataWriter_c(w).w_data(odata)\n    elif opts.mode == \"gas\":\n        DataWriter_gas(w).w_data(odata)\n    elif opts.mode == \"gas-be32\":\n        DataWriter_gas_be32(w).w_data(odata)\n    elif opts.mode == \"gas-le32\":\n        DataWriter_gas_le32(w).w_data(odata)\n    elif opts.mode == \"nasm\":\n        DataWriter_nasm(w).w_data(odata)\n    else:\n        assert 0, (\"invalid mode\", opts.mode)\n    if opts.ident:\n        if opts.mode == \"c\":\n            w(\"};\\n\")\n\n    if len(methods) > 1:\n        if method_index == len(methods) - 1:\n            w(\"\\n#endif\\n\")\n\n\n# /***********************************************************************\n# // compress stub\n# ************************************************************************/\n\ndef encode_compressed_stub_header(method, idata, odata):\n    assert 0 < method <= 255\n    if len(idata) <= 65535:\n        h = \"UPX#\" + struct.pack(\"<BHH\", method, len(idata), len(odata))\n        assert len(h) == 9\n    else:\n        h = \"UPX#\" + \"\\x00\" + struct.pack(\"<BII\", method, len(idata), len(odata))\n        assert len(h) == 14\n    ##assert len(h) + len(odata) < len(idata), (\"stub compression failed\", len(h), len(odata), len(idata))\n    return h\n\n\ndef compress_stub(method, idata):\n    # compress\n    if method == 0:\n        return 0, idata\n    elif method == 14: # M_LZMA\n        import pylzma\n        odata = pylzma.compress(idata, eos=0)\n        ## FIXME: internal pylzma-0.3.0 error\n        ##assert pylzma.decompress(odata, maxlength=len(idata)) == idata\n        # recode lzma-header\n        prop = ord(odata[0])\n        pb = (prop / 9) / 5; lp = (prop / 9) % 5; lc = prop % 9\n        h = chr(((lc + lp) << 3) | pb) + chr((lp << 4) | lc)\n        odata = h + odata[5:]\n        # encode upx stub header\n        odata = encode_compressed_stub_header(method, idata, odata) + odata\n    elif method == 15: # M_DEFLATE\n        odata = zlib.compress(idata, 9)\n        # strip zlib-header and zlib-trailer (adler32)\n        odata = odata[2:-4]\n        assert zlib.decompress(odata, -15) == idata\n        # encode upx stub header\n        odata = encode_compressed_stub_header(method, idata, odata) + odata\n    else:\n        raise Exception(\"invalid method\", method, opts.methods)\n    if 1 and len(odata) >= len(idata):\n        # not compressible\n        return 0, idata\n    assert len(odata) <= len(idata), \"stub compression failed\"\n    return method, odata\n\n\n# /***********************************************************************\n# // main\n# ************************************************************************/\n\ndef main(argv):\n    try: assert 0\n    except AssertionError: pass\n    else: raise Exception(\"fatal error - assertions not enabled\")\n    shortopts, longopts = \"qv\", [\n        \"compress=\", \"dry-run\", \"ident=\", \"mode=\", \"quiet\", \"verbose\"\n    ]\n    xopts, args = getopt.gnu_getopt(argv[1:], shortopts, longopts)\n    for opt, optarg in xopts:\n        if 0: pass\n        elif opt in [\"-q\", \"--quiet\"]: opts.verbose = opts.verbose - 1\n        elif opt in [\"-v\", \"--verbose\"]: opts.verbose = opts.verbose + 1\n        elif opt in [\"--compress\"]: opts.methods = map(int, optarg.split(\",\"))\n        elif opt in [\"--dry-run\"]: opts.dry_run = opts.dry_run + 1\n        elif opt in [\"--ident\"]: opts.ident = optarg\n        elif opt in [\"--mode\"]: opts.mode = optarg.lower()\n        else: assert 0, (\"getopt problem:\", opt, optarg, xopts, args)\n\n    assert len(args) == 2\n    ifile = args[0]\n    ofile = args[1]\n\n    # check file size\n    st = os.stat(ifile)\n    if 1 and st.st_size <= 0:\n        print >> sys.stderr, \"%s: ERROR: empty file\" % (ifile)\n        sys.exit(1)\n    if 1 and st.st_size > 128*1024:\n        print >> sys.stderr, \"%s: ERROR: file is too big (%d bytes)\" % (ifile, st.st_size)\n        sys.exit(1)\n\n    # read ifile\n    ifile = os.path.normpath(ifile)\n    ifp = open(ifile, \"rb\")\n    idata = ifp.read()\n    ifp.close()\n    assert len(idata) == st.st_size\n\n    # opts.ident\n    if opts.ident in [\"auto\", \"auto-stub\"]:\n        s = os.path.basename(ifile)\n        s = re.sub(r\"\\.(bin|out)$\", \"\", s)\n        s = re.sub(r\"[-.]\", \"_\", s)\n        if opts.ident in [\"auto-stub\"]:\n            s = \"stub_\"  + s\n        opts.ident = s\n    if opts.ident:\n        assert re.search(r\"^[a-zA-Z]\", opts.ident), opts.ident\n        assert not re.search(r\"[^a-zA-Z0-9_]\", opts.ident), opts.ident\n\n    # compress stubs\n    # (process in reverse order so that incompressible do not get sorted first)\n    mdata, mdata_odata = [], {}\n    assert len(opts.methods) >= 1\n    r_methods = opts.methods[:]\n    r_methods.reverse()\n    for method in r_methods:\n        method, odata = compress_stub(method, idata)\n        if mdata_odata.has_key(method):\n            assert mdata_odata[method] == odata\n        else:\n            mdata_odata[method] = odata\n            mdata.append(method)\n    assert len(mdata) >= 1\n    mdata.reverse()\n    ##print opts.methods, [(i, len(mdata_odata[i])) for i in mdata]\n\n    # write ofile\n    if opts.dry_run:\n        ofp = None\n        def dummy_write(s): pass\n        w = dummy_write\n    else:\n        if ofile == \"-\":\n            ofp = sys.stdout\n        else:\n            ofp = open(ofile, \"wb\")\n        w = ofp.write\n    if opts.mode == \"c\":\n        if opts.verbose >= 0:\n            w_header_c(w, ifile, ofile, len(idata))\n        w(\"/* clang\" + \"-format\" + \" off */\\n\\n\")\n    for i in range(len(mdata)):\n        write_stub(w, mdata_odata[mdata[i]], i, mdata)\n    if ofp:\n        if ofp is sys.stdout:\n            ofp.flush()\n        else:\n            ofp.close()\n\n    # write an extra C file so that we can test the total size of the stubs:\n    #   $ gcc -Wall -c test_size*.c\n    #   $ size --totals test_size*.o\n    # current results (2022-12-22):\n    #   89 files, 1,082,956 bytes\n    if 0 and not opts.dry_run:\n        if opts.ident and ofile and ofile != \"-\":\n            tfp = open(\"test_size_\" + ofile + \".c\", \"wb\")\n            tfp.write(\"const\\n\")\n            tfp.write('#include \"' + ofile + '\"\\n')\n            tfp.close()\n\nif __name__ == \"__main__\":\n    sys.exit(main(sys.argv))\n","size_bytes":12411},"src/stub/scripts/brandelf.py":{"content":"#! /usr/bin/env python2\n## vim:set ts=4 sw=4 et: -*- coding: utf-8 -*-\n#\n#  brandelf.py --\n#\n#  This file is part of the UPX executable compressor.\n#\n#  Copyright (C) 1996-2025 Markus Franz Xaver Johannes Oberhumer\n#  All Rights Reserved.\n#\n#  UPX and the UCL library are free software; you can redistribute them\n#  and/or modify them under the terms of the GNU General Public License as\n#  published by the Free Software Foundation; either version 2 of\n#  the License, or (at your option) any later version.\n#\n#  This program is distributed in the hope that it will be useful,\n#  but WITHOUT ANY WARRANTY; without even the implied warranty of\n#  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n#  GNU General Public License for more details.\n#\n#  You should have received a copy of the GNU General Public License\n#  along with this program; see the file COPYING.\n#  If not, write to the Free Software Foundation, Inc.,\n#  59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.\n#\n#  Markus F.X.J. Oberhumer              Laszlo Molnar\n#  <markus@oberhumer.com>               <ezerotven+github@gmail.com>\n#\n\n\nimport getopt, os, re, sys\n\n\nclass opts:\n    bfdname = None\n    dry_run = 0\n    elfosabi = None\n    verbose = 0\n\n\n# /***********************************************************************\n# //\n# ************************************************************************/\n\ndef do_file(fn):\n    done = 1\n    if opts.dry_run:\n        fp = open(fn, \"rb\")\n    else:\n        fp = open(fn, \"r+b\")\n    fp.seek(0, 0)\n    e_ident = fp.read(16)\n    fp.seek(0, 0)\n\n    def write(s):\n        if not opts.dry_run:\n            fp.write(s)\n\n    def brand_arm(s):\n        if e_ident[4:7] != s:\n            raise Exception(\"%s is not %s\" % (fn, opts.bfdname))\n        write(\"\\x61\") # ELFOSABI_ARM\n    def brand_freebsd(s):\n        if e_ident[4:7] != s:\n            raise Exception(\"%s is not %s\" % (fn, opts.bfdname))\n        write(\"\\x09\")\n    def brand_linux(s):\n        if e_ident[4:7] != s:\n            raise Exception(\"%s is not %s\" % (fn, opts.bfdname))\n        ##write(\"\\x00Linux\\x00\\x00\\x00\")\n        write(\"\\x00\" * 9)\n    def brand_netbsd(s):\n        if e_ident[4:7] != s:\n            raise Exception(\"%s is not %s\" % (fn, opts.bfdname))\n        write(\"\\x02\")\n    def brand_openbsd(s):\n        if e_ident[4:7] != s:\n            raise Exception(\"%s is not %s\" % (fn, opts.bfdname))\n        write(\"\\x0c\")\n\n    if opts.bfdname[:3] == \"elf\":\n        if e_ident[:4] != \"\\x7f\\x45\\x4c\\x46\":\n            raise Exception(\"%s is not %s\" % (fn, \"ELF\"))\n        fp.seek(7, 0)\n        if opts.bfdname == \"elf32-bigarm\" and opts.elfosabi == \"arm\":\n            brand_arm(\"\\x01\\x02\\x01\")\n        elif opts.bfdname == \"elf32-i386\" and opts.elfosabi == \"freebsd\":\n            brand_freebsd(\"\\x01\\x01\\x01\")\n        elif opts.bfdname == \"elf32-i386\" and opts.elfosabi == \"linux\":\n            brand_linux(\"\\x01\\x01\\x01\")\n        elif opts.bfdname == \"elf32-i386\" and opts.elfosabi == \"netbsd\":\n            brand_netbsd(\"\\x01\\x01\\x01\")\n        elif opts.bfdname == \"elf32-i386\" and opts.elfosabi == \"openbsd\":\n            brand_openbsd(\"\\x01\\x01\\x01\")\n        elif opts.bfdname == \"elf32-littlearm\" and opts.elfosabi == \"arm\":\n            brand_arm(\"\\x01\\x01\\x01\")\n        elif opts.bfdname == \"elf32-littlemips\" and opts.elfosabi == \"linux\":\n            brand_linux(\"\\x01\\x01\\x01\")\n        elif opts.bfdname == \"elf32-powerpc\" and opts.elfosabi == \"linux\":\n            brand_linux(\"\\x01\\x02\\x01\")\n        elif opts.bfdname == \"elf64-x86_64\" and opts.elfosabi == \"linux\":\n            brand_linux(\"\\x02\\x01\\x01\")\n        else:\n            done = 0\n    else:\n        done = 0\n    fp.close()\n    if not done:\n        raise Exception(\"error: invalid args\", opts.__dict__)\n\n\ndef main(argv):\n    try: assert 0\n    except AssertionError: pass\n    else: raise Exception(\"fatal error - assertions not enabled\")\n    shortopts, longopts = \"qv\", [\n        \"bfdname=\", \"dry-run\", \"elfosabi=\", \"quiet\", \"verbose\"\n    ]\n    xopts, args = getopt.gnu_getopt(argv[1:], shortopts, longopts)\n    for opt, optarg in xopts:\n        if 0: pass\n        elif opt in [\"-q\", \"--quiet\"]: opts.verbose = opts.verbose - 1\n        elif opt in [\"-v\", \"--verbose\"]: opts.verbose = opts.verbose + 1\n        elif opt in [\"--dry-run\"]: opts.dry_run = opts.dry_run + 1\n        elif opt in [\"--bfdname\"]: opts.bfdname = optarg.lower()\n        elif opt in [\"--elfosabi\"]: opts.elfosabi = optarg.lower()\n        else: assert 0, (\"getopt problem:\", opt, optarg, xopts, args)\n    # process arguments\n    if not args:\n        raise Exception(\"error: no arguments given\")\n    for arg in args:\n        do_file(arg)\n    return 0\n\n\nif __name__ == \"__main__\":\n    sys.exit(main(sys.argv))\n","size_bytes":4731},"src/stub/scripts/gpp_inc.py":{"content":"#! /usr/bin/env python2\n## vim:set ts=4 sw=4 et: -*- coding: utf-8 -*-\n#\n#  gpp_inc.py -- Generic PreProcessor: include\n#\n#  This file is part of the UPX executable compressor.\n#\n#  Copyright (C) 1996-2025 Markus Franz Xaver Johannes Oberhumer\n#  All Rights Reserved.\n#\n#  UPX and the UCL library are free software; you can redistribute them\n#  and/or modify them under the terms of the GNU General Public License as\n#  published by the Free Software Foundation; either version 2 of\n#  the License, or (at your option) any later version.\n#\n#  This program is distributed in the hope that it will be useful,\n#  but WITHOUT ANY WARRANTY; without even the implied warranty of\n#  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n#  GNU General Public License for more details.\n#\n#  You should have received a copy of the GNU General Public License\n#  along with this program; see the file COPYING.\n#  If not, write to the Free Software Foundation, Inc.,\n#  59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.\n#\n#  Markus F.X.J. Oberhumer              Laszlo Molnar\n#  <markus@oberhumer.com>               <ezerotven+github@gmail.com>\n#\n\n\nimport getopt, os, re, sys\n\n\nclass opts:\n    dry_run = 0\n    verbose = 0\n    fatal = 1\n    includes = []\n    mode = \"c\"\n    target_mf = None\n    target_mmd = None\n\n\nfiles_md = []\nfiles_mmd = []\nfiles_st = {}\n\ndef add_dep(state, fn, mode):\n    if mode:\n        files = files_md\n    else:\n        files = files_mmd\n    fn = os.path.normpath(fn)\n    fn = os.path.normcase(fn)\n    if fn in files:\n        return\n    # FIXME: could use os.path.samestat() etc.\n    files.append(fn)\n    files_st[fn] = os.stat(fn)\n\n\ndef not_found(state, l, inc, fatal=None):\n    if fatal is None:\n        fatal = opts.fatal\n    if fatal:\n        raise Exception(\"%s:%d: include file %s not found\" % (state[0], state[2], inc))\n    return l\n\n\ndef parse_comment(state, l, comment):\n    cf = {}\n    if not comment: return cf\n    m = re.search(r\"gpp_inc:(.+?):\", comment.strip())\n    if not m: return cf\n    flags = re.split(r\"\\s+\", m.group(1).strip())\n    for f in flags:\n        assert f, (f, flags, m.groups(), comment)\n        if   f == \"ignore=0\": cf[\"fatal\"] = 1\n        elif f == \"ignore=1\": cf[\"fatal\"] = 0\n        else:\n            raise Exception(\"%s:%d: bad flags %s %s\" % (state[0], state[2], f, str(flags)))\n    return cf\n\n\ndef handle_inc_c(state, l, ofp):\n    m = re.search(r\"^\\s*\\#\\s*include\\s+([\\\"\\<])(.+?)([\\\"\\>])(.*)$\", l)\n    if not m:\n        return l\n    q1, inc, q2, comment = m.groups()\n    cf = parse_comment(state, l, comment)\n    if q1 == '<' and q2 == '>':\n        dirs = opts.includes\n    elif q1 == '\"' and q2 == '\"':\n        dirs = [state[1]] + opts.includes\n    else:\n        raise Exception(\"syntax error: include line \" + l)\n    for dir in dirs:\n        fn = os.path.join(dir, inc)\n        if os.path.isfile(fn):\n            add_dep(state, fn, q1 == '<')\n            handle_file(fn, ofp, state)\n            return None\n    return not_found(state, l, inc, cf.get(\"fatal\"))\n\n\ndef handle_inc_nasm(state, l, ofp):\n    m = re.search(r\"^\\s*\\%\\s*include\\s+([\\\"\\<])(.+?)([\\\"\\>])(.*)$\", l)\n    if not m:\n        return l\n    q1, inc, q2, comment = m.groups()\n    cf = parse_comment(state, l, comment)\n    if q1 == '<' and q2 == '>':\n        pass\n    elif q1 == '\"' and q2 == '\"':\n        pass\n    else:\n        raise Exception(\"syntax error: include line \" + l)\n    # info: nasm simply does concat the includes\n    for prefix in opts.includes + [\"\"]:\n        fn = prefix + inc\n        if os.path.isfile(fn):\n            add_dep(state, fn, False)\n            handle_file(fn, ofp, state)\n            return None\n    return not_found(state, l, inc, cf.get(\"fatal\"))\n\n\ndef handle_file(ifn, ofp, parent_state=None):\n    state = [ifn, os.path.dirname(ifn) or \".\", 0, parent_state]\n    ifp = open(ifn, \"rb\")\n    for l in ifp.readlines():\n        state[2] += 1       # line counter\n        l = l.rstrip(\"\\n\")\n        if opts.mode == \"c\":\n            l = handle_inc_c(state, l, ofp)\n        elif opts.mode == \"nasm\":\n            l = handle_inc_nasm(state, l, ofp)\n        if l is not None:\n            ofp.write(l + \"\\n\")\n\n\ndef main(argv):\n    try: assert 0\n    except AssertionError: pass\n    else: raise Exception(\"fatal error - assertions not enabled\")\n    ofile = None\n    shortopts, longopts = \"qvI:o:\", [\"dry-run\", \"MF=\", \"MMD=\", \"mode=\", \"quiet\", \"verbose\"]\n    xopts, args = getopt.gnu_getopt(argv[1:], shortopts, longopts)\n    for opt, optarg in xopts:\n        if 0: pass\n        elif opt in [\"-q\", \"--quiet\"]: opts.verbose = opts.verbose - 1\n        elif opt in [\"-v\", \"--verbose\"]: opts.verbose = opts.verbose + 1\n        elif opt in [\"--dry-run\"]: opts.dry_run = opts.dry_run + 1\n        elif opt in [\"-I\"]: opts.includes.append(optarg)\n        elif opt in [\"-o\"]: ofile = optarg\n        elif opt in [\"--mode\"]: opts.mode = optarg.lower()\n        elif opt in [\"--MF\"]: opts.target_mf = optarg\n        elif opt in [\"--MMD\"]: opts.target_mmd = optarg\n        else: assert 0, (\"getopt problem:\", opt, optarg, xopts, args)\n\n    if ofile is None:\n        assert len(args) == 2\n        ifile = args[0]\n        ofile = args[1]\n    else:\n        assert len(args) == 1\n        ifile = args[0]\n\n    assert os.path.isfile(ifile)\n    ofp = open(ofile, \"wb\")\n    handle_file(ifile, ofp)\n    ofp.close()\n\n    if opts.target_mmd:\n        fn = ofile + \".d\"\n        if opts.target_mf:\n            fn = opts.target_mf\n        if os.path.isfile(fn):\n            os.unlink(fn)\n        if files_mmd:\n            fp = open(fn, \"wb\")\n            fp.write(\"%s : \\\\\\n\" % opts.target_mmd)\n            for i, f in enumerate(files_mmd):\n                if i < len(files_mmd) - 1:\n                    fp.write(\"  %s \\\\\\n\" % f)\n                else:\n                    fp.write(\"  %s\\n\" % f)\n            fp.close()\n\n\nif __name__ == \"__main__\":\n    sys.exit(main(sys.argv))\n","size_bytes":5894},"src/stub/scripts/xstrip.py":{"content":"#! /usr/bin/env python2\n## vim:set ts=4 sw=4 et: -*- coding: utf-8 -*-\n#\n#  xstrip.py -- truncate ELF objects created by multiarch-objcopy-2.17\n#\n#  This file is part of the UPX executable compressor.\n#\n#  Copyright (C) 1996-2025 Markus Franz Xaver Johannes Oberhumer\n#  All Rights Reserved.\n#\n#  UPX and the UCL library are free software; you can redistribute them\n#  and/or modify them under the terms of the GNU General Public License as\n#  published by the Free Software Foundation; either version 2 of\n#  the License, or (at your option) any later version.\n#\n#  This program is distributed in the hope that it will be useful,\n#  but WITHOUT ANY WARRANTY; without even the implied warranty of\n#  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n#  GNU General Public License for more details.\n#\n#  You should have received a copy of the GNU General Public License\n#  along with this program; see the file COPYING.\n#  If not, write to the Free Software Foundation, Inc.,\n#  59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.\n#\n#  Markus F.X.J. Oberhumer              Laszlo Molnar\n#  <markus@oberhumer.com>               <ezerotven+github@gmail.com>\n#\n\n\nimport getopt, os, re, string, struct, sys\n\n\nclass opts:\n    dry_run = 0\n    verbose = 0\n    bindump = None\n    with_dump = None\n\n\n# /***********************************************************************\n# //\n# ************************************************************************/\n\ndef strip_with_dump(dump_fn, eh, idata):\n    new_len = 0\n    lines = open(dump_fn, \"rb\").readlines()\n    for l in lines:\n        l = re.sub(r\"\\s+\", \" \", l.strip())\n        f = l.split(\" \")\n        if len(f) >= 8:\n            if f[7].startswith(\"CONTENTS\"):\n                sh_offset = int(\"0x\" + f[5], 16)\n                sh_size   = int(\"0x\" + f[2], 16)\n                if sh_offset + sh_size > new_len:\n                    new_len = sh_offset + sh_size\n                    ##print sh_offset, sh_size, f\n    if new_len > len(eh):\n        ##print dump_fn, new_len\n        return eh, idata[:new_len-len(eh)]\n    return eh, idata\n\n\n# /***********************************************************************\n# // FIXME - this is only a first stub version\n# ************************************************************************/\n\ndef check_dump(dump_fn):\n    lines = open(dump_fn, \"rb\").readlines()\n    lines = map(lambda l: re.sub(r\"\\s+\", \" \", l.strip()).strip(), lines)\n    lines = filter(None, lines)\n    d = \"\\n\".join(lines)\n    psections = d.find(\"Sections:\\n\")\n    psymbols  = d.find(\"SYMBOL TABLE:\\n\")\n    prelocs   = d.find(\"RELOCATION RECORDS FOR \");\n    if prelocs == -1: # no relocations\n        prelocs = len(d)\n    assert 0 <= psections < psymbols < prelocs\n    # preprocessSections\n    sections = []\n    section_names = {}\n    for l in d[psections:psymbols].split(\"\\n\")[2:]:\n        if not l: continue\n        f = l.split(\" \")\n        assert len(f) >= 8, (l, f)\n        assert f[6].startswith(\"2**\"), (l, f)\n        assert f[7].startswith(\"CONTENTS\"), (l, f)\n        assert int(f[0], 10) == len(sections)\n        e = f[1], int(f[2], 16), int(f[5], 16), int(f[6][3:], 10), len(sections)\n        sections.append(e)\n        assert not section_names.has_key(e[0]), e\n        assert not e[0].endswith(\":\"), (\"bad section name\", e)\n        section_names[e[0]] = e\n    ##print sections\n    # preprocessSymbols\n    symbols = []\n    section = None\n    for l in d[psymbols:prelocs].split(\"\\n\")[1:]:\n        if not l: continue\n        f = l.split(\" \")\n        if len(f) == 6:\n            assert f[1] in \"gl\", (l, f)\n            assert f[2] in \"dFO\", (l, f)\n            section = section_names[f[3]]\n        elif len(f) == 5 and f[2] == \"*ABS*\":\n            pass\n        elif len(f) == 5:\n            assert f[1] in \"gl\", (l, f)\n            section = section_names[f[2]]\n        elif len(f) == 4:\n            assert f[1] in [\"*UND*\"], (l, f)\n            section = None\n        else:\n            assert 0, (l, f)\n        pass\n    # preprocessRelocations\n    relocs = []\n    section = None\n    for l in d[prelocs:].split(\"\\n\")[1:]:\n        if not l: continue\n        m = re.search(r\"^RELOCATION RECORDS FOR \\[(.+)\\]\", l)\n        if m:\n            section = section_names[m.group(1)]\n            continue\n        f = l.split(\" \")\n        if f[0] == \"OFFSET\": continue\n        assert len(f) == 3, (l, f)\n        pass\n\n\n# /***********************************************************************\n# //\n# ************************************************************************/\n\ndef do_file(fn):\n    odata = None\n    if opts.dry_run:\n        fp = open(fn, \"rb\")\n    else:\n        fp = open(fn, \"r+b\")\n    fp.seek(0, 0)\n    idata = fp.read()\n    if idata[:4] != \"\\x7f\\x45\\x4c\\x46\":\n        raise Exception(\"%s is not %s\" % (fn, \"ELF\"))\n    if idata[4:7] == \"\\x01\\x01\\x01\":\n        # ELF32 LE\n        eh, idata = idata[:52], idata[52:]\n        e_shnum, e_shstrndx = struct.unpack(\"<HH\", eh[48:52])\n        assert e_shstrndx + 3 == e_shnum\n        ##eh = eh[:48] + struct.pack(\"<HH\", e_shnum - 3, e_shstrndx)\n    elif idata[4:7] == \"\\x01\\x02\\x01\":\n        # ELF32 BE\n        eh, idata = idata[:52], idata[52:]\n        e_shnum, e_shstrndx = struct.unpack(\">HH\", eh[48:52])\n        assert e_shstrndx + 3 == e_shnum\n    elif idata[4:7] == \"\\x02\\x01\\x01\":\n        # ELF64 LE\n        eh, idata = idata[:64], idata[64:]\n        e_shnum, e_shstrndx = struct.unpack(\"<HH\", eh[60:64])\n        assert e_shstrndx + 3 == e_shnum\n    elif idata[4:7] == \"\\x02\\x02\\x01\":\n        # ELF64 BE\n        eh, idata = idata[:64], idata[64:]\n        e_shnum, e_shstrndx = struct.unpack(\">HH\", eh[60:64])\n        assert e_shstrndx + 3 == e_shnum\n    else:\n        raise Exception(\"%s is not %s\" % (fn, \"ELF\"))\n\n    odata = None\n    pos = idata.find(\"\\0.symtab\\0.strtab\\0.shstrtab\\0\")\n    if opts.with_dump:\n        eh, odata = strip_with_dump(opts.with_dump, eh, idata)\n        # Other compilers can intermix the contents of .rela sections\n        # with PROGBITS sections.  This happens on powerpc64le and arm64.\n        # The general solution probably requires a C++ program\n        # that combines \"objcopy -R\", \"objdump -htr\", and xstrip.\n        if re.search(r\"^powerpc64\", os.path.basename(fn)):\n            assert pos >= len(odata), (\"unexpected strip_with_dump\", pos, len(odata))\n        elif re.search(r\"^arm64-\", os.path.basename(fn)):\n            assert pos >= len(odata), (\"unexpected strip_with_dump\", pos, len(odata))\n        else:\n            assert pos == len(odata), (\"unexpected strip_with_dump\", pos, len(odata))\n    else:\n        if pos >= 0:\n            odata = idata[:pos]\n\n    if eh and odata and not opts.dry_run:\n        fp.seek(0, 0)\n        fp.write(eh[:-4])  # all but e_shnum, e_shstrndx\n        fp.write(struct.pack(\"I\", 0))  # clear e_shnum, e_shstrndx\n        fp.write(odata)\n        fp.truncate()\n    fp.close()\n\n\ndef main(argv):\n    try: assert 0\n    except AssertionError: pass\n    else: raise Exception(\"fatal error - assertions not enabled\")\n    shortopts, longopts = \"qv\", [\n        \"dry-run\", \"quiet\", \"verbose\", \"with-dump=\"\n    ]\n    xopts, args = getopt.gnu_getopt(argv[1:], shortopts, longopts)\n    for opt, optarg in xopts:\n        if 0: pass\n        elif opt in [\"-q\", \"--quiet\"]: opts.verbose = opts.verbose - 1\n        elif opt in [\"-v\", \"--verbose\"]: opts.verbose = opts.verbose + 1\n        elif opt in [\"--dry-run\"]: opts.dry_run = opts.dry_run + 1\n        elif opt in [\"--with-dump\"]: opts.with_dump = optarg\n        else: assert 0, (\"getopt problem:\", opt, optarg, xopts, args)\n    if not args:\n        raise Exception(\"error: no arguments given\")\n    if opts.with_dump or opts.bindump:\n        assert len(args) == 1, \"need exactly one file\"\n    # process arguments\n    for arg in args:\n        do_file(arg)\n        check_dump(opts.with_dump);\n    return 0\n\n\nif __name__ == \"__main__\":\n    sys.exit(main(sys.argv))\n","size_bytes":7896},"src/stub/src/MAX_ELF_HDR.c":{"content":"#define MAX_ELF_HDR_32 512\n#define MAX_ELF_HDR_64 1024\n","size_bytes":55},"src/stub/src/amd64-darwin.macho-main.c":{"content":"/* amd64-darwin.macho-main.c -- loader stub for Mach-o AMD64\n\n   This file is part of the UPX executable compressor.\n\n   Copyright (C) 1996-2025 Markus Franz Xaver Johannes Oberhumer\n   Copyright (C) 1996-2025 Laszlo Molnar\n   Copyright (C) 2000-2025 John F. Reiser\n   All Rights Reserved.\n\n   UPX and the UCL library are free software; you can redistribute them\n   and/or modify them under the terms of the GNU General Public License as\n   published by the Free Software Foundation; either version 2 of\n   the License, or (at your option) any later version.\n\n   This program is distributed in the hope that it will be useful,\n   but WITHOUT ANY WARRANTY; without even the implied warranty of\n   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n   GNU General Public License for more details.\n\n   You should have received a copy of the GNU General Public License\n   along with this program; see the file COPYING.\n   If not, write to the Free Software Foundation, Inc.,\n   59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.\n\n   Markus F.X.J. Oberhumer              Laszlo Molnar\n   <markus@oberhumer.com>               <ezerotven+github@gmail.com>\n\n   John F. Reiser\n   <jreiser@users.sourceforge.net>\n */\n\n\n#define __WORDSIZE 64\n#include \"include/darwin.h\"\n\n#define SIMULATE_ON_LINUX_EABI4 0\n\n#if defined(__arm__)  //{\n#define DEBUG 0  /* __arm__ */\n#endif  //}\n\n#if defined(__aarch64__)  //{\n#define DEBUG 0  /* __aarch64__ */\n#endif  //}\n\n#ifndef DEBUG  /*{*/\n#define DEBUG 0\n#endif  /*}*/\n\n/*************************************************************************\n// configuration section\n**************************************************************************/\n\n// In order to make it much easier to move this code at runtime and execute\n// it at an address different from it load address:  there must be no\n// static data, and no string constants.\n\n#if !DEBUG //{\n#define DPRINTF(fmt, args...) /*empty*/\n#else  //}{\n// DPRINTF is defined as an expression using \"({ ... })\"\n// so that DPRINTF can be invoked inside an expression,\n// and then followed by a comma to ignore the return value.\n// The only complication is that percent and backslash\n// must be doubled in the format string, because the format\n// string is processed twice: once at compile-time by 'asm'\n// to produce the assembled value, and once at runtime to use it.\n#if defined(__powerpc__)  //{\n#define DPRINTF(fmt, args...) ({ \\\n    char const *r_fmt; \\\n    asm(\"bl 0f; .string \\\"\" fmt \"\\\"; .balign 4; 0: mflr %0\" \\\n/*out*/ : \"=r\"(r_fmt) \\\n/* in*/ : \\\n/*und*/ : \"lr\"); \\\n    dprintf(r_fmt, args); \\\n})\n#elif defined(__x86_64) //}{\n#define DPRINTF(fmt, args...) ({ \\\n    char const *r_fmt; \\\n    asm(\"call 0f; .asciz \\\"\" fmt \"\\\"; 0: pop %0\" \\\n/*out*/ : \"=r\"(r_fmt) ); \\\n    dprintf(r_fmt, args); \\\n})\n#elif defined(__aarch64__) //}{\n#define DPRINTF(fmt, args...) ({ \\\n    char const *r_fmt; \\\n    asm(\"bl 0f; .string \\\"\" fmt \"\\\"; .balign 4; 0: mov %0,x30\" \\\n/*out*/ : \"=r\"(r_fmt) \\\n/* in*/ : \\\n/*und*/ : \"x30\"); \\\n    dprintf(r_fmt, args); \\\n})\n#elif defined(__arm__)  //}{\n#define DPRINTF(fmt, args...) ({ \\\n    char const *r_fmt; \\\n    asm(\"bl 0f; .string \\\"\" fmt \"\\\"; .balign 4; 0: mov %0,lr\" \\\n/*out*/ : \"=r\"(r_fmt) \\\n/* in*/ : \\\n/*und*/ : \"lr\"); \\\n    dprintf(r_fmt, args); \\\n})\n#endif  //}\n\nstatic int dprintf(char const *fmt, ...); // forward\n#endif  /*}*/\n\n\n/*************************************************************************\n// \"file\" util\n**************************************************************************/\n\ntypedef struct {\n    size_t size;  // must be first to match size[0] uncompressed size\n    void *buf;\n} Extent;\n\nstatic void\nxread(Extent *x, void *buf, size_t count)\n{\n    unsigned char *p=x->buf, *q=buf;\n    size_t j;\n    DPRINTF(\"xread %%p(%%x %%p) %%p %%x\\\\n\", x, x->size, x->buf, buf, count);\n    if (x->size < count) {\n        DPRINTF(\"xreadfail %%p(%%x %%p) %%p %%x\\\\n\",\n            x, x->size, x->buf, buf, count);\n        exit(127);\n    }\n    for (j = count; 0!=j--; ++p, ++q) {\n        *q = *p;\n    }\n    DPRINTF(\"   buf: %%x %%x %%x\\\\n\", ((int *)buf)[0], ((int *)buf)[1], ((int *)buf)[2]);\n    x->buf  += count;\n    x->size -= count;\n}\n\nstatic void\nxpeek(Extent *x, void *buf, size_t count)\n{\n    DPRINTF(\"xpeek buf=%%p  count=%%x  \", buf, count);\n    xread(x, buf, count);\n    x->size += count;\n    x->buf  -= count;\n}\n\n/*************************************************************************\n// util\n**************************************************************************/\n\n#if 0  //{  save space\n#define ERR_LAB error: exit(127);\n#define err_exit(a) goto error\n#else  //}{  save debugging time\n#define ERR_LAB /*empty*/\n\nstatic void\nerr_exit(int a)\n{\n    DPRINTF(\"err_exit %%x\\\\n\", a);\n    (void)a;  // debugging convenience\n    exit(a);\n}\n#endif  //}\n\n\n/*************************************************************************\n// UPX & NRV stuff\n**************************************************************************/\n\nstruct l_info { // 12-byte trailer for loader (after macho headers)\n    unsigned l_checksum;\n    unsigned l_magic;  // UPX_MAGIC_LE32\n    unsigned short l_lsize;\n    unsigned char l_version;\n    unsigned char l_format;\n};\nstruct p_info { // 12-byte packed program header\n    unsigned p_progid;\n    unsigned p_filesize;\n    unsigned p_blocksize;\n};\n\nstruct b_info { // 12-byte header before each compressed block\n    unsigned sz_unc;  // uncompressed_size\n    unsigned sz_cpr;  //   compressed_size\n    unsigned char b_method;  // compression algorithm\n    unsigned char b_ftid;  // filter id\n    unsigned char b_cto8;  // filter parameter\n    unsigned char b_extra;\n};\n\ntypedef void f_unfilter(\n    nrv_byte *,  // also addvalue\n    nrv_uint,\n    unsigned cto8, // junk in high 24 bits\n    unsigned ftid\n);\ntypedef int f_expand(\n    const nrv_byte *, nrv_uint,\n          nrv_byte *, size_t *, unsigned );\n\nstatic void\nunpackExtent(\n    Extent *const xi,  // input\n    Extent *const xo,  // output\n    f_expand *const f_exp,\n    f_unfilter *f_unf\n)\n{\n    DPRINTF(\"unpackExtent in=%%p(%%x %%p)  out=%%p(%%x %%p)  %%p %%p\\\\n\",\n        xi, xi->size, xi->buf, xo, xo->size, xo->buf, f_exp, f_unf);\n    while (xo->size) {\n        struct b_info h;\n        //   Note: if h.sz_unc == h.sz_cpr then the block was not\n        //   compressible and is stored in its uncompressed form.\n\n        // Read and check block sizes.\n        xread(xi, (unsigned char *)&h, sizeof(h));\n        if (h.sz_unc == 0) {                     // uncompressed size 0 -> EOF\n            if (h.sz_cpr != UPX_MAGIC_LE32)      // h.sz_cpr must be h->magic\n                err_exit(2);\n            if (xi->size != 0)                 // all bytes must be written\n                err_exit(3);\n            break;\n        }\n        if (h.sz_cpr <= 0) {\n            err_exit(4);\nERR_LAB\n        }\n        if (h.sz_cpr > h.sz_unc\n        ||  h.sz_unc > xo->size ) {\n            DPRINTF(\"sz_cpr=%%x  sz_unc=%%x  xo->size=%%x\\\\n\",\n                h.sz_cpr, h.sz_unc, xo->size);\n            err_exit(5);\n        }\n        // Now we have:\n        //   assert(h.sz_cpr <= h.sz_unc);\n        //   assert(h.sz_unc > 0 && h.sz_unc <= blocksize);\n        //   assert(h.sz_cpr > 0 && h.sz_cpr <= blocksize);\n\n        if (h.sz_cpr < h.sz_unc) { // Decompress block\n            size_t out_len = h.sz_unc;  // EOF for lzma\n            int const j = (*f_exp)(xi->buf, h.sz_cpr,\n                xo->buf, &out_len, h.b_method);\n            if (j != 0 || out_len != (nrv_uint)h.sz_unc)\n                err_exit(7);\n            if (h.b_ftid!=0 && f_unf) {  // have filter\n                (*f_unf)(xo->buf, out_len, h.b_cto8, h.b_ftid);\n            }\n            xi->buf  += h.sz_cpr;\n            xi->size -= h.sz_cpr;\n        }\n        else { // copy literal block\n            xi->size += sizeof(h);  // xread(xi, &h, sizeof(h)) was a peek\n            xread(xi, xo->buf, h.sz_cpr);\n        }\n        xo->buf  += h.sz_unc;\n        xo->size -= h.sz_unc;\n    }\n}\n\nstatic void\nupx_bzero(unsigned char *p, size_t len)\n{\n    if (len) do {\n        *p++= 0;\n    } while (--len);\n}\n#define bzero upx_bzero\n\n\n// The PF_* and PROT_* bits are {1,2,4}; the conversion table fits in 32 bits.\n#define REP8(x) \\\n    ((x)|((x)<<4)|((x)<<8)|((x)<<12)|((x)<<16)|((x)<<20)|((x)<<24)|((x)<<28))\n#define EXP8(y) \\\n    ((1&(y)) ? 0xf0f0f0f0 : (2&(y)) ? 0xff00ff00 : (4&(y)) ? 0xffff0000 : 0)\n#define PF_TO_PROT(pf) \\\n    ((PROT_READ|PROT_WRITE|PROT_EXEC) & ( \\\n        ( (REP8(PROT_EXEC ) & EXP8(PF_X)) \\\n         |(REP8(PROT_READ ) & EXP8(PF_R)) \\\n         |(REP8(PROT_WRITE) & EXP8(PF_W)) \\\n        ) >> ((pf & (PF_R|PF_W|PF_X))<<2) ))\n\ntypedef struct {\n    unsigned magic;\n    unsigned nfat_arch;\n} Fat_header;\ntypedef struct {\n    unsigned cputype;\n    unsigned cpusubtype;\n    unsigned offset;\n    unsigned size;\n    unsigned align;  /* shift count (log base 2) */\n} Fat_arch;\n    enum e8 {\n        FAT_MAGIC = 0xcafebabe,\n        FAT_CIGAM = 0xbebafeca\n    };\n    enum e9 {\n        CPU_TYPE_I386      =          7,\n        CPU_TYPE_AMD64     = 0x01000007,\n        CPU_TYPE_ARM       =         12,\n        CPU_TYPE_POWERPC   = 0x00000012,\n        CPU_TYPE_POWERPC64 = 0x01000012\n    };\n\ntypedef struct {\n    unsigned magic;\n    unsigned cputype;\n    unsigned cpysubtype;\n    unsigned filetype;\n    unsigned ncmds;\n    unsigned sizeofcmds;\n    unsigned flags;\n#if defined(__x86_64__) || defined(__aarch64__)  //{\n    unsigned reserved;  // for 64-bit alignment\n#endif  //}\n} Mach_header;  // also Mach_header64 which has 4 more bytes\n        enum e0 {\n            MH_MAGIC   =   0xfeedface,\n            MH_MAGIC64 = 1+0xfeedface\n        };\n        enum e2 {\n            MH_EXECUTE = 2,\n            MH_DYLINKER= 7     /* /usr/bin/dyld */\n        };\n        enum e3 {\n            MH_NOUNDEFS = 1\n            , MH_PIE      = 0x200000   // ASLR\n        };\n\ntypedef struct {\n    unsigned cmd;\n    unsigned cmdsize;\n} Mach_load_command;\n        enum e4 {\n//            LC_SEGMENT       = 0x1,\n//            LC_SEGMENT_64    = 0x19,\n            LC_THREAD        = 0x4,\n            LC_UNIXTHREAD    = 0x5,\n            LC_LOAD_DYLINKER = 0xe\n        };\n\ntypedef struct {\n    unsigned cmd;\n    unsigned cmdsize;\n    char segname[16];\n    uint64_t vmaddr;\n    uint64_t vmsize;\n    uint64_t fileoff;\n    uint64_t filesize;\n    unsigned maxprot;\n    unsigned initprot;\n    unsigned nsects;\n    unsigned flags;\n} Mach_segment_command;\n        enum e5 {\n            VM_PROT_READ = 1,\n            VM_PROT_WRITE = 2,\n            VM_PROT_EXECUTE = 4\n        };\n\ntypedef struct {\n    char sectname[16];\n    char segname[16];\n    uint64_t addr;   /* memory address */\n    uint64_t size;   /* size in bytes */\n    unsigned offset; /* file offset */\n    unsigned align;  /* power of 2 */\n    unsigned reloff; /* file offset of relocation entries */\n    unsigned nreloc; /* number of relocation entries */\n    unsigned flags;  /* section type and attributes */\n    unsigned reserved1;  /* for offset or index */\n    unsigned reserved2;  /* for count or sizeof */\n} Mach_section_command;\n\ntypedef struct {\n    uint32_t cmd;  // LC_MAIN;  MH_EXECUTE only\n    uint32_t cmdsize;  // 24\n    uint64_t entryoff;  // file offset of main() [expected in __TEXT]\n    uint64_t stacksize;  // non-default initial stack size\n} Mach_main_command;\n\n#if defined(__aarch64__)  // {\ntypedef struct {\n    uint64_t x0,  x1,  x2,  x3;\n    uint64_t x4,  x5,  x6,  x7;\n    uint64_t x8,  x9,  x10, x11;\n    uint64_t x12, x13, x14, x15;\n    uint64_t x16, x17, x18, x19;\n    uint64_t x20, x21, x22, x23;\n    uint64_t x24, x25, x26, x27;\n    uint64_t x28, fp,  lr,  sp;\n    uint64_t pc;\n    uint32_t cpsr;\n} Mach_thread_state;  // Mach_ARM64_thread_state\n        enum e6 {\n            THREAD_STATE = 4  // ARM64_THREAD_STATE\n        };\n        enum e7 {\n            THREAD_STATE_COUNT = sizeof(Mach_thread_state)/4\n        };\n        enum e10 {\n            LC_SEGMENT       = 0x19  // LC_SEGMENT_64\n        };\n\n#elif defined(__arm__)  //}{\ntypedef struct {\n    uint32_t r[13];  // r0-r12\n    uint32_t sp;  // r13\n    uint32_t lr;  // r14\n    uint32_t pc;  // r15\n    uint32_t cpsr;\n} Mach_thread_state;  // Mach_ARM_thead_state;\n        enum e6 {\n            THREAD_STATE = 1  // ARM_THREAD_STATE\n        };\n        enum e7 {\n            THREAD_STATE_COUNT = sizeof(Mach_thread_state)/4\n        };\n        enum e10 {\n            LC_SEGMENT       = 0x1\n        };\n\n#elif defined(__x86_64__)  //}{\ntypedef struct {\n    uint64_t rax, rbx, rcx, rdx;\n    uint64_t rdi, rsi, rbp, rsp;\n    uint64_t  r8,  r9, r10, r11;\n    uint64_t r12, r13, r14, r15;\n    uint64_t rip, rflags;\n    uint64_t cs, fs, gs;\n} Mach_thread_state;  // Mach_AMD64_thread_state;\n        enum e6 {\n            THREAD_STATE = 4  // AMD_THREAD_STATE\n        };\n        enum e7 {\n            THREAD_STATE_COUNT = sizeof(Mach_thread_state)/4\n        };\n        enum e10 {\n            LC_SEGMENT       = 0x19  // LC_SEGMENT_64\n        };\n\n#endif  //}\n\ntypedef struct {\n    unsigned cmd;            /* LC_THREAD or  LC_UNIXTHREAD */\n    unsigned cmdsize;        /* total size of this command */\n    unsigned flavor;\n    unsigned count;          /* sizeof(following_thread_state)/4 */\n    Mach_thread_state state;\n} Mach_thread_command;\n\ntypedef union {\n    unsigned offset;  /* from start of load command to string */\n} Mach_lc_str;\n\n#define MAP_FIXED     0x10\n#define MAP_PRIVATE   0x02\n\n#if SIMULATE_ON_LINUX_EABI4  //{\n#define MAP_ANON  0x20  /* SIMULATE_ON_LINUX_EABI4 */\n#else  //}{\n#define MAP_ANON    0x1000  /* native darwin usual case */\n#endif  //}\n#define MAP_ANON_FD    -1\n\n#define PROT_NONE      0\n#define PROT_READ      1\n#define PROT_WRITE     2\n#define PROT_EXEC      4\n\nextern void *mmap(void *, size_t, unsigned, unsigned, int, off_t_upx_stub);\nssize_t pread(int, void *, size_t, off_t_upx_stub);\nextern void bswap(void *, unsigned);\n\ntypedef size_t Addr;  // this source file is used by 32-bit and 64-bit machines\n\nvoid my_bkpt(void const *foo, ...)\n{\n    (void)foo;\n#if defined(__x86_64__)  //{\n    __asm__(\".byte 0xcc\");\n#elif  defined(__aarch64__)  //}{\n     __asm__(\"brk #0\");\n#elif  defined(__arm__)  //}{\n     __asm__(\".long 0xe7f001f0\"); // \"bkpt\" ==> \"udf #16\"\n#endif  //}\n}\n\n// Find convex hull of PT_LOAD (the minimal interval which covers all PT_LOAD),\n// and mmap that much, to be sure that a kernel using exec-shield-randomize\n// won't place the first piece in a way that leaves no room for the rest.\nstatic Addr // returns relocation constant\nxfind_pages(\n    Mach_header const *const mhdr,\n    Mach_segment_command const *sc,\n    int const ncmds,\n    Addr addr\n)\n{\n    Addr lo= ~(Addr)0, hi= 0;\n    int j;\n    unsigned mflags = ((mhdr->filetype == MH_DYLINKER || mhdr->flags & MH_PIE) ? 0 : MAP_FIXED);\n    mflags += MAP_PRIVATE | MAP_ANON;  // '+' can optimize better than '|'\n    DPRINTF(\"xfind_pages  mhdr=%%p  sc=%%p  ncmds=%%d  addr=%%p  mflags=%%x\\\\n\",\n        mhdr, sc, ncmds, addr, mflags);\n    for (j=0; j < ncmds; ++j,\n        (sc = (Mach_segment_command const *)((sc->cmdsize>>2) + (unsigned const *)sc))\n    ) if (LC_SEGMENT==sc->cmd) {\n        DPRINTF(\"  #%%d  cmd=%%x  cmdsize=%%x  vmaddr=%%p  vmsize==%%p  filesize=%%p  lo=%%p  mflags=%%x\\\\n\",\n            j, sc->cmd, sc->cmdsize, sc->vmaddr, sc->vmsize, sc->filesize, lo, mflags);\n        if (sc->vmsize  // theoretically occupies address space\n        &&  !(sc->vmaddr==0 && (MAP_FIXED & mflags))  // but ignore PAGEZERO when MAP_FIXED\n        ) {\n            if (mhdr->filetype == MH_DYLINKER  // /usr/lib/dyld\n            &&  0==(1+ lo)  // 1st LC_SEGMENT\n            &&  sc->vmaddr != 0  // non-floating address\n            ) {\n                // \"pre-linked\" dyld on MacOS 10.11.x El Capitan\n                mflags |= MAP_FIXED;\n            }\n            if (lo > sc->vmaddr) {\n                lo = sc->vmaddr;\n            }\n            if (hi < (sc->vmsize + sc->vmaddr)) {\n                hi =  sc->vmsize + sc->vmaddr;\n            }\n        }\n    }\n    lo -= ~PAGE_MASK & lo;  // round down to page boundary\n    hi  =  PAGE_MASK & (hi - lo - PAGE_MASK -1);  // page length\n    DPRINTF(\"  addr=%%p  lo=%%p  len=%%p  mflags=%%x\\\\n\", addr, lo, hi, mflags);\n    if (MAP_FIXED & mflags) {\n        addr = lo;\n        int rv = munmap((void *)addr, hi);\n        if (rv) {\n            DPRINTF(\"munmap addr=%%p len=%%p, rv=%%x\\\\n\", addr, hi, rv);\n        }\n    }\n    addr = (Addr)mmap((void *)addr, hi, PROT_NONE, mflags, MAP_ANON_FD, 0);\n    DPRINTF(\"  addr=%%p\\\\n\", addr);\n    if (~PAGE_MASK & addr) {\n        err_exit(6);\n    }\n    return (Addr)(addr - lo);\n}\n\nunsigned * // &hatch if main; &Mach_thread_state if dyld\ndo_xmap(\n    Mach_header *const mhdr,\n    off_t_upx_stub const fat_offset,\n    Extent *const xi,\n    int const fdi,\n    Mach_header **mhdrpp,\n    f_expand *const f_exp,\n    f_unfilter *const f_unf\n)\n{\n    DPRINTF(\"do_xmap  fdi=%%x  mhdr=%%p  *mhdrpp=%%p  xi=%%p(%%x %%p) f_unf=%%p\\\\n\",\n        fdi, mhdr, (mhdrpp ? *mhdrpp : 0), xi, (xi? xi->size: 0), (xi? xi->buf: 0), f_unf);\n\n    unsigned *rv = 0;\n    Extent xi_orig = {0, 0};\n    Mach_segment_command *sc = (Mach_segment_command *)(1+ mhdr);\n    Addr const reloc = xfind_pages(mhdr, sc, mhdr->ncmds, 0);\n    DPRINTF(\"do_xmap reloc=%%p\\\\n\", reloc);\n    unsigned j;\n    if (xi) { // remember \"Beginning of tape\"\n        xi_orig = *xi;\n    }\n    for ( j=0; j < mhdr->ncmds; ++j,\n        (sc = (Mach_segment_command *)((sc->cmdsize>>2) + (unsigned *)sc))\n    ) {\n        DPRINTF(\"  #%%d  sc=%%x  cmd=%%x  cmdsize=%%x  vmsize=%%x\\\\n\",\n                j, sc, sc->cmd, sc->cmdsize, sc->vmsize);\n        if (LC_SEGMENT==sc->cmd) {\n            struct b_info h;\n            if (xi && sc->filesize) { // Find the correct compressed block.\n                xpeek(xi, (unsigned char *)&h, sizeof(h));\n                DPRINTF(\"  h.b_extra=%%d  j=%%d\\n\", h.b_extra, j);\n                if (h.b_extra != j) { // not the next one\n                    *xi = xi_orig;  // rewind\n                    for (;;) {\n                        xpeek(xi, (unsigned char *)&h, sizeof(h));\n                        if (h.b_extra == j) {\n                            break;\n                        }\n                        xi->size -= sizeof(h) + h.sz_cpr;\n                        xi->buf  += sizeof(h) + h.sz_cpr;\n                    }\n                }\n            }\n            if (!sc->vmsize) { // not mapped, such as __DWARF info for 'go'\n                if (xi) {\n                    DPRINTF(\"    0==.vmsize; skipping %%x\\\\n\", h.sz_cpr);\n                    xi->size -= sizeof(h) + h.sz_cpr;\n                    xi->buf  += sizeof(h) + h.sz_cpr;\n                }\n                continue;  // redundant for clarity\n            }\n            else { // finally, some meat!\n                Extent xo;\n                size_t mlen = xo.size = sc->filesize;\n                              xo.buf  = (void *)(reloc + sc->vmaddr);\n                Addr  addr = (Addr)xo.buf;\n                Addr haddr = sc->vmsize + addr;\n                size_t frag = addr &~ PAGE_MASK;\n                addr -= frag;\n                mlen += frag;\n\n                DPRINTF(\"    mlen=%%p  frag=%%p  addr=%%p\\\\n\", mlen, frag, addr);\n                if (0!=mlen) {\n                    size_t const mlen3 = mlen\n        #if defined(__x86_64__)  //{\n                        // Decompressor can overrun the destination by 3 bytes.  [x86 only]\n                        + (xi ? 3 : 0)\n        #endif  //}\n                        ;\n                    unsigned const prot = VM_PROT_READ | VM_PROT_WRITE;\n                    // MAP_FIXED: xfind_pages() reserved them, so use them!\n                    unsigned const flags = MAP_FIXED | MAP_PRIVATE |\n                                    ((xi || 0==sc->filesize) ? MAP_ANON    : 0);\n                    int const fdm = ((xi || 0==sc->filesize) ? MAP_ANON_FD : fdi);\n                    off_t_upx_stub const offset = sc->fileoff + fat_offset;\n\n                    DPRINTF(\"mmap  addr=%%p  len=%%p  prot=%%x  flags=%%x  fd=%%d  off=%%p  reloc=%%p\\\\n\",\n                        addr, mlen3, prot, flags, fdm, offset, reloc);\n                    {\n                        Addr maddr = (Addr)mmap((void *)addr, mlen3, prot, flags, fdm, offset);\n                        DPRINTF(\"maddr=%%p\\\\n\", maddr);\n                        if (maddr != addr) {\n                            err_exit(8);\n                        }\n                        addr = maddr;\n                    }\n                    if (!*mhdrpp) { // MH_DYLINKER\n                        *mhdrpp = (Mach_header*)addr;\n                    }\n                }\n                if (xi && 0!=sc->filesize) {\n                    if (0==sc->fileoff /*&& 0!=mhdrpp*/) {\n                        *mhdrpp = (Mach_header *)(void *)addr;\n                    }\n                    unpackExtent(xi, &xo, f_exp, f_unf);\n                }\n                DPRINTF(\"xi=%%p  mlen=%%p  fileoff=%%p  nsects=%%d\\\\n\",\n                    xi, mlen, sc->fileoff, sc->nsects);\n                if (xi && mlen && !sc->fileoff && sc->nsects) {\n                    // main target __TEXT segment at beginning of file with sections (__text)\n                    // Use upto 2 words of header padding for the escape hatch.\n                    // fold.S could do this easier, except PROT_WRITE is missing then.\n                    union {\n                        unsigned char  *p0;\n                        unsigned short *p1;\n                        unsigned int   *p2;\n                        unsigned long  *p3;\n                    } u;\n                    u.p0 = (unsigned char *)addr;\n                    Mach_segment_command *segp = (Mach_segment_command *)((((char *)sc - (char *)mhdr)>>2) + u.p2);\n                    Mach_section_command *const secp = (Mach_section_command *)(1+ segp);\n        #if defined(__aarch64__)  //{\n                    unsigned *hatch= -2+ (secp->offset>>2) + u.p2;\n                    hatch[0] = 0xd4000001;  // svc #0  // syscall\n                    hatch[1] = 0xd65f03c0;  // ret\n        #elif defined(__arm__)  //}{\n                    unsigned *hatch= -2+ (secp->offset>>2) + u.p2;\n                    hatch[0] = 0xef000000;  // svc 0x0  // syscall\n                    hatch[1] = 0xe12fff1e;  // bx lr\n        #elif defined(__x86_64__)  //}{\n                    unsigned *hatch= -1+ (secp->offset>>2) + u.p2;\n                    hatch[0] = 0xc3050f90;  // nop; syscall; ret\n        #endif  //}\n                    DPRINTF(\"hatch=%%p  secp=%%p  segp=%%p  mhdr=%%p\\\\n\", hatch, secp, segp, addr);\n                    rv = hatch;\n                }\n                /*bzero(addr, frag);*/  // fragment at lo end\n                frag = (-mlen) &~ PAGE_MASK;  // distance to next page boundary\n                bzero((void *)(mlen+addr), frag);  // fragment at hi end\n                if (0!=mlen && 0!=mprotect((void *)addr, mlen, sc->initprot)) {\n                    err_exit(10);\n        ERR_LAB\n                }\n                addr += mlen + frag;  /* page boundary on hi end */\n                if (\n        #if SIMULATE_ON_LINUX_EABI4  /*{*/\n                    0!=addr &&\n        #endif  /*}*/\n                                addr < haddr) { // need pages for .bss\n                    if (0!=addr && addr != (Addr)mmap((void *)addr, haddr - addr, sc->initprot,\n                            MAP_FIXED | MAP_PRIVATE | MAP_ANON, MAP_ANON_FD, 0 ) ) {\n                        err_exit(9);\n                    }\n                }\n                else if (xi) { // cleanup if decompressor overrun crosses page boundary\n                    mlen = ~PAGE_MASK & (3+ mlen);\n                    if (mlen<=3) { // page fragment was overrun buffer only\n                        DPRINTF(\"munmap  %%x  %%x\\\\n\", addr, mlen);\n                        munmap((char *)addr, mlen);\n                    }\n                }\n            }\n        }\n        else if (!xi  // dyld\n        && (LC_UNIXTHREAD==sc->cmd || LC_THREAD==sc->cmd)) {\n            Mach_thread_command *const thrc = (Mach_thread_command *)sc;\n            DPRINTF(\"thread_command= %%p\\\\n\", sc);\n            if (1\n            // FIXME  THREAD_STATE      ==thrc->flavor\n            //    &&  THREAD_STATE_COUNT==thrc->count\n            ) {\n                DPRINTF(\"thread_state= %%p  flavor=%%d  count=%%x  reloc=%%p\\\\n\",\n                    &thrc->state, thrc->flavor, thrc->count, reloc);\n    #if defined(__aarch64__)  //{\n                thrc->state.pc += reloc;\n    #elif defined(__arm__)  //}{\n                thrc->state.pc += reloc;\n    #elif defined(__x86_64__)  //}{\n                thrc->state.rip += reloc;\n    #endif  //}\n                rv = (unsigned *)&thrc->state;\n            }\n        }\n    }\n    DPRINTF(\"do_xmap= %%p\\\\n\", rv);\n    return rv;\n}\n\n/*************************************************************************\n// upx_main - called by our unfolded entry code\n//\n**************************************************************************/\nMach_thread_state const *\nupx_main(\n    struct l_info const *const li,\n    size_t volatile sz_compressed,  // total length\n    Mach_header *const mhdr,  // temp char[sz_mhdr] for decompressing\n    size_t const sz_mhdr,\n    f_expand *const f_exp,\n    f_unfilter *const f_unf,\n    Mach_header **const mhdrpp  // Out: *mhdrpp= &real Mach_header\n)\n{\n    Mach_thread_state *ts = 0;\n    unsigned *hatch;\n    off_t_upx_stub fat_offset = 0;\n    Extent xi, xo, xi0;\n    xi.buf  = CONST_CAST(unsigned char *, 1+ (struct p_info const *)(1+ li));  // &b_info\n    xi.size = sz_compressed - (sizeof(struct l_info) + sizeof(struct p_info));\n    xo.buf  = (unsigned char *)mhdr;\n    xo.size = ((struct b_info const *)(void const *)xi.buf)->sz_unc;\n    xi0 = xi;\n\n    DPRINTF(\"upx_main szc=%%x  f_exp=%%p  f_unf=%%p  \"\n        \"  xo=%%p(%%x %%p)  xi=%%p(%%x %%p)  mhdrpp=%%p  mhdrp=%%p\\\\n\",\n        sz_compressed, f_exp, f_unf, &xo, xo.size, xo.buf,\n        &xi, xi.size, xi.buf, mhdrpp, *mhdrpp);\n\n    // Uncompress Macho headers\n    unpackExtent(&xi, &xo, f_exp, 0);  // never filtered?\n\n    // Overwrite the OS-chosen address space at *mhdrpp.\n    hatch = do_xmap(mhdr, fat_offset, &xi0, MAP_ANON_FD, mhdrpp, f_exp, f_unf);\n\n  { // Map dyld dynamic loader\n    Mach_load_command const *lc = (Mach_load_command const *)(1+ mhdr);\n    unsigned j;\n\n    for (j=0; j < mhdr->ncmds; ++j,\n        (lc = (Mach_load_command const *)(lc->cmdsize + (void const *)lc))\n    ) if (LC_LOAD_DYLINKER==lc->cmd) {\n        char const *const dyld_name = ((Mach_lc_str const *)(1+ lc))->offset +\n            (char const *)lc;\n        DPRINTF(\"dyld= %%s\\\\n\", dyld_name);\n        int const fdi = open(dyld_name, O_RDONLY, 0);\n        if (0 > fdi) {\n            err_exit(18);\n        }\nfat:\n        DPRINTF(\"fat_offset= %%p\\\\n\", fat_offset);\n        if ((ssize_t)sz_mhdr!=pread(fdi, (void *)mhdr, sz_mhdr, fat_offset)) {\nERR_LAB\n            err_exit(19);\n        }\n        switch (mhdr->magic) {\n        case MH_MAGIC: break;\n        case MH_MAGIC64: break;\n        case FAT_CIGAM:\n        case FAT_MAGIC: {\n            // stupid Apple: waste code and a page fault on EVERY execve\n            Fat_header *const fh = (Fat_header *)mhdr;\n            Fat_arch *fa = (Fat_arch *)(1+ fh);\n            bswap(fh, sizeof(*fh) + (fh->nfat_arch>>24)*sizeof(*fa));\n            for (j= 0; j < fh->nfat_arch; ++j, ++fa) {\n                if (CPU_TYPE_AMD64==fa->cputype) {\n                    fat_offset= fa->offset;\n                    goto fat;\n                }\n            }\n        } break;\n        } // switch\n        Mach_header *dyhdr = 0;\n        ts = (Mach_thread_state *)do_xmap(mhdr, fat_offset, 0, fdi, &dyhdr, 0, 0);\n            DPRINTF(\"ts= %%p  hatch=%%p\\\\n\", ts, hatch);\n#if defined(__aarch64__)  // {\n            ts->x0 = (uint64_t)hatch;\n#elif defined(__arm__)  //}{\n            ts->r[0] = (uint32_t)hatch;\n#elif defined(__x86_64__)  //}{\n            ts->rax = (uint64_t)hatch;\n#endif  //}\n        close(fdi);\n        break;\n    }\n  }\n\n    return ts;\n}\n\n#if DEBUG  //{\n\nstatic int\nunsimal(unsigned x, char *ptr, int n)\n{\n    unsigned m = 10;\n    while (10 <= (x / m)) m *= 10;\n    while (10 <= x) {\n        unsigned d = x / m;\n    x -= m * d;\n        m /= 10;\n        ptr[n++] = '0' + d;\n    }\n    ptr[n++] = '0' + x;\n    return n;\n}\n\nstatic int\ndecimal(int x, char *ptr, int n)\n{\n    if (x < 0) {\n        x = -x;\n        ptr[n++] = '-';\n    }\n    return unsimal(x, ptr, n);\n}\n\nstatic int\nheximal(unsigned long x, char *ptr, int n)\n{\n    unsigned j = -1+ 2*sizeof(unsigned long);\n    unsigned long m = 0xful << (4 * j);\n    for (; j; --j, m >>= 4) { // omit leading 0 digits\n        if (m & x) break;\n    }\n    for (; m; --j, m >>= 4) {\n        unsigned d = 0xf & (x >> (4 * j));\n        ptr[n++] = ((10<=d) ? ('a' - 10) : '0') + d;\n    }\n    return n;\n}\n\n#define va_arg      __builtin_va_arg\n#define va_end      __builtin_va_end\n#define va_list     __builtin_va_list\n#define va_start    __builtin_va_start\n\nstatic int\ndprintf(char const *fmt, ...)\n{\n    int n= 0;\n    char const *literal = 0;  // NULL\n    char buf[24];  // ~0ull == 18446744073709551615 ==> 20 chars\n    va_list va; va_start(va, fmt);\n    for (;;) {\n        char c = *fmt++;\n        if (!c) { // end of fmt\n            if (literal) {\n                goto finish;\n            }\n            break;  // goto done\n        }\n        if ('%'!=c) {\n            if (!literal) {\n                literal = fmt;  // 1 beyond start of literal\n            }\n            continue;\n        }\n        // '%' == c\n        if (literal) {\nfinish:\n            n += write(2, -1+ literal, fmt - literal);\n            literal = 0;  // NULL\n            if (!c) { // fmt already ended\n               break;  // goto done\n            }\n        }\n        switch (c= *fmt++) { // deficiency: does not handle _long_\n        default: { // un-implemented conversion\n            n+= write(2, -1+ fmt, 1);\n        } break;\n        case 0: { // fmt ends with \"%\\0\" ==> ignore\n            goto done;\n        } break;\n        case 'u': {\n            n+= write(2, buf, unsimal(va_arg(va, unsigned), buf, 0));\n        } break;\n        case 'd': {\n            n+= write(2, buf, decimal(va_arg(va, int), buf, 0));\n        } break;\n        case 'p': {\n            buf[0] = '0';\n            buf[1] = 'x';\n            n+= write(2, buf, heximal((unsigned long)va_arg(va, void *), buf, 2));\n        } break;\n        case 'x': {\n            buf[0] = '0';\n            buf[1] = 'x';\n            n+= write(2, buf, heximal(va_arg(va, unsigned int), buf, 2));\n        } break;\n        case 's': {\n            char *s0= (char *)va_arg(va, unsigned char *), *s= s0;\n            if (s) while (*s) ++s;\n            n+= write(2, s0, s - s0);\n        } break;\n        } // 'switch'\n    }\ndone:\n    va_end(va);\n    return n;\n}\n\n#endif  //}\n\n/* vim:set ts=4 sw=4 et: */\n","size_bytes":30765},"src/stub/src/amd64-darwin.macho-upxmain.c":{"content":"/* amd64-darwin.macho-upxmain.c -- loader hack for Mach-o AMD64\n\n   This file is part of the UPX executable compressor.\n\n   Copyright (C) 1996-2025 Markus Franz Xaver Johannes Oberhumer\n   Copyright (C) 1996-2025 Laszlo Molnar\n   Copyright (C) 2000-2025 John F. Reiser\n   All Rights Reserved.\n\n   UPX and the UCL library are free software; you can redistribute them\n   and/or modify them under the terms of the GNU General Public License as\n   published by the Free Software Foundation; either version 2 of\n   the License, or (at your option) any later version.\n\n   This program is distributed in the hope that it will be useful,\n   but WITHOUT ANY WARRANTY; without even the implied warranty of\n   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n   GNU General Public License for more details.\n\n   You should have received a copy of the GNU General Public License\n   along with this program; see the file COPYING.\n   If not, write to the Free Software Foundation, Inc.,\n   59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.\n\n   Markus F.X.J. Oberhumer              Laszlo Molnar\n   <markus@oberhumer.com>               <ezerotven+github@gmail.com>\n\n   John F. Reiser\n   <jreiser@users.sourceforge.net>\n */\n\n#define __WORDSIZE 64\n#include \"include/darwin.h\"\n\ntypedef unsigned char * Addr;\n\n#define SIMULATE_ON_LINUX_EABI4 0\n#ifndef DEBUG  /*{*/\n#define DEBUG 0\n#endif  /*}*/\n\n/*************************************************************************\n// configuration section\n**************************************************************************/\n\n// In order to make it much easier to move this code at runtime and execute\n// it at an address different from it load address:  there must be no\n// static data, and no string constants.\n\n#if !DEBUG  /*{*/\n#define DPRINTF(a) /* empty: no debug drivel */\n#define DEBUG_STRCON(name, value) /* empty */\n#else  /*}{ DEBUG */\nextern int write(int, void const *, size_t);\n#if 0\n#include \"stdarg.h\"\n#else\n#define va_arg      __builtin_va_arg\n#define va_end      __builtin_va_end\n#define va_list     __builtin_va_list\n#define va_start    __builtin_va_start\n#endif\n\n#if defined(__i386__) || defined(__x86_64__) /*{*/\n#define PIC_STRING(value, var) \\\n    __asm__ __volatile__ ( \\\n        \"call 0f; .asciz \\\"\" value \"\\\"; \\\n      0: pop %0;\" : \"=r\"(var) : \\\n    )\n#elif defined(__arm__)  /*}{*/\n#define PIC_STRING(value, var) \\\n    __asm__ __volatile__ ( \\\n        \"mov %0,pc; b 0f; \\\n        .asciz \\\"\" value \"\\\"; .balign 4; \\\n      0: \" : \"=r\"(var) \\\n    )\n#elif defined(__mips__)  /*}{*/\n#define PIC_STRING(value, var) \\\n    __asm__ __volatile__ ( \\\n        \".set noreorder; bal 0f; move %0,$31; .set reorder; \\\n        .asciz \\\"\" value \"\\\"; .balign 4; \\\n      0: \" \\\n        : \"=r\"(var) : : \"ra\" \\\n    )\n#endif  /*}*/\n\n\n#define DEBUG_STRCON(name, strcon) \\\n    static char const *name(void) { \\\n        register char const *rv; PIC_STRING(strcon, rv); \\\n        return rv; \\\n    }\n\n\n#ifdef __arm__  /*{*/\nextern unsigned div10(unsigned);\n#else  /*}{*/\nstatic unsigned\ndiv10(unsigned x)\n{\n    return x / 10u;\n}\n#endif  /*}*/\n\nstatic int\nunsimal(unsigned x, char *ptr, int n)\n{\n    if (10<=x) {\n        unsigned const q = div10(x);\n        x -= 10 * q;\n        n = unsimal(q, ptr, n);\n    }\n    ptr[n] = '0' + x;\n    return 1+ n;\n}\n\nstatic int\ndecimal(int x, char *ptr, int n)\n{\n    if (x < 0) {\n        x = -x;\n        ptr[n++] = '-';\n    }\n    return unsimal(x, ptr, n);\n}\n\nDEBUG_STRCON(STR_hex, \"0123456789abcdef\");\n\nstatic int\nheximal(unsigned long x, char *ptr, int n)\n{\n    if (16<=x) {\n        n = heximal(x>>4, ptr, n);\n        x &= 0xf;\n    }\n    ptr[n] = STR_hex()[x];\n    return 1+ n;\n}\n\n\n#define DPRINTF(a) my_printf a\n\nstatic int\nmy_printf(char const *fmt, ...)\n{\n    char c;\n    int n= 0;\n    char *ptr;\n    char buf[20];\n    va_list va; va_start(va, fmt);\n    ptr= &buf[0];\n    while (0!=(c= *fmt++)) if ('%'!=c) goto literal;\n    else switch (c= *fmt++) {\n    default: {\nliteral:\n        n+= write(2, fmt-1, 1);\n    } break;\n    case 0: goto done;  /* early */\n    case 'u': {\n        n+= write(2, buf, unsimal(va_arg(va, unsigned), buf, 0));\n    } break;\n    case 'd': {\n        n+= write(2, buf, decimal(va_arg(va, int), buf, 0));\n    } break;\n    case 'p': {\n        buf[0] = '0';\n        buf[1] = 'x';\n        n+= write(2, buf, heximal((unsigned long)va_arg(va, void *), buf, 2));\n    } break;\n    case 'x': {\n        buf[0] = '0';\n        buf[1] = 'x';\n        n+= write(2, buf, heximal(va_arg(va, int), buf, 2));\n    } break;\n    }\ndone:\n    va_end(va);\n    return n;\n}\n#endif  /*}*/\n\n\n/*************************************************************************\n// \"file\" util\n**************************************************************************/\n\ntypedef struct {\n    size_t size;  // must be first to match size[0] uncompressed size\n    Addr buf;\n} Extent;\n\nDEBUG_STRCON(STR_xread, \"xread %%p(%%x %%p) %%p %%x\\\\n\")\nDEBUG_STRCON(STR_xreadfail, \"xreadfail %%p(%%x %%p) %%p %%x\\\\n\")\n\nstatic void\nxread(Extent *x, Addr buf, size_t count)\n{\n    Addr p=x->buf, q=buf;\n    size_t j;\n    DPRINTF((STR_xread(), x, x->size, x->buf, buf, count));\n    if (x->size < count) {\n        DPRINTF((STR_xreadfail(), x, x->size, x->buf, buf, count));\n        exit(127);\n    }\n    for (j = count; 0!=j--; ++p, ++q) {\n        *q = *p;\n    }\n    x->buf  += count;\n    x->size -= count;\n}\n\n\n/*************************************************************************\n// util\n**************************************************************************/\n\n#if 1  //{  save space\n#define ERR_LAB error: exit(127);\n#define err_exit(a) goto error\n#else  //}{  save debugging time\n#define ERR_LAB /*empty*/\nDEBUG_STRCON(STR_exit, \"err_exit %%x\\\\n\");\n\nstatic void\nerr_exit(int a)\n{\n    DPRINTF((STR_exit(), a));\n    (void)a;  // debugging convenience\n    exit(127);\n}\n#endif  //}\n\n\n/*************************************************************************\n// UPX & NRV stuff\n**************************************************************************/\n\nstruct l_info { // 12-byte trailer for loader (after macho headers)\n    unsigned l_checksum;\n    unsigned l_magic;  // UPX_MAGIC_LE32\n    unsigned short l_lsize;\n    unsigned char l_version;\n    unsigned char l_format;\n};\nstruct p_info { // 12-byte packed program header\n    unsigned p_progid;\n    unsigned p_filesize;\n    unsigned p_blocksize;\n};\n\nstruct b_info { // 12-byte header before each compressed block\n    unsigned sz_unc;  // uncompressed_size\n    unsigned sz_cpr;  //   compressed_size\n    unsigned char b_method;  // compression algorithm\n    unsigned char b_ftid;  // filter id\n    unsigned char b_cto8;  // filter parameter\n    unsigned char b_unused;\n};\n\ntypedef void f_unfilter(\n    nrv_byte *,  // also addvalue\n    nrv_uint,\n    unsigned cto8, // junk in high 24 bits\n    unsigned ftid\n);\ntypedef int f_expand(\n    const nrv_byte *, nrv_uint,\n          nrv_byte *, nrv_uint *, unsigned );\n\nDEBUG_STRCON(STR_unpackExtent,\n        \"unpackExtent in=%%p(%%x %%p)  out=%%p(%%x %%p)  %%p %%p\\\\n\");\nDEBUG_STRCON(STR_err5, \"sz_cpr=%%x  sz_unc=%%x  xo->size=%%x\\\\n\");\n\nstatic void\nunpackExtent(\n    Extent *const xi,  // input\n    Extent *const xo,  // output\n    f_expand *const f_decompress,\n    f_unfilter *f_unf\n)\n{\n    DPRINTF((STR_unpackExtent(),\n        xi, xi->size, xi->buf, xo, xo->size, xo->buf, f_decompress, f_unf));\n    while (xo->size) {\n        struct b_info h;\n        //   Note: if h.sz_unc == h.sz_cpr then the block was not\n        //   compressible and is stored in its uncompressed form.\n\n        // Read and check block sizes.\n        xread(xi, (Addr)&h, sizeof(h));\n        if (h.sz_unc == 0) {                     // uncompressed size 0 -> EOF\n            if (h.sz_cpr != UPX_MAGIC_LE32)      // h.sz_cpr must be h->magic\n                err_exit(2);\n            if (xi->size != 0)                 // all bytes must be written\n                err_exit(3);\n            break;\n        }\n        if (h.sz_cpr <= 0) {\n            err_exit(4);\nERR_LAB\n        }\n        if (h.sz_cpr > h.sz_unc\n        ||  h.sz_unc > xo->size ) {\n            DPRINTF((STR_err5(), h.sz_cpr, h.sz_unc, xo->size));\n            err_exit(5);\n        }\n        // Now we have:\n        //   assert(h.sz_cpr <= h.sz_unc);\n        //   assert(h.sz_unc > 0 && h.sz_unc <= blocksize);\n        //   assert(h.sz_cpr > 0 && h.sz_cpr <= blocksize);\n\n        if (h.sz_cpr < h.sz_unc) { // Decompress block\n            nrv_uint out_len = h.sz_unc;  // EOF for lzma\n            int const j = (*f_decompress)(xi->buf, h.sz_cpr,\n                xo->buf, &out_len, h.b_method);\n            if (j != 0 || out_len != (nrv_uint)h.sz_unc)\n                err_exit(7);\n            if (h.b_ftid!=0 && f_unf) {  // have filter\n                (*f_unf)(xo->buf, out_len, h.b_cto8, h.b_ftid);\n            }\n            xi->buf  += h.sz_cpr;\n            xi->size -= h.sz_cpr;\n        }\n        else { // copy literal block\n            xi->size += sizeof(h);  // xread(xi, &h, sizeof(h)) was a peek\n            xread(xi, xo->buf, h.sz_cpr);\n        }\n        xo->buf  += h.sz_unc;\n        xo->size -= h.sz_unc;\n    }\n}\n\nstatic void\nupx_bzero(Addr p, size_t len)\n{\n    if (len) do {\n        *p++= 0;\n    } while (--len);\n}\n#define bzero upx_bzero\n\n\n// The PF_* and PROT_* bits are {1,2,4}; the conversion table fits in 32 bits.\n#define REP8(x) \\\n    ((x)|((x)<<4)|((x)<<8)|((x)<<12)|((x)<<16)|((x)<<20)|((x)<<24)|((x)<<28))\n#define EXP8(y) \\\n    ((1&(y)) ? 0xf0f0f0f0 : (2&(y)) ? 0xff00ff00 : (4&(y)) ? 0xffff0000 : 0)\n#define PF_TO_PROT(pf) \\\n    ((PROT_READ|PROT_WRITE|PROT_EXEC) & ( \\\n        ( (REP8(PROT_EXEC ) & EXP8(PF_X)) \\\n         |(REP8(PROT_READ ) & EXP8(PF_R)) \\\n         |(REP8(PROT_WRITE) & EXP8(PF_W)) \\\n        ) >> ((pf & (PF_R|PF_W|PF_X))<<2) ))\n\ntypedef struct {\n    unsigned magic;\n    unsigned nfat_arch;\n} Fat_header;\ntypedef struct {\n    unsigned cputype;\n    unsigned cpusubtype;\n    unsigned offset;\n    unsigned size;\n    unsigned align;  /* shift count (log base 2) */\n} Fat_arch;\n    enum e8 {\n        FAT_MAGIC = 0xcafebabe,\n        FAT_CIGAM = 0xbebafeca\n    };\n    enum e9 {\n        CPU_TYPE_I386      =          7,\n        CPU_TYPE_AMD64     = 0x01000007,\n        CPU_TYPE_ARM       =         12,\n        CPU_TYPE_POWERPC   = 0x00000012,\n        CPU_TYPE_POWERPC64 = 0x01000012\n    };\n\ntypedef struct {\n    unsigned magic;\n    unsigned cputype;\n    unsigned cpysubtype;\n    unsigned filetype;\n    unsigned ncmds;\n    unsigned sizeofcmds;\n    unsigned flags;\n    unsigned reserved;\n} Mach_header64;\n        enum e0 {\n            MH_MAGIC   =   0xfeedface,\n            MH_MAGIC64 = 1+0xfeedface\n        };\n        enum e2 {\n            MH_EXECUTE = 2\n        };\n        enum e3 {\n            MH_NOUNDEFS = 1\n        };\n\ntypedef struct {\n    unsigned cmd;\n    unsigned cmdsize;\n} Mach_load_command;\n        enum e4 {\n            LC_REQ_DYLD      = 0x80000000,  // OR'ed ==> must not ignore\n            LC_SEGMENT       = 0x1,\n            LC_SEGMENT_64    = 0x19,\n            LC_THREAD        = 0x4,\n            LC_UNIXTHREAD    = 0x5,\n            LC_LOAD_DYLINKER = 0xe,\n            LC_MAIN          = (0x28|LC_REQ_DYLD)\n        };\n\ntypedef struct {\n    unsigned cmd;\n    unsigned cmdsize;\n    char segname[16];\n    uint64_t vmaddr;\n    uint64_t vmsize;\n    uint64_t fileoff;\n    uint64_t filesize;\n    unsigned maxprot;\n    unsigned initprot;\n    unsigned nsects;\n    unsigned flags;\n} Mach_segment_command;\n        enum e5 {\n            VM_PROT_READ = 1,\n            VM_PROT_WRITE = 2,\n            VM_PROT_EXECUTE = 4\n        };\n\ntypedef struct {\n    char sectname[16];\n    char segname[16];\n    uint64_t addr;   /* memory address */\n    uint64_t size;   /* size in bytes */\n    unsigned offset; /* file offset */\n    unsigned align;  /* power of 2 */\n    unsigned reloff; /* file offset of relocation entries */\n    unsigned nreloc; /* number of relocation entries */\n    unsigned flags;  /* section type and attributes */\n    unsigned reserved1;  /* for offset or index */\n    unsigned reserved2;  /* for count or sizeof */\n} Mach_section_command;\n\ntypedef struct {\n    uint32_t cmd;  // LC_MAIN;  MH_EXECUTE only\n    uint32_t cmdsize;  // 24\n    uint64_t entryoff;  // file offset of main() [expected in __TEXT]\n    uint64_t stacksize;  // non-default initial stack size\n} Mach_main_command;\n\ntypedef struct {\n    uint64_t rax, rbx, rcx, rdx;\n    uint64_t rdi, rsi, rbp, rsp;\n    uint64_t  r8,  r9, r10, r11;\n    uint64_t r12, r13, r14, r15;\n    uint64_t rip, rflags;\n    uint64_t cs, fs, gs;\n} Mach_AMD64_thread_state;\n\ntypedef struct {\n    unsigned cmd;            /* LC_THREAD or  LC_UNIXTHREAD */\n    unsigned cmdsize;        /* total size of this command */\n    unsigned flavor;\n    unsigned count;          /* sizeof(following_thread_state)/4 */\n    Mach_AMD64_thread_state state;\n} Mach_thread_command;\n        enum e6 {\n            AMD64_THREAD_STATE = 4  // x86_THREAD_STATE64\n        };\n        enum e7 {\n            AMD64_THREAD_STATE_COUNT = sizeof(Mach_AMD64_thread_state)/4\n        };\n\ntypedef union {\n    unsigned offset;  /* from start of load command to string */\n} Mach_lc_str;\n\n#define MAP_FIXED     0x10\n#define MAP_PRIVATE   0x02\n#define MAP_ANON    0x1000\n//#define MAP_ANON  0x20  // x86 DEBUG ONLY\n#define PROT_READ      1\n#define PROT_WRITE     2\n#define PROT_EXEC      4\n#define MAP_ANON_FD    -1\n#define MAP_FAILED ((void *) -1)\n\nextern void *mmap(void *, size_t, unsigned, unsigned, int, off_t_upx_stub);\nssize_t pread(int, void *, size_t, off_t_upx_stub);\nextern void bswap(void *, unsigned);\n\nDEBUG_STRCON(STR_mmap,\n    \"mmap  addr=%%p  len=%%p  prot=%%x  flags=%%x  fd=%%d  off=%%p\\\\n\");\nDEBUG_STRCON(STR_do_xmap,\n    \"do_xmap  fdi=%%x  mhdr=%%p  xi=%%p(%%x %%p) f_unf=%%p\\\\n\")\n\nstatic uint64_t  // entry address\ndo_xmap(\n    Mach_header64 const *const mhdr,\n    off_t_upx_stub const fat_offset,\n    Extent *const xi,\n    int const fdi,\n    Mach_header64 **mhdrpp,\n    f_expand *const f_decompress,\n    f_unfilter *const f_unf\n)\n{\n    Mach_segment_command const *sc = (Mach_segment_command const *)(1+ mhdr);\n    Mach_segment_command const *segTEXT = 0;\n    uint64_t entry = 0;\n    unsigned long base = 0;\n    unsigned j;\n\n    DPRINTF((STR_do_xmap(),\n        fdi, mhdr, xi, (xi? xi->size: 0), (xi? xi->buf: 0), f_unf));\n\n    for ( j=0; j < mhdr->ncmds; ++j,\n        (sc = (Mach_segment_command const *)(sc->cmdsize + (unsigned char const *)sc))\n    ) if (LC_SEGMENT_64==sc->cmd && sc->vmsize==0) {\n            // Typical __DWARF info segment for 'rust'\n            struct b_info h;\n            xread(xi, (unsigned char *)&h, sizeof(h));\n            DPRINTF(\"    0==.vmsize; skipping %%x\\\\n\", h.sz_cpr);\n            xi->buf += h.sz_cpr;\n    else if (LC_SEGMENT_64==sc->cmd && sc->vmsize!=0) {\n        Extent xo;\n        size_t mlen = xo.size = sc->filesize;\n        Addr  addr = xo.buf  = base + (Addr)sc->vmaddr;\n        Addr haddr =     sc->vmsize +             addr;\n        size_t frag = (int)(uint64_t)addr &~ PAGE_MASK;\n        addr -= frag;\n        mlen += frag;\n\n        if (0!=mlen) { // In particular, omitted for __PAGEZERO\n            // Decompressor can overrun the destination by 3 bytes.  [x86 only]\n            size_t const mlen3 = mlen + (xi ? 3 : 0);\n            unsigned const prot = VM_PROT_READ | VM_PROT_WRITE;\n            unsigned const flags = (addr ? MAP_FIXED : 0) | MAP_PRIVATE |\n                        ((xi || 0==sc->filesize) ? MAP_ANON : 0);\n            int const fdm = ((0==sc->filesize) ? MAP_ANON_FD : fdi);\n            off_t_upx_stub const offset = sc->fileoff + fat_offset;\n\n            DPRINTF((STR_mmap(),       addr, mlen3, prot, flags, fdm, offset));\n            Addr mapa = (Addr)mmap(addr, mlen3, prot, flags, fdm, offset);\n            if (MAP_FAILED == mapa) {\n                err_exit(8);\n            }\n            if (0 == addr) { // dyld auto-relocate\n                base = (unsigned long)mapa;  // relocation constant\n            }\n            addr = mapa;\n        }\n        if (xi && 0!=sc->filesize) {\n            if (0==sc->fileoff /*&& 0!=mhdrpp*/) {\n                segTEXT = sc;\n                *mhdrpp = (Mach_header64 *)(void *)addr;\n            }\n            unpackExtent(xi, &xo, f_decompress, f_unf);\n        }\n        /*bzero(addr, frag);*/  // fragment at lo end\n        frag = (-mlen) &~ PAGE_MASK;  // distance to next page boundary\n        bzero(mlen+addr, frag);  // fragment at hi end\n        if (0!=mlen && 0!=mprotect(addr, mlen, sc->initprot)) {\n            err_exit(10);\nERR_LAB\n        }\n        addr += mlen + frag;  /* page boundary on hi end */\n        if (\n#if SIMULATE_ON_LINUX_EABI4  /*{*/\n            0!=addr &&\n#endif  /*}*/\n                        addr < haddr) { // need pages for .bss\n            if (0!=addr && addr != mmap(addr, haddr - addr, sc->initprot,\n                    MAP_FIXED | MAP_PRIVATE | MAP_ANON, MAP_ANON_FD, 0 ) ) {\n                err_exit(9);\n            }\n        }\n        else if (xi) { // cleanup if decompressor overrun crosses page boundary\n            mlen = ~PAGE_MASK & (3+ mlen);\n            if (mlen<=3) { // page fragment was overrun buffer only\n                munmap((char *)addr, mlen);\n            }\n        }\n    }\n    else if (LC_UNIXTHREAD==sc->cmd || LC_THREAD==sc->cmd) {\n        Mach_thread_command const *const thrc = (Mach_thread_command const *)sc;\n        if (AMD64_THREAD_STATE      ==thrc->flavor\n        &&  AMD64_THREAD_STATE_COUNT==thrc->count ) {\n            entry = thrc->state.rip + base;  // JMP\n        }\n    }\n    else if (LC_MAIN==sc->cmd) {\n        entry = ((Mach_main_command const *)sc)->entryoff;\n        if (segTEXT->fileoff <= entry && entry < segTEXT->filesize) {\n            entry += segTEXT->vmaddr;  // CALL\n        }\n        // XXX FIXME TODO: if entry not in segTEXT?\n        // XXX FIXME TODO: LC_MAIN is a CALL; LC_*THREAD is a JMP\n    }\n    return entry;\n}\n\nstatic off_t_upx_stub\nfat_find(Fat_header *fh) // *fh suffers bswap()\n{\n    Fat_arch *fa = (Fat_arch *)(1+ fh);\n    bswap(fh, sizeof(*fh) + (fh->nfat_arch>>24)*sizeof(*fa));\n    unsigned j;\n    for (j= 0; j < fh->nfat_arch; ++j, ++fa) {\n        if (CPU_TYPE_AMD64==fa->cputype) {\n            return fa->offset;  // should not be 0 because of header\n        }\n    }\n    return 0;\n}\n\n/*************************************************************************\n// upx_main - called by our entry code\n//\n**************************************************************************/\n\nDEBUG_STRCON(STR_upx_main,\n    \"upx_main szc=%%x  f_dec=%%p  f_unf=%%p  \"\n    \"  xo=%%p(%%x %%p)  xi=%%p(%%x %%p)  mhdrpp=%%p\\\\n\")\n\nuint64_t // entry address\nupx_main(\n    struct l_info const *const li,\n    size_t volatile sz_compressed,  // total length\n    Mach_header64 *const mhdr,  // temp char[sz_mhdr] for decompressing\n    size_t const sz_mhdr,\n    f_expand *const f_decompress,\n    f_unfilter *const f_unf,\n    Mach_header64 **const mhdrpp  // Out: *mhdrpp= &real Mach_header64\n)\n{\n    uint64_t entry;\n    off_t_upx_stub fat_offset = 0;\n    Extent xi, xo, xi0;\n    xi.buf  = CONST_CAST(Addr, 1+ (struct p_info const *)(1+ li));  // &b_info\n    xi.size = sz_compressed - (sizeof(struct l_info) + sizeof(struct p_info));\n    xo.buf  = (Addr)mhdr;\n    xo.size = ((struct b_info const *)(void const *)xi.buf)->sz_unc;\n    xi0 = xi;\n\n    DPRINTF((STR_upx_main(),\n        sz_compressed, f_decompress, f_unf, &xo, xo.size, xo.buf,\n        &xi, xi.size, xi.buf, mhdrpp));\n\n    // Uncompress Macho headers\n    unpackExtent(&xi, &xo, f_decompress, 0);  // never filtered?\n\n    entry = do_xmap(mhdr, fat_offset, &xi0, MAP_ANON_FD, mhdrpp, f_decompress, f_unf);\n\n  { // Map dyld dynamic loader\n    Mach_load_command const *lc = (Mach_load_command const *)(1+ mhdr);\n    unsigned j;\n\n    for (j=0; j < mhdr->ncmds; ++j,\n        (lc = (Mach_load_command const *)(lc->cmdsize + (unsigned char const *)lc))\n    ) if (LC_LOAD_DYLINKER==lc->cmd) {\n        char const *const dyld_name = ((Mach_lc_str const *)(1+ lc))->offset +\n            (char const *)lc;\n        int const fdi = open(dyld_name, O_RDONLY, 0);\n        if (0 > fdi) {\n            err_exit(18);\n        }\n        for (;;) { // possibly 2 times for 'fat' binary\n            if (sz_mhdr!=pread(fdi, (void *)mhdr, sz_mhdr, fat_offset)) {\nERR_LAB\n                err_exit(19);\n            }\n            switch (mhdr->magic) {\n            case MH_MAGIC: break;  // i686 on x86_64 ?\n            case MH_MAGIC64: break;\n\n            case FAT_CIGAM:\n            case FAT_MAGIC: {\n                // stupid Apple: waste code and a page fault on EVERY execve\n                fat_offset = fat_find((Fat_header *)mhdr);\n                if (fat_offset) {\n                    continue;  // the 'for' loop\n                }\n                err_exit(20);  // no other choice\n            } break;\n            } // switch\n            break;\n        }\n        entry = do_xmap(mhdr, fat_offset, 0, fdi, 0, 0, 0);\n        close(fdi);\n        break;\n    }\n  }\n\n    return entry;\n}\n\n/* vim:set ts=4 sw=4 et: */\n","size_bytes":20991},"src/stub/src/amd64-linux.elf-main.c":{"content":"/* amd64-linux.elf-main.c -- stub loader for Linux 64-bit ELF executable\n\n   This file is part of the UPX executable compressor.\n\n   Copyright (C) 1996-2025 Markus Franz Xaver Johannes Oberhumer\n   Copyright (C) 1996-2025 Laszlo Molnar\n   Copyright (C) 2000-2025 John F. Reiser\n   All Rights Reserved.\n\n   UPX and the UCL library are free software; you can redistribute them\n   and/or modify them under the terms of the GNU General Public License as\n   published by the Free Software Foundation; either version 2 of\n   the License, or (at your option) any later version.\n\n   This program is distributed in the hope that it will be useful,\n   but WITHOUT ANY WARRANTY; without even the implied warranty of\n   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n   GNU General Public License for more details.\n\n   You should have received a copy of the GNU General Public License\n   along with this program; see the file COPYING.\n   If not, write to the Free Software Foundation, Inc.,\n   59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.\n\n   Markus F.X.J. Oberhumer              Laszlo Molnar\n   <markus@oberhumer.com>               <ezerotven+github@gmail.com>\n\n   John F. Reiser\n   <jreiser@users.sourceforge.net>\n */\n\n\n#include \"include/linux.h\"\n// Pprotect is mprotect but uses page-aligned address (Linux requirement)\nunsigned Pprotect(void *, size_t, unsigned);\n\n#ifndef DEBUG  //{\n#define DEBUG 0\n#endif  //}\n\n#if !DEBUG //{\n#define DPRINTF(fmt, args...) /*empty*/\n#else  //}{\n// DPRINTF is defined as an expression using \"({ ... })\"\n// so that DPRINTF can be invoked inside an expression,\n// and then followed by a comma to ignore the return value.\n// The only complication is that percent and backslash\n// must be doubled in the format string, because the format\n// string is processed twice: once at compile-time by 'asm'\n// to produce the assembled value, and once at runtime to use it.\n#if defined(__powerpc__)  //{\n#define DPRINTF(fmt, args...) ({ \\\n    char const *r_fmt; \\\n    asm(\"bl 0f; .string \\\"\" fmt \"\\\"; .balign 4; 0: mflr %0\" \\\n/*out*/ : \"=r\"(r_fmt) \\\n/* in*/ : \\\n/*und*/ : \"lr\"); \\\n    dprintf(r_fmt, args); \\\n})\n#elif defined(__x86_64) //}{\n#define DPRINTF(fmt, args...) ({ \\\n    char const *r_fmt; \\\n    asm(\"call 0f; .asciz \\\"\" fmt \"\\\"; 0: pop %0\" \\\n/*out*/ : \"=r\"(r_fmt) ); \\\n    dprintf(r_fmt, args); \\\n})\n#elif defined(__aarch64__) //}{\n#define DPRINTF(fmt, args...) ({ \\\n    char const *r_fmt; \\\n    asm(\"bl 0f; .string \\\"\" fmt \"\\\"; .balign 4; 0: mov %0,x30\" \\\n/*out*/ : \"=r\"(r_fmt) \\\n/* in*/ : \\\n/*und*/ : \"x30\"); \\\n    dprintf(r_fmt, args); \\\n})\n\n#endif  //}\n\nstatic int dprintf(char const *fmt, ...); // forward\n#endif  /*}*/\n\nextern void my_bkpt(void *, ...);\n\n/*************************************************************************\n// configuration section\n**************************************************************************/\n\n// In order to make it much easier to move this code at runtime and execute\n// it at an address different from it load address:  there must be no\n// static data, and no string constants.\n\n#include \"MAX_ELF_HDR.c\"\n\n/*************************************************************************\n// \"file\" util\n**************************************************************************/\n\ntypedef struct {\n    size_t size;  // must be first to match size[0] uncompressed size\n    char *buf;\n} Extent;\n\n\nstatic void\nxread(Extent *x, char *buf, size_t count)\n{\n    DPRINTF(\"xread x.size=%%x  x.buf=%%p  buf=%%p  count=%%x\\\\n\",\n        x->size, x->buf, buf, count);\n    char *p=x->buf, *q=buf;\n    size_t j;\n    if (x->size < count) {\n        exit(127);\n    }\n    for (j = count; 0!=j--; ++p, ++q) {\n        *q = *p;\n    }\n    x->buf  += count;\n    x->size -= count;\n    DPRINTF(\"xread done\\\\n\",0);\n}\n\n\n/*************************************************************************\n// util\n**************************************************************************/\n\n#if !DEBUG  //{  save space\n#define ERR_LAB error: exit(127);\n#define err_exit(a) goto error\n#else  //}{  save debugging time\n#define ERR_LAB /*empty*/\nstatic void\nerr_exit(int a)\n{\n    (void)a;  // debugging convenience\n    DPRINTF(\"err_exit %%d\\\\n\", a);\n    exit(127);\n}\n#endif  //}\n\n/*************************************************************************\n// UPX & NRV stuff\n**************************************************************************/\n\ntypedef void f_unfilter(\n    nrv_byte *,  // also addvalue\n    nrv_uint,\n    unsigned cto8, // junk in high 24 bits\n    unsigned ftid\n);\ntypedef int f_expand(\n    const nrv_byte *, nrv_uint,\n          nrv_byte *, size_t *, unsigned );\n\nstatic void\nunpackExtent(\n    Extent *const xi,  // input\n    Extent *const xo,  // output\n    f_expand *const f_exp,\n    f_unfilter *f_unf\n)\n{\n    while (xo->size) {\n        DPRINTF(\"unpackExtent xi=(%%p %%p)  xo=(%%p %%p)  f_exp=%%p  f_unf=%%p\\\\n\",\n            xi->size, xi->buf, xo->size, xo->buf, f_exp, f_unf);\n        struct b_info h;\n        //   Note: if h.sz_unc == h.sz_cpr then the block was not\n        //   compressible and is stored in its uncompressed form.\n\n        // Read and check block sizes.\n        xread(xi, (char *)&h, sizeof(h));\n        DPRINTF(\"h.sz_unc=%%x  h.sz_cpr=%%x  h.b_method=%%x\\\\n\",\n            h.sz_unc, h.sz_cpr, h.b_method);\n        if (h.sz_unc == 0) {                     // uncompressed size 0 -> EOF\n            if (h.sz_cpr != UPX_MAGIC_LE32)      // h.sz_cpr must be h->magic\n                err_exit(2);\n            if (xi->size != 0)                 // all bytes must be written\n                err_exit(3);\n            break;\n        }\n        if (h.sz_cpr <= 0) {\n            err_exit(4);\nERR_LAB\n        }\n        if (h.sz_cpr > h.sz_unc\n        ||  h.sz_unc > xo->size ) {\n            err_exit(5);\n        }\n        // Now we have:\n        //   assert(h.sz_cpr <= h.sz_unc);\n        //   assert(h.sz_unc > 0 && h.sz_unc <= blocksize);\n        //   assert(h.sz_cpr > 0 && h.sz_cpr <= blocksize);\n\n        if (h.sz_cpr < h.sz_unc) { // Decompress block\n            size_t out_len = h.sz_unc;  // EOF for lzma\n            int const j = (*f_exp)((unsigned char *)xi->buf, h.sz_cpr,\n                (unsigned char *)xo->buf, &out_len,\n#if defined(__x86_64)  //{\n                    *(int *)(void *)&h.b_method\n#elif defined(__powerpc64__) || defined(__aarch64__) //}{\n                    h.b_method\n#endif  //}\n                );\n            if (j != 0 || out_len != (nrv_uint)h.sz_unc) {\n                DPRINTF(\"j=%%x  out_len=%%x  &h=%%p\\\\n\", j, out_len, &h);\n                err_exit(7);\n            }\n            // Skip Ehdr+Phdrs: separate 1st block, not filtered\n            if (h.b_ftid!=0 && f_unf  // have filter\n            &&  ((512 < out_len)  // this block is longer than Ehdr+Phdrs\n              || (xo->size==(unsigned)h.sz_unc) )  // block is last in Extent\n            ) {\n                (*f_unf)((unsigned char *)xo->buf, out_len, h.b_cto8, h.b_ftid);\n            }\n            xi->buf  += h.sz_cpr;\n            xi->size -= h.sz_cpr;\n        }\n        else { // copy literal block\n            xi->size += sizeof(h);  // xread(xi, &h, sizeof(h)) was a peek\n            xread(xi, xo->buf, h.sz_cpr);\n        }\n        xo->buf  += h.sz_unc;\n        xo->size -= h.sz_unc;\n    }\n}\n\n#if defined(__x86_64__)  //{\nstatic void *\nmake_hatch_x86_64(\n    Elf64_Phdr const *const phdr,\n    Elf64_Addr reloc,\n    unsigned const frag_mask\n)\n{\n    unsigned xprot = 0;\n    unsigned *hatch = 0;\n    DPRINTF(\"make_hatch %%p %%p %%x  %%x\\\\n\",phdr,reloc,frag_mask, phdr->p_flags);\n    if (phdr->p_type==PT_LOAD && phdr->p_flags & PF_X) {\n        if (\n        // Try page fragmentation just beyond .text .\n             ( (hatch = (void *)(phdr->p_memsz + phdr->p_vaddr + reloc)),\n                ( phdr->p_memsz==phdr->p_filesz  // don't pollute potential .bss\n                &&  (1*4)<=(frag_mask & -(int)(size_t)hatch) ) ) // space left on page\n        // Try Elf64_Ehdr.e_ident[12..15] .  warning: 'const' cast away\n        ||   ( (hatch = (void *)(&((Elf64_Ehdr *)(phdr->p_vaddr + reloc))->e_ident[12])),\n                (phdr->p_offset==0) )\n        // Allocate and use a new page.\n        ||   (  xprot = 1, hatch = mmap(0, PAGE_SIZE, PROT_WRITE|PROT_READ,\n                MAP_PRIVATE|MAP_ANONYMOUS, -1, 0) )\n        )\n        {\n            hatch[0] = 0xc35a050f;  // syscall; pop %rdx; ret\n            if (xprot) {\n                Pprotect(hatch, 1*sizeof(unsigned), PROT_EXEC|PROT_READ);\n            }\n        }\n        else {\n            hatch = 0;\n        }\n    }\n    DPRINTF(\"hatch=%%p\\n\", hatch);\n    return hatch;\n}\n#elif defined(__powerpc64__)  //}{\nstatic unsigned\nORRX(unsigned ra, unsigned rs, unsigned rb) // or ra,rs,rb\n{\n    return (31<<26) | ((037&(rs))<<21) | ((037&(ra))<<16) | ((037&(rb))<<11) | (444<<1) | 0;\n}\n\nstatic void *\nmake_hatch_ppc64(\n    Elf64_Phdr const *const phdr,\n    Elf64_Addr reloc,\n    unsigned const frag_mask\n)\n{\n    unsigned xprot = 0;\n    unsigned *hatch = 0;\n    DPRINTF(\"make_hatch %%p %%p %%x\\\\n\",phdr,reloc,frag_mask);\n    if (phdr->p_type==PT_LOAD && phdr->p_flags & PF_X) {\n        if (\n        // Try page fragmentation just beyond .text .\n            ( (hatch = (void *)(~3ul & (3+ phdr->p_memsz + phdr->p_vaddr + reloc))),\n                ( phdr->p_memsz==phdr->p_filesz  // don't pollute potential .bss\n                &&  (4*4)<=(frag_mask & -(int)(size_t)hatch) ) ) // space left on page\n        // Try Elf64_Phdr[1].p_paddr (2 instr) and .p_filesz (2 instr)\n        ||   ( (hatch = (void *)(&((Elf64_Phdr *)(1+  // Ehdr and Phdr are contiguous\n                ((Elf64_Ehdr *)(phdr->p_vaddr + reloc))))[1].p_paddr)),\n                (phdr->p_offset==0) )\n        // Allocate and use a new page.\n        ||   (  xprot = 1, hatch = mmap(0, 1<<12, PROT_WRITE|PROT_READ,\n                MAP_PRIVATE|MAP_ANONYMOUS, -1, 0) )\n        )\n        {\n            hatch[0]= 0x44000002;  // sc\n            hatch[1]= ORRX(12,31,31);  // movr r12,r31 ==> or r12,r31,r31\n            hatch[2]= 0x38800000;  // li r4,0\n            hatch[3]= 0x4e800020;  // blr\n            if (xprot) {\n                Pprotect(hatch, 4*sizeof(unsigned), PROT_EXEC|PROT_READ);\n            }\n        }\n        else {\n            hatch = 0;\n        }\n    }\n    return hatch;\n}\n#elif defined(__aarch64__)  //{\n#define NBPI 4\n#define NINSTR 3\nstatic void *\nmake_hatch_arm64(\n    Elf64_Phdr const *const phdr,\n    uint64_t const reloc,\n    unsigned const frag_mask\n)\n{\n    unsigned xprot = 0;\n    unsigned *hatch = 0;\n    DPRINTF(\"make_hatch %%p %%p %%x\\\\n\",phdr,reloc,frag_mask);\n    if (phdr->p_type==PT_LOAD && phdr->p_flags & PF_X) {\n        // The format of the 'if' is\n        //  if ( ( (hatch = loc1), test_loc1 )\n        //  ||   ( (hatch = loc2), test_loc2 ) ) {\n        //      action\n        //  }\n        // which uses the comma to save bytes when test_locj involves locj\n        // and the action is the same when either test succeeds.\n\n        if (\n        // Try page fragmentation just beyond .text .\n             ( (hatch = (void *)(~3ul & (3+ phdr->p_memsz + phdr->p_vaddr + reloc))),\n                ( phdr->p_memsz==phdr->p_filesz  // don't pollute potential .bss\n                &&  (NINSTR*NBPI)<=(frag_mask & -(int)(uint64_t)hatch) ) ) // space left on page\n        // Allocate and use a new page.\n        ||   (  xprot = 1, hatch = mmap(0, 1<<12, PROT_WRITE|PROT_READ,\n                MAP_PRIVATE|MAP_ANONYMOUS, -1, 0) )\n        )\n        {\n            hatch[0] = 0xd4000001;  // svc #0;  # {addr,len,__NR_munmap} already in {x0,x1,w8}\n            hatch[1] = 0xa8c107e0;  // ldp x0,x1,[sp],#2*NBPI  # ABI owns x0?\n            hatch[2] = 0xd65f03c0;  // ret (jmp *lr)\n            if (xprot) {\n                Pprotect(hatch, NINSTR * NBPI, PROT_EXEC|PROT_READ);\n            }\n        }\n        else {\n            hatch = 0;\n        }\n    }\n    DPRINTF(\"hatch=%%p\\n\", hatch);\n    return hatch;\n}\n#undef NBPI\n#undef NINSTR\n#endif  //}\n\n#if defined(__powerpc64__) || defined(__aarch64__)  //{ bzero\nstatic void\nupx_bzero(char *p, size_t len)\n{\n    DPRINTF(\"bzero %%x  %%x\\\\n\", p, len);\n    if (len) do {\n        *p++= 0;\n    } while (--len);\n}\n#define bzero upx_bzero\n#else  //}{\n#define bzero(a,b)  __builtin_memset(a,0,b)\n#endif  //}\n\nstatic void\nauxv_up(Elf64_auxv_t *av, unsigned const tag, uint64_t const value)\n{\n    if (!av || (1& (size_t)av)) { // none, or inhibited for PT_INTERP\n        return;\n    }\n    DPRINTF(\"\\\\nauxv_up %%d  %%p\\\\n\", tag, value);\n    // Multiple slots can have 'tag' which wastes space but is legal.\n    // rtld (ld-linux) uses the last one, so we must scan the whole table.\n    Elf64_auxv_t *ignore_slot = 0;\n    int found = 0;\n    for (;; ++av) {\n        DPRINTF(\"  %%d  %%p\\\\n\", av->a_type, av->a_un.a_val);\n        if (av->a_type == tag) {\n            av->a_un.a_val = value;\n            ++found;\n        }\n        else if (av->a_type == AT_IGNORE) {\n            ignore_slot = av;\n        }\n        if (av->a_type==AT_NULL) { // done scanning\n            if (found) {\n                return;\n            }\n            if (ignore_slot) {\n                ignore_slot->a_type = tag;\n                ignore_slot->a_un.a_val = value;\n                return;\n            }\n            err_exit(20);\nERR_LAB\n            return;\n        }\n    }\n}\n\n// The PF_* and PROT_* bits are {1,2,4}; the conversion table fits in 32 bits.\n#define REP8(x) \\\n    ((x)|((x)<<4)|((x)<<8)|((x)<<12)|((x)<<16)|((x)<<20)|((x)<<24)|((x)<<28))\n#define EXP8(y) \\\n    ((1&(y)) ? 0xf0f0f0f0 : (2&(y)) ? 0xff00ff00 : (4&(y)) ? 0xffff0000 : 0)\n#define PF_TO_PROT(pf) \\\n    ((PROT_READ|PROT_WRITE|PROT_EXEC) & ( \\\n        ( (REP8(PROT_EXEC ) & EXP8(PF_X)) \\\n         |(REP8(PROT_READ ) & EXP8(PF_R)) \\\n         |(REP8(PROT_WRITE) & EXP8(PF_W)) \\\n        ) >> ((pf & (PF_R|PF_W|PF_X))<<2) ))\n\n\n// Find convex hull of PT_LOAD (the minimal interval which covers all PT_LOAD),\n// and mmap that much, to be sure that a kernel using exec-shield-randomize\n// won't place the first piece in a way that leaves no room for the rest.\nstatic Elf64_Addr // returns relocation constant\nxfind_pages(unsigned mflags, Elf64_Phdr const *phdr, int phnum,\n    Elf64_Addr *const p_brk\n    , Elf64_Addr const elfaddr\n#if defined(__powerpc64__) || defined(__aarch64__)\n    , size_t const PAGE_MASK\n#endif\n)\n{\n    Elf64_Addr lo= ~0, hi= 0, addr= 0;\n    mflags += MAP_PRIVATE | MAP_ANONYMOUS;  // '+' can optimize better than '|'\n    DPRINTF(\"xfind_pages  %%x  %%p  %%d  %%p  %%p\\\\n\", mflags, phdr, phnum, elfaddr, p_brk);\n    for (; --phnum>=0; ++phdr) if (PT_LOAD==phdr->p_type) {\n        DPRINTF(\" p_vaddr=%%p  p_memsz=%%p\\\\n\", phdr->p_vaddr, phdr->p_memsz);\n        if (phdr->p_vaddr < lo) {\n            lo = phdr->p_vaddr;\n        }\n        if (hi < (phdr->p_memsz + phdr->p_vaddr)) {\n            hi =  phdr->p_memsz + phdr->p_vaddr;\n        }\n    }\n    lo -= ~PAGE_MASK & lo;  // round down to page boundary\n    hi  =  PAGE_MASK & (hi - lo - PAGE_MASK -1);  // page length\n    if (MAP_FIXED & mflags) {\n        addr = lo;\n    }\n    else if (0==lo) { // -pie ET_DYN\n        addr = elfaddr;\n        if (addr) {\n            mflags |= MAP_FIXED;\n        }\n    }\n    DPRINTF(\"  addr=%%p  lo=%%p  hi=%%p\\\\n\", addr, lo, hi);\n    // PROT_WRITE allows testing of 64k pages on 4k Linux\n    addr = (Elf64_Addr)mmap((void *)addr, hi, (DEBUG ? PROT_WRITE : PROT_NONE),  // FIXME XXX EVIL\n        mflags, -1, 0);\n    DPRINTF(\"  addr=%%p\\\\n\", addr);\n    *p_brk = hi + addr;  // the logical value of brk(0)\n    return (Elf64_Addr)(addr - lo);\n}\n\nstatic Elf64_Addr  // entry address\ndo_xmap(\n    Elf64_Ehdr const *const ehdr,\n    Extent *const xi,\n    int const fdi,\n    Elf64_auxv_t *const av,\n    f_expand *const f_exp,\n    f_unfilter *const f_unf,\n    Elf64_Addr *p_reloc\n#if defined(__powerpc64__) || defined(__aarch64__)\n    , size_t const PAGE_MASK\n#endif\n)\n{\n    Elf64_Phdr const *phdr = (Elf64_Phdr const *)(void const *)(ehdr->e_phoff +\n        (char const *)ehdr);\n    Elf64_Addr v_brk;\n    Elf64_Addr reloc;\n    if (xi) { // compressed main program:\n        // C_BASE space reservation, C_TEXT compressed data and stub\n        Elf64_Addr ehdr0 = *p_reloc;  // the 'hi' copy!\n        Elf64_Phdr const *phdr0 = (Elf64_Phdr const *)(\n            ((Elf64_Ehdr *)ehdr0)->e_phoff + ehdr0);\n        // Clear the 'lo' space reservation for use by PT_LOADs\n        ehdr0 -= phdr0[1].p_vaddr;  // the 'lo' copy\n        if (ET_EXEC==ehdr->e_type) {\n            ehdr0 = phdr0[0].p_vaddr;\n        }\n        v_brk = phdr0->p_memsz + ehdr0;\n        reloc = (Elf64_Addr)mmap((void *)ehdr0, phdr0->p_memsz, PROT_NONE,\n            MAP_FIXED|MAP_ANONYMOUS|MAP_PRIVATE, -1, 0);\n        if (ET_EXEC==ehdr->e_type) {\n            reloc = 0;\n        }\n        DPRINTF(\"do_xmap 1 reloc=%%p\\\\n\", reloc);\n    }\n    else { // PT_INTERP\n        DPRINTF(\"INTERP\\\\n\", 0);\n        reloc = xfind_pages(\n            ((ET_DYN!=ehdr->e_type) ? MAP_FIXED : 0), phdr, ehdr->e_phnum, &v_brk, *p_reloc\n#if defined(__powerpc64__) || defined(__aarch64__)\n            , PAGE_MASK\n#endif\n        );\n        DPRINTF(\"do_xmap 2 reloc=%%p\\\\n\", reloc);\n    }\n    int j;\n    for (j=0; j < ehdr->e_phnum; ++phdr, ++j)\n    if (xi && PT_PHDR==phdr->p_type) {\n        auxv_up(av, AT_PHDR, phdr->p_vaddr + reloc);\n    } else\n    if (PT_LOAD==phdr->p_type && phdr->p_memsz != 0) {\n        unsigned const prot = PF_TO_PROT(phdr->p_flags);\n        DPRINTF(\"LOAD p_offset=%%p  p_vaddr=%%p  p_filesz=%%p  p_memsz=%%p  p_flags=%%x  prot=%%x\\\\n\",\n            phdr->p_offset, phdr->p_vaddr, phdr->p_filesz, phdr->p_memsz, phdr->p_flags, prot);\n        if (xi && !phdr->p_offset /*&& ET_EXEC==ehdr->e_type*/) { // 1st PT_LOAD\n            // ? Compressed PT_INTERP must not overwrite values from compressed a.out?\n            auxv_up(av, AT_PHDR, phdr->p_vaddr + reloc + ehdr->e_phoff);\n            auxv_up(av, AT_PHNUM, ehdr->e_phnum);\n            auxv_up(av, AT_PHENT, ehdr->e_phentsize);  /* ancient kernels might omit! */\n            //auxv_up(av, AT_PAGESZ, PAGE_SIZE);  /* ld-linux.so.2 does not need this */\n        }\n        Extent xo;\n        size_t mlen = xo.size = phdr->p_filesz;\n        char  *addr = xo.buf = reloc + (char *)phdr->p_vaddr;\n        char *hi_addr = phdr->p_memsz  + addr;  // end of local .bss\n        char *addr2 = mlen + addr;  // end of local .data\n        unsigned lo_frag  = (unsigned)(long)addr &~ PAGE_MASK;\n        mlen += lo_frag;\n        addr -= lo_frag;\n#if defined(__powerpc64__) || defined(__aarch64__)\n        // Round up to hardware PAGE_SIZE; allows emulator with smaller.\n        // But (later) still need bzero when .p_filesz < .p_memsz .\n        mlen += -(mlen + (size_t)addr) &~ PAGE_MASK;\n        DPRINTF(\"  mlen=%%p\\\\n\", mlen);\n#endif\n\n        DPRINTF(\"mmap addr=%%p  mlen=%%p  offset=%%p  lo_frag=%%p  prot=%%x  reloc=%%p\\\\n\",\n            addr, mlen, phdr->p_offset - lo_frag, lo_frag, prot, reloc);\n        if (addr != mmap(addr, mlen,\n                // If compressed, then we need PROT_WRITE to de-compress;\n                // but then SELinux 'execmod' requires no PROT_EXEC for now.\n                (prot | (xi ? PROT_WRITE : 0)) &~ (xi ? PROT_EXEC : 0),\n                MAP_FIXED | MAP_PRIVATE | (xi ? MAP_ANONYMOUS : 0),\n                (xi ? -1 : fdi), phdr->p_offset - lo_frag) ) {\n            err_exit(8);\n        }\n        if (xi) {\n            unpackExtent(xi, &xo, f_exp, f_unf);\n        }\n        // Linux does not fixup the low end, so neither do we.\n        //if (PROT_WRITE & prot) {\n        //    bzero(addr, lo_frag);  // fragment at lo end\n        //}\n        if (PROT_WRITE & prot) { // note: read-only .bss not supported here\n            // Clear to end-of-page (first part of .bss or &_end)\n            unsigned hi_frag = -(long)addr2 &~ PAGE_MASK;\n            bzero(addr2, hi_frag);\n            addr2 += hi_frag;  // will be page aligned\n        }\n        if (xi) {\n#if defined(__x86_64)  //{\n            void *const hatch = make_hatch_x86_64(phdr, reloc, ~PAGE_MASK);\n#elif defined(__powerpc64__)  //}{\n            void *const hatch = make_hatch_ppc64(phdr, reloc, ~PAGE_MASK);\n#elif defined(__aarch64__)  //}{\n            void *const hatch = make_hatch_arm64(phdr, reloc, ~PAGE_MASK);\n#endif  //}\n            if (0!=hatch) {\n                auxv_up((Elf64_auxv_t *)(~1 & (size_t)av), AT_NULL, (size_t)hatch);\n            }\n            DPRINTF(\"Pprotect addr=%%p  len=%%p  prot=%%x\\\\n\", addr, mlen, prot);\n            if (0!=Pprotect(addr, mlen, prot)) {\n                err_exit(10);\nERR_LAB\n            }\n        }\n        if (addr2 < hi_addr) { // pages for .bss beyond last page for p_filesz\n            DPRINTF(\"zmap addr2=%%p  len=%%p  prot=%%x\\\\n\", addr2, hi_addr - addr2, prot);\n            if (addr2 != mmap(addr2, hi_addr - addr2, prot,\n                    MAP_FIXED | MAP_PRIVATE | MAP_ANONYMOUS, -1, 0 ) ) {\n                err_exit(9);\n            }\n        }\n    }\n    if (xi) { // 1st call (main); also have (0!=av) here\n        if (ET_DYN!=ehdr->e_type) {\n            // Needed only if compressed shell script invokes compressed shell.\n            // brk(v_brk);  // SIGSEGV when is_big [unmaps ourself!]\n        }\n    }\n    if (p_reloc) {\n        *p_reloc = reloc;\n    }\n    return ehdr->e_entry + reloc;\n}\n\n\n/*************************************************************************\n// upx_main - called by our entry code\n//\n// This function is optimized for size.\n**************************************************************************/\n\nvoid *\nupx_main(  // returns entry address\n    struct b_info const *const bi,  // 1st block header\n    size_t const sz_compressed,  // total length\n    Elf64_Ehdr *const ehdr,  // temp char[sz_ehdr] for decompressing\n    Elf64_auxv_t *const av,\n    f_expand *const f_exp,\n    f_unfilter *const f_unf\n#if defined(__x86_64)  //{\n    , Elf64_Addr elfaddr  // In: &Elf64_Ehdr for stub\n#elif defined(__powerpc64__)  //}{\n    , Elf64_Addr *p_reloc  // In: &Elf64_Ehdr for stub; Out: 'slide' for PT_INTERP\n    , size_t const PAGE_MASK\n#elif defined(__aarch64__) //}{\n    , Elf64_Addr elfaddr\n    , size_t const PAGE_MASK\n#endif  //}\n)\n{\n    Extent xo, xi1, xi2;\n    xo.buf  = (char *)ehdr;\n    xo.size = bi->sz_unc;\n    xi2.buf = CONST_CAST(char *, bi); xi2.size = bi->sz_cpr + sizeof(*bi);\n    xi1.buf = CONST_CAST(char *, bi); xi1.size = sz_compressed;\n\n    // ehdr = Uncompress Ehdr and Phdrs\n    unpackExtent(&xi2, &xo, f_exp, 0);  // never filtered?\n\n#if defined(__x86_64) || defined(__aarch64__)  //{\n    Elf64_Addr *const p_reloc = &elfaddr;\n#endif  //}\n    DPRINTF(\"upx_main1  .e_entry=%%p  p_reloc=%%p  *p_reloc=%%p  PAGE_MASK=%%p\\\\n\",\n        ehdr->e_entry, p_reloc, *p_reloc, PAGE_MASK);\n    Elf64_Phdr *phdr = (Elf64_Phdr *)(1+ ehdr);\n\n    // De-compress Ehdr again into actual position, then de-compress the rest.\n    Elf64_Addr entry = do_xmap(ehdr, &xi1, 0, av, f_exp, f_unf, p_reloc\n#if defined(__powerpc64__) || defined(__aarch64__)\n       , PAGE_MASK\n#endif\n    );\n    DPRINTF(\"upx_main2  entry=%%p  *p_reloc=%%p\\\\n\", entry, *p_reloc);\n    auxv_up(av, AT_ENTRY , entry);\n\n  { // Map PT_INTERP program interpreter\n    phdr = (Elf64_Phdr *)(1+ ehdr);\n    unsigned j;\n    for (j=0; j < ehdr->e_phnum; ++phdr, ++j) if (PT_INTERP==phdr->p_type) {\n        char const *const iname = *p_reloc + (char const *)phdr->p_vaddr;\n        int const fdi = open(iname, O_RDONLY, 0);\n        if (0 > fdi) {\n            err_exit(18);\n        }\n        if (MAX_ELF_HDR_64!=read(fdi, (void *)ehdr, MAX_ELF_HDR_64)) {\nERR_LAB\n            err_exit(19);\n        }\n        // We expect PT_INTERP to be ET_DYN at 0.\n        // Thus do_xmap will set *p_reloc = slide.\n        *p_reloc = 0;  // kernel picks where PT_INTERP goes\n        entry = do_xmap(ehdr, 0, fdi, 0, 0, 0, p_reloc\n#if defined(__powerpc64__) || defined(__aarch64__)\n            , PAGE_MASK\n#endif\n        );\n        auxv_up(av, AT_BASE, *p_reloc);  // musl\n        close(fdi);\n    }\n  }\n\n    return (void *)entry;\n}\n\n#if DEBUG  //{\n\n#if defined(__powerpc64__) //{\n#define __NR_write 4\n\ntypedef unsigned long size_t;\n\n#if 0  //{\nstatic int\nwrite(int fd, char const *ptr, size_t len)\n{\n    register  int        sys asm(\"r0\") = __NR_write;\n    register  int         a0 asm(\"r3\") = fd;\n    register void const  *a1 asm(\"r4\") = ptr;\n    register size_t const a2 asm(\"r5\") = len;\n    __asm__ __volatile__(\"sc\"\n    : \"=r\"(a0)\n    : \"r\"(sys), \"r\"(a0), \"r\"(a1), \"r\"(a2)\n    : \"r0\", \"r4\", \"r5\", \"r6\", \"r7\", \"r8\", \"r9\", \"r10\", \"r11\", \"r12\", \"r13\"\n    );\n    return a0;\n}\n#else //}{\nssize_t\nwrite(int fd, void const *ptr, size_t len)\n{\n    register  int        sys asm(\"r0\") = __NR_write;\n    register  int         a0 asm(\"r3\") = fd;\n    register void const  *a1 asm(\"r4\") = ptr;\n    register size_t       a2 asm(\"r5\") = len;\n    __asm__ __volatile__(\"sc\"\n    : \"+r\"(sys), \"+r\"(a0), \"+r\"(a1), \"+r\"(a2)\n    :\n    : \"r6\", \"r7\", \"r8\", \"r9\", \"r10\", \"r11\", \"r12\", \"r13\"\n    );\n    return a0;\n}\n#endif  //}\n#endif  //}\n\nstatic int\nunsimal(unsigned x, char *ptr, int n)\n{\n    unsigned m = 10;\n    while (10 <= (x / m)) m *= 10;\n    while (10 <= x) {\n        unsigned d = x / m;\n    x -= m * d;\n        m /= 10;\n        ptr[n++] = '0' + d;\n    }\n    ptr[n++] = '0' + x;\n    return n;\n}\n\nstatic int\ndecimal(int x, char *ptr, int n)\n{\n    if (x < 0) {\n        x = -x;\n        ptr[n++] = '-';\n    }\n    return unsimal(x, ptr, n);\n}\n\nstatic int\nheximal(unsigned long x, char *ptr, int n)\n{\n    unsigned j = -1+ 2*sizeof(unsigned long);\n    unsigned long m = 0xful << (4 * j);\n    for (; j; --j, m >>= 4) { // omit leading 0 digits\n        if (m & x) break;\n    }\n    for (; m; --j, m >>= 4) {\n        unsigned d = 0xf & (x >> (4 * j));\n        ptr[n++] = ((10<=d) ? ('a' - 10) : '0') + d;\n    }\n    return n;\n}\n\n#define va_arg      __builtin_va_arg\n#define va_end      __builtin_va_end\n#define va_list     __builtin_va_list\n#define va_start    __builtin_va_start\n\nstatic int\ndprintf(char const *fmt, ...)\n{\n    int n= 0;\n    char const *literal = 0;  // NULL\n    char buf[24];  // ~0ull == 18446744073709551615 ==> 20 chars\n    va_list va; va_start(va, fmt);\n    for (;;) {\n        char c = *fmt++;\n        if (!c) { // end of fmt\n            if (literal) {\n                goto finish;\n            }\n            break;  // goto done\n        }\n        if ('%'!=c) {\n            if (!literal) {\n                literal = fmt;  // 1 beyond start of literal\n            }\n            continue;\n        }\n        // '%' == c\n        if (literal) {\nfinish:\n            n += write(2, -1+ literal, fmt - literal);\n            literal = 0;  // NULL\n            if (!c) { // fmt already ended\n               break;  // goto done\n            }\n        }\n        switch (c= *fmt++) { // deficiency: does not handle _long_\n        default: { // un-implemented conversion\n            n+= write(2, -1+ fmt, 1);\n        } break;\n        case 0: { // fmt ends with \"%\\0\" ==> ignore\n            goto done;\n        } break;\n        case 'u': {\n            n+= write(2, buf, unsimal(va_arg(va, unsigned), buf, 0));\n        } break;\n        case 'd': {\n            n+= write(2, buf, decimal(va_arg(va, int), buf, 0));\n        } break;\n        case 'p': {\n            buf[0] = '0';\n            buf[1] = 'x';\n            n+= write(2, buf, heximal((unsigned long)va_arg(va, void *), buf, 2));\n        } break;\n        case 'x': {\n            buf[0] = '0';\n            buf[1] = 'x';\n            n+= write(2, buf, heximal(va_arg(va, int), buf, 2));\n        } break;\n        } // 'switch'\n    }\ndone:\n    va_end(va);\n    return n;\n }\n#endif  //}\n\n/* vim:set ts=4 sw=4 et: */\n","size_bytes":27545},"src/stub/src/amd64-linux.elf-main2.c":{"content":"/* amd64-linux.elf-main.c -- stub loader for Linux 64-bit ELF executable\n\n   This file is part of the UPX executable compressor.\n\n   Copyright (C) 1996-2025 Markus Franz Xaver Johannes Oberhumer\n   Copyright (C) 1996-2025 Laszlo Molnar\n   Copyright (C) 2000-2025 John F. Reiser\n   All Rights Reserved.\n\n   UPX and the UCL library are free software; you can redistribute them\n   and/or modify them under the terms of the GNU General Public License as\n   published by the Free Software Foundation; either version 2 of\n   the License, or (at your option) any later version.\n\n   This program is distributed in the hope that it will be useful,\n   but WITHOUT ANY WARRANTY; without even the implied warranty of\n   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n   GNU General Public License for more details.\n\n   You should have received a copy of the GNU General Public License\n   along with this program; see the file COPYING.\n   If not, write to the Free Software Foundation, Inc.,\n   59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.\n\n   Markus F.X.J. Oberhumer              Laszlo Molnar\n   <markus@oberhumer.com>               <ezerotven+github@gmail.com>\n\n   John F. Reiser\n   <jreiser@users.sourceforge.net>\n */\n\n#ifndef DEBUG  //{\n#define DEBUG 0\n#endif  //}\n\n#include \"include/linux.h\"\n// memfd_create, but fall back to /dev/shm\n// such as Ubuntu-20.04, Linux kernel 5.15.0-67, #74-20.04.1, 2023-02-22\nextern int upxfd_create(char const *tag, unsigned flags);\n#define MFD_EXEC 0x0010\n#define MS_SYNC 4\n\nextern void *memcpy(void *dst, void const *src, size_t n);\n// Pprotect is mprotect but uses page-aligned address (Linux requirement)\nextern unsigned Pprotect(void *, size_t, unsigned);\nextern int Psync(void*, size_t, unsigned);\n//extern void *Pmap(void *, size_t, unsigned, unsigned, int, size_t);\n//extern int Punmap(void *, size_t);\nextern size_t Pwrite(unsigned, void const *, size_t);\n#  define mmap_privanon(addr,len,prot,flgs) mmap((addr),(len),(prot), \\\n        MAP_PRIVATE|MAP_ANONYMOUS|(flgs),-1,0)\n\nextern void my_bkpt(void *, ...);\n\n#if defined(__powerpc64__) //}{\n#define addr_string(string) ({ \\\n    char const *str; \\\n    asm(\"bl 0f; .string \\\"\" string \"\\\"; .balign 4; 0: mflr %0\" \\\n/*out*/ : \"=r\"(str) \\\n/* in*/ : \\\n/*und*/ : \"lr\"); \\\n    str; \\\n})\n#elif defined(__x86_64) //}{\n#define addr_string(string) ({ \\\n    char const *str; \\\n    asm(\"lea 9f(%%rip),%0; .section STRCON; 9:.asciz \\\"\" string \"\\\"; .previous\" \\\n/*out*/ : \"=r\"(str) ); \\\n    str; \\\n})\n#elif defined(__aarch64__) //}{\n#define addr_string(string) ({ \\\n    char const *str; \\\n    asm(\"bl 0f; .string \\\"\" string \"\\\"; .balign 4; 0: mov %0,x30\" \\\n/*out*/ : \"=r\"(str) \\\n/* in*/ : \\\n/*und*/ : \"x30\"); \\\n    str; \\\n})\n#else  //}{\n#error;\n#endif  //}\n#if !DEBUG //{\n#define DPRINTF(fmt, args...) /*empty*/\n#else  //}{\n// DPRINTF is defined as an expression using \"({ ... })\"\n// so that DPRINTF can be invoked inside an expression,\n// and then followed by a comma to ignore the return value.\n// The only complication is that percent and backslash\n// must be doubled in the format string, because the format\n// string is processd twice: once at compile-time by 'asm'\n// to produce the assembled value, and once at runtime to use it.\n#if defined(__powerpc64__)  //{\n#define DPRINTF(fmt, args...) ({ \\\n    char const *r_fmt; \\\n    asm(\"bl 0f; .string \\\"\" fmt \"\\\"; .balign 4; 0: mflr %0\" \\\n/*out*/ : \"=r\"(r_fmt) \\\n/* in*/ : \\\n/*und*/ : \"lr\"); \\\n    dprintf(r_fmt, args); \\\n})\n#elif defined(__x86_64) //}{\n#define DPRINTF(fmt, args...) ({ \\\n    char const *r_fmt; \\\n    asm(\"call 0f; .asciz \\\"\" fmt \"\\\"; 0: pop %0\" \\\n/*out*/ : \"=r\"(r_fmt) ); \\\n    dprintf(r_fmt, args); \\\n})\n#elif defined(__aarch64__) //}{\n#define DPRINTF(fmt, args...) ({ \\\n    char const *r_fmt; \\\n    asm(\"bl 0f; .string \\\"\" fmt \"\\\"; .balign 4; 0: mov %0,x30\" \\\n/*out*/ : \"=r\"(r_fmt) \\\n/* in*/ : \\\n/*und*/ : \"x30\"); \\\n    dprintf(r_fmt, args); \\\n})\n\n#endif  //}\n\nstatic int dprintf(char const *fmt, ...); // forward\n#endif  /*}*/\n\n/*************************************************************************\n// configuration section\n**************************************************************************/\n\n// In order to make it much easier to move this code at runtime and execute\n// it at an address different from it load address:  there must be no\n// static data, and no string constants.\n\n#define ElfW(sym) Elf64_ ## sym\n\n#include \"MAX_ELF_HDR.c\"\n\n/*************************************************************************\n// \"file\" util\n**************************************************************************/\n\ntypedef struct {\n    size_t size;  // must be first to match size[0] uncompressed size\n    char *buf;\n} Extent;\n\n\nstatic void\nxread(Extent *x, char *buf, size_t count)\n{\n    DPRINTF(\"xread x.size=%%x  x.buf=%%p  buf=%%p  count=%%x\\\\n\",\n        x->size, x->buf, buf, count);\n    char *p=x->buf, *q=buf;\n    size_t j;\n    if (x->size < count) {\n        exit(127);\n    }\n    for (j = count; 0!=j--; ++p, ++q) {\n        *q = *p;\n    }\n    x->buf  += count;\n    x->size -= count;\n    DPRINTF(\"xread done count=%%x\\\\n\", count);\n}\n\n\n/*************************************************************************\n// util\n**************************************************************************/\n\n#if !DEBUG  //{  save space\n#define ERR_LAB error: exit(127);\n#define err_exit(a) goto error\n#else  //}{  save debugging time\n#define ERR_LAB /*empty*/\nstatic void\nerr_exit(int a)\n{\n    (void)a;  // debugging convenience\n    DPRINTF(\"err_exit %%d\\\\n\", a);\n    exit(127);\n}\n#endif  //}\n\n/*************************************************************************\n// UPX & NRV stuff\n**************************************************************************/\n\nextern size_t get_page_mask(void);  // variable page size AT_PAGESZ; see *-fold.S\n\nint f_expand( // .globl in $(ARCH)-expand.S\n    nrv_byte const *binfo, nrv_byte *dst, size_t *dstlen);\n\nstatic void\nunpackExtent(\n    Extent *const xi,  // input includes struct b_info\n    Extent *const xo   // output\n)\n{\n    while (xo->size) {\n        DPRINTF(\"unpackExtent xi=(%%p %%p)  xo=(%%p %%p)\\\\n\",\n            xi->size, xi->buf, xo->size, xo->buf);\n        struct b_info h;\n        //   Note: if h.sz_unc == h.sz_cpr then the block was not\n        //   compressible and is stored in its uncompressed form.\n\n        // Read and check block sizes.\n        xread(xi, (char *)&h, sizeof(h));\n        DPRINTF(\"h.sz_unc=%%x  h.sz_cpr=%%x  h.b_method=%%x\\\\n\",\n            h.sz_unc, h.sz_cpr, h.b_method);\n        if (h.sz_unc == 0) {                     // uncompressed size 0 -> EOF\n            if (h.sz_cpr != UPX_MAGIC_LE32)      // h.sz_cpr must be h->magic\n                err_exit(2);\n            if (xi->size != 0)                 // all bytes must be written\n                err_exit(3);\n            break;\n        }\n        if (h.sz_cpr <= 0) {\n            err_exit(4);\nERR_LAB\n        }\n        if (h.sz_cpr > h.sz_unc\n        ||  h.sz_unc > xo->size ) {\n            err_exit(5);\n        }\n        // Now we have:\n        //   assert(h.sz_cpr <= h.sz_unc);\n        //   assert(h.sz_unc > 0 && h.sz_unc <= blocksize);\n        //   assert(h.sz_cpr > 0 && h.sz_cpr <= blocksize);\n\n        if (h.sz_cpr < h.sz_unc) { // Decompress block\n            size_t out_len = h.sz_unc;  // EOF for lzma\n            int const j = f_expand((unsigned char *)xi->buf - sizeof(h),\n                (unsigned char *)xo->buf, &out_len);\n            if (j != 0 || out_len != (nrv_uint)h.sz_unc) {\n                DPRINTF(\"  j=%%x  out_len=%%x  &h=%%p\\\\n\", j, out_len, &h);\n                err_exit(6);\n            }\n            xi->buf  += h.sz_cpr;\n            xi->size -= h.sz_cpr;\n        }\n        else { // copy literal block\n            DPRINTF(\"  copy %%p  %%p  %%p\\\\n\", xi->buf, xo->buf, h.sz_cpr);\n            xi->size += sizeof(h);  // xread(xi, &h, sizeof(h)) was a peek\n            xread(xi, xo->buf, h.sz_cpr);\n        }\n        xo->buf  += h.sz_unc;\n        xo->size -= h.sz_unc;\n    }\n    DPRINTF(\"unpackExtent done xo->buf=%%p\\\\n\", xo->buf);\n}\n\n#if defined(__x86_64__)  //{\nstatic void *\nmake_hatch(\n    ElfW(Phdr) const *const phdr,\n    char *next_unc,\n    unsigned const frag_mask\n)\n{\n    char *hatch = next_unc;\n    int code[3] =  {\n        0xfa1e0ff3,  // endbr64\n        0x585a050f,  // syscall; pop %arg3{%rdx}; pop %rax\n        0x90e0ff3e,  // notrack jmp *%rax; nop\n    };\n    DPRINTF(\"make_hatch %%p %%p %%x\\\\n\", phdr, next_unc, frag_mask);\n    if (phdr->p_type==PT_LOAD && phdr->p_flags & PF_X) {\n        if (sizeof(code) <= (unsigned)(frag_mask & -(long)hatch)) {\n            ((int *)hatch)[0] = code[0];  // endbr64\n            ((int *)hatch)[1] = code[1];  // syscall; pop %arg3{%rdx}; pop %rax\n            ((int *)hatch)[2] = code[2];  // notrack jmp *%rax; nop\n        }\n        else { // Does not fit at hi end of .text, so must use a new page \"permanently\"\n            int mfd = upxfd_create(addr_string(\"upx\"), MFD_EXEC);  // the directory entry\n            write(mfd, &code, sizeof(code));\n            hatch = mmap(0, sizeof(code), PROT_READ|PROT_EXEC, MAP_SHARED, mfd, 0);\n            close(mfd);\n        }\n    }\n    DPRINTF(\"hatch=%%p\\\\n\", hatch);\n    return hatch;\n}\n#elif defined(__powerpc64__)  //}{\nstatic void *\nmake_hatch(\n    ElfW(Phdr) const *const phdr,\n    char *next_unc,\n    unsigned const frag_mask\n)\n{\n    unsigned *hatch = (unsigned *)(~3& (3+ (long)next_unc));\n    unsigned const *code;\n    unsigned const sz_code = 4*4;\n    asm(\"bl 0f; \\\n        sc; \\\n        mr 12,31; \\\n        li 4,0; \\\n        blr; \\\n     0: mflr %0 \"\n/*out*/ : \"=r\"(code)\n/* in*/ :\n/*und*/ : \"lr\");\n    DPRINTF(\"make_hatch %%p %%p %%x\\\\n\",phdr,next_unc,frag_mask);\n    if (phdr->p_type==PT_LOAD && phdr->p_flags & PF_X) {\n        if (sz_code <= (frag_mask & -(long)hatch)) {\n            memcpy(hatch, code, sz_code);\n        }\n        else { // Does not fit at hi end of .text, so must use a new page \"permanently\"\n            int mfd = upxfd_create(addr_string(\"upx\"), MFD_EXEC);  // the directory entry\n            write(mfd, code, sz_code);\n            hatch = mmap(0, sz_code, PROT_READ|PROT_EXEC, MAP_SHARED, mfd, 0);\n            close(mfd);\n        }\n    }\n    DPRINTF(\"hatch=%%p\\\\n\", hatch);\n    return hatch;\n}\n#elif defined(__aarch64__)  //{\n#define NBPI 4\n#define NINSTR 3\nstatic void *\nmake_hatch(\n    ElfW(Phdr) const *const phdr,\n    char *next_unc,\n    unsigned const frag_mask\n)\n{\n    unsigned *hatch = (unsigned *)(~3& (3+ (long)next_unc));\n    unsigned const *code;\n    unsigned const sz_code = 2*4;\n    asm (\"bl 0f; \\\n        svc #0; \\\n        br x30; \\\n     0: mov %0,x30\"\n/*out*/ : \"=r\"(code)\n/* in*/ :\n/*und*/ : );\n    DPRINTF(\"make_hatch %%p %%p %%x\\\\n\",phdr,next_unc,frag_mask);\n    if (phdr->p_type==PT_LOAD && phdr->p_flags & PF_X) {\n        if (sz_code <= (frag_mask & -(long)hatch)) {\n            memcpy(hatch, code, sz_code);\n        }\n        else { // Does not fit at hi end of .text, so must use a new page \"permanently\"\n            int mfd = upxfd_create(addr_string(\"upx\"), MFD_EXEC);  // the directory entry\n            write(mfd, code, sz_code);\n            hatch = mmap(0, sz_code, PROT_READ|PROT_EXEC, MAP_SHARED, mfd, 0);\n            close(mfd);\n        }\n    }\n    DPRINTF(\"hatch=%%p\\\\n\", hatch);\n    return hatch;\n}\n#undef NBPI\n#undef NINSTR\n#endif  //}\n\n#if defined(__powerpc64__) || defined(__aarch64__)  //{ bzero\nstatic void\nupx_bzero(char *p, size_t len)\n{\n    DPRINTF(\"bzero %%x  %%x\\\\n\", p, len);\n    if (len) do {\n        *p++= 0;\n    } while (--len);\n}\n#define bzero upx_bzero\n#else  //}{\n#define bzero(a,b)  __builtin_memset(a,0,b)\n#endif  //}\n\nstatic void\nauxv_up(ElfW(auxv_t) *av, unsigned const type, uint64_t const value)\n{\n    if (!av || (1& (size_t)av)) { // none, or inhibited for PT_INTERP\n        return;\n    }\n    DPRINTF(\"\\\\nauxv_up %%d  %%p\\\\n\", type, value);\n    // Multiple slots can have 'type' which wastes space but is legal.\n    // rtld (ld-linux) uses the last one, so we must scan the whole table.\n    Elf64_auxv_t *ignore_slot = 0;\n    int found = 0;\n    for (;; ++av) {\n        DPRINTF(\"  %%d  %%p\\\\n\", av->a_type, av->a_un.a_val);\n        if (av->a_type == type) {\n            av->a_un.a_val = value;\n            ++found;\n        }\n        else if (av->a_type == AT_IGNORE) {\n            ignore_slot = av;\n        }\n        if (av->a_type==AT_NULL) { // done scanning\n            if (found) {\n                return;\n            }\n            if (ignore_slot) {\n                ignore_slot->a_type = type;\n                ignore_slot->a_un.a_val = value;\n                return;\n            }\n            err_exit(20);\nERR_LAB\n            return;\n        }\n    }\n}\n\n// Segregate large local array, to avoid code bloat due to large displacements.\n// Not 'static' to disaable inlining, to control sizeof stack frame in callers.\n/*static*/ void\nunderlay(unsigned size, char *ptr, unsigned len)  // len <= PAGE_SIZE\n{\n    DPRINTF(\"underlay size=%%u  ptr=%%p  len=%%u\\\\n\", size, ptr, len);\n    unsigned saved[4096/sizeof(unsigned)];\n    memcpy(saved, ptr, len);\n    mmap(ptr, size, PROT_WRITE|PROT_READ,\n        MAP_FIXED|MAP_PRIVATE|MAP_ANONYMOUS, -1, 0);\n    memcpy(ptr, saved, len);\n}\n\n#if 0  //{\n// Exchange the bits with values 4 (PF_R, PROT_EXEC) and 1 (PF_X, PROT_READ)\n// Use table lookup into a PIC-string that pre-computes the result.\nunsigned PF_TO_PROT(unsigned flags)\n{\n    char const *table = addr_string(\"\\x80\\x04\\x02\\x06\\x01\\x05\\x03\\x07\");\n    return 7& table[flags & (PF_R|PF_W|PF_X)];\n}\n#else  //}{\n// The PF_* and PROT_* bits are {1,2,4}; the conversion table fits in 32 bits.\n#define REP8(x) \\\n    ((x)|((x)<<4)|((x)<<8)|((x)<<12)|((x)<<16)|((x)<<20)|((x)<<24)|((x)<<28))\n#define EXP8(y) \\\n    ((1&(y)) ? 0xf0f0f0f0 : (2&(y)) ? 0xff00ff00 : (4&(y)) ? 0xffff0000 : 0)\n#define PF_TO_PROT(pf) \\\n    ((PROT_READ|PROT_WRITE|PROT_EXEC) & ( \\\n        ( (REP8(PROT_EXEC ) & EXP8(PF_X)) \\\n         |(REP8(PROT_READ ) & EXP8(PF_R)) \\\n         |(REP8(PROT_WRITE) & EXP8(PF_W)) \\\n        ) >> ((pf & (PF_R|PF_W|PF_X))<<2) ))\n#endif  //}\n\n// Find convex hull of PT_LOAD (the minimal interval which covers all PT_LOAD),\n// and mmap that much, to be sure that a kernel using exec-shield-randomize\n// won't place the first piece in a way that leaves no room for the rest.\nstatic ElfW(Addr) // returns relocation constant\nxfind_pages(unsigned mflags, ElfW(Phdr) const *phdr, int phnum, ElfW(Addr) *const p_brk)\n{\n    ElfW(Addr) lo= ~0, hi= 0, addr = 0, p_align = 0x1000;\n    ElfW(Addr) page_mask = get_page_mask();\n    DPRINTF(\"xfind_pages  %%x  %%p  %%d  %%p  %%p\\\\n\", mflags, phdr, phnum, p_brk, page_mask);\n    for (; --phnum>=0; ++phdr) if (PT_LOAD==phdr->p_type && phdr->p_memsz) {\n        if (phdr->p_vaddr < lo) {\n            lo = phdr->p_vaddr;\n        }\n        if (hi < (phdr->p_memsz + phdr->p_vaddr)) {\n            hi =  phdr->p_memsz + phdr->p_vaddr;\n        }\n        if (p_align < phdr->p_align) {\n            p_align = phdr->p_align;\n        }\n    } // end scan of PT_LOADs\n    size_t page_size = 0u - page_mask;\n    lo &= page_mask;  // round down to page boundary\n    size_t len1 = page_mask & (hi - lo + page_size -1);  // desired length\n\n    // Linux lacks mmap_aligned(), so allocate a larger space, then trim the ends.\n    // Avoid division (p_align / page_size); both are powers of 2\n    unsigned q = 1;\n    while ((q * page_size) < p_align) q <<= 1;\n    --q;  // number of extra pages\n    unsigned len2 = len1 + (q * page_size);  // get enough space to align\n    addr = (ElfW(Addr))mmap_privanon((void *)lo, len2, PROT_NONE, mflags);\n    DPRINTF(\"  addr=%%p  lo=%%p  hi=%%p align=%%p  q=%%p  len1=%%p  len2=%%p  align=%%p\\\\n\",\n        addr, lo, hi, p_align, q, len1, len2, p_align);\n    if (q) {\n        size_t len3 = (-1 + p_align) & -addr;  // up to p_align boundary\n        if (len3) {\n            munmap((void *)addr, len3);  // trim the low end\n            addr += len3;\n            len2 -= len3;\n        }\n        if (len2 -= len1) {\n            munmap((void *)(addr + len1), len2); // trim the high end\n        }\n    }\n    DPRINTF(\"  addr=%%p\\\\n\", addr);\n    *p_brk = len1 + addr;  // the logical value of brk(0)\n    return (ptrdiff_t)addr - lo;\n}\n\nstatic ElfW(Addr)  // entry address\ndo_xmap(\n    ElfW(Ehdr) const *const ehdr,\n    Extent *const xi,\n    int const fdi,\n    ElfW(auxv_t) *const av,\n    ElfW(Addr) *const p_reloc\n)\n{\n    ElfW(Phdr) const *phdr = (ElfW(Phdr) const *)(void const *)(ehdr->e_phoff +\n        (char const *)ehdr);\n    ElfW(Addr) v_brk = 0;\n    ElfW(Addr) reloc = 0;\n    if (xi) { // compressed main program:\n        // C_BASE space reservation, C_TEXT compressed data and stub\n        ElfW(Addr)  ehdr0 = *p_reloc;\n        ElfW(Phdr) *phdr0 = (ElfW(Phdr) *)(1+ (ElfW(Ehdr) *)ehdr0);  // cheats .e_phoff\n        v_brk = ehdr0 + phdr0->p_vaddr + phdr0->p_memsz;\n        if (ET_DYN == ehdr->e_type) {\n            reloc = ehdr0 - phdr0[1].p_vaddr;\n        }\n        // paranoia: prevent \"hangover\" from VMA for C_BASE\n        munmap((void *)(reloc + phdr0->p_vaddr), phdr0->p_memsz);\n    }\n    else { // PT_INTERP\n        DPRINTF(\"INTERP\\\\n\", 0);\n        reloc = xfind_pages(\n            ((ET_DYN!=ehdr->e_type) ? MAP_FIXED : 0), phdr, ehdr->e_phnum, &v_brk);\n    }\n    DPRINTF(\"do_xmap  ehdr=%%p  xi=%%p(%%x %%p)  fdi=%%x\\\\n\"\n          \"  av=%%p  reloc=%%p  p_reloc=%%p/%%p\\\\n\",\n        ehdr, xi, (xi? xi->size: 0), (xi? xi->buf: 0), fdi,\n        av, reloc, p_reloc, *p_reloc);\n\n    size_t const page_mask = get_page_mask();\n    int j;\n    for (j=0; j < ehdr->e_phnum; ++phdr, ++j)\n    if (xi && PT_PHDR==phdr->p_type) {\n        auxv_up(av, AT_PHDR, phdr->p_vaddr + reloc);\n    } else\n    if (PT_LOAD==phdr->p_type && phdr->p_memsz != 0) {\n        unsigned const prot = PF_TO_PROT(phdr->p_flags);\n        DPRINTF(\"\\\\n\\\\nLOAD@%%p  p_offset=%%p  p_vaddr=%%p  p_filesz=%%p\"\n            \"  p_memsz=%%p  p_flags=%%x  prot=%%x\\\\n\",\n            phdr, phdr->p_offset, phdr->p_vaddr, phdr->p_filesz,\n            phdr->p_memsz, phdr->p_flags, prot);\n        if (xi && !phdr->p_offset /*&& ET_EXEC==ehdr->e_type*/) { // 1st PT_LOAD\n            // ? Compressed PT_INTERP must not overwrite values from compressed a.out?\n            auxv_up(av, AT_PHDR, phdr->p_vaddr + reloc + ehdr->e_phoff);\n            auxv_up(av, AT_PHNUM, ehdr->e_phnum);\n            auxv_up(av, AT_PHENT, ehdr->e_phentsize);  /* ancient kernels might omit! */\n            //auxv_up(av, AT_PAGESZ, PAGE_SIZE);  /* ld-linux.so.2 does not need this */\n        }\n        Extent xo;\n        size_t mlen = xo.size = phdr->p_filesz;\n        char * addr = xo.buf  = reloc + (char *)phdr->p_vaddr;\n            // xo.size, xo.buf are not changed except by unpackExtent()\n        char *const hi_addr = phdr->p_memsz + addr;  // end of local .bss\n        char *addr2 = mlen + addr;  // end of local .data\n        size_t frag  = ~page_mask & (ElfW(Addr))addr;\n        mlen += frag;\n        addr -= frag;\n\n#if defined(__powerpc64__) || defined(__aarch64__)\n        // Round up to hardware PAGE_SIZE; allows emulator with smaller.\n        // But (later) still need bzero when .p_filesz < .p_memsz .\n        mlen += -(mlen + (size_t)addr) &~ page_mask;\n        DPRINTF(\"  mlen=%%p\\\\n\", mlen);\n#endif\n\n        DPRINTF(\"mmap addr=%%p  mlen=%%p  offset=%%p  frag=%%p  prot=%%x\\\\n\",\n            addr, mlen, phdr->p_offset - frag, frag, prot);\n        int mfd = 0;\n        if (xi && phdr->p_flags & PF_X) { // SELinux\n            // Cannot set PROT_EXEC except via mmap() into a region (Linux \"vma\")\n            // that has never had PROT_WRITE.  So use a Linux-only \"memory file\"\n            // to hold the contents.\n            mfd = upxfd_create(addr_string(\"upx\"), MFD_EXEC);  // the directory entry\n            ftruncate(mfd, mlen);  // Allocate the pages in the file.\n            if (frag) {\n                // Note: *addr does not exist yet, and figuring out a substitute\n                // Note: location is a cumbersome heristic.  So do not attempt.\n                //\n                // write(mfd, addr, frag);  // Save lo fragment of contents on first page.\n            }\n            if (addr != mmap(addr, mlen, PROT_READ|PROT_WRITE, MAP_FIXED|MAP_SHARED, mfd, 0)) {\n                err_exit(7);\n            }\n        }\n        else {\n            unsigned tprot = prot;\n            // Notice that first 4 args are same: mmap vs mmap_privanon\n            if (xi) {\n                tprot |=  PROT_WRITE;  // De-compression needs Write\n                tprot &= ~PROT_EXEC;  // Avoid simultaneous Write and eXecute\n                if (addr != mmap_privanon(addr, mlen, tprot, MAP_FIXED|MAP_PRIVATE)) {\n                    err_exit(11);\n                }\n            }\n            else if (addr != mmap(addr, mlen, tprot, MAP_FIXED|MAP_PRIVATE,\n                        fdi, phdr->p_offset - frag)) {\n                err_exit(8);\n            }\n        }\n        DPRINTF(\"addr= %%p\\\\n\", addr);\n\n        if (xi) {\n            DPRINTF(\"before unpack xi=(%%p %%p  xo=(%%p %%p)\\\\n\", xi->size, xi->buf, xo.size, xo.buf);\n            unpackExtent(xi, &xo);  // updates xi and xo\n            DPRINTF(\" after unpack xi=(%%p %%p  xo=(%%p %%p)\\\\n\", xi->size, xi->buf, xo.size, xo.buf);\n        }\n        if (PROT_WRITE & prot) { // note: read-only .bss not supported here\n            // Clear to end-of-page (first part of .bss or &_end)\n            unsigned hi_frag = -(long)addr2 &~ page_mask;\n            bzero(addr2, hi_frag);\n            addr2 += hi_frag;  // will be page aligned\n        }\n\n        if (xi && phdr->p_flags & PF_X) {\n            void *const hatch = make_hatch(phdr, xo.buf, ~page_mask);\n            if (0!=hatch) {\n                // Always update AT_NULL, especially for compressed PT_INTERP.\n                // Clearing lo bit of av is for i386 only; else is superfluous.\n                auxv_up((ElfW(auxv_t) *)(~1 & (size_t)av), AT_NULL, (size_t)hatch);\n            }\n\n            // SELinux: Map the contents of mfd as per *phdr.\n            DPRINTF(\"hatch protect addr=%%p  mlen=%%p\\\\n\", addr, mlen);\n            Psync(addr, mlen, MS_SYNC); // be sure file gets de-compressed bytes\n            munmap(addr, mlen);  // toss the VMA that has PROT_WRITE\n            if (addr != mmap(addr, mlen, prot, MAP_FIXED|MAP_SHARED, mfd, 0)) {\n                err_exit(9);\n            }\n            close(mfd);\n        }\n        else if ((PROT_WRITE|PROT_READ) != prot\n        &&  0!=Pprotect(addr, mlen, prot)) {\n            err_exit(10);\nERR_LAB\n        }\n        if (addr2 < hi_addr) { // pages for .bss beyond last page for p_filesz\n            DPRINTF(\"zmap addr2=%%p  len=%%p\\\\n\", addr2, hi_addr - addr2);\n            if (addr2 != mmap_privanon(addr2, hi_addr - addr2, prot, MAP_FIXED)) {\n                err_exit(10);\n            }\n        }\n    }\n    if (xi && ET_DYN!=ehdr->e_type) {\n        // Needed only if compressed shell script invokes compressed shell.\n        // Besides, fold.S needs _Ehdr that is tossed\n        // do_brk((void *)v_brk);\n    }\n    if (p_reloc) {\n        *p_reloc = reloc;\n    }\n    return ehdr->e_entry + reloc;\n}\n\n\n/*************************************************************************\n// upx_main2 - called by our entry code\n//\n// This function is optimized for size.\n**************************************************************************/\n\nvoid *\nupx_main2(  // returns entry address\n/*arg1*/    struct b_info const *const bi,  // 1st block header\n/*arg2*/    size_t const sz_compressed,  // total length\n/*arg3*/    ElfW(Ehdr) *const ehdr,  // temp char[sz_ehdr] for decompressing\n/*arg4*/    ElfW(auxv_t) *const av\n#if defined(__x86_64)  //{\n/*arg5*/    , ElfW(Addr) elfaddr  // In: &ElfW(Ehdr) for stub\n#elif defined(__aarch64__) //}{\n/*arg5*/    , ElfW(Addr) elfaddr\n#elif defined(__powerpc64__)  //}{\n/*arg5*/    , ElfW(Addr) *p_reloc  // In: &ElfW(Ehdr) for stub; Out: 'slide' for PT_INTERP\n#endif  //}\n)\n{\n    DPRINTF(\"upx_main2  b_info=%%p  sz_compressed=%%p  ehdr=%%p  av=%%p\\\\n\",\n        bi, sz_compressed, ehdr, av);\n#if defined(__powerpc64__)\n    DPRINTF(\"   p_reloc=%%p\\\\n\", p_reloc);\n#endif\n    Extent xo, xi1, xi2;\n    xo.buf  = (char *)ehdr;\n    xo.size = bi->sz_unc;  // can require bi aligned(4)\n    xi2.buf = CONST_CAST(char *, bi); xi2.size = bi->sz_cpr + sizeof(*bi);\n    xi1.buf = CONST_CAST(char *, bi); xi1.size = sz_compressed;\n\n    // ehdr = Uncompress Ehdr and Phdrs\n    unpackExtent(&xi2, &xo);  // never filtered?\n\n#if defined(__x86_64) || defined(__aarch64__)  //{\n    ElfW(Addr) *const p_reloc = &elfaddr;\n#endif  //}\n    ElfW(Addr) page_mask = get_page_mask(); (void)page_mask;\n    DPRINTF(\"upx_main21  .e_entry=%%p  p_reloc=%%p  *p_reloc=%%p  page_mask=%%p\\\\n\",\n        ehdr->e_entry, p_reloc, *p_reloc, page_mask);\n    ElfW(Phdr) *phdr = (ElfW(Phdr) *)(1+ ehdr);\n\n    // De-compress Ehdr again into actual position, then de-compress the rest.\n    ElfW(Addr) entry = do_xmap(ehdr, &xi1, 0, av, p_reloc);\n    DPRINTF(\"upx_main22  entry=%%p  *p_reloc=%%p\\\\n\", entry, *p_reloc);\n    auxv_up(av, AT_ENTRY , entry);\n\n  { // Map PT_INTERP program interpreter\n    phdr = (ElfW(Phdr) *)(1+ ehdr);\n    unsigned j;\n    for (j=0; j < ehdr->e_phnum; ++phdr, ++j) if (PT_INTERP==phdr->p_type) {\n        char const *const iname = *p_reloc + (char const *)phdr->p_vaddr;\n        int const fdi = open(iname, O_RDONLY, 0);\n        if (0 > fdi) {\n            err_exit(18);\n        }\n        if (MAX_ELF_HDR_64!=read(fdi, (void *)ehdr, MAX_ELF_HDR_64)) {\nERR_LAB\n            err_exit(19);\n        }\n        // We expect PT_INTERP to be ET_DYN at 0.\n        // Thus do_xmap will set *p_reloc = slide.\n        *p_reloc = 0;  // kernel picks where PT_INTERP goes\n        entry = do_xmap(ehdr, 0, fdi, 0, p_reloc);\n        DPRINTF(\"interp p_reloc=%%p  reloc=%%p\\\\n\", p_reloc, *p_reloc);\n        auxv_up(av, AT_BASE, *p_reloc);  // musl\n        close(fdi);\n    }\n  }\n\n    return (void *)entry;\n}\n\n#if DEBUG  //{\n\nstatic int\nunsimal(unsigned x, char *ptr, int n)\n{\n    unsigned m = 10;\n    while (10 <= (x / m)) m *= 10;\n    while (10 <= x) {\n        unsigned d = x / m;\n    x -= m * d;\n        m /= 10;\n        ptr[n++] = '0' + d;\n    }\n    ptr[n++] = '0' + x;\n    return n;\n}\n\nstatic int\ndecimal(int x, char *ptr, int n)\n{\n    if (x < 0) {\n        x = -x;\n        ptr[n++] = '-';\n    }\n    return unsimal(x, ptr, n);\n}\n\nstatic int\nheximal(unsigned long x, char *ptr, int n)\n{\n    unsigned j = -1+ 2*sizeof(unsigned long);\n    unsigned long m = 0xful << (4 * j);\n    for (; j; --j, m >>= 4) { // omit leading 0 digits\n        if (m & x) break;\n    }\n    for (; m; --j, m >>= 4) {\n        unsigned d = 0xf & (x >> (4 * j));\n        ptr[n++] = ((10<=d) ? ('a' - 10) : '0') + d;\n    }\n    return n;\n}\n\n#define va_arg      __builtin_va_arg\n#define va_end      __builtin_va_end\n#define va_list     __builtin_va_list\n#define va_start    __builtin_va_start\n\nstatic int\ndprintf(char const *fmt, ...)\n{\n    int n= 0;\n    char const *literal = 0;  // NULL\n    char buf[24];  // ~0ull == 18446744073709551615 ==> 20 chars\n    va_list va; va_start(va, fmt);\n    for (;;) {\n        char c = *fmt++;\n        if (!c) { // end of fmt\n            if (literal) {\n                goto finish;\n            }\n            break;  // goto done\n        }\n        if ('%'!=c) {\n            if (!literal) {\n                literal = fmt;  // 1 beyond start of literal\n            }\n            continue;\n        }\n        // '%' == c\n        if (literal) {\nfinish:\n            n += write(2, -1+ literal, fmt - literal);\n            literal = 0;  // NULL\n            if (!c) { // fmt already ended\n               break;  // goto done\n            }\n        }\n        switch (c= *fmt++) { // deficiency: does not handle _long_\n        default: { // un-implemented conversion\n            n+= write(2, -1+ fmt, 1);\n        } break;\n        case 0: { // fmt ends with \"%\\0\" ==> ignore\n            goto done;\n        } break;\n        case 'u': {\n            n+= write(2, buf, unsimal(va_arg(va, unsigned), buf, 0));\n        } break;\n        case 'd': {\n            n+= write(2, buf, decimal(va_arg(va, int), buf, 0));\n        } break;\n        case 'p': {\n            buf[0] = '0';\n            buf[1] = 'x';\n            n+= write(2, buf, heximal((unsigned long)va_arg(va, void *), buf, 2));\n        } break;\n        case 'x': {\n            buf[0] = '0';\n            buf[1] = 'x';\n            n+= write(2, buf, heximal(va_arg(va, int), buf, 2));\n        } break;\n        } // 'switch'\n    }\ndone:\n    va_end(va);\n    return n;\n }\n#endif  //}\n\n/* vim:set ts=4 sw=4 et: */\n","size_bytes":28497},"src/stub/src/amd64-linux.elf-so_main.c":{"content":"/* amd64-linux.elf-so_main.c -- stub loader for compressed shared library\n\n   This file is part of the UPX executable compressor.\n\n   Copyright (C) 1996-2021 Markus Franz Xaver Johannes Oberhumer\n   Copyright (C) 1996-2021 Laszlo Molnar\n   Copyright (C) 2000-2025 John F. Reiser\n   All Rights Reserved.\n\n   UPX and the UCL library are free software; you can redistribute them\n   and/or modify them under the terms of the GNU General Public License as\n   published by the Free Software Foundation; either version 2 of\n   the License, or (at your option) any later version.\n\n   This program is distributed in the hope that it will be useful,\n   but WITHOUT ANY WARRANTY; without even the implied warranty of\n   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n   GNU General Public License for more details.\n\n   You should have received a copy of the GNU General Public License\n   along with this program; see the file COPYING.\n   If not, write to the Free Software Foundation, Inc.,\n   59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.\n\n   Markus F.X.J. Oberhumer              Laszlo Molnar\n   <markus@oberhumer.com>               <ezerotven+github@gmail.com>\n\n   John F. Reiser\n   <jreiser@users.sourceforge.net>\n */\n\n\n#include \"include/linux.h\"\n\n// Pprotect is mprotect, but page-aligned on the lo end (Linux requirement)\nextern unsigned Pprotect(void *, size_t, unsigned);\nextern void *Pmap(void *, size_t, unsigned, unsigned, int, size_t);\nextern int Punmap(void *, size_t);\nextern int Psync(void const *, size_t, unsigned);\nextern size_t Pwrite(unsigned, void const *, size_t);\n#define MS_SYNC 4\n\nextern void f_int3(int arg);\n\n#ifndef DEBUG  //{\n#define DEBUG 0\n#endif  //}\n\n#if !DEBUG //{\n#define DPRINTF(fmt, args...) /*empty*/\n#else  //}{\n// DPRINTF is defined as an expression using \"({ ... })\"\n// so that DPRINTF can be invoked inside an expression,\n// and then followed by a comma to ignore the return value.\n// The only complication is that percent and backslash\n// must be doubled in the format string, because the format\n// string is processed twice: once at compile-time by 'asm'\n// to produce the assembled value, and once at runtime to use it.\n#if defined(__powerpc__)  //{\n#define DPRINTF(fmt, args...) ({ \\\n    char const *r_fmt; \\\n    asm(\"bl 0f; .string \\\"\" fmt \"\\\"; .balign 4; 0: mflr %0\" \\\n/*out*/ : \"=r\"(r_fmt) \\\n/* in*/ : \\\n/*und*/ : \"lr\"); \\\n    dprintf(r_fmt, args); \\\n})\n#elif defined(__x86_64) //}{\n#define DPRINTF(fmt, args...) ({ \\\n    char const *r_fmt; \\\n    asm(\"call 0f; .asciz \\\"\" fmt \"\\\"; 0: pop %0\" \\\n/*out*/ : \"=r\"(r_fmt) ); \\\n    dprintf(r_fmt, args); \\\n})\n#elif defined(__aarch64__) //}{\n#define DPRINTF(fmt, args...) ({ \\\n    char const *r_fmt; \\\n    asm(\"bl 0f; .string \\\"\" fmt \"\\\"; .balign 4; 0: mov %0,x30\" \\\n/*out*/ : \"=r\"(r_fmt) \\\n/* in*/ : \\\n/*und*/ : \"x30\"); \\\n    dprintf(r_fmt, args); \\\n})\n\n#endif  //}\n\nstatic int dprintf(char const *fmt, ...); // forward\n#endif  /*}*/\n\n#if DEBUG  //{\nvoid dprint8(\n    char const *fmt,\n    void *a, void *b, void *c, void *d,\n    void *e, void *f, void *g, void *h\n)\n{\n    dprintf(fmt, a, b, c, d, e, f, g, h);\n}\n#endif  //}\n\n/*************************************************************************\n// configuration section\n**************************************************************************/\n\n// In order to make it much easier to move this code at runtime and execute\n// it at an address different from it load address:  there must be no\n// static data, and no string constants.\n\n/*************************************************************************\n// util\n**************************************************************************/\n\n#if 0  //{  save space\n#define ERR_LAB error: exit(127);\n#define err_exit(a) goto error\n#else  //}{  save debugging time\n#define ERR_LAB /*empty*/\nvoid my_bkpt(void const *, ...);\n\nstatic void\nerr_exit(int a)\n{\n    (void)a;  // debugging convenience\n    DPRINTF(\"err_exit %%x\\\\n\", a);\n    my_bkpt((void const *)(long)a);\n    exit(127);\n}\n#endif  //}\n\n/*************************************************************************\n// \"file\" util\n**************************************************************************/\n\ntypedef struct {\n    size_t size;  // must be first to match size[0] uncompressed size\n    char *buf;\n} Extent;\n\n\nstatic void\nxread(Extent *x, char *buf, size_t count)\n{\n    DPRINTF(\"xread x.size=%%x  x.buf=%%p  buf=%%p  count=%%x\\\\n\",\n        x->size, x->buf, buf, count);\n    char *p=x->buf, *q=buf;\n    size_t j;\n    if (x->size < count) {\n        err_exit(8);\n    }\n    for (j = count; 0!=j--; ++p, ++q) {\n        *q = *p;\n    }\n    x->buf  += count;\n    x->size -= count;\n    DPRINTF(\"yread x.size=%%x  x.buf=%%p  buf=%%p  count=%%x\\\\n\",\n        x->size, x->buf, buf, count);\n}\n\n/*************************************************************************\n// UPX & NRV stuff\n**************************************************************************/\n\nint f_expand( // .globl in $(ARCH)-linux.elf-so_fold.S\n    nrv_byte const *binfo, nrv_byte *dst, size_t *dstlen);\n\nstatic void\nunpackExtent(\n    Extent *const xi,  // input includes struct b_info\n    Extent *const xo   // output\n)\n{\n    while (xo->size) {\n        DPRINTF(\"unpackExtent xi=(%%p %%p)  xo=(%%p %%p)\\\\n\",\n            xi->size, xi->buf, xo->size, xo->buf);\n        struct b_info h;\n        //   Note: if h.sz_unc == h.sz_cpr then the block was not\n        //   compressible and is stored in its uncompressed form.\n\n        // Read and check block sizes.\n        xread(xi, (char *)&h, sizeof(h));\n        DPRINTF(\"h.sz_unc=%%x  h.sz_cpr=%%x  h.b_method=%%x\\\\n\",\n            h.sz_unc, h.sz_cpr, h.b_method);\n        if (h.sz_unc == 0) {                     // uncompressed size 0 -> EOF\n            if (h.sz_cpr != UPX_MAGIC_LE32)      // h.sz_cpr must be h->magic\n                err_exit(2);\n            if (xi->size != 0)                 // all bytes must be written\n                err_exit(3);\n            break;\n        }\n        if (h.sz_cpr <= 0) {\n            err_exit(4);\nERR_LAB\n        }\n        if (h.sz_cpr > h.sz_unc\n        ||  h.sz_unc > xo->size ) {\n            err_exit(5);\n        }\n        // Now we have:\n        //   assert(h.sz_cpr <= h.sz_unc);\n        //   assert(h.sz_unc > 0 && h.sz_unc <= blocksize);\n        //   assert(h.sz_cpr > 0 && h.sz_cpr <= blocksize);\n\n        if (h.sz_cpr < h.sz_unc) { // Decompress block\n            size_t out_len = h.sz_unc;  // EOF for lzma\n            int const j = f_expand((unsigned char *)xi->buf - sizeof(h),\n                (unsigned char *)xo->buf, &out_len);\n            if (j != 0 || out_len != (nrv_uint)h.sz_unc) {\n                DPRINTF(\"  j=%%x  out_len=%%x  &h=%%p\\\\n\", j, out_len, &h);\n                err_exit(7);\n            }\n            xi->buf  += h.sz_cpr;\n            xi->size -= h.sz_cpr;\n        }\n        else { // copy literal block\n            DPRINTF(\"  copy %%p  %%p  %%p\\\\n\", xi->buf, xo->buf, h.sz_cpr);\n            xi->size += sizeof(h);  // xread(xi, &h, sizeof(h)) was a peek\n            xread(xi, xo->buf, h.sz_cpr);\n        }\n        xo->buf  += h.sz_unc;\n        xo->size -= h.sz_unc;\n    }\n}\n\n#if defined(__x86_64) //}{\n#define addr_string(string) ({ \\\n    char const *str; \\\n    asm(\"call 0f; .asciz \\\"\" string \"\\\"; 0: pop %0\" \\\n/*out*/ : \"=r\"(str) ); \\\n    str; \\\n})\n#elif defined(__aarch64__) //}{\n#define addr_string(string) ({ \\\n    char const *str; \\\n    asm(\"bl 0f; .string \\\"\" string \"\\\"; .balign 4; 0: mov %0,x30\" \\\n/*out*/ : \"=r\"(str) \\\n/* in*/ : \\\n/*und*/ : \"x30\"); \\\n    str; \\\n})\n#else  //}{\n       error;\n#endif  //}\n\nextern int memfd_create(const char *name, unsigned int flags);\n\n#define ElfW(sym) Elf64_ ## sym\n\n#define nullptr (void *)0\n\nextern char *upx_mmap_and_fd(  // x86_64 Android emulator of i386 is not faithful\n     void *ptr  // desired address\n     , unsigned len  // also pre-allocate space in file\n     , char *pathname  // 0 ==> call get_upxfn_path, which stores if 1st time\n);\n\n#if defined(__x86_64__)  //{\nchar *\nmake_hatch(\n    ElfW(Phdr) const *const phdr,\n    char *next_unc,\n    unsigned frag_mask\n)\n{\n    unsigned *hatch = 0;\n    unsigned code[3] = {\n        0x5e5f050f,  // syscall; pop %arg1{%rdi}; pop %arg2{%rsi}\n        0xff3e585a,  // pop %arg3{%rdx}; pop %rax; notrack jmp\n        0x909090e0   // *%rax; nop; nop; nop\n    };\n    DPRINTF(\"make_hatch %%p %%p %%x\\\\n\", phdr, next_unc, frag_mask);\n    if (phdr->p_type==PT_LOAD && phdr->p_flags & PF_X) {\n        next_unc += phdr->p_memsz - phdr->p_filesz;  // Skip over local .bss\n        frag_mask &= -(long)next_unc;  // bytes left on page\n        if (sizeof(code) <= frag_mask) {\n            hatch = (unsigned *)next_unc;\n            hatch[0] = code[0];\n            hatch[1] = code[1];\n            hatch[2] = code[2];\n        }\n        else { // Does not fit at hi end of .text, so must use a new page \"permanently\"\n            unsigned long fdmap = (long)upx_mmap_and_fd((void *)0, sizeof(code), nullptr);\n            unsigned mfd = -1+ (0xfff& fdmap);\n            write(mfd, &code, sizeof(code));\n            hatch = mmap((void *)(fdmap & ~0xffful), sizeof(code),\n              PROT_READ|PROT_EXEC, MAP_PRIVATE, mfd, 0);\n            close(mfd);\n        }\n    }\n    DPRINTF(\"hatch=%%p\\\\n\", hatch);\n    return (char *)hatch;\n}\n#elif defined(__powerpc64__)  //}{\nstatic unsigned\nORRX(unsigned ra, unsigned rs, unsigned rb) // or ra,rs,rb\n{\n    return (31<<26) | ((037&(rs))<<21) | ((037&(ra))<<16) | ((037&(rb))<<11) | (444<<1) | 0;\n}\n\nstatic char *\nmake_hatch(\n    ElfW(Phdr) const *const phdr,\n    char *next_unc,\n    unsigned frag_mask\n)\n{\n    unsigned code[4] = {\n        0x44000002,  // sc\n        ORRX(12,31,31),  // movr r12,r31 ==> or r12,r31,r31\n        0x38800000,  // li r4,0\n        0x4e800020,  // blr\n    };\n    unsigned *hatch = 0;\n    DPRINTF(\"make_hatch %%p %%p %%x\\\\n\", phdr, next_unc, frag_mask);\n    if (phdr->p_type==PT_LOAD && phdr->p_flags & PF_X) {\n        next_unc += phdr->p_memsz - phdr->p_filesz;  // Skip over local .bss\n        frag_mask &= -(long)next_unc;  // bytes left on page\n        if (4*4 <= frag_mask) {\n            hatch = (unsigned *)(void *)(~3ul & (long)(3+ next_unc);\n            hatch[0]= code[0];\n            hatch[1]= code[1];\n            hatch[2]= code[2];\n            hatch[3]= code[3];\n        }\n        else { // Does not fit at hi end of .text, so must use a new page \"permanently\"\n            int mfd = memfd_create(addr_string(\"upx\"), 0);  // the directory entry\n            Pwrite(mfd, code, sizeof(code));\n            hatch = Pmap(0, sizeof(code), PROT_READ|PROT_EXEC, MAP_PRIVATE, mfd, 0);\n            close(mfd);\n        }\n    }\n    DPRINTF(\"hatch=%%p\\\\n\", hatch);\n    return hatch;\n}\n#elif defined(__aarch64__)  //{\nstatic char *\nmake_hatch(\n    ElfW(Phdr) const *const phdr,\n    char *next_unc,\n    unsigned frag_mask\n)\n{\n    unsigned code[4] = {\n        0xd4000001,  // svc #0\n        0xa9417be2,  // ldp x2,lr,[sp,#2*8)]\n        0xa8c207e0,  // ldp x0,x1,[sp], 4*8\n        0xd61f03c0,  // br x30\n    };\n    unsigned *hatch = 0;\n    DPRINTF(\"make_hatch phdr=%%p  next_unc=%%p  frag_mask= %%x\\\\n\",\n        phdr, next_unc, frag_mask);\n    if (phdr->p_type==PT_LOAD && phdr->p_flags & PF_X) {\n        next_unc += phdr->p_memsz - phdr->p_filesz;  // Skip over local .bss\n        frag_mask &= -(long)next_unc;  // bytes left on page\n        if (4*4 <= frag_mask) {\n            hatch = (unsigned *)(void *)(~3ul & (long)(3+ next_unc));\n            hatch[0]= code[0];\n            hatch[1]= code[1];\n            hatch[2]= code[2];\n            hatch[3]= code[3];\n            hatch = (unsigned *)&hatch[0];\n        }\n        else { // Does not fit at hi end of .text, so must use a new page \"permanently\"\n            int mfd = memfd_create(addr_string(\"upx\"), 0);  // the directory entry\n            Pwrite(mfd, code, sizeof(code));\n            void *mfd_addr = Pmap(0, sizeof(code), PROT_READ|PROT_EXEC, MAP_PRIVATE, mfd, 0);\n            close(mfd);\n            hatch = (unsigned *)mfd_addr;\n        }\n    }\n    DPRINTF(\"hatch=%%p\\\\n\", hatch);\n    return (char *)hatch;\n}\n#endif  //}\n\n// The PF_* and PROT_* bits are {1,2,4}; the conversion table fits in 32 bits.\n#define REP8(x) \\\n    ((x)|((x)<<4)|((x)<<8)|((x)<<12)|((x)<<16)|((x)<<20)|((x)<<24)|((x)<<28))\n#define EXP8(y) \\\n    ((1&(y)) ? 0xf0f0f0f0 : (2&(y)) ? 0xff00ff00 : (4&(y)) ? 0xffff0000 : 0)\n#define PF_TO_PROT(pf) \\\n    ((PROT_READ|PROT_WRITE|PROT_EXEC) & ( \\\n        ( (REP8(PROT_EXEC ) & EXP8(PF_X)) \\\n         |(REP8(PROT_READ ) & EXP8(PF_R)) \\\n         |(REP8(PROT_WRITE) & EXP8(PF_W)) \\\n        ) >> ((pf & (PF_R|PF_W|PF_X))<<2) ))\n\n#undef PAGE_MASK\nstatic ElfW(Addr)\nget_page_mask(void)  // the mask which KEEPS the page, discards the offset\n{\n    ElfW(Addr) rv = ~0xffful;  // default to (PAGE_SIZE == 4KiB)\n    int fd = openat(0, addr_string(\"/proc/self/auxv\"), O_RDONLY, 0);\n    if (0 <= fd) {\n        ElfW(auxv_t) data[40];\n        ElfW(auxv_t) *end = &data[read(fd, data, sizeof(data)) / sizeof(data[0])];\n        close(fd);\n        ElfW(auxv_t) *ptr; for (ptr = &data[0]; ptr < end ; ++ptr) {\n            if (AT_PAGESZ == ptr->a_type) {\n                rv = (0u - ptr->a_un.a_val);\n                break;\n            }\n        }\n    }\n    DPRINTF(\"get_page_mask= %%p\\\\n\", rv);\n    return rv;\n}\n\nextern void *memcpy(void *dst, void const *src, size_t n);\nextern void *memset(void *dst, unsigned val, size_t n);\n\n// maximum page sizes\n#if defined(__powerpc64__) || defined(__powerpc__)\n#define SAVED_SIZE (1<<16)  /* 64 KB */\n#else\n#define SAVED_SIZE (1<<14)  /* 16 KB */\n#endif\n\n#ifndef __arm__  //{\n// Segregate large local array, to avoid code bloat due to large displacements.\nstatic void\nunderlay(unsigned size, char *ptr, unsigned page_mask)\n{\n    unsigned frag = ~page_mask & (unsigned)(long)ptr;\n    if (frag) {\n        unsigned saved[SAVED_SIZE / sizeof(unsigned)];  // want alignment\n        ptr -= frag;\n        memcpy(saved, ptr, frag);\n        mmap(ptr, frag + size, PROT_WRITE|PROT_READ,\n            MAP_FIXED|MAP_PRIVATE|MAP_ANONYMOUS, -1, 0);\n        memcpy(ptr, saved, frag);\n    }\n    else { // already page-aligned\n        mmap(ptr, frag + size, PROT_WRITE|PROT_READ,\n            MAP_FIXED|MAP_PRIVATE|MAP_ANONYMOUS, -1, 0);\n    }\n}\n#else  //}{ // use assembler because large local array on __arm__ is horrible\nextern void\nunderlay(unsigned size, char *ptr, unsigned page_mask);\n#endif  //}\n\n// Exchange the bits with values 4 (PF_R, PROT_EXEC) and 1 (PF_X, PROT_READ)\n// Use table lookup into a PIC-string that pre-computes the result.\nunsigned PF_to_PROT(ElfW(Phdr) const *phdr)\n{\n    return 7& addr_string(\"@\\x04\\x02\\x06\\x01\\x05\\x03\\x07\")\n        [phdr->p_flags & (PF_R|PF_W|PF_X)];\n}\n\nunsigned\nfini_SELinux(\n    unsigned size,\n    char *ptr,\n    ElfW(Phdr) const *phdr,\n    unsigned mfd,\n    ElfW(Addr) base\n)\n{\n    DPRINTF(\"fini_SELinux  size=%%p  ptr=%%p  phdr=%%p  mfd=%%p  base=%%p\\\\n\",\n            size, ptr, phdr, mfd, base);\n    if (phdr->p_flags & PF_X) {\n        // Map the contents of mfd as per *phdr.\n\n        Psync(ptr, size, MS_SYNC); // be sure file gets de-compressed bytes\n            // Android 14 gets -EINVAL; ignore it\n\n        Punmap(ptr, size);\n        Pmap(ptr, size, PF_to_PROT(phdr), MAP_FIXED|MAP_PRIVATE, mfd, 0);\n        close(mfd);\n    }\n    else { // easy\n        Pprotect( (char *)(phdr->p_vaddr + base), phdr->p_memsz, PF_to_PROT(phdr));\n    }\n    return 0;\n}\n\nunsigned\nprep_SELinux(unsigned size, char *ptr, ElfW(Addr) page_mask) // returns mfd\n{\n    // Cannot set PROT_EXEC except via mmap() into a region (Linux \"vma\")\n    // that has never had PROT_WRITE.  So use a Linux-only \"memory file\"\n    // to hold the contents.\n    unsigned saved[SAVED_SIZE / sizeof(unsigned)];  // want alignment\n    char *page = (char *)(page_mask & (ElfW(Addr))ptr);\n    unsigned frag = (unsigned)(ptr - page);\n    if (frag) {\n        memcpy(saved, page, frag);\n    }\n    char *val = upx_mmap_and_fd(page, frag + size, nullptr);\n    unsigned mfd = 0xfff & (unsigned)(ElfW(Addr))val;\n    val -= mfd; --mfd;\n    if (val != page) {\n        my_bkpt((void const *)0x1262, val, page, ptr, frag);\n    }\n    if (frag)\n        write(mfd, saved, frag);  // Save lo fragment of contents on page.\n    return mfd;\n}\n\ntypedef struct {\n    long argc;\n    char **argv;\n    char **envp;\n} So_args;\n\ntypedef struct {\n    unsigned off_reloc;  // distance back to &ElfW(Ehdr)\n    unsigned off_user_DT_INIT;\n    unsigned off_xct_off;  // where un-compressed bytes end\n    unsigned off_info;  //  xct_off: {l_info; p_info; b_info; compressed data)\n} So_info;\n\n/*************************************************************************\n// upx_so_main - called by our folded entry code\n**************************************************************************/\n\nvoid *\nupx_so_main(  // returns &escape_hatch\n    So_info *so_info,\n    So_args *so_args,\n    ElfW(Ehdr) *elf_tmp  // scratch for ElfW(Ehdr) and ElfW(Phdrs)\n)\n{\n    ElfW(Addr) const page_mask = get_page_mask();\n    char *const va_load = (char *)&so_info->off_reloc - so_info->off_reloc;\n    So_info so_infc;  // So_info Copy\n    memcpy(&so_infc, so_info, sizeof(so_infc));  // before de-compression overwrites\n    unsigned const xct_off = so_infc.off_xct_off;  (void)xct_off;\n\n    char *const cpr_ptr = so_info->off_info + va_load;\n    unsigned const cpr_len = (char *)so_info - cpr_ptr;\n    typedef void (*Dt_init)(int argc, char *argv[], char *envp[]);\n    Dt_init const dt_init = (Dt_init)(void *)(so_info->off_user_DT_INIT + va_load);\n    DPRINTF(\"upx_so_main  va_load=%%p  so_infc=%%p  cpr_ptr=%%p  cpr_len=%%x  xct_off=%%x\\\\n\",\n        va_load, &so_infc, cpr_ptr, cpr_len, xct_off);\n    // DO NOT USE *so_info AFTER THIS!!  It gets overwritten.\n\n    // Copy compressed data before de-compression overwrites it.\n    char *const sideaddr = mmap(nullptr, cpr_len, PROT_WRITE|PROT_READ,\n        MAP_PRIVATE|MAP_ANONYMOUS, -1, 0);\n    DPRINTF(\"&sideaddr=%%p\\\\n\", &sideaddr);\n    memcpy(sideaddr, cpr_ptr, cpr_len);\n\n    // Transition to copied data\n    struct b_info *binfo = (struct b_info *)(void *)(sideaddr +\n        sizeof(struct l_info) + sizeof(struct p_info));\n    DPRINTF(\"upx_so_main  va_load=%%p  sideaddr=%%p  b_info=%%p\\\\n\",\n        va_load, sideaddr, binfo);\n\n    // All the destination page frames exist or have been reserved,\n    // but the access permissions may be wrong and the data may be compressed.\n    // Also, rtld maps the convex hull of all PT_LOAD but assumes that the\n    // file supports those pages, even though the pages might lie beyond EOF.\n    // If so, then Pprotect() is not enough: SIGBUS will occur.  Thus we\n    // must mmap anonymous pages, except for first PT_LOAD with ELF headers.\n    // So the general strategy (for each PT_LOAD) is:\n    //   Save any contents on low end of destination page (the \"prefix\" pfx).\n    //   mmap(,, PROT_WRITE|PROT_READ, MAP_FIXED|MAP_PRIVATE|MAP_ANONYMOUS, -1, 0);\n    //   Restore the prefix on the first destination page.\n    //   De-compress from remaining [sideaddr, +sidelen).\n    //   Pprotect(,, PF_TO_PROT(.p_flags));\n\n    // Get the uncompressed ElfW(Ehdr) and ElfW(Phdr)\n    // The first b_info is aligned, so direct access to fields is OK.\n    Extent x1 = {binfo->sz_unc, (char *)elf_tmp};  // destination\n    Extent x0 = {binfo->sz_cpr + sizeof(*binfo), (char *)binfo};  // source\n    unpackExtent(&x0, &x1);  // de-compress _Ehdr and _Phdrs; x0.buf is updated\n\n    ElfW(Phdr) const *phdr = (ElfW(Phdr) *)(1+ elf_tmp);\n    ElfW(Phdr) const *const phdrN = &phdr[elf_tmp->e_phnum];\n\n    // Process each read-only PT_LOAD.\n    // A read+write PT_LOAD might be relocated by rtld before de-compression,\n    // so it cannot be compressed.\n    void *hatch = nullptr;\n    ElfW(Addr) base = 0;\n    int n_load = 0;\n\n    for (; phdr < phdrN; ++phdr)\n    if (phdr->p_type == PT_LOAD && !(phdr->p_flags & PF_W)) {\n        if  (!base) {\n            base = (ElfW(Addr))va_load - phdr->p_vaddr;\n            DPRINTF(\"base=%%p\\\\n\", base);\n        }\n        unsigned const va_top = phdr->p_filesz + phdr->p_vaddr;\n        // Need un-aligned read of b_info to determine compression sizes.\n        struct b_info al_bi;  // for aligned data from binfo\n        x0.size = sizeof(struct b_info);\n        xread(&x0, (char *)&al_bi, x0.size);  // aligned binfo\n        x0.buf -= sizeof(al_bi);  // back up (the xread() was a peek)\n        x0.size = al_bi.sz_cpr;\n        x1.size = al_bi.sz_unc;\n        x1.buf = (void *)(va_top + base - al_bi.sz_unc);\n\n        DPRINTF(\"\\\\nphdr@%%p  p_offset=%%p  p_vaddr=%%p  p_filesz=%%p  p_memsz=%%p\\\\n\",\n            phdr, phdr->p_offset, phdr->p_vaddr, phdr->p_filesz, phdr->p_memsz);\n        DPRINTF(\"x0=%%p  x1=%%p\\\\n\", &x0, &x1);\n\n        if ((phdr->p_filesz + phdr->p_offset) <= xct_off) { // va_top <= xct_off\n            if (!n_load) {\n                ++n_load;\n                continue;  // 1st PT_LOAD is non-compressed loader tables ONLY!\n            }\n        }\n\n        int mfd = 0;\n        if (phdr->p_flags & PF_X) {\n            mfd = prep_SELinux(x1.size, x1.buf, page_mask);\n        }\n        else {\n            underlay(x1.size, x1.buf, page_mask);  // also makes PROT_WRITE\n        }\n        Extent xt = x1;\n        unpackExtent(&x0, &x1);\n        if (!hatch && phdr->p_flags & PF_X) {\n            hatch = make_hatch(phdr, x1.buf, ~page_mask);\n            fini_SELinux(xt.size, xt.buf, phdr, mfd, base);\n        }\n        ++n_load;\n    }\n\n    DPRINTF(\"Punmap sideaddr=%%p  cpr_len=%%p\\\\n\", sideaddr, cpr_len);\n    Punmap(sideaddr, cpr_len);\n    DPRINTF(\"calling user DT_INIT %%p\\\\n\", dt_init);\n    dt_init(so_args->argc, so_args->argv, so_args->envp);\n\n    DPRINTF(\"returning hatch=%%p\\\\n\", hatch);\n    return hatch;\n}\n\n#if DEBUG  //{\n\n#if defined(__powerpc64__) //{\n#define __NR_write 4\n\ntypedef unsigned long size_t;\n\n#if 0  //{\nstatic int\nwrite(int fd, char const *ptr, size_t len)\n{\n    register  int        sys asm(\"r0\") = __NR_write;\n    register  int         a0 asm(\"r3\") = fd;\n    register void const  *a1 asm(\"r4\") = ptr;\n    register size_t const a2 asm(\"r5\") = len;\n    __asm__ __volatile__(\"sc\"\n    : \"=r\"(a0)\n    : \"r\"(sys), \"r\"(a0), \"r\"(a1), \"r\"(a2)\n    : \"r0\", \"r4\", \"r5\", \"r6\", \"r7\", \"r8\", \"r9\", \"r10\", \"r11\", \"r12\", \"r13\"\n    );\n    return a0;\n}\n#else //}{\nssize_t\nwrite(int fd, void const *ptr, size_t len)\n{\n    register  int        sys asm(\"r0\") = __NR_write;\n    register  int         a0 asm(\"r3\") = fd;\n    register void const  *a1 asm(\"r4\") = ptr;\n    register size_t       a2 asm(\"r5\") = len;\n    __asm__ __volatile__(\"sc\"\n    : \"+r\"(sys), \"+r\"(a0), \"+r\"(a1), \"+r\"(a2)\n    :\n    : \"r6\", \"r7\", \"r8\", \"r9\", \"r10\", \"r11\", \"r12\", \"r13\"\n    );\n    return a0;\n}\n#endif  //}\n#endif  //}\n\nstatic int\nunsimal(unsigned x, char *ptr, int n)\n{\n    unsigned m = 10;\n    while (10 <= (x / m)) m *= 10;\n    while (10 <= x) {\n        unsigned d = x / m;\n        x -= m * d;\n        m /= 10;\n        ptr[n++] = '0' + d;\n    }\n    ptr[n++] = '0' + x;\n    return n;\n}\n\nstatic int\ndecimal(int x, char *ptr, int n)\n{\n    if (x < 0) {\n        ptr[n++] = '-';\n    }\n    return unsimal(-x, ptr, n);\n}\n\nstatic int\nheximal(unsigned long x, char *ptr, int n)\n{\n    unsigned j = -1+ 2*sizeof(unsigned long);\n    unsigned long m = 0xful << (4 * j);\n    for (; j; --j, m >>= 4) { // omit leading 0 digits\n        if (m & x) break;\n    }\n    for (; m; --j, m >>= 4) {\n        unsigned d = 0xf & (x >> (4 * j));\n        ptr[n++] = ((10<=d) ? ('a' - 10) : '0') + d;\n    }\n    return n;\n}\n\n#define va_arg      __builtin_va_arg\n#define va_end      __builtin_va_end\n#define va_list     __builtin_va_list\n#define va_start    __builtin_va_start\n\nstatic int\ndprintf(char const *fmt, ...)\n{\n    int n= 0;\n    char const *literal = 0;  // NULL\n    char buf[24];  // ~0ull == 18446744073709551615 ==> 20 chars\n    va_list va; va_start(va, fmt);\n    for (;;) {\n        char c = *fmt++;\n        if (!c) { // end of fmt\n            if (literal) {\n                goto finish;\n            }\n            break;  // goto done\n        }\n        if ('%'!=c) {\n            if (!literal) {\n                literal = fmt;  // 1 beyond start of literal\n            }\n            continue;\n        }\n        // '%' == c\n        if (literal) {\nfinish:\n            n += write(2, -1+ literal, fmt - literal);\n            literal = 0;  // NULL\n            if (!c) { // fmt already ended\n               break;  // goto done\n            }\n        }\n        switch (c= *fmt++) { // deficiency: does not handle _long_\n        default: { // un-implemented conversion\n            n+= write(2, -1+ fmt, 1);\n        } break;\n        case 0: { // fmt ends with \"%\\0\" ==> ignore\n            goto done;\n        } break;\n        case 'u': {\n            n+= write(2, buf, unsimal((unsigned)(unsigned long)va_arg(va, void *), buf, 0));\n        } break;\n        case 'd': {\n            n+= write(2, buf, decimal((int)(unsigned long)va_arg(va, void *), buf, 0));\n        } break;\n        case 'p': {\n            buf[0] = '0';\n            buf[1] = 'x';\n            n+= write(2, buf, heximal((unsigned long)va_arg(va, void *), buf, 2));\n        } break;\n        case 'x': {\n            buf[0] = '0';\n            buf[1] = 'x';\n            n+= write(2, buf, heximal((unsigned)(unsigned long)va_arg(va, void *), buf, 2));\n        } break;\n        } // 'switch'\n    }\ndone:\n    va_end(va);\n    return n;\n }\n#endif  //}\n\n/* vim:set ts=4 sw=4 et: */\n","size_bytes":25345},"src/stub/src/arm.v4a-linux.elf-main.c":{"content":"#include \"i386-linux.elf-main.c\"\n\n/* vim:set ts=4 sw=4 et: */\n","size_bytes":62},"src/stub/src/arm.v4a-linux.elf-main2.c":{"content":"#include \"i386-linux.elf-main2.c\"\n","size_bytes":34},"src/stub/src/arm.v4a-linux.elf-so_main.c":{"content":"#include \"i386-linux.elf-so_main.c\"\n","size_bytes":36},"src/stub/src/arm.v5a-darwin.macho-main.c":{"content":"#include \"amd64-darwin.macho-main.c\"\n","size_bytes":37},"src/stub/src/arm.v5a-linux.elf-main2.c":{"content":"#include \"i386-linux.elf-main2.c\"\n","size_bytes":34},"src/stub/src/arm.v5a-linux.elf-so_main.c":{"content":"#include \"i386-linux.elf-so_main.c\"\n","size_bytes":36},"src/stub/src/arm64-darwin.macho-main.c":{"content":"#include \"amd64-darwin.macho-main.c\"\n","size_bytes":37},"src/stub/src/arm64-linux.elf-main.c":{"content":"#include \"amd64-linux.elf-main.c\"\n","size_bytes":34},"src/stub/src/arm64-linux.elf-main2.c":{"content":"#include \"amd64-linux.elf-main2.c\"\n","size_bytes":35},"src/stub/src/arm64-linux.elf-so_main.c":{"content":"#include \"amd64-linux.elf-so_main.c\"\n","size_bytes":37},"src/stub/src/armeb.v4a-linux.elf-main.c":{"content":"#include \"i386-linux.elf-main.c\"\n\n/* vim:set ts=4 sw=4 et: */\n","size_bytes":62},"src/stub/src/armeb.v4a-linux.elf-main2.c":{"content":"#include \"arm.v4a-linux.elf-main2.c\"\n","size_bytes":37},"src/stub/src/armeb.v4a-linux.elf-so_main2.c":{"content":"#include \"i386-linux.elf-so_main2.c\"\n","size_bytes":37},"src/stub/src/armel-linux.elf-main.c":{"content":"#include \"i386-linux.elf-main.c\"\n\n/* vim:set ts=4 sw=4 et: */\n","size_bytes":62},"src/stub/src/i386-bsd.elf-main.c":{"content":"/* i386-bsd.elf-main.c -- stub loader for Linux x86 ELF executable\n\n   This file is part of the UPX executable compressor.\n\n   Copyright (C) 1996-2025 Markus Franz Xaver Johannes Oberhumer\n   Copyright (C) 1996-2025 Laszlo Molnar\n   Copyright (C) 2000-2025 John F. Reiser\n   All Rights Reserved.\n\n   UPX and the UCL library are free software; you can redistribute them\n   and/or modify them under the terms of the GNU General Public License as\n   published by the Free Software Foundation; either version 2 of\n   the License, or (at your option) any later version.\n\n   This program is distributed in the hope that it will be useful,\n   but WITHOUT ANY WARRANTY; without even the implied warranty of\n   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n   GNU General Public License for more details.\n\n   You should have received a copy of the GNU General Public License\n   along with this program; see the file COPYING.\n   If not, write to the Free Software Foundation, Inc.,\n   59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.\n\n   Markus F.X.J. Oberhumer              Laszlo Molnar\n   <markus@oberhumer.com>               <ezerotven+github@gmail.com>\n\n   John F. Reiser\n   <jreiser@users.sourceforge.net>\n */\n\n\n#include \"include/bsd.h\"\n\n\n/*************************************************************************\n// configuration section\n**************************************************************************/\n\n// In order to make it much easier to move this code at runtime and execute\n// it at an address different from it load address:  there must be no\n// static data, and no string constants.\n\n#if 1  /*{*/\n#define DPRINTF(a) /* empty: no debug drivel */\n#else  /*}{*/\n#include \"stdarg.h\"\n\nstatic int\nunsimal(unsigned x, char *ptr, int n)\n{\n    if (10<=x) {\n        n = unsimal(x/10, ptr, n);\n        x %= 10;\n    }\n    ptr[n] = '0' + x;\n    return 1+ n;\n}\n\nstatic int\ndecimal(int x, char *ptr, int n)\n{\n    if (x < 0) {\n        x = -x;\n        ptr[n++] = '-';\n    }\n    return unsimal(x, ptr, n);\n}\n\nextern char const *STR_hex();\n\nstatic int\nheximal(unsigned x, char *ptr, int n)\n{\n    if (16<=x) {\n        n = heximal(x>>4, ptr, n);\n        x &= 0xf;\n    }\n    ptr[n] = STR_hex()[x];\n    return 1+ n;\n}\n\n\n#define DPRINTF(a) dprintf a\nextern char const *STR_0x();\nextern char const *STR_xread();\nextern char const *STR_unpackExtent();\nextern char const *STR_make_hatch_arm();\nextern char const *STR_auxv_up();\nextern char const *STR_xfind_pages();\nextern char const *STR_do_xmap();\nextern char const *STR_upx_main();\n\nstatic int\ndprintf(char const *fmt, ...)\n{\n    char c;\n    int n= 0;\n    char *ptr;\n    char buf[20];\n    va_list va; va_start(va, fmt);\n    ptr= &buf[0];\n    while (0!=(c= *fmt++)) if ('%'!=c) goto literal;\n    else switch (c= *fmt++) {\n    default: {\nliteral:\n        n+= write(2, fmt-1, 1);\n    } break;\n    case 0: goto done;  /* early */\n    case 'u': {\n        n+= write(2, buf, unsimal(va_arg(va, unsigned), buf, 0));\n    } break;\n    case 'd': {\n        n+= write(2, buf, decimal(va_arg(va, int), buf, 0));\n    } break;\n    case 'p':  /* same as 'x'; relies on sizeof(int)==sizeof(void *) */\n    case 'x': {\n        buf[0] = '0';\n        buf[1] = 'x';\n        n+= write(2, buf, heximal(va_arg(va, int), buf, 2));\n    } break;\n    }\ndone:\n    va_end(va);\n    return n;\n}\n#endif  /*}*/\n\n#include \"MAX_ELF_HDR.c\"\n\n/*************************************************************************\n// \"file\" util\n**************************************************************************/\n\nstruct Extent {\n    size_t size;  // must be first to match size[0] uncompressed size\n    char *buf;\n};\n\n\nstatic void\n#if (ACC_CC_GNUC >= 0x030300) && defined(__i386__)  /*{*/\n__attribute__((__noinline__, __used__, regparm(3), stdcall))\n#endif  /*}*/\nxread(struct Extent *x, char *buf, size_t count)\n{\n    char *p=x->buf, *q=buf;\n    size_t j;\n    DPRINTF((STR_xread(), x, x->size, x->buf, buf, count));\n    if (x->size < count) {\n        exit(127);\n    }\n    for (j = count; 0!=j--; ++p, ++q) {\n        *q = *p;\n    }\n    x->buf  += count;\n    x->size -= count;\n}\n\n\n/*************************************************************************\n// util\n**************************************************************************/\n\n#if 1  //{  save space\n#define ERR_LAB error: exit(127);\n#define err_exit(a) goto error\n#else  //}{  save debugging time\n#define ERR_LAB /*empty*/\nstatic void\nerr_exit(int a) __attribute__ ((__noreturn__));\n{\n    (void)a;  // debugging convenience\n    exit(127);\n}\n#endif  //}\n\nstatic void *\ndo_brk(void *addr)\n{\n    return brk(addr);\n}\n\n/*************************************************************************\n// UPX & NRV stuff\n**************************************************************************/\n\ntypedef void f_unfilter(\n    nrv_byte *,  // also addvalue\n    nrv_uint,\n    unsigned cto8, // junk in high 24 bits\n    unsigned ftid\n);\ntypedef int f_expand(\n    const nrv_byte *, nrv_uint,\n          nrv_byte *, nrv_uint *, unsigned );\n\nstatic void\nunpackExtent(\n    struct Extent *const xi,  // input\n    struct Extent *const xo,  // output\n    f_expand *const f_decompress,\n    f_unfilter *f_unf\n)\n{\n    DPRINTF((STR_unpackExtent(),\n        xi, xi->size, xi->buf, xo, xo->size, xo->buf, f_decompress, f_unf));\n    while (xo->size) {\n        struct b_info h;\n        //   Note: if h.sz_unc == h.sz_cpr then the block was not\n        //   compressible and is stored in its uncompressed form.\n\n        // Read and check block sizes.\n        xread(xi, (char *)&h, sizeof(h));\n        if (h.sz_unc == 0) {                     // uncompressed size 0 -> EOF\n            if (h.sz_cpr != UPX_MAGIC_LE32)      // h.sz_cpr must be h->magic\n                err_exit(2);\n            if (xi->size != 0)                 // all bytes must be written\n                err_exit(3);\n            break;\n        }\n        if (h.sz_cpr <= 0) {\n            err_exit(4);\nERR_LAB\n        }\n        if (h.sz_cpr > h.sz_unc\n        ||  h.sz_unc > xo->size ) {\n            err_exit(5);\n        }\n        // Now we have:\n        //   assert(h.sz_cpr <= h.sz_unc);\n        //   assert(h.sz_unc > 0 && h.sz_unc <= blocksize);\n        //   assert(h.sz_cpr > 0 && h.sz_cpr <= blocksize);\n\n        if (h.sz_cpr < h.sz_unc) { // Decompress block\n            nrv_uint out_len = h.sz_unc;  // EOF for lzma\n            int const j = (*f_decompress)((unsigned char *)xi->buf, h.sz_cpr,\n                (unsigned char *)xo->buf, &out_len, *(int *)(void *)&h.b_method );\n            if (j != 0 || out_len != (nrv_uint)h.sz_unc)\n                err_exit(7);\n            // Skip Ehdr+Phdrs: separate 1st block, not filtered\n            if (h.b_ftid!=0 && f_unf  // have filter\n            &&  ((512 < out_len)  // this block is longer than Ehdr+Phdrs\n              || (xo->size==(unsigned)h.sz_unc) )  // block is last in Extent\n            ) {\n                (*f_unf)((unsigned char *)xo->buf, out_len, h.b_cto8, h.b_ftid);\n            }\n            xi->buf  += h.sz_cpr;\n            xi->size -= h.sz_cpr;\n        }\n        else { // copy literal block\n            xi->size += sizeof(h);  // xread(xi, &h, sizeof(h)) was a peek\n            xread(xi, xo->buf, h.sz_cpr);\n        }\n        xo->buf  += h.sz_unc;\n        xo->size -= h.sz_unc;\n    }\n}\n\n#if defined(__i386__)  /*{*/\n// Create (or find) an escape hatch to use when munmapping ourselves the stub.\n// Called by do_xmap to create it; remembered in AT_NULL.d_val\nstatic void *\nmake_hatch_x86(Elf32_Phdr const *const phdr, unsigned const reloc)\n{\n    unsigned *hatch = 0;\n    if (phdr->p_type==PT_LOAD && phdr->p_flags & PF_X) {\n        // The format of the 'if' is\n        //  if ( ( (hatch = loc1), test_loc1 )\n        //  ||   ( (hatch = loc2), test_loc2 ) ) {\n        //      action\n        //  }\n        // which uses the comma to save bytes when test_locj involves locj\n        // and the action is the same when either test succeeds.\n\n        // Try page fragmentation just beyond .text .\n        if ( ( (hatch = (void *)(phdr->p_memsz + phdr->p_vaddr + reloc)),\n                ( phdr->p_memsz==phdr->p_filesz  // don't pollute potential .bss\n                &&  4<=(~PAGE_MASK & -(int)hatch) ) ) // space left on page\n        // Try Elf32_Ehdr.e_ident[12..15] .  warning: 'const' cast away\n        ||   ( (hatch = (void *)(&((Elf32_Ehdr *)phdr->p_vaddr + reloc)->e_ident[12])),\n                (phdr->p_offset==0) ) ) {\n            // Omitting 'const' saves repeated literal in gcc.\n            unsigned /*const*/ escape = 0xc3c980cd;  // \"int $0x80; leave; ret\"\n            // Don't store into read-only page if value is already there.\n            if (* (volatile unsigned*) hatch != escape) {\n                * hatch  = escape;\n            }\n        }\n    }\n    return hatch;\n}\n#elif defined(__arm__)  /*}{*/\nstatic void *\nmake_hatch_arm(Elf32_Phdr const *const phdr, unsigned const reloc)\n{\n    unsigned *hatch = 0;\n    DPRINTF((STR_make_hatch_arm(),phdr,reloc));\n    if (phdr->p_type==PT_LOAD && phdr->p_flags & PF_X) {\n        // The format of the 'if' is\n        //  if ( ( (hatch = loc1), test_loc1 )\n        //  ||   ( (hatch = loc2), test_loc2 ) ) {\n        //      action\n        //  }\n        // which uses the comma to save bytes when test_locj involves locj\n        // and the action is the same when either test succeeds.\n\n        // Try page fragmentation just beyond .text .\n        if ( ( (hatch = (void *)(phdr->p_memsz + phdr->p_vaddr + reloc)),\n                ( phdr->p_memsz==phdr->p_filesz  // don't pollute potential .bss\n                &&  8<=(~PAGE_MASK & -(int)hatch) ) ) // space left on page\n        // Try Elf32_Ehdr.e_ident[8..15] .  warning: 'const' cast away\n        ||   ( (hatch = (void *)(&((Elf32_Ehdr *)phdr->p_vaddr + reloc)->e_ident[8])),\n                (phdr->p_offset==0) ) )\n        {\n            hatch[0]= 0xef90005b;  // syscall __NR_unmap\n            hatch[1]= 0xe1a0f00e;  // mov pc,lr\n        }\n    }\n    return hatch;\n}\n#endif  /*}*/\n\nstatic void\n#if defined(__i386__)  /*{*/\n__attribute__((regparm(2), stdcall))\n#endif  /*}*/\nupx_bzero(char *p, size_t len)\n{\n    if (len) do {\n        *p++= 0;\n    } while (--len);\n}\n#define bzero upx_bzero\n\n\nstatic void\n#if defined(__i386__)  /*{*/\n__attribute__((regparm(3), stdcall))\n#endif  /*}*/\nauxv_up(Elf32_auxv_t *av, unsigned const type, unsigned const value)\n{\n    DPRINTF((STR_auxv_up(),av,type,value));\n    if (av\n#if defined(__i386__)  /*{*/\n    && 0==(1&(int)av)  /* PT_INTERP usually inhibits, except for hatch */\n#endif  /*}*/\n    )\n    for (;; ++av) {\n        if (av->a_type==type || (av->a_type==AT_IGNORE && type!=AT_NULL)) {\n            av->a_type = type;\n            av->a_un.a_val = value;\n            return;\n        }\n        if (av->a_type==AT_NULL) {\n            // We can't do this as part of the for loop because we overwrite\n            // AT_NULL too.\n            return;\n        }\n    }\n}\n\n// The PF_* and PROT_* bits are {1,2,4}; the conversion table fits in 32 bits.\n#define REP8(x) \\\n    ((x)|((x)<<4)|((x)<<8)|((x)<<12)|((x)<<16)|((x)<<20)|((x)<<24)|((x)<<28))\n#define EXP8(y) \\\n    ((1&(y)) ? 0xf0f0f0f0 : (2&(y)) ? 0xff00ff00 : (4&(y)) ? 0xffff0000 : 0)\n#define PF_TO_PROT(pf) \\\n    ((PROT_READ|PROT_WRITE|PROT_EXEC) & ( \\\n        ( (REP8(PROT_EXEC ) & EXP8(PF_X)) \\\n         |(REP8(PROT_READ ) & EXP8(PF_R)) \\\n         |(REP8(PROT_WRITE) & EXP8(PF_W)) \\\n        ) >> ((pf & (PF_R|PF_W|PF_X))<<2) ))\n\n\n#define MAP_ANON_FD -1\n\n// Find convex hull of PT_LOAD (the minimal interval which covers all PT_LOAD),\n// and mmap that much, to be sure that a kernel using exec-shield-randomize\n// won't place the first piece in a way that leaves no room for the rest.\nstatic unsigned long  // returns relocation constant\n#if defined(__i386__)  /*{*/\n__attribute__((regparm(3), stdcall))\n#endif  /*}*/\nxfind_pages(unsigned mflags, Elf32_Phdr const *phdr, int phnum,\n    char **const p_brk\n)\n{\n    size_t lo= ~0, hi= 0, szlo= 0;\n    char *addr;\n    DPRINTF((STR_xfind_pages(), mflags, phdr, phnum, p_brk));\n    mflags += MAP_PRIVATE | MAP_ANONYMOUS;  // '+' can optimize better than '|'\n    for (; --phnum>=0; ++phdr) if (PT_LOAD==phdr->p_type) {\n        if (phdr->p_vaddr < lo) {\n            lo = phdr->p_vaddr;\n            szlo = phdr->p_filesz;\n        }\n        if (hi < (phdr->p_memsz + phdr->p_vaddr)) {\n            hi =  phdr->p_memsz + phdr->p_vaddr;\n        }\n    }\n    szlo += ~PAGE_MASK & lo;  // page fragment on lo edge\n    lo   -= ~PAGE_MASK & lo;  // round down to page boundary\n    hi    =  PAGE_MASK & (hi - lo - PAGE_MASK -1);  // page length\n    szlo  =  PAGE_MASK & (szlo    - PAGE_MASK -1);  // page length\n    addr = mmap((void *)lo, hi, PROT_NONE, mflags, MAP_ANON_FD, 0);\n    *p_brk = hi + addr;  // the logical value of brk(0)\n    //mprotect(szlo + addr, hi - szlo, PROT_NONE);  // no access, but keep the frames!\n    return (unsigned long)addr - lo;\n}\n\nstatic Elf32_Addr  // entry address\ndo_xmap(int const fdi, Elf32_Ehdr const *const ehdr, struct Extent *const xi,\n    Elf32_auxv_t *const av, unsigned *p_reloc, f_unfilter *const f_unf)\n{\n    Elf32_Phdr const *phdr = (Elf32_Phdr const *) (ehdr->e_phoff +\n        (void const *)ehdr);\n    char *v_brk;\n    unsigned const reloc = xfind_pages(\n        ((ET_EXEC==ehdr->e_type) ? MAP_FIXED : 0), phdr, ehdr->e_phnum, &v_brk);\n    int j;\n    DPRINTF((STR_do_xmap(),\n        fdi, ehdr, xi, (xi? xi->size: 0), (xi? xi->buf: 0), av, p_reloc, f_unf));\n    for (j=0; j < ehdr->e_phnum; ++phdr, ++j)\n    if (PT_PHDR==phdr->p_type) {\n        if (xi) {\n            auxv_up(av, AT_PHDR, phdr->p_vaddr + reloc);\n        }\n    }\n    else if (PT_LOAD==phdr->p_type && phdr->p_memsz != 0) {\n        unsigned const prot = PF_TO_PROT(phdr->p_flags);\n        struct Extent xo;\n        size_t mlen = xo.size = phdr->p_filesz;\n        char  *addr = xo.buf  =  (char *)(phdr->p_vaddr + reloc);\n        char *haddr =           phdr->p_memsz + addr;\n        size_t frag  = (int)addr &~ PAGE_MASK;\n        mlen += frag;\n        addr -= frag;\n\n        if (addr != (xi\n            ? mmap(addr, mlen\n#if defined(__i386__)  /*{*/\n                    // Decompressor can overrun the destination by 3 bytes.\n                    + 3\n#endif  /*}*/\n                , prot | PROT_WRITE, MAP_FIXED | MAP_PRIVATE | MAP_ANONYMOUS,\n                MAP_ANON_FD , 0 )\n            : mmap(addr, mlen\n                , prot,              MAP_FIXED | MAP_PRIVATE,\n                fdi,          phdr->p_offset - frag) ))\n        {\n            err_exit(8);\n        }\n        if (xi) {\n            unpackExtent(xi, &xo, (f_expand *)fdi,\n                ((PROT_EXEC & prot) ? f_unf : 0) );\n        }\n        // Linux does not fixup the low end, so neither do we.\n        //if (PROT_WRITE & prot) {\n        //    bzero(addr, frag);  // fragment at lo end\n        //}\n        frag = (-mlen) &~ PAGE_MASK;  // distance to next page boundary\n        if (PROT_WRITE & prot) { // note: read-only .bss not supported here\n            bzero(mlen+addr, frag);  // fragment at hi end\n        }\n        if (xi) {\n#if defined(__i386__)  /*{*/\n            void *const hatch = make_hatch_x86(phdr, reloc);\n            if (0!=hatch) {\n                /* always update AT_NULL, especially for compressed PT_INTERP */\n                auxv_up((Elf32_auxv_t *)(~1 & (int)av), AT_NULL, (unsigned)hatch);\n            }\n#elif defined(__arm__)  /*}{*/\n            void *const hatch = make_hatch_arm(phdr, reloc);\n            if (0!=hatch) {\n                auxv_up((Elf32_auxv_t *)(void *)av, AT_NULL, (unsigned)hatch);\n            }\n#endif  /*}*/\n            if (0!=mprotect(addr, mlen, prot)) {\n                err_exit(10);\nERR_LAB\n            }\n        }\n        addr += mlen + frag;  /* page boundary on hi end */\n        if (addr < haddr) { // need pages for .bss\n            if (addr != mmap(addr, haddr - addr, prot,\n                    MAP_FIXED | MAP_PRIVATE | MAP_ANONYMOUS, MAP_ANON_FD, 0 ) ) {\n                err_exit(9);\n            }\n        }\n#if defined(__i386__)  /*{*/\n        else if (xi) { // cleanup if decompressor overrun crosses page boundary\n            mlen = ~PAGE_MASK & (3+ mlen);\n            if (mlen<=3) { // page fragment was overrun buffer only\n                munmap(addr, mlen);\n            }\n        }\n#endif  /*}*/\n    }\n    if (!xi) { // 2nd call (PT_INTERP); close()+check is smaller here\n        if (0!=close(fdi)) {\n            err_exit(11);\n        }\n    }\n    else { // 1st call (main); also have (0!=av) here\n        if (ET_DYN!=ehdr->e_type) {\n            // Needed only if compressed shell script invokes compressed shell.\n            do_brk(v_brk);\n        }\n    }\n    if (0!=p_reloc) {\n        *p_reloc = reloc;\n    }\n    return ehdr->e_entry + reloc;\n}\n\n\n/*************************************************************************\n// upx_main - called by our entry code\n//\n// This function is optimized for size.\n**************************************************************************/\n\nvoid *upx_main(\n    Elf32_auxv_t *const av,\n    unsigned const sz_compressed,\n    f_expand *const f_decompress,\n    f_unfilter */*const*/ f_unfilter,\n    struct Extent xo,\n    struct Extent xi,\n    unsigned const volatile dynbase\n) __asm__(\"upx_main\");\n\nvoid *upx_main(\n    Elf32_auxv_t *const av,\n    unsigned const sz_compressed,\n    f_expand *const f_decompress,\n    f_unfilter */*const*/ f_unf,\n    struct Extent xo,  // {sz_unc, ehdr}    for ELF headers\n    struct Extent xi,  // {sz_cpr, &b_info} for ELF headers\n    unsigned const volatile dynbase  // value+result: compiler must not change\n)\n{\n    Elf32_Ehdr *const ehdr = (Elf32_Ehdr *)(void *)xo.buf;  // temp char[MAX_ELF_HDR_32+OVERHEAD]\n    Elf32_Phdr const *phdr = (Elf32_Phdr const *)(1+ ehdr);\n    Elf32_Addr reloc;\n    Elf32_Addr entry;\n\n    // sizeof(Ehdr+Phdrs),   compressed; including b_info header\n    size_t const sz_pckhdrs = xi.size;\n\n    DPRINTF((STR_upx_main(),\n        av, sz_compressed, f_decompress, f_unf, &xo, xo.size, xo.buf,\n        &xi, xi.size, xi.buf, dynbase));\n#if defined(__i386__)  /*{*/\n    f_unf = (f_unfilter *)(2+ (long)f_decompress);\n#endif  /*}*/\n\n    // Uncompress Ehdr and Phdrs.\n    unpackExtent(&xi, &xo, f_decompress, 0);\n\n    // Prepare to decompress the Elf headers again, into the first PT_LOAD.\n    xi.buf  -= sz_pckhdrs;\n    xi.size  = sz_compressed;\n\n    // Some kernels omit AT_PHNUM,AT_PHENT,AT_PHDR because this stub has no PT_INTERP.\n    // That is \"too much\" optimization.  Linux 2.6.x seems to give all AT_*.\n    auxv_up(av, AT_PAGESZ, PAGE_SIZE);\n    auxv_up(av, AT_PHNUM , ehdr->e_phnum);\n    auxv_up(av, AT_PHENT , ehdr->e_phentsize);\n    auxv_up(av, AT_PHDR  , dynbase + (unsigned)(1+(Elf32_Ehdr *)phdr->p_vaddr));\n    // AT_PHDR.a_un.a_val  is set again by do_xmap if PT_PHDR is present.\n    // This is necessary for ET_DYN if|when we override a prelink address.\n\n    entry = do_xmap((int)f_decompress, ehdr, &xi, av, &reloc, f_unf);\n    auxv_up(av, AT_ENTRY , entry);  // might not be necessary?\n\n  { // Map PT_INTERP program interpreter\n    int j;\n    for (j=0; j < ehdr->e_phnum; ++phdr, ++j) if (PT_INTERP==phdr->p_type) {\n        int const fdi = open(reloc + (char const *)phdr->p_vaddr, O_RDONLY, 0);\n        if (0 > fdi) {\n            err_exit(18);\n        }\n        if (MAX_ELF_HDR_32!=read(fdi, (void *)ehdr, MAX_ELF_HDR_32)) {\nERR_LAB\n            err_exit(19);\n        }\n        entry = do_xmap(fdi, ehdr, 0, 0, &reloc, 0);\n        auxv_up(av, AT_BASE, reloc);\n        break;\n    }\n  }\n\n    return (void *)entry;\n}\n\n/* vim:set ts=4 sw=4 et: */\n","size_bytes":19524},"src/stub/src/i386-bsd.elf.execve-main.c":{"content":"/* i386-bsd.elf.execve-main.c -- generic stub loader for *BSD using execve()\n\n   This file is part of the UPX executable compressor.\n\n   Copyright (C) 1996-2025 Markus Franz Xaver Johannes Oberhumer\n   Copyright (C) 1996-2025 Laszlo Molnar\n   All Rights Reserved.\n\n   UPX and the UCL library are free software; you can redistribute them\n   and/or modify them under the terms of the GNU General Public License as\n   published by the Free Software Foundation; either version 2 of\n   the License, or (at your option) any later version.\n\n   This program is distributed in the hope that it will be useful,\n   but WITHOUT ANY WARRANTY; without even the implied warranty of\n   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n   GNU General Public License for more details.\n\n   You should have received a copy of the GNU General Public License\n   along with this program; see the file COPYING.\n   If not, write to the Free Software Foundation, Inc.,\n   59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.\n\n   Markus F.X.J. Oberhumer              Laszlo Molnar\n   <markus@oberhumer.com>               <ezerotven+github@gmail.com>\n\n   John F. Reiser\n   <jreiser@users.sourceforge.net>\n */\n\n\n#include \"include/bsd.h\"\n\n\n/*************************************************************************\n// configuration section\n**************************************************************************/\n\n// mmap() the temporary output file\n#define USE_MMAP_FO 1\n\n\n/*************************************************************************\n// file util\n**************************************************************************/\n\nstruct Extent {\n    int  size;  // must be first to match size[0] uncompressed size\n    char *buf;\n};\n\n\n#if !(USE_MMAP_FO)\n#if 1\nstatic __inline__ int xwrite(int fd, const void *buf, int count)\n{\n    // note: we can assert(count > 0);\n    do {\n        int n = write(fd, buf, count);\n        if (n == -EINTR)\n            continue;\n        if (n <= 0)\n            break;\n        buf += n;               // gcc extension: add to void *\n        count -= n;\n    } while (count > 0);\n    return count;\n}\n#else\n#define xwrite(fd,buf,count)    ((count) - write(fd,buf,count))\n#endif\n#endif /* !USE_MMAP_FO */\n\n\n/*************************************************************************\n// util\n**************************************************************************/\n\n#if 1\n\nextern char *\n__attribute__((regparm(2), stdcall))  // be ruthless\nupx_itoa(unsigned long v, char *buf);\n\n#else\n\n// Some versions of gcc optimize the division and/or remainder using\n// a multiplication by (2**32)/10, and use a relocatable 32-bit address\n// to reference the constant.  We require no relocations because we move\n// the code at runtime.  See upx_itoa.S for replacement [also smaller.]\nstatic char *upx_itoa(unsigned long v, char *buf)\n{\n//    const unsigned TEN = 10;\n    volatile unsigned TEN = 10;  // an ugly way to achieve no relocation\n    char *p = buf;\n    {\n        unsigned long k = v;\n        do {\n            p++;\n            k /= TEN;\n        } while (k > 0);\n    }\n    buf = p;\n    *p = 0;\n    {\n        unsigned long k = v;\n        do {\n            *--p = '0' + k % TEN;\n            k /= TEN;\n        } while (k > 0);\n    }\n    return buf;\n}\n\n#endif\n\n\nstatic uint32_t ascii5(char *p, uint32_t v, unsigned n)\n{\n    do {\n        unsigned char d = v % 32;\n        if (d >= 26) d -= 43;       // 43 == 'Z' - '0' + 1\n        *--p = (d += 'A');\n        v /= 32;\n    } while (--n > 0);\n    return v;\n}\n\n\n#if defined(__i386__)\n#  define SET2(p, c0, c1) \\\n        * (unsigned short *) (p) = ((c1)<<8 | (c0))\n#  define SET4(p, c0, c1, c2, c3) \\\n        * (uint32_t *) (p) = ((c3)<<24 | (c2)<<16 | (c1)<<8 | (c0))\n#  define SET3(p, c0, c1, c2) \\\n        SET4(p, c0, c1, c2, 0)\n#else\n#  define SET2(p, c0, c1) \\\n        (p)[0] = c0, (p)[1] = c1\n#  define SET3(p, c0, c1, c2) \\\n        (p)[0] = c0, (p)[1] = c1, (p)[2] = c2\n#  define SET4(p, c0, c1, c2, c3) \\\n        (p)[0] = c0, (p)[1] = c1, (p)[2] = c2, (p)[3] = c3\n#endif\n\n\n// go_self is a separate subroutine to spread the burden of local arrays.\n// Otherwise the size of the stack frame in upx_main exceeds 128 bytes,\n// which causes too many offsets to expand from 1 byte to 4.\n\nstatic int\n#if (ACC_CC_GNUC >= 0x030300)\n__attribute__((__noinline__, __used__, __stdcall__))\n#endif\ngo_self(char const *tmpname, char *argv[], char *envp[])\n{\n    // Old FreeBSD does not have /proc/self, so use /proc/<pid> instead.\n\n    // Open the temp file.\n    int const fdi = open(tmpname, O_RDONLY, 0);\n\n    if (0 <= fdi) {\n        // 17 chars for \"/proc/PPPPP/fd/XX\" should be enough, but we\n        // play safe in case there will be 32-bit pid_t at some time.\n        //char procself_buf[17+1];\n        char procself_buf[31+1];\n\n        // Compute name of temp fdi.\n        SET4(procself_buf + 0, '/', 'p', 'r', 'o');\n        SET4(procself_buf + 4, 'c', '/',  0 ,  0 );\n        {\n            char *const procself = upx_itoa(getpid(), procself_buf + 6);\n            SET4(procself, '/', 'f', 'd', '/');\n            upx_itoa(fdi, procself + 4);\n        }\n\n        // Check for working /proc/self/fd/X by accessing the\n        // temp file again, now via temp fdi.\n        if (UPX2 == (unsigned) access(procself_buf, R_OK | X_OK)) {\n            // Now it's safe to unlink the temp file (as it is still open).\n            unlink(tmpname);\n            // Set the file close-on-exec.\n            fcntl(fdi, F_SETFD, FD_CLOEXEC);\n            // Execute the original program via /proc/self/fd/X.\n            execve(procself_buf, (char const *const *)argv, (char const *const *)envp);\n            // NOTE: if we get here we've lost.\n        }\n\n        // The proc filesystem isn't working. No problem.\n        close(fdi);\n    }\n    return fdi;\n}\n\n\n/*************************************************************************\n// UPX & NRV stuff\n**************************************************************************/\n\ntypedef void f_unfilter(\n    nrv_byte *,  // also addvalue\n    nrv_uint,\n    unsigned cto8  // junk in high 24 bits\n);\ntypedef int f_expand(\n    const nrv_byte *src, nrv_uint  src_len,\n          nrv_byte *dst, nrv_uint *dst_len, int method );\n\n\n/*************************************************************************\n// upx_main - called by our entry code\n//\n// This function is optimized for size.\n**************************************************************************/\n\nvoid upx_main(\n    struct Extent xi,\n    f_expand *const f_decompress,\n    int junk2,\n    f_unfilter *const f_unf,\n    char *envp[],\n    char *argv[],\n    int argc\n) __asm__(\"upx_main\");\nvoid upx_main(\n    struct Extent xi,\n    f_expand *const f_decompress,\n    int junk,\n    f_unfilter *const f_unf,\n    char *envp[],\n    char *argv[],\n    int argc\n)\n{\n    // file descriptor\n    int fdo;\n\n    // decompression buffer\n    unsigned char *buf;\n\n    char *tmpname;\n    struct p_info header;\n\n    // temporary file name\n    char tmpname_buf[20];\n\n    (void)junk;\n\n    //\n    // ----- Step 0: set /proc/self using /proc/<pid> -----\n    //\n\n    //personality(PER_LINUX);\n\n\n    //\n    // ----- Step 1: prepare input file -----\n    //\n\n    // Read header.\n    {\n        register char *__d0, *__d1;\n        __asm__ __volatile__( \"movsl; movsl; movsl\"\n            : \"=&D\" (__d0), \"=&S\" (__d1)\n            : \"0\" (&header), \"1\" (xi.buf)\n            : \"memory\");\n        xi.buf   = __d1;\n        xi.size -= sizeof(header);\n    }\n\n    // Paranoia. Make sure this is actually our expected executable\n    // by checking the random program id. (The id is both stored\n    // in the header and patched into this stub.)\n    if (header.p_progid != UPX3)\n        goto error1;\n\n\n    //\n    // ----- Step 2: prepare temporary output file -----\n    //\n\n    tmpname = tmpname_buf;\n    SET4(tmpname + 0, '/', 't', 'm', 'p');\n    SET4(tmpname + 4, '/', 'u', 'p', 'x');\n\n    // Compute name of temporary output file in tmpname[].\n    // Protect against Denial-of-Service attacks.\n    {\n        char *p = tmpname_buf + sizeof(tmpname_buf) - 1;\n\n        // Compute the last 4 characters (20 bits) from getpid().\n        uint32_t r = ascii5(p, (uint32_t)getpid(), 4); *p = '\\0'; p -= 4;\n\n        // Provide 4 random bytes from our program id.\n        r ^= header.p_progid;\n        // Mix in 4 runtime random bytes.\n        // Don't consume precious bytes from /dev/urandom.\n        {\n#if 1\n            struct timeval tv;\n            gettimeofday(&tv, 0);\n            r ^= (uint32_t) tv.tv_sec;\n            r ^= ((uint32_t) tv.tv_usec) << 12;      // shift into high-bits\n#else\n            // using adjtimex() may cause portability problems\n            struct timex tx;\n            adjtimex(&tx);\n            r ^= (uint32_t) tx.time.tv_sec;\n            r ^= ((uint32_t) tx.time.tv_usec) << 12; // shift into high-bits\n            r ^= (uint32_t) tx.errcnt;\n#endif\n        }\n        // Compute 7 more characters from the 32 random bits.\n        ascii5(p, r, 7);\n    }\n\n    // Just in case, remove the file.\n    {\n        int err = unlink(tmpname);\n        if (err != -ENOENT && err != 0)\n            goto error1;\n    }\n\n    // Create the temporary output file.\n#if (USE_MMAP_FO)\n    fdo = open(tmpname, O_RDWR | O_CREAT | O_EXCL, 0700);\n#else\n    fdo = open(tmpname, O_WRONLY | O_CREAT | O_EXCL, 0700);\n#endif\n#if 0\n    // Save some bytes of code - the ftruncate() below will fail anyway.\n    if (fdo < 0)\n        goto error;\n#endif\n\n    // Set expected uncompressed file size.\n    if (ftruncate(fdo, header.p_filesize) != 0)\n        goto error;\n\n\n    //\n    // ----- Step 3: setup memory -----\n    //\n\n#if (USE_MMAP_FO)\n    // FIXME: packer could set length\n    buf = (unsigned char *)mmap(0, header.p_filesize,\n        PROT_READ | PROT_WRITE, MAP_SHARED, fdo, 0);\n    if ((unsigned long) buf >= (unsigned long) -4095)\n        goto error;\n\n    // Decompressor can overrun the output by 3 bytes.\n    // Defend against SIGSEGV by using a scratch page.\n    // FIXME: packer could set address delta\n    mmap(buf + (PAGE_MASK & (header.p_filesize + ~PAGE_MASK)),\n        -PAGE_MASK, PROT_READ | PROT_WRITE,\n        MAP_FIXED | MAP_PRIVATE | MAP_ANONYMOUS, -1, 0 );\n#else\n    // Temporary decompression buffer.\n    // FIXME: packer could set length\n    buf = mmap(0, (header.p_blocksize + OVERHEAD + ~PAGE_MASK) & PAGE_MASK,\n        PROT_READ | PROT_WRITE, MAP_PRIVATE | MAP_ANONYMOUS, -1, 0 );\n    if ((unsigned long) buf >= (unsigned long) -4095)\n        goto error;\n#endif\n\n    //\n    // ----- Step 4: decompress blocks -----\n    //\n\n    for (;;)\n    {\n        struct b_info h;\n\n        // Read and check block sizes.\n        {\n            register char *__d0, *__d1;\n            __asm__ __volatile__( \"movsl; movsl; movsl\"\n                : \"=&D\" (__d0), \"=&S\" (__d1)\n                : \"0\" (&h), \"1\" (xi.buf)\n                : \"memory\");\n            xi.buf   = __d1;\n            xi.size -= sizeof(h);\n        }\n        if (h.sz_unc == 0)                      // uncompressed size 0 -> EOF\n        {\n            if (h.sz_cpr != UPX_MAGIC_LE32)     // h.sz_cpr must be h->magic\n                goto error;\n            if (header.p_filesize != 0)         // all bytes must be written\n                goto error;\n            break;\n        }\n        //   Note: if sz_unc == sz_cpr then the block was not\n        //   compressible and is stored in its uncompressed form.\n\n        if (h.sz_cpr > h.sz_unc || h.sz_cpr > header.p_blocksize)\n            goto error;\n        // Now we have:\n        //   assert(h.sz_cpr <= h.sz_unc);\n        //   assert(h.sz_unc > 0 && h.sz_unc <= blocksize);\n        //   assert(h.sz_cpr > 0 && h.sz_cpr <= blocksize);\n\n        if (h.sz_cpr < h.sz_unc) { // Decompress block.\n            nrv_uint out_len = h.sz_unc;  // EOF for lzma\n            int i = (*f_decompress)((unsigned char *)xi.buf, h.sz_cpr, buf,\n                &out_len, *(int *)(void *)&h.b_method);\n            if (i != 0 || out_len != (nrv_uint)h.sz_unc)\n                goto error;\n            // Right now, unfilter is combined with decompression.\n            // (*f_unfilter)(buf, out_len, cto8);\n            (void)f_unf;\n        }\n        else\n        {\n            // Incompressible block\n#if (USE_MMAP_FO)\n            //memcpy(buf, xi.buf, h.sz_unc);\n            register unsigned long int __d0, __d1, __d2;\n            __asm__ __volatile__( \"rep; movsb\"\n                : \"=&c\" (__d0), \"=&D\" (__d1), \"=&S\" (__d2)\n                : \"0\" (h.sz_unc), \"1\" (buf), \"2\" (xi.buf)\n                : \"memory\");\n#endif\n        }\n\n#if (USE_MMAP_FO)\n        // unmap part of the output\n        munmap(buf, h.sz_unc);\n        buf     += h.sz_unc;\n#else\n        // write output file\n        if (xwrite(fdo, buf, h.sz_unc) != 0)\n            goto error;\n#endif\n\n        header.p_filesize -= h.sz_unc;\n\n        xi.buf  += h.sz_cpr;\n        xi.size -= h.sz_cpr;\n\n        if (xi.size < 0) {\n// error exit is here in the middle to keep the jumps short.\n        error:\n            (void) unlink(tmpname);\n        error1:\n            // Note: the kernel will close all open files and\n            //       unmap any allocated memory.\n            for (;;)\n                (void) exit(127);\n        }\n    }\n\n    //\n    // ----- Step 5: release resources -----\n    //\n\n\n#if !(USE_MMAP_FO)\n    // Free our temporary decompression buffer.\n    munmap(buf, malloc_args.ma_length);\n#endif\n\n    if (close(fdo) != 0)\n        goto error;\n\n\n    //\n    // ----- Step 6: try to start program via /proc/self/fd/X -----\n    //\n\n    // Many thanks to Andi Kleen <ak@muc.de> and\n    // Jamie Lokier <nospam@cern.ch> for this nice idea.\n\n    if (0 > go_self(tmpname, argv, envp))\n        goto error;\n\n\n    //\n    // ----- Step 7: start program in /tmp  -----\n    //\n\n    // Fork off a subprocess to clean up.\n    // We have to do this double-fork trick to keep a zombie from\n    // hanging around if the spawned original program doesn't check for\n    // subprocesses (as well as to prevent the real program from getting\n    // confused about this subprocess it shouldn't have).\n    // Thanks to Adam Ierymenko <api@one.net> for this solution.\n\n    if (fork() == 0)\n    {\n        if (fork() == 0)\n        {\n            // Sleep 3 seconds, then remove the temp file.\n            struct timespec ts; ts.tv_sec = UPX4; ts.tv_nsec = 0;\n            nanosleep(&ts, 0);\n            unlink(tmpname);\n        }\n        exit(0);\n    }\n\n    // Wait for the first fork()'d process to die.\n    waitpid(-1, (int *)0, 0);\n\n    // Execute the original program.\n    (void)argc;\n    execve(tmpname, (char const *const *)argv, (char const *const *)envp);\n\n\n    //\n    // ----- Step 8: error exit -----\n    //\n\n    // If we return from execve() there was an error. Give up.\n    goto error;\n}\n\n/* vim:set ts=4 sw=4 et: */\n","size_bytes":14769},"src/stub/src/i386-darwin.macho-main.c":{"content":"/* i386-darwin.macho-main.c -- loader stub for Mach-o i386\n\n   This file is part of the UPX executable compressor.\n\n   Copyright (C) 1996-2025 Markus Franz Xaver Johannes Oberhumer\n   Copyright (C) 1996-2025 Laszlo Molnar\n   Copyright (C) 2000-2025 John F. Reiser\n   All Rights Reserved.\n\n   UPX and the UCL library are free software; you can redistribute them\n   and/or modify them under the terms of the GNU General Public License as\n   published by the Free Software Foundation; either version 2 of\n   the License, or (at your option) any later version.\n\n   This program is distributed in the hope that it will be useful,\n   but WITHOUT ANY WARRANTY; without even the implied warranty of\n   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n   GNU General Public License for more details.\n\n   You should have received a copy of the GNU General Public License\n   along with this program; see the file COPYING.\n   If not, write to the Free Software Foundation, Inc.,\n   59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.\n\n   Markus F.X.J. Oberhumer              Laszlo Molnar\n   <markus@oberhumer.com>               <ezerotven+github@gmail.com>\n\n   John F. Reiser\n   <jreiser@users.sourceforge.net>\n */\n\n\n#define __WORDSIZE 32\n#include \"include/darwin.h\"\n\n#ifndef DEBUG  /*{*/\n#define DEBUG 0\n#endif  /*}*/\n\n/*************************************************************************\n// configuration section\n**************************************************************************/\n\n// In order to make it much easier to move this code at runtime and execute\n// it at an address different from it load address:  there must be no\n// static data, and no string constants.\n\n#if !DEBUG  /*{*/\n#define DPRINTF(a ...) /* empty: no debug drivel */\n#else  /*}{ DEBUG */\n#define DPRINTF(fmt, args...) ({ \\\n    char const *r_fmt; \\\n    asm(\"call 0f; .asciz \\\"\" fmt \"\\\"; 0: pop %0\" \\\n/*out*/ : \"=r\"(r_fmt) ); \\\n    dprintf(r_fmt, args); \\\n})\n\n#define va_arg      __builtin_va_arg\n#define va_end      __builtin_va_end\n#define va_list     __builtin_va_list\n#define va_start    __builtin_va_start\n\nstatic int\nunsimal(unsigned x, char *ptr, int n)\n{\n    if (10<=x) {\n        unsigned const q = x / 10;\n        x -= 10 * q;\n        n = unsimal(q, ptr, n);\n    }\n    ptr[n] = '0' + x;\n    return 1+ n;\n}\n\nstatic int\ndecimal(int x, char *ptr, int n)\n{\n    if (x < 0) {\n        x = -x;\n        ptr[n++] = '-';\n    }\n    return unsimal(x, ptr, n);\n}\n\nstatic int\nheximal(unsigned long x, char *ptr, int n)\n{\n    unsigned j = -1+ 2*sizeof(unsigned long);\n    unsigned long m = 0xful << (4 * j);\n    for (; j; --j, m >>= 4) { // omit leading 0 digits\n        if (m & x) break;\n    }\n    for (; m; --j, m >>= 4) {\n        unsigned d = 0xf & (x >> (4 * j));\n        ptr[n++] = ((10<=d) ? ('a' - 10) : '0') + d;\n    }\n    return n;\n}\n\nstatic int\ndprintf(char const *fmt, ...)\n{\n    int n= 0;\n    char const *literal = 0;  // NULL\n    char buf[24];  // ~0ull == 18446744073709551615 ==> 20 chars\n    va_list va; va_start(va, fmt);\n    for (;;) {\n        char c = *fmt++;\n        if (!c) { // end of fmt\n            if (literal) {\n                goto finish;\n            }\n            break;  // goto done\n        }\n        if ('%'!=c) {\n            if (!literal) {\n                literal = fmt;  // 1 beyond start of literal\n            }\n            continue;\n        }\n        // '%' == c\n        if (literal) {\nfinish:\n            n += write(2, -1+ literal, fmt - literal);\n            literal = 0;  // NULL\n            if (!c) { // fmt already ended\n               break;  // goto done\n            }\n        }\n        switch (c= *fmt++) { // deficiency: does not handle _long_\n        default: { // un-implemented conversion\n            n+= write(2, -1+ fmt, 1);\n        } break;\n        case 0: { // fmt ends with \"%\\0\" ==> ignore\n            goto done;\n        } break;\n        case 'u': {\n            n+= write(2, buf, unsimal(va_arg(va, unsigned), buf, 0));\n        } break;\n        case 'd': {\n            n+= write(2, buf, decimal(va_arg(va, int), buf, 0));\n        } break;\n        case 'p': {\n            buf[0] = '0';\n            buf[1] = 'x';\n            n+= write(2, buf, heximal((unsigned long)va_arg(va, void *), buf, 2));\n        } break;\n        case 'x': {\n            buf[0] = '0';\n            buf[1] = 'x';\n            n+= write(2, buf, heximal(va_arg(va, unsigned int), buf, 2));\n        } break;\n        case 's': {\n            char *s0= (char *)va_arg(va, unsigned char *), *s= s0;\n            if (s) while (*s) ++s;\n            n+= write(2, s0, s - s0);\n        } break;\n        } // 'switch'\n    }\ndone:\n    va_end(va);\n    return n;\n}\n#endif  /*}*/\n\nextern int spin(int);\n\n/*************************************************************************\n// \"file\" util\n**************************************************************************/\n\ntypedef struct {\n    size_t size;  // must be first to match size[0] uncompressed size\n    void *buf;\n} Extent;\n\nstatic void\nxread(Extent *x, void *buf, size_t count)\n{\n    unsigned char *p=x->buf, *q=buf;\n    size_t j;\n    DPRINTF(\"xread %%p(%%x %%p) %%p %%x\\\\n\",\n            x, x->size, x->buf, buf, count);\n    if (x->size < count) {\n        DPRINTF(\"xreadfail %%p(%%x %%p) %%p %%x\\\\n\",\n                x, x->size, x->buf, buf, count);\n        exit(127);\n    }\n    for (j = count; 0!=j--; ++p, ++q) {\n        *q = *p;\n    }\n    x->buf  += count;\n    x->size -= count;\n}\n\n\n/*************************************************************************\n// util\n**************************************************************************/\n\n#if 1  //{  save space\n#define ERR_LAB error: exit(127);\n#define err_exit(a) goto error\n#else  //}{  save debugging time\n#define ERR_LAB /*empty*/\n\nstatic void\nerr_exit(int a)\n{\n    DPRINTF((STR_exit(), a));\n    (void)a;  // debugging convenience\n    exit(127);\n}\n#endif  //}\n\n\n/*************************************************************************\n// UPX & NRV stuff\n**************************************************************************/\n\nstruct l_info { // 12-byte trailer for loader (after macho headers)\n    unsigned l_checksum;\n    unsigned l_magic;  // UPX_MAGIC_LE32\n    unsigned short l_lsize;\n    unsigned char l_version;\n    unsigned char l_format;\n};\nstruct p_info { // 12-byte packed program header\n    unsigned p_progid;\n    unsigned p_filesize;\n    unsigned p_blocksize;\n};\n\nstruct b_info { // 12-byte header before each compressed block\n    unsigned sz_unc;  // uncompressed_size\n    unsigned sz_cpr;  //   compressed_size\n    unsigned char b_method;  // compression algorithm\n    unsigned char b_ftid;  // filter id\n    unsigned char b_cto8;  // filter parameter\n    unsigned char b_unused;\n};\n\ntypedef void f_unfilter(\n    nrv_byte *,  // also addvalue\n    nrv_uint,\n    unsigned cto8, // junk in high 24 bits\n    unsigned ftid\n);\ntypedef int f_expand(\n    const nrv_byte *, nrv_uint,\n          nrv_byte *, nrv_uint *, unsigned );\n\nstatic void\nunpackExtent(\n    Extent *const xi,  // input\n    Extent *const xo,  // output\n    f_expand *const f_decompress,\n    f_unfilter *f_unf\n)\n{\n    DPRINTF(\"unpackExtent in=%%p(%%x %%p)  out=%%p(%%x %%p)  %%p %%p\\\\n\",\n        xi, xi->size, xi->buf, xo, xo->size, xo->buf, f_decompress, f_unf);\n    while (xo->size) {\n        struct b_info h;\n        //   Note: if h.sz_unc == h.sz_cpr then the block was not\n        //   compressible and is stored in its uncompressed form.\n\n        // Read and check block sizes.\n        xread(xi, (unsigned char *)&h, sizeof(h));\n        DPRINTF(\"  sz_unc=%%x  sz_cpr=%%x  param=%%x\\\\n\",\n            h.sz_unc, h.sz_cpr, *(int *)&h.b_method);\n        if (h.sz_unc == 0) {                     // uncompressed size 0 -> EOF\n            if (h.sz_cpr != UPX_MAGIC_LE32)      // h.sz_cpr must be h->magic\n                err_exit(2);\n            if (xi->size != 0)                 // all bytes must be written\n                err_exit(3);\n            break;\n        }\n        if (h.sz_cpr <= 0) {\n            err_exit(4);\nERR_LAB\n        }\n        if (h.sz_cpr > h.sz_unc\n        ||  h.sz_unc > xo->size ) {\n            DPRINTF(\"sz_cpr=%%x  sz_unc=%%x  xo->size=%%x\\\\n\",\n                        h.sz_cpr, h.sz_unc, xo->size);\n            err_exit(5);\n        }\n        // Now we have:\n        //   assert(h.sz_cpr <= h.sz_unc);\n        //   assert(h.sz_unc > 0 && h.sz_unc <= blocksize);\n        //   assert(h.sz_cpr > 0 && h.sz_cpr <= blocksize);\n\n        if (h.sz_cpr < h.sz_unc) { // Decompress block\n            nrv_uint out_len = h.sz_unc;  // EOF for lzma\n            int const j = (*f_decompress)(xi->buf, h.sz_cpr,\n                xo->buf, &out_len, h.b_method);\n            if (j != 0 || out_len != (nrv_uint)h.sz_unc)\n                err_exit(7);\n            DPRINTF(\"  b_ftid=%%x  f_unf=%%p\\\\n\", h.b_ftid, f_unf);\n            if (h.b_ftid!=0 && f_unf) {  // have filter\n                DPRINTF(\" unfiltering f_unf=%%p  buf=%%p  len=%%x  cto=%%x  ftid=%%x\\\\n\",\n                        f_unf, xo->buf, out_len, h.b_cto8, h.b_ftid);\n                (*f_unf)(xo->buf, out_len, h.b_cto8, h.b_ftid);\n            }\n            xi->buf  += h.sz_cpr;\n            xi->size -= h.sz_cpr;\n        }\n        else { // copy literal block\n            xi->size += sizeof(h);  // xread(xi, &h, sizeof(h)) was a peek\n            xread(xi, xo->buf, h.sz_cpr);\n        }\n        xo->buf  += h.sz_unc;\n        xo->size -= h.sz_unc;\n    }\n}\n\nstatic void\nupx_bzero(unsigned char *p, size_t len)\n{\n    if (len) do {\n        *p++= 0;\n    } while (--len);\n}\n#define bzero upx_bzero\n\n\n// The PF_* and PROT_* bits are {1,2,4}; the conversion table fits in 32 bits.\n#define REP8(x) \\\n    ((x)|((x)<<4)|((x)<<8)|((x)<<12)|((x)<<16)|((x)<<20)|((x)<<24)|((x)<<28))\n#define EXP8(y) \\\n    ((1&(y)) ? 0xf0f0f0f0 : (2&(y)) ? 0xff00ff00 : (4&(y)) ? 0xffff0000 : 0)\n#define PF_TO_PROT(pf) \\\n    ((PROT_READ|PROT_WRITE|PROT_EXEC) & ( \\\n        ( (REP8(PROT_EXEC ) & EXP8(PF_X)) \\\n         |(REP8(PROT_READ ) & EXP8(PF_R)) \\\n         |(REP8(PROT_WRITE) & EXP8(PF_W)) \\\n        ) >> ((pf & (PF_R|PF_W|PF_X))<<2) ))\n\ntypedef size_t Addr;\n\ntypedef struct {\n    unsigned magic;\n    unsigned nfat_arch;\n} Fat_header;\ntypedef struct {\n    unsigned cputype;\n    unsigned cpusubtype;\n    unsigned offset;\n    unsigned size;\n    unsigned align;  /* shift count (log base 2) */\n} Fat_arch;\n    enum e8 {\n        FAT_MAGIC = 0xcafebabe,\n        FAT_CIGAM = 0xbebafeca\n    };\n    enum e9 {\n        CPU_TYPE_I386      =          7,\n        CPU_TYPE_AMD64     = 0x01000007,\n        CPU_TYPE_ARM       =         12,\n        CPU_TYPE_POWERPC   = 0x00000012,\n        CPU_TYPE_POWERPC64 = 0x01000012\n    };\n\ntypedef struct {\n    unsigned magic;\n    unsigned cputype;\n    unsigned cpysubtype;\n    unsigned filetype;\n    unsigned ncmds;\n    unsigned sizeofcmds;\n    unsigned flags;\n} Mach_header;\n        enum e0 {\n            MH_MAGIC   =   0xfeedface,\n            MH_MAGIC64 = 1+0xfeedface\n        };\n        enum e2 {\n            MH_EXECUTE = 2\n        };\n        enum e3 {\n            MH_NOUNDEFS = 1\n        };\n\ntypedef struct {\n    unsigned cmd;\n    unsigned cmdsize;\n} Mach_load_command;\n        enum e4 {\n            LC_SEGMENT       = 0x1,\n            LC_SEGMENT_64    = 0x19,\n            LC_THREAD        = 0x4,\n            LC_UNIXTHREAD    = 0x5,\n            LC_LOAD_DYLINKER = 0xe\n        };\n\ntypedef struct {\n    unsigned cmd;\n    unsigned cmdsize;\n    char segname[16];\n    Addr vmaddr;\n    Addr vmsize;\n    unsigned fileoff;\n    unsigned filesize;\n    unsigned maxprot;\n    unsigned initprot;\n    unsigned nsects;\n    unsigned flags;\n} Mach_segment_command;\n        enum e5 {\n            VM_PROT_NONE = 0,\n            VM_PROT_READ = 1,\n            VM_PROT_WRITE = 2,\n            VM_PROT_EXECUTE = 4\n        };\n\ntypedef struct {\n    char sectname[16];\n    char segname[16];\n    Addr addr;   /* memory address */\n    Addr size;   /* size in bytes */\n    unsigned offset; /* file offset */\n    unsigned align;  /* power of 2 */\n    unsigned reloff; /* file offset of relocation entries */\n    unsigned nreloc; /* number of relocation entries */\n    unsigned flags;  /* section type and attributes */\n    unsigned reserved1;  /* for offset or index */\n    unsigned reserved2;  /* for count or sizeof */\n} Mach_section_command;\n\ntypedef struct {\n    unsigned eax, ebx, ecx, edx;\n    unsigned edi, esi, ebp;\n    unsigned esp, ss;\n    unsigned eflags;\n    unsigned eip, cs;\n    unsigned ds, es, fs, gs;\n} Mach_i386_thread_state;\n\ntypedef struct {\n    unsigned cmd;            /* LC_THREAD or  LC_UNIXTHREAD */\n    unsigned cmdsize;        /* total size of this command */\n    unsigned flavor;\n    unsigned count;          /* sizeof(following_thread_state)/4 */\n    Mach_i386_thread_state state;\n} Mach_thread_command;\n        enum e6 {\n            i386_THREAD_STATE = 1\n        };\n        enum e7 {\n            i386_THREAD_STATE_COUNT = sizeof(Mach_i386_thread_state)/4\n        };\n\ntypedef union {\n    unsigned long offset;  /* from start of load command to string */\n    char *ptr;\n} Mach_lc_str;\n\n#define MAP_FIXED     0x10\n#define MAP_PRIVATE   0x02\n#define MAP_ANON    0x1000\n#define PROT_READ      1\n#define PROT_WRITE     2\n#define PROT_EXEC      4\n#define MAP_ANON_FD    -1\n\n// We have off_t_upx_stub as 32 bits, but syscalls consider off_t as 64 bits.\n// Make the top 32 bits explicit, and pass a 0.\nextern void *mmap(void *, size_t, unsigned, unsigned, int, off_t_upx_stub, unsigned);\nextern ssize_t pread(int, void *, size_t, off_t_upx_stub, unsigned);\nextern void bswap(void *, unsigned);\n\nenum {\n        MH_DYLINKER= 7,     /* /usr/bin/dyld */\n        MH_PIE      = 0x200000   // ASLR\n\n};\n\n// Find convex hull of PT_LOAD (the minimal interval which covers all PT_LOAD),\n// and mmap that much, to be sure that a kernel using exec-shield-randomize\n// won't place the first piece in a way that leaves no room for the rest.\nstatic Addr // returns relocation constant\nxfind_pages(\n    Mach_header const *const mhdr,\n    Mach_segment_command const *sc,\n    int const ncmds,\n    Addr addr\n)\n{\n    Addr lo= ~(Addr)0, hi= 0;\n    int j;\n    unsigned mflags = ((mhdr->filetype == MH_DYLINKER || mhdr->flags & MH_PIE) ? 0 : MAP_FIXED);\n    mflags += MAP_PRIVATE | MAP_ANON;  // '+' can optimize better than '|'\n    DPRINTF(\"xfind_pages  mhdr=%%p  sc=%%p  ncmds=%%d  addr=%%p  mflags=%%x\\\\n\",\n        mhdr, sc, ncmds, addr, mflags);\n    for (j=0; j < ncmds; ++j,\n        (sc = (Mach_segment_command const *)((sc->cmdsize>>2) + (unsigned const *)sc))\n    ) if (LC_SEGMENT==sc->cmd) {\n        DPRINTF(\"  #%%d  cmd=%%x  cmdsize=%%x  vmaddr=%%p  vmsize==%%p  lo=%%p  mflags=%%x\\\\n\",\n            j, sc->cmd, sc->cmdsize, sc->vmaddr, sc->vmsize, lo, mflags);\n        if (sc->vmsize  // theoretically occupies address space\n        &&  !(sc->vmaddr==0 && (MAP_FIXED & mflags))  // but ignore PAGEZERO when MAP_FIXED\n        ) {\n            if (mhdr->filetype == MH_DYLINKER  // /usr/lib/dyld\n            &&  0==(1+ lo)  // 1st LC_SEGMENT\n            &&  sc->vmaddr != 0  // non-floating address\n            ) {\n                // \"pre-linked\" dyld on MacOS 10.11.x El Capitan\n                mflags |= MAP_FIXED;\n            }\n            if (lo > sc->vmaddr) {\n                lo = sc->vmaddr;\n            }\n            if (hi < (sc->vmsize + sc->vmaddr)) {\n                hi =  sc->vmsize + sc->vmaddr;\n            }\n        }\n    }\n    lo -= ~PAGE_MASK & lo;  // round down to page boundary\n    hi  =  PAGE_MASK & (hi - lo - PAGE_MASK -1);  // page length\n    DPRINTF(\"  addr=%%p  lo=%%p  len=%%p  mflags=%%x\\\\n\", addr, lo, hi, mflags);\n    if (MAP_FIXED & mflags) {\n        addr = lo;\n        int rv = munmap((void *)addr, hi);\n        if (rv) {\n            DPRINTF(\"munmap addr=%%p len=%%p, rv=%%x\\\\n\", addr, hi, rv);\n        }\n    }\n    addr = (Addr)mmap((void *)addr, hi, VM_PROT_NONE, mflags, MAP_ANON_FD, 0, 0);\n    DPRINTF(\"  addr=%%p\\\\n\", addr);\n    if (~PAGE_MASK & addr) {\n        //err_exit(6);\n    }\n    return (Addr)(addr - lo);\n}\nAddr  // entry: &hatch if main; Mach_thread_state->eip if dyld\ndo_xmap(\n    Mach_header *const mhdr,\n    off_t_upx_stub const fat_offset,\n    Extent *const xi,\n    int const fdi,\n    Mach_header **mhdrpp,\n    f_expand *const f_exp,\n    f_unfilter *const f_unf\n)\n{\n    DPRINTF(\"do_xmap  fdi=%%x  mhdr=%%p  *mhdrpp=%%p  xi=%%p(%%x %%p) f_unf=%%p\\\\n\",\n        fdi, mhdr, (mhdrpp ? *mhdrpp : 0), xi, (xi? xi->size: 0), (xi? xi->buf: 0), f_unf);\n\n    Addr rv = 0;\n    Mach_segment_command *sc = (Mach_segment_command *)(1+ mhdr);\n    Addr const reloc = xfind_pages(mhdr, sc, mhdr->ncmds, 0);\n    DPRINTF(\"do_xmap reloc=%%p\\\\n\", reloc);\n    unsigned j;\n    for ( j=0; j < mhdr->ncmds; ++j,\n        (sc = (Mach_segment_command *)((sc->cmdsize>>2) + (unsigned *)sc))\n    ) {\n        DPRINTF(\"  #%%d  cmd=%%x  cmdsize=%%x  vmsize=%%x\\\\n\",\n                j, sc->cmd, sc->cmdsize, sc->vmsize);\n        if (LC_SEGMENT==sc->cmd && !sc->vmsize) {\n            // Typical __DWARF info segment for 'rust'\n            struct b_info h;\n            xread(xi, (unsigned char *)&h, sizeof(h));\n            DPRINTF(\"    0==.vmsize; skipping %%x\\\\n\", h.sz_cpr);\n            xi->buf += h.sz_cpr;\n        }\n        if (LC_SEGMENT==sc->cmd && sc->vmsize) {\n            Extent xo;\n            size_t mlen = xo.size = sc->filesize;\n                          xo.buf  = (void *)(reloc + sc->vmaddr);\n            Addr  addr = (Addr)xo.buf;\n            Addr haddr = sc->vmsize + addr;\n            size_t frag = addr &~ PAGE_MASK;\n            addr -= frag;\n            mlen += frag;\n\n            DPRINTF(\"    mlen=%%p  frag=%%p  addr=%%p\\\\n\", mlen, frag, addr);\n            if (0!=mlen) { // In particular, omitted for __PAGEZERO\n                size_t const mlen3 = mlen\n    #if defined(__x86_64__)  //{\n                    // Decompressor can overrun the destination by 3 bytes.  [x86 only]\n                    + (xi ? 3 : 0)\n    #endif  //}\n                    ;\n                unsigned const prot = VM_PROT_READ | VM_PROT_WRITE;\n                // MAP_FIXED: xfind_pages() reserved them, so use them!\n                unsigned const flags = MAP_FIXED | MAP_PRIVATE |\n                                ((xi || 0==sc->filesize) ? MAP_ANON    : 0);\n                int const fdm = ((xi || 0==sc->filesize) ? MAP_ANON_FD : fdi);\n                off_t_upx_stub const offset = sc->fileoff + fat_offset;\n\n                DPRINTF(\"mmap  addr=%%p  len=%%p  prot=%%x  flags=%%x  fd=%%d  off=%%p  reloc=%%p\\\\n\",\n                    addr, mlen3, prot, flags, fdm, offset, reloc);\n                {\n                    Addr maddr = (Addr)mmap((void *)addr, mlen3, prot, flags, fdm, offset, 0);\n                    DPRINTF(\"maddr=%%p\\\\n\", maddr);\n                    if (maddr != addr) {\n                        err_exit(8);\n                    }\n                    addr = maddr;\n                }\n                if (mhdrpp && !*mhdrpp) { // MH_DYLINKER\n                    *mhdrpp = (Mach_header*)addr;\n                }\n            }\n            if (xi && 0!=sc->filesize) {\n                if (0==sc->fileoff /*&& 0!=mhdrpp*/) {\n                    *mhdrpp = (Mach_header *)(void *)addr;\n                }\n                unpackExtent(xi, &xo, f_exp, f_unf);\n            }\n            DPRINTF(\"xi=%%p  mlen=%%p  fileoff=%%p  nsects=%%d\\\\n\",\n                xi, mlen, sc->fileoff, sc->nsects);\n            if (xi && mlen && !sc->fileoff && sc->nsects) {\n                // main target __TEXT segment at beginning of file with sections (__text)\n                // Use upto 2 words of header padding for the escape hatch.\n                // fold.S could do this easier, except PROT_WRITE is missing then.\n                union {\n                    unsigned char  *p0;\n                    unsigned short *p1;\n                    unsigned int   *p2;\n                    unsigned long  *p3;\n                } u;\n                u.p0 = (unsigned char *)addr;\n                Mach_segment_command *segp = (Mach_segment_command *)((((char *)sc - (char *)mhdr)>>2) + u.p2);\n                Mach_section_command *const secp = (Mach_section_command *)(1+ segp);\n                unsigned *hatch= -2+ (secp->offset>>2) + u.p2;\n                DPRINTF(\"hatch=%%p  segp=%%p  secp=%%p  secp->offset=%%p  mhdr=%%p\\\\n\", hatch, segp, secp, secp->offset, addr);\n    #if defined(__aarch64__)  //{\n                hatch[0] = 0xd4000001;  // svc #0  // syscall\n                hatch[1] = 0xd65f03c0;  // ret\n    #elif defined(__arm__)  //}{\n                hatch[0] = 0xef000000;  // svc 0x0  // syscall\n                hatch[1] = 0xe12fff1e;  // bx lr\n    #elif defined(__x86_64__)  //}{\n                hatch[0] = 0xc3050f90;  // nop; syscall; ret\n    #elif defined(__i386__)  //}{\n                hatch[0] = 0xc3050f90;  // nop; syscall; ret\n    #endif  //}\n                rv = (Addr)hatch;\n            }\n            /*bzero(addr, frag);*/  // fragment at lo end\n            frag = (-mlen) &~ PAGE_MASK;  // distance to next page boundary\n            bzero((void *)(mlen+addr), frag);  // fragment at hi end\n            if (0!=mlen && 0!=mprotect((void *)addr, mlen, sc->initprot)) {\n                err_exit(10);\n    ERR_LAB\n            }\n            addr += mlen + frag;  /* page boundary on hi end */\n            if (\n    #if SIMULATE_ON_LINUX_EABI4  /*{*/\n                0!=addr &&\n    #endif  /*}*/\n                            addr < haddr) { // need pages for .bss\n                if (0!=addr && addr != (Addr)mmap((void *)addr, haddr - addr, sc->initprot,\n                        MAP_FIXED | MAP_PRIVATE | MAP_ANON, MAP_ANON_FD, 0, 0) ) {\n                    err_exit(9);\n                }\n            }\n            else if (xi) { // cleanup if decompressor overrun crosses page boundary\n                mlen = ~PAGE_MASK & (3+ mlen);\n                if (mlen<=3) { // page fragment was overrun buffer only\n                    DPRINTF(\"munmap  %%x  %%x\\\\n\", addr, mlen);\n                    munmap((char *)addr, mlen);\n                }\n            }\n        }\n        else if (!xi  // dyld\n        && (LC_UNIXTHREAD==sc->cmd || LC_THREAD==sc->cmd)) {\n            Mach_thread_command *const thrc = (Mach_thread_command *)sc;\n            DPRINTF(\"thread_command= %%p\\\\n\", sc);\n            if (1\n            // FIXME  THREAD_STATE      ==thrc->flavor\n            //    &&  THREAD_STATE_COUNT==thrc->count\n            ) {\n                DPRINTF(\"thread_state= %%p  flavor=%%d  count=%%x  reloc=%%p\\\\n\",\n                    &thrc->state, thrc->flavor, thrc->count, reloc);\n    #if defined(__aarch64__)  //{\n                rv = reloc + thrc->state.pc;\n    #elif defined(__arm__)  //}{\n                rv = reloc + thrc->state.pc;\n    #elif defined(__x86_64__)  //}{\n                rv = reloc + thrc->state.rip;\n    #elif defined(__i386__)  //}{\n                rv = reloc + thrc->state.eip;\n    #else  //}{\n        #error do_xmap rv $ARCH\n    #endif  //}\n            }\n        }\n    }\n    DPRINTF(\"do_xmap= %%p\\\\n\", rv);\n    return rv;\n}\n\n/*************************************************************************\n// upx_main - called by our entry code\n//\n**************************************************************************/\n\nAddr\nupx_main(\n    Mach_header **const mhdrpp,  // Out: *mhdrpp= &real Mach_header\n    f_unfilter *const f_unf,\n    f_expand *const f_decompress,\n    Mach_header *const mhdr,  // temp char[sz_mhdr] for decompressing\n    size_t const sz_mhdr,\n    size_t volatile sz_compressed,  // total length\n    struct l_info const *const li\n)\n{\n    Addr entry;\n    off_t_upx_stub fat_offset = 0;\n    Extent xi, xo, xi0;\n    xi.buf  = CONST_CAST(unsigned char *, 1+ (struct p_info const *)(1+ li));  // &b_info\n    xi.size = sz_compressed - (sizeof(struct l_info) + sizeof(struct p_info));\n    xo.buf  = (unsigned char *)mhdr;\n    xo.size = ((struct b_info const *)(void const *)xi.buf)->sz_unc;\n    xi0 = xi;\n\n    DPRINTF(\"upx_main szc=%%x  f_dec=%%p  f_unf=%%p  \"\n    \"  xo=%%p(%%x %%p)  xi=%%p(%%x %%p)  mhdrpp=%%p\\\\n\",\n        sz_compressed, f_decompress, f_unf,\n        &xo, xo.size, xo.buf,\n        &xi, xi.size, xi.buf, mhdrpp);\n\n    // Uncompress Macho headers\n    unpackExtent(&xi, &xo, f_decompress, 0);  // never filtered?\n\n    entry = do_xmap(mhdr, fat_offset, &xi0, MAP_ANON_FD, mhdrpp, f_decompress, f_unf);\n\n  { // Map dyld dynamic loader\n    Mach_load_command const *lc = (Mach_load_command const *)(1+ mhdr);\n    unsigned j;\n\n    for (j=0; j < mhdr->ncmds; ++j,\n        (lc = (Mach_load_command const *)(lc->cmdsize + (void const *)lc))\n    ) if (LC_LOAD_DYLINKER==lc->cmd) {\n        char const *const dyld_name = ((Mach_lc_str const *)(1+ lc))->offset +\n            (char const *)lc;\n        int const fdi = open(dyld_name, O_RDONLY, 0);\n        if (0 > fdi) {\n            err_exit(18);\n        }\nfat:\n        if ((ssize_t)sz_mhdr!=pread(fdi, (void *)mhdr, sz_mhdr, fat_offset, 0)) {\nERR_LAB\n            err_exit(19);\n        }\n        switch (mhdr->magic) {\n        case MH_MAGIC: break;\n        case MH_MAGIC64: break;\n        case FAT_CIGAM:\n        case FAT_MAGIC: {\n            // stupid Apple: waste code and a page fault on EVERY execve\n            Fat_header *const fh = (Fat_header *)mhdr;\n            Fat_arch *fa = (Fat_arch *)(1+ fh);\n            bswap(fh, sizeof(*fh) + (fh->nfat_arch>>24)*sizeof(*fa));\n            for (j= 0; j < fh->nfat_arch; ++j, ++fa) {\n                if (CPU_TYPE_I386==fa->cputype) {\n                    fat_offset= fa->offset;\n                    goto fat;\n                }\n            }\n        } break;\n        } // switch\n        entry = do_xmap(mhdr, fat_offset, 0, fdi, 0, 0, 0);\n        close(fdi);\n        break;\n    }\n  }\n\n    return entry;\n}\n\n/* vim:set ts=4 sw=4 et: */\n","size_bytes":25695},"src/stub/src/i386-darwin.macho-upxmain.c":{"content":"/* i386-darwin.macho-upxmain.c -- loader hack for Mach-o i386\n\n   This file is part of the UPX executable compressor.\n\n   Copyright (C) 1996-2025 Markus Franz Xaver Johannes Oberhumer\n   Copyright (C) 1996-2025 Laszlo Molnar\n   Copyright (C) 2000-2025 John F. Reiser\n   All Rights Reserved.\n\n   UPX and the UCL library are free software; you can redistribute them\n   and/or modify them under the terms of the GNU General Public License as\n   published by the Free Software Foundation; either version 2 of\n   the License, or (at your option) any later version.\n\n   This program is distributed in the hope that it will be useful,\n   but WITHOUT ANY WARRANTY; without even the implied warranty of\n   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n   GNU General Public License for more details.\n\n   You should have received a copy of the GNU General Public License\n   along with this program; see the file COPYING.\n   If not, write to the Free Software Foundation, Inc.,\n   59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.\n\n   Markus F.X.J. Oberhumer              Laszlo Molnar\n   <markus@oberhumer.com>               <ml1050@users.sourceforge.net>\n\n   John F. Reiser\n   <jreiser@users.sourceforge.net>\n */\n\n#define __WORDSIZE 32\n#include <stdio.h>\n#include <stdlib.h>\n#include \"include/darwin.h\"\n\n#ifndef DEBUG  /*{*/\n#define DEBUG 0\n#endif  /*}*/\n\n/*************************************************************************\n// configuration section\n**************************************************************************/\n\n// In order to make it much easier to move this code at runtime and execute\n// it at an address different from it load address:  there must be no\n// static data, and no string constants.\n\n#if !DEBUG  /*{*/\n#define DPRINTF(a) /* empty: no debug drivel */\n#define DEBUG_STRCON(name, value) /* empty */\n#else  /*}{ DEBUG */\nextern int write(int, void const *, size_t);\n#if 0\n#include \"stdarg.h\"\n#else\n#define va_arg      __builtin_va_arg\n#define va_end      __builtin_va_end\n#define va_list     __builtin_va_list\n#define va_start    __builtin_va_start\n#endif\n\n#if defined(__i386__) || defined(__x86_64__) /*{*/\n#define PIC_STRING(value, var) \\\n    __asm__ __volatile__ ( \\\n        \"call 0f; .asciz \\\"\" value \"\\\"; \\\n      0: pop %0;\" : \"=r\"(var) : \\\n    )\n#elif defined(__arm__)  /*}{*/\n#define PIC_STRING(value, var) \\\n    __asm__ __volatile__ ( \\\n        \"mov %0,pc; b 0f; \\\n        .asciz \\\"\" value \"\\\"; .balign 4; \\\n      0: \" : \"=r\"(var) \\\n    )\n#elif defined(__mips__)  /*}{*/\n#define PIC_STRING(value, var) \\\n    __asm__ __volatile__ ( \\\n        \".set noreorder; bal 0f; move %0,$31; .set reorder; \\\n        .asciz \\\"\" value \"\\\"; .balign 4; \\\n      0: \" \\\n        : \"=r\"(var) : : \"ra\" \\\n    )\n#endif  /*}*/\n\n\n#define DEBUG_STRCON(name, strcon) \\\n    static char const *name(void) { \\\n        register char const *rv; PIC_STRING(strcon, rv); \\\n        return rv; \\\n    }\n\n\n#ifdef __arm__  /*{*/\nextern unsigned div10(unsigned);\n#else  /*}{*/\nstatic unsigned\ndiv10(unsigned x)\n{\n    return x / 10u;\n}\n#endif  /*}*/\n\nstatic int\nunsimal(unsigned x, char *ptr, int n)\n{\n    if (10<=x) {\n        unsigned const q = div10(x);\n        x -= 10 * q;\n        n = unsimal(q, ptr, n);\n    }\n    ptr[n] = '0' + x;\n    return 1+ n;\n}\n\nstatic int\ndecimal(int x, char *ptr, int n)\n{\n    if (x < 0) {\n        x = -x;\n        ptr[n++] = '-';\n    }\n    return unsimal(x, ptr, n);\n}\n\nDEBUG_STRCON(STR_hex, \"0123456789abcdef\");\n\nstatic int\nheximal(unsigned long x, char *ptr, int n)\n{\n    if (16<=x) {\n        n = heximal(x>>4, ptr, n);\n        x &= 0xf;\n    }\n    ptr[n] = STR_hex()[x];\n    return 1+ n;\n}\n\n\n#define DPRINTF(a) my_printf a\n\nstatic int\nmy_printf(char const *fmt, ...)\n{\n    char c;\n    int n= 0;\n    char *ptr;\n    char buf[20];\n    va_list va; va_start(va, fmt);\n    ptr= &buf[0];\n    while (0!=(c= *fmt++)) if ('%'!=c) goto literal;\n    else switch (c= *fmt++) {\n    default: {\nliteral:\n        n+= write(2, fmt-1, 1);\n    } break;\n    case 0: goto done;  /* early */\n    case 'u': {\n        n+= write(2, buf, unsimal(va_arg(va, unsigned), buf, 0));\n    } break;\n    case 'd': {\n        n+= write(2, buf, decimal(va_arg(va, int), buf, 0));\n    } break;\n    case 'p': {\n        buf[0] = '0';\n        buf[1] = 'x';\n        n+= write(2, buf, heximal((unsigned long)va_arg(va, void *), buf, 2));\n    } break;\n    case 'x': {\n        buf[0] = '0';\n        buf[1] = 'x';\n        n+= write(2, buf, heximal(va_arg(va, int), buf, 2));\n    } break;\n    }\ndone:\n    va_end(va);\n    return n;\n}\n#endif  /*}*/\n\n\n/*************************************************************************\n// \"file\" util\n**************************************************************************/\n\ntypedef struct {\n    size_t size;  // must be first to match size[0] uncompressed size\n    void *buf;\n} Extent;\n\nDEBUG_STRCON(STR_xread, \"xread %%p(%%x %%p) %%p %%x\\\\n\")\nDEBUG_STRCON(STR_xreadfail, \"xreadfail %%p(%%x %%p) %%p %%x\\\\n\")\n\nstatic void\nxread(Extent *x, void *buf, size_t count)\n{\n    unsigned char *p=x->buf, *q=buf;\n    size_t j;\n    DPRINTF((STR_xread(), x, x->size, x->buf, buf, count));\n    if (x->size < count) {\n        DPRINTF((STR_xreadfail(), x, x->size, x->buf, buf, count));\n        exit(127);\n    }\n    for (j = count; 0!=j--; ++p, ++q) {\n        *q = *p;\n    }\n    x->buf  += count;\n    x->size -= count;\n}\n\n\n/*************************************************************************\n// util\n**************************************************************************/\n\n#if 1  //{  save space\n#define ERR_LAB error: exit(127);\n#define err_exit(a) goto error\n#else  //}{  save debugging time\n#define ERR_LAB /*empty*/\nDEBUG_STRCON(STR_exit, \"err_exit %%x\\\\n\");\n\nstatic void\nerr_exit(int a)\n{\n    DPRINTF((STR_exit(), a));\n    (void)a;  // debugging convenience\n    exit(127);\n}\n#endif  //}\n\n\n/*************************************************************************\n// UPX & NRV stuff\n**************************************************************************/\n\nstruct l_info { // 12-byte trailer for loader (after macho headers)\n    unsigned l_checksum;\n    unsigned l_magic;  // UPX_MAGIC_LE32\n    unsigned short l_lsize;\n    unsigned char l_version;\n    unsigned char l_format;\n};\nstruct p_info { // 12-byte packed program header\n    unsigned p_progid;\n    unsigned p_filesize;\n    unsigned p_blocksize;\n};\n\nstruct b_info { // 12-byte header before each compressed block\n    unsigned sz_unc;  // uncompressed_size\n    unsigned sz_cpr;  //   compressed_size\n    unsigned char b_method;  // compression algorithm\n    unsigned char b_ftid;  // filter id\n    unsigned char b_cto8;  // filter parameter\n    unsigned char b_unused;\n};\n\ntypedef void f_unfilter(\n    nrv_byte *,  // also addvalue\n    nrv_uint,\n    unsigned cto8, // junk in high 24 bits\n    unsigned ftid\n);\ntypedef int f_expand(\n    const nrv_byte *, nrv_uint,\n          nrv_byte *, nrv_uint *, unsigned );\n\nDEBUG_STRCON(STR_unpackExtent,\n        \"unpackExtent in=%%p(%%x %%p)  out=%%p(%%x %%p)  %%p %%p\\\\n\");\nDEBUG_STRCON(STR_err5, \"sz_cpr=%%x  sz_unc=%%x  xo->size=%%x\\\\n\");\n\nstatic void\nunpackExtent(\n    Extent *const xi,  // input\n    Extent *const xo,  // output\n    f_expand *const f_decompress,\n    f_unfilter *f_unf\n)\n{\n    DPRINTF((STR_unpackExtent(),\n        xi, xi->size, xi->buf, xo, xo->size, xo->buf, f_decompress, f_unf));\n    while (xo->size) {\n        struct b_info h;\n        //   Note: if h.sz_unc == h.sz_cpr then the block was not\n        //   compressible and is stored in its uncompressed form.\n\n        // Read and check block sizes.\n        xread(xi, (unsigned char *)&h, sizeof(h));\n        if (h.sz_unc == 0) {                     // uncompressed size 0 -> EOF\n            if (h.sz_cpr != UPX_MAGIC_LE32)      // h.sz_cpr must be h->magic\n                err_exit(2);\n            if (xi->size != 0)                 // all bytes must be written\n                err_exit(3);\n            break;\n        }\n        if (h.sz_cpr <= 0) {\n            err_exit(4);\nERR_LAB\n        }\n        if (h.sz_cpr > h.sz_unc\n        ||  h.sz_unc > xo->size ) {\n            DPRINTF((STR_err5(), h.sz_cpr, h.sz_unc, xo->size));\n            err_exit(5);\n        }\n        // Now we have:\n        //   assert(h.sz_cpr <= h.sz_unc);\n        //   assert(h.sz_unc > 0 && h.sz_unc <= blocksize);\n        //   assert(h.sz_cpr > 0 && h.sz_cpr <= blocksize);\n\n        if (h.sz_cpr < h.sz_unc) { // Decompress block\n            nrv_uint out_len = h.sz_unc;  // EOF for lzma\n            int const j = (*f_decompress)(xi->buf, h.sz_cpr,\n                xo->buf, &out_len, h.b_method);\n            if (j != 0 || out_len != (nrv_uint)h.sz_unc)\n                err_exit(7);\n            if (h.b_ftid!=0 && f_unf) {  // have filter\n                (*f_unf)(xo->buf, out_len, h.b_cto8, h.b_ftid);\n            }\n            xi->buf  += h.sz_cpr;\n            xi->size -= h.sz_cpr;\n        }\n        else { // copy literal block\n            xi->size += sizeof(h);  // xread(xi, &h, sizeof(h)) was a peek\n            xread(xi, xo->buf, h.sz_cpr);\n        }\n        xo->buf  += h.sz_unc;\n        xo->size -= h.sz_unc;\n    }\n}\n\nstatic void\nupx_bzero(unsigned char *p, size_t len)\n{\n    if (len) do {\n        *p++= 0;\n    } while (--len);\n}\n#define bzero upx_bzero\n\n\n// The PF_* and PROT_* bits are {1,2,4}; the conversion table fits in 32 bits.\n#define REP8(x) \\\n    ((x)|((x)<<4)|((x)<<8)|((x)<<12)|((x)<<16)|((x)<<20)|((x)<<24)|((x)<<28))\n#define EXP8(y) \\\n    ((1&(y)) ? 0xf0f0f0f0 : (2&(y)) ? 0xff00ff00 : (4&(y)) ? 0xffff0000 : 0)\n#define PF_TO_PROT(pf) \\\n    ((PROT_READ|PROT_WRITE|PROT_EXEC) & ( \\\n        ( (REP8(PROT_EXEC ) & EXP8(PF_X)) \\\n         |(REP8(PROT_READ ) & EXP8(PF_R)) \\\n         |(REP8(PROT_WRITE) & EXP8(PF_W)) \\\n        ) >> ((pf & (PF_R|PF_W|PF_X))<<2) ))\n\ntypedef struct {\n    unsigned magic;\n    unsigned nfat_arch;\n} Fat_header;\ntypedef struct {\n    unsigned cputype;\n    unsigned cpusubtype;\n    unsigned offset;\n    unsigned size;\n    unsigned align;  /* shift count (log base 2) */\n} Fat_arch;\n    enum e8 {\n        FAT_MAGIC = 0xcafebabe,\n        FAT_CIGAM = 0xbebafeca\n    };\n    enum e9 {\n        CPU_TYPE_I386      =          7,\n        CPU_TYPE_AMD64     = 0x01000007,\n        CPU_TYPE_ARM       =         12,\n        CPU_TYPE_POWERPC   = 0x00000012,\n        CPU_TYPE_POWERPC64 = 0x01000012\n    };\n\ntypedef struct {\n    unsigned magic;\n    unsigned cputype;\n    unsigned cpysubtype;\n    unsigned filetype;\n    unsigned ncmds;\n    unsigned sizeofcmds;\n    unsigned flags;\n} Mach_header;\n        enum e0 {\n            MH_MAGIC   =   0xfeedface,\n            MH_MAGIC64 = 1+0xfeedface\n        };\n        enum e2 {\n            MH_EXECUTE = 2\n        };\n        enum e3 {\n            MH_NOUNDEFS = 1\n        };\n\ntypedef struct {\n    unsigned cmd;\n    unsigned cmdsize;\n} Mach_load_command;\n        enum e4 {\n            LC_REQ_DYLD      = 0x80000000,  // OR'ed ==> must not ignore\n            LC_SEGMENT       = 0x1,\n            LC_SEGMENT_64    = 0x19,\n            LC_THREAD        = 0x4,\n            LC_UNIXTHREAD    = 0x5,\n            LC_LOAD_DYLINKER = 0xe,\n            LC_MAIN          = (0x28|LC_REQ_DYLD)\n        };\n\ntypedef struct {\n    unsigned cmd;\n    unsigned cmdsize;\n    char segname[16];\n    uint32_t vmaddr;\n    uint32_t vmsize;\n    uint32_t fileoff;\n    uint32_t filesize;\n    unsigned maxprot;\n    unsigned initprot;\n    unsigned nsects;\n    unsigned flags;\n} Mach_segment_command;\n        enum e5 {\n            VM_PROT_READ = 1,\n            VM_PROT_WRITE = 2,\n            VM_PROT_EXECUTE = 4\n        };\n\ntypedef struct {\n    char sectname[16];\n    char segname[16];\n    uint32_t addr;   /* memory address */\n    uint32_t size;   /* size in bytes */\n    unsigned offset; /* file offset */\n    unsigned align;  /* power of 2 */\n    unsigned reloff; /* file offset of relocation entries */\n    unsigned nreloc; /* number of relocation entries */\n    unsigned flags;  /* section type and attributes */\n    unsigned reserved1;  /* for offset or index */\n    unsigned reserved2;  /* for count or sizeof */\n} Mach_section_command;\n\ntypedef struct {\n    uint32_t cmd;  // LC_MAIN;  MH_EXECUTE only\n    uint32_t cmdsize;  // 24\n    uint64_t entryoff;  // file offset of main() [expected in __TEXT]\n    uint64_t stacksize;  // non-default initial stack size\n} Mach_main_command;\n\ntypedef struct {\n    uint32_t eax, ebx, ecx, edx;\n    uint32_t edi, esi, ebp;\n    uint32_t esp, ss;\n    uint32_t eflags;\n    uint32_t eip, cs;\n    uint32_t ds,es,fs,gs;\n} Mach_i386_thread_state;\n\ntypedef struct {\n    unsigned cmd;            /* LC_THREAD or  LC_UNIXTHREAD */\n    unsigned cmdsize;        /* total size of this command */\n    unsigned flavor;\n    unsigned count;          /* sizeof(following_thread_state)/4 */\n    Mach_i386_thread_state state;\n} Mach_thread_command;\n        enum e6 {\n            x86_THREAD_STATE32 = 1\n        };\n        enum e7 {\n            i386_THREAD_STATE_COUNT = sizeof(Mach_i386_thread_state)/4\n        };\n\ntypedef union {\n    unsigned offset;  /* from start of load command to string */\n} Mach_lc_str;\n\n#define MAP_FIXED     0x10\n#define MAP_PRIVATE   0x02\n#define MAP_ANON    0x1000\n//#define MAP_ANON  0x20  // x86 DEBUG ONLY\n#define PROT_READ      1\n#define PROT_WRITE     2\n#define PROT_EXEC      4\n#define MAP_ANON_FD    -1\n#define MAP_FAILED ((void *) -1)\n\nextern void *mmap(void *, size_t, unsigned, unsigned, int, off_t);\nssize_t pread(int, void *, size_t, off_t);\nextern void bswap(void *, unsigned);\n\nDEBUG_STRCON(STR_mmap,\n    \"mmap  addr=%%p  len=%%p  prot=%%x  flags=%%x  fd=%%d  off=%%p\\\\n\");\nDEBUG_STRCON(STR_do_xmap,\n    \"do_xmap  fdi=%%x  mhdr=%%p  xi=%%p(%%x %%p) f_unf=%%p\\\\n\")\n\nstatic uint32_t  // entry address\ndo_xmap(\n    Mach_header const *const mhdr,\n    off_t const fat_offset,\n    Extent *const xi,\n    int const fdi,\n    Mach_header **mhdrpp,\n    f_expand *const f_decompress,\n    f_unfilter *const f_unf\n)\n{\n    Mach_segment_command const *sc = (Mach_segment_command const *)(1+ mhdr);\n    Mach_segment_command const *segTEXT = 0;\n    uint32_t entry = 0;\n    unsigned long base = 0;\n    unsigned j;\n\n    DPRINTF((STR_do_xmap(),\n        fdi, mhdr, xi, (xi? xi->size: 0), (xi? xi->buf: 0), f_unf));\n\n    for ( j=0; j < mhdr->ncmds; ++j,\n        (sc = (Mach_segment_command const *)(sc->cmdsize + (void const *)sc))\n    ) if (LC_SEGMENT==sc->cmd && sc->vmsize!=0) {\n        Extent xo;\n        size_t mlen = xo.size = sc->filesize;\n        unsigned char  *addr = xo.buf  = base + (unsigned char *)sc->vmaddr;\n        unsigned char *haddr =     sc->vmsize +                        addr;\n        size_t frag = (int)(uint32_t)addr &~ PAGE_MASK;\n        addr -= frag;\n        mlen += frag;\n\n        if (0!=mlen) { // In particular, omitted for __PAGEZERO\n            // Decompressor can overrun the destination by 3 bytes.  [x86 only]\n            size_t const mlen3 = mlen + (xi ? 3 : 0);\n            unsigned const prot = VM_PROT_READ | VM_PROT_WRITE;\n            unsigned const flags = (addr ? MAP_FIXED : 0) | MAP_PRIVATE |\n                        ((xi || 0==sc->filesize) ? MAP_ANON : 0);\n            int const fdm = ((0==sc->filesize) ? MAP_ANON_FD : fdi);\n            off_t const offset = sc->fileoff + fat_offset;\n\n            DPRINTF((STR_mmap(),       addr, mlen3, prot, flags, fdm, offset));\n            unsigned char *mapa = mmap(addr, mlen3, prot, flags, fdm, offset);\n            if (MAP_FAILED == mapa) {\n                err_exit(8);\n            }\n            if (0 == addr) { // dyld auto-relocate\n                base = (unsigned long)mapa;  // relocation constant\n            }\n            addr = mapa;\n        }\n        if (xi && 0!=sc->filesize) {\n            if (0==sc->fileoff /*&& 0!=mhdrpp*/) {\n                segTEXT = sc;\n                *mhdrpp = (Mach_header *)(void *)addr;\n            }\n            unpackExtent(xi, &xo, f_decompress, f_unf);\n        }\n        /*bzero(addr, frag);*/  // fragment at lo end\n        frag = (-mlen) &~ PAGE_MASK;  // distance to next page boundary\n        bzero(mlen+addr, frag);  // fragment at hi end\n        if (0!=mlen && 0!=mprotect(addr, mlen, sc->initprot)) {\n            err_exit(10);\nERR_LAB\n        }\n        addr += mlen + frag;  /* page boundary on hi end */\n        if (\n#if defined(SIMULATE_ON_LINUX_EABI4)  /*{*/\n            0!=addr &&\n#endif  /*}*/\n                        addr < haddr) { // need pages for .bss\n            if (0!=addr && addr != mmap(addr, haddr - addr, sc->initprot,\n                    MAP_FIXED | MAP_PRIVATE | MAP_ANON, MAP_ANON_FD, 0 ) ) {\n                err_exit(9);\n            }\n        }\n        else if (xi) { // cleanup if decompressor overrun crosses page boundary\n            mlen = ~PAGE_MASK & (3+ mlen);\n            if (mlen<=3) { // page fragment was overrun buffer only\n                munmap((char *)addr, mlen);\n            }\n        }\n    }\n    else if (LC_UNIXTHREAD==sc->cmd || LC_THREAD==sc->cmd) {\n        Mach_thread_command const *const thrc = (Mach_thread_command const *)sc;\n        if (x86_THREAD_STATE32      ==thrc->flavor\n        &&  i386_THREAD_STATE_COUNT ==thrc->count ) {\n            entry = thrc->state.eip + base;  // JMP\n        }\n    }\n    else if (LC_MAIN==sc->cmd) {\n        entry = ((Mach_main_command const *)sc)->entryoff;\n        if (segTEXT->fileoff <= entry && entry < segTEXT->filesize) {\n            entry += segTEXT->vmaddr;  // CALL\n        }\n        // XXX FIXME TODO: if entry not in segTEXT?\n        // XXX FIXME TODO: LC_MAIN is a CALL; LC_*THREAD is a JMP\n    }\n    return entry;\n}\n\nstatic off_t\nfat_find(Fat_header *fh) // *fh suffers bswap()\n{\n    Fat_arch *fa = (Fat_arch *)(1+ fh);\n    bswap(fh, sizeof(*fh) + (fh->nfat_arch>>24)*sizeof(*fa));\n    unsigned j;\n    for (j= 0; j < fh->nfat_arch; ++j, ++fa) {\n        if (CPU_TYPE_I386==fa->cputype) {\n            return fa->offset;  // should not be 0 because of header\n        }\n    }\n    return 0;\n}\n\n/*************************************************************************\n// upx_main - called by our entry code\n//\n**************************************************************************/\n\nDEBUG_STRCON(STR_upx_main,\n    \"upx_main szc=%%x  f_dec=%%p  f_unf=%%p  \"\n    \"  xo=%%p(%%x %%p)  xi=%%p(%%x %%p)  mhdrpp=%%p\\\\n\")\n\nuint32_t // entry address\nupx_main(\n    struct l_info const *const li,\n    size_t volatile sz_compressed,  // total length\n    Mach_header *const mhdr,  // temp char[sz_mhdr] for decompressing\n    size_t const sz_mhdr,\n    f_expand *const f_decompress,\n    f_unfilter *const f_unf,\n    Mach_header **const mhdrpp  // Out: *mhdrpp= &real Mach_header\n)\n{\n    uint32_t entry;\n    off_t fat_offset = 0;\n    Extent xi, xo, xi0;\n    xi.buf  = CONST_CAST(unsigned char *, 1+ (struct p_info const *)(1+ li));  // &b_info\n    xi.size = sz_compressed - (sizeof(struct l_info) + sizeof(struct p_info));\n    xo.buf  = (unsigned char *)mhdr;\n    xo.size = ((struct b_info const *)(void const *)xi.buf)->sz_unc;\n    xi0 = xi;\n\n    DPRINTF((STR_upx_main(),\n        sz_compressed, f_decompress, f_unf, &xo, xo.size, xo.buf,\n        &xi, xi.size, xi.buf, mhdrpp));\n\n    // Uncompress Macho headers\n    unpackExtent(&xi, &xo, f_decompress, 0);  // never filtered?\n\n    entry = do_xmap(mhdr, fat_offset, &xi0, MAP_ANON_FD, mhdrpp, f_decompress, f_unf);\n\n  { // Map dyld dynamic loader\n    Mach_load_command const *lc = (Mach_load_command const *)(1+ mhdr);\n    unsigned j;\n\n    for (j=0; j < mhdr->ncmds; ++j,\n        (lc = (Mach_load_command const *)(lc->cmdsize + (void const *)lc))\n    ) if (LC_LOAD_DYLINKER==lc->cmd) {\n        char const *const dyld_name = ((Mach_lc_str const *)(1+ lc))->offset +\n            (char const *)lc;\n        int const fdi = open(dyld_name, O_RDONLY, 0);\n        if (0 > fdi) {\n            err_exit(18);\n        }\n        for (;;) { // possibly 2 times for 'fat' binary\n            if (sz_mhdr!=pread(fdi, (void *)mhdr, sz_mhdr, fat_offset)) {\nERR_LAB\n                err_exit(19);\n            }\n            switch (mhdr->magic) {\n            case MH_MAGIC: break;  // i686 on x86_64 ?\n            case MH_MAGIC64: break;\n\n            case FAT_CIGAM:\n            case FAT_MAGIC: {\n                // stupid Apple: waste code and a page fault on EVERY execve\n                fat_offset = fat_find((Fat_header *)mhdr);\n                if (fat_offset) {\n                    continue;  // the 'for' loop\n                }\n                err_exit(20);  // no other choice\n            } break;\n            } // switch\n            break;\n        }\n        entry = do_xmap(mhdr, fat_offset, 0, fdi, 0, 0, 0);\n        close(fdi);\n        break;\n    }\n  }\n\n    return entry;\n}\n\ntypedef struct {\n    uint32_t cmd;\n    uint32_t cmdsize;\n    uint32_t data[2];  // because cmdsize >= 16\n} Mach_command;  // generic prefix\n\n//\n// Build on Mac OS X: (where gcc is really clang)\n// gcc -o i386-darwin.macho-upxmain.exe \\\n//    -Os -fPIC -fno-stack-protector \\\n//    i386-darwin.macho-upxmain.c \\\n//    i386-darwin.macho-upxsubr.S \\\n//    -Wl,-pagezero_size,0x1000 \\\n//    -Wl,-no_pie \\\n//    -Wl,-no_uuid \\\n//    -Wl,-no_function_starts \\\n//    -Wl,-bind_at_load \\\n//    -Wl,-headerpad,0x400 \\\n//\n//#    -Wl,-unexported_symbols_list unexport-upxload.txt \\\n//# strip -u -r i386-darwin.macho-upxmain.exe\n\n// Makefile:\n//# Compile i386-darwin.macho-upxmain.c on MacOS 10.9 (Mavericks) or later,\n//# to get smaller code.  Then copy i386-darwin.macho-upxmain.o to MacOS 10.6.x,\n//# and static link, to get runtime conventions straight [??]\n//#\\tgcc -m32 -c -I $PWD \\\n//#\\t    -Os -fPIC -fno-stack-protector -fno-unwind-tables \\\n//#\\t    i386-darwin.macho-upxmain.c\n//\n//i386-darwin.macho-upxmain.exe: Makefile\n//i386-darwin.macho-upxmain.exe: start.S\n//i386-darwin.macho-upxmain.exe: i386-darwin.macho-upxsubr.S\n//i386-darwin.macho-upxmain.exe: i386-darwin.macho-upxmain.o\n//\\tgcc -c start.S i386-darwin.macho-upxsubr.S\n//\\tgcc -o $@ -I $PWD \\\n//\\t    -O -nostartfiles -fno-stack-protector -fno-unwind-tables \\\n//\\t    start.o \\\n//\\t    i386-darwin.macho-upxmain.o \\\n//\\t    i386-darwin.macho-upxsubr.o \\\n//\\t    -Wl,-pagezero_size,0x1000 \\\n//\\t    -Wl,-no_uuid \\\n//\\t    -Wl,-bind_at_load \\\n//\\t    -Wl,-headerpad,0x400\n//\\tstrip -u -r -S -x $@\n//\\totool -hl $@ >upxmain-new.otool\n\n// History: Originally this file i386-darwin.macho-upxmain.c was the entry point\n// of the compressed program.  The output i386-darwin.macho-upxmain.exe was used\n// as a prototype for LC_* commands.  The start address was in LC_UNIXTHREAD.\n// The decompressor upx_main() i386-darwin.macho-main.c itself was not compressed.\n//\n// Then MacOS 10.7 (\"Lion\") supported 64-bit x86_64, and things began to change.\n// The start address (for anything except the dynamic linker) is in LC_MAIN.\n// We still use LC_UNIXTHREAD because we are \"dynamic linker\".\n// Because no program on MacOS uses brk(0), then the compressed program and stub\n// could above the space for un-compressed program, saving a copy-and-relocate.\n// The run-time decompression could be more like on Linux, using: macho-entry.S,\n// macho-fold.S, macho-main.c\n\nint\nmain(int argc, char *argv[])\n{\n    // Entry via JMP (with no parameters) instead of CALL\n    asm(\"movl 1*4(%%ebp),%0; lea 2*4(%%ebp),%1\" : \"=r\" (argc), \"=r\" (argv) : );\n\n    Mach_header const *mhdr0 = (Mach_header const *)((~0ul<<12) & (unsigned long)&main);\n    Mach_command const *ptr = (Mach_command const *)(1+ mhdr0);\n    f_unfilter *f_unf;\n    f_expand *f_exp;\n    char *payload;\n    size_t paysize;\n\n    unsigned j;\n    for (j=0; j < mhdr0->ncmds; ++j,\n            ptr = (Mach_command const *)(ptr->cmdsize + (char const *)ptr))\n    if (LC_SEGMENT==ptr->cmd) {\n        Mach_segment_command const *const seg = (Mach_segment_command const *)ptr;\n        // Compare 8 characters\n        if (*(uint64_t const *)(&\"__LINKEDIT\"[2]) == *(uint64_t const *)(&seg->segname[2])) {\n            f_unf = (f_unfilter *)(sizeof(unsigned short)             + seg->vmaddr);\n            f_exp = (f_expand *)(*(unsigned short const *)seg->vmaddr + seg->vmaddr);\n            unsigned const *q = (unsigned const *)seg->vmaddr;\n            while (!(paysize = *--q)) /*empty*/ ;\n            payload = (char *)(-paysize + (char const *)q);\n            break;\n        }\n    }\n    char mhdr[32768];\n    uint32_t entry = upx_main((struct l_info const *)payload, paysize,\n        (Mach_header *)mhdr, sizeof(mhdr),\n        f_exp, f_unf, (Mach_header **)&argv[-2]);\n\n    munmap(payload, paysize);  // leaving __LINKEDIT\n    argv[-1] = (char *)(long)argc;\n    asm(\"lea -2*4(%1),%%esp; jmp *%0\" : : \"r\" (entry), \"r\" (argv));\n    return 0;\n}\n\n/* vim:set ts=4 sw=4 et: */\n","size_bytes":24545},"src/stub/src/i386-linux.elf-main.c":{"content":"/* i386-linux.elf-main.c -- stub loader for Linux x86 ELF executable\n\n   This file is part of the UPX executable compressor.\n\n   Copyright (C) 1996-2025 Markus Franz Xaver Johannes Oberhumer\n   Copyright (C) 1996-2025 Laszlo Molnar\n   Copyright (C) 2000-2025 John F. Reiser\n   All Rights Reserved.\n\n   UPX and the UCL library are free software; you can redistribute them\n   and/or modify them under the terms of the GNU General Public License as\n   published by the Free Software Foundation; either version 2 of\n   the License, or (at your option) any later version.\n\n   This program is distributed in the hope that it will be useful,\n   but WITHOUT ANY WARRANTY; without even the implied warranty of\n   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n   GNU General Public License for more details.\n\n   You should have received a copy of the GNU General Public License\n   along with this program; see the file COPYING.\n   If not, write to the Free Software Foundation, Inc.,\n   59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.\n\n   Markus F.X.J. Oberhumer              Laszlo Molnar\n   <markus@oberhumer.com>               <ezerotven+github@gmail.com>\n\n   John F. Reiser\n   <jreiser@users.sourceforge.net>\n */\n\n#ifndef DEBUG  /*{*/\n#define DEBUG 0\n#endif  /*}*/\n\n#include \"include/linux.h\"\n// Pprotect is mprotect, but page-aligned on the lo end (Linux requirement)\nunsigned Pprotect(void *, size_t, unsigned);\n#if defined(__mips__)  //{\n  #define Pprotect mprotect\n#endif  //}\nvoid *mmap(void *, size_t, int, int, int, off_t);\n#if defined(__i386__) || defined(__mips__) || defined(__powerpc__) //{\n#  define mmap_privanon(addr,len,prot,flgs) mmap((addr),(len),(prot), \\\n        MAP_PRIVATE|MAP_ANONYMOUS|(flgs),-1,0)\n#else  //}{\n  void *mmap_privanon(void *, size_t, int, int);\n#endif  //}\nssize_t write(int, void const *, size_t);\n\n\n/*************************************************************************\n// configuration section\n**************************************************************************/\n\n// In order to make it much easier to move this code at runtime and execute\n// it at an address different from it load address:  there must be no\n// static data, and no string constants.\n\n#if !DEBUG //{\n#define DPRINTF(fmt, args...) /*empty*/\n#else  //}{\n// DPRINTF is defined as an expression using \"({ ... })\"\n// so that DPRINTF can be invoked inside an expression,\n// and then followed by a comma to ignore the return value.\n// The only complication is that percent and backslash\n// must be doubled in the format string, because the format\n// string is processed twice: once at compile-time by 'asm'\n// to produce the assembled value, and once at runtime to use it.\n#if defined(__powerpc__)  //{\n#define DPRINTF(fmt, args...) ({ \\\n    char const *r_fmt; \\\n    asm(\"bl 0f; .string \\\"\" fmt \"\\\"; .balign 4; 0: mflr %0\" \\\n/*out*/ : \"=r\"(r_fmt) \\\n/* in*/ : \\\n/*und*/ : \"lr\"); \\\n    dprintf(r_fmt, args); \\\n})\n#elif defined(__x86_64) || defined(__i386__) //}{\n#define DPRINTF(fmt, args...) ({ \\\n    char const *r_fmt; \\\n    asm(\"call 0f; .asciz \\\"\" fmt \"\\\"; 0: pop %0\" \\\n/*out*/ : \"=r\"(r_fmt) ); \\\n    dprintf(r_fmt, args); \\\n})\n#elif defined(__arm__)  /*}{*/\n#define DPRINTF(fmt, args...) ({ \\\n    char const *r_fmt; \\\n    asm(\"mov %0,pc; b 0f; \\\n        .asciz \\\"\" fmt \"\\\"; .balign 4; \\\n      0: \" \\\n/*out*/ : \"=r\"(r_fmt) ); \\\n    dprintf(r_fmt, args); \\\n})\n#elif defined(__mips__)  /*}{*/\n#define DPRINTF(fmt, args...) ({ \\\n    char const *r_fmt; \\\n    asm(\".set noreorder; bal L%=j; move %0,$31; .set reorder; \\\n        .asciz \\\"\" fmt \"\\\"; .balign 4; \\\n      L%=j: \" \\\n/*out*/ : \"=r\"(r_fmt) \\\n/* in*/ : \\\n/*und*/ : \"ra\"); \\\n    dprintf(r_fmt, args); \\\n})\n#endif  //}\n\nstatic int dprintf(char const *fmt, ...); // forward\n\n#ifdef __arm__  /*{*/\nextern unsigned div10(unsigned);\n#else  /*}{*/\nstatic unsigned\ndiv10(unsigned x)\n{\n    return x / 10u;\n}\n#endif  /*}*/\n\nstatic int\nunsimal(unsigned x, char *ptr, int n)\n{\n    if (10<=x) {\n        unsigned const q = div10(x);\n        x -= 10 * q;\n        n = unsimal(q, ptr, n);\n    }\n    ptr[n] = '0' + x;\n    return 1+ n;\n}\n\nstatic int\ndecimal(int x, char *ptr, int n)\n{\n    if (x < 0) {\n        x = -x;\n        ptr[n++] = '-';\n    }\n    return unsimal(x, ptr, n);\n}\n\nstatic int\nheximal(unsigned long x, char *ptr, int n)\n{\n    unsigned j = -1+ 2*sizeof(unsigned long);\n    unsigned long m = 0xful << (4 * j);\n    for (; j; --j, m >>= 4) { // omit leading 0 digits\n        if (m & x) break;\n    }\n    for (; m; --j, m >>= 4) {\n        unsigned d = 0xf & (x >> (4 * j));\n        ptr[n++] = ((10<=d) ? ('a' - 10) : '0') + d;\n    }\n    return n;\n}\n\n#define va_arg      __builtin_va_arg\n#define va_end      __builtin_va_end\n#define va_list     __builtin_va_list\n#define va_start    __builtin_va_start\n\nstatic int\ndprintf(char const *fmt, ...)\n{\n    int n= 0;\n    char const *literal = 0;  // NULL\n    char buf[24];  // ~0ull == 18446744073709551615 ==> 20 chars\n    va_list va; va_start(va, fmt);\n    for (;;) {\n        char c = *fmt++;\n        if (!c) { // end of fmt\n            if (literal) {\n                goto finish;\n            }\n            break;  // goto done\n        }\n        if ('%'!=c) {\n            if (!literal) {\n                literal = fmt;  // 1 beyond start of literal\n            }\n            continue;\n        }\n        // '%' == c\n        if (literal) {\nfinish:\n            n += write(2, -1+ literal, fmt - literal);\n            literal = 0;  // NULL\n            if (!c) { // fmt already ended\n               break;  // goto done\n            }\n        }\n        switch (c= *fmt++) { // deficiency: does not handle _long_\n        default: { // un-implemented conversion\n            n+= write(2, -1+ fmt, 1);\n        } break;\n        case 0: { // fmt ends with \"%\\0\" ==> ignore\n            goto done;\n        } break;\n        case 'u': {\n            n+= write(2, buf, unsimal(va_arg(va, unsigned), buf, 0));\n        } break;\n        case 'd': {\n            n+= write(2, buf, decimal(va_arg(va, int), buf, 0));\n        } break;\n        case 'p': {\n            buf[0] = '0';\n            buf[1] = 'x';\n            n+= write(2, buf, heximal((unsigned long)va_arg(va, void *), buf, 2));\n        } break;\n        case 'x': {\n            buf[0] = '0';\n            buf[1] = 'x';\n            n+= write(2, buf, heximal(va_arg(va, int), buf, 2));\n        } break;\n        } // 'switch'\n    }\ndone:\n    va_end(va);\n    return n;\n }\n#endif  /*}*/\n\n#include \"MAX_ELF_HDR.c\"\n\n/*************************************************************************\n// \"file\" util\n**************************************************************************/\n\ntypedef struct {\n    size_t size;  // must be first to match size[0] uncompressed size\n    char *buf;\n} Extent;\n\nstatic void\n#if (ACC_CC_GNUC >= 0x030300) && defined(__i386__)  /*{*/\n__attribute__((__noinline__, __used__, regparm(3), stdcall))\n#endif  /*}*/\nxread(Extent *x, char *buf, size_t count)\n{\n    char *p=x->buf, *q=buf;\n    size_t j;\n    DPRINTF(\"xread %%p(%%x %%p) %%p %%x\\\\n\", x, x->size, x->buf, buf, count);\n    if (x->size < count) {\n        exit(127);\n    }\n    for (j = count; 0!=j--; ++p, ++q) {\n        *q = *p;\n    }\n    x->buf  += count;\n    x->size -= count;\n}\n\n\n/*************************************************************************\n// util\n**************************************************************************/\n\n#if !DEBUG  //{ save space\n#define ERR_LAB error: exit(127);\n#define err_exit(a) goto error\n#else  //}{  save debugging time\n#define ERR_LAB /*empty*/\n\nextern void my_bkpt(int, ...);\n\nstatic void __attribute__ ((__noreturn__))\nerr_exit(int a)\n{\n    DPRINTF(\"err_exit %%x\\\\n\", a);\n    (void)a;  // debugging convenience\n#if defined(__powerpc__)  //{\n    my_bkpt(a);\n#endif  //}\n    exit(127);\n}\n#endif  //}\n\n/*************************************************************************\n// UPX & NRV stuff\n**************************************************************************/\n\ntypedef void f_unfilter(\n    nrv_byte *,  // also addvalue\n    nrv_uint,\n    unsigned cto8, // junk in high 24 bits\n    unsigned ftid\n);\ntypedef int f_expand(\n    const nrv_byte *, nrv_uint,\n          nrv_byte *, size_t *, unsigned );\n\n\nstatic void\nunpackExtent(\n    Extent *const xi,  // input\n    Extent *const xo,  // output\n    f_expand *const f_exp,\n    f_unfilter *f_unf\n)\n{\n    DPRINTF(\"unpackExtent in=%%p(%%x %%p)  out=%%p(%%x %%p)  %%p %%p\\\\n\",\n        xi, xi->size, xi->buf, xo, xo->size, xo->buf, f_exp, f_unf);\n    while (xo->size) {\n        struct b_info h;\n        //   Note: if h.sz_unc == h.sz_cpr then the block was not\n        //   compressible and is stored in its uncompressed form.\n\n        // Read and check block sizes.\n        xread(xi, (char *)&h, sizeof(h));\n        if (h.sz_unc == 0) {                     // uncompressed size 0 -> EOF\n            if (h.sz_cpr != UPX_MAGIC_LE32)      // h.sz_cpr must be h->magic\n                err_exit(2);\n            if (xi->size != 0)                 // all bytes must be written\n                err_exit(3);\n            break;\n        }\n        if (h.sz_cpr <= 0) {\n            err_exit(4);\nERR_LAB\n        }\n        if (h.sz_cpr > h.sz_unc\n        ||  h.sz_unc > xo->size ) {\n            DPRINTF(\"sz_cpr=%%x  sz_unc=%%x  xo->size=%%x\\\\n\", h.sz_cpr, h.sz_unc, xo->size);\n            err_exit(5);\n        }\n        // Now we have:\n        //   assert(h.sz_cpr <= h.sz_unc);\n        //   assert(h.sz_unc > 0 && h.sz_unc <= blocksize);\n        //   assert(h.sz_cpr > 0 && h.sz_cpr <= blocksize);\n\n        if (h.sz_cpr < h.sz_unc) { // Decompress block\n            size_t out_len = h.sz_unc;  // EOF for lzma\n            int const j = (*f_exp)((unsigned char *)xi->buf, h.sz_cpr,\n                (unsigned char *)xo->buf, &out_len,\n#if defined(__i386__) //{\n                *(int *)(void *)&h.b_method\n#else\n                h.b_method\n#endif\n                );\n            if (j != 0 || out_len != (nrv_uint)h.sz_unc)\n                err_exit(7);\n            // Skip Ehdr+Phdrs: separate 1st block, not filtered\n            if (h.b_ftid!=0 && f_unf  // have filter\n            &&  ((512 < out_len)  // this block is longer than Ehdr+Phdrs\n              || (xo->size==(unsigned)h.sz_unc) )  // block is last in Extent\n            ) {\n                (*f_unf)((unsigned char *)xo->buf, out_len, h.b_cto8, h.b_ftid);\n            }\n            xi->buf  += h.sz_cpr;\n            xi->size -= h.sz_cpr;\n        }\n        else { // copy literal block\n            xi->size += sizeof(h);  // xread(xi, &h, sizeof(h)) was a peek\n            xread(xi, xo->buf, h.sz_cpr);\n        }\n        xo->buf  += h.sz_unc;\n        xo->size -= h.sz_unc;\n    }\n}\n\n\n#if defined(__i386__)  /*{*/\n// Create (or find) an escape hatch to use when munmapping ourselves the stub.\n// Called by do_xmap to create it; remembered in AT_NULL.d_val\nstatic void *\nmake_hatch_x86(Elf32_Phdr const *const phdr, ptrdiff_t reloc)\n{\n    unsigned xprot = 0;\n    unsigned *hatch = 0;\n    DPRINTF(\"make_hatch %%p %%x %%x\\\\n\",phdr,reloc,0);\n    if (phdr->p_type==PT_LOAD && phdr->p_flags & PF_X) {\n        // The format of the 'if' is\n        //  if ( ( (hatch = loc1), test_loc1 )\n        //  ||   ( (hatch = loc2), test_loc2 ) ) {\n        //      action\n        //  }\n        // which uses the comma to save bytes when test_locj involves locj\n        // and the action is the same when either test succeeds.\n\n        if (\n        // Try page fragmentation just beyond .text .\n             ( (hatch = (void *)(phdr->p_memsz + phdr->p_vaddr + reloc)),\n                ( phdr->p_memsz==phdr->p_filesz  // don't pollute potential .bss\n                &&  4<=(~PAGE_MASK & -(int)hatch) ) ) // space left on page\n        // Try Elf32_Ehdr.e_ident[12..15] .  warning: 'const' cast away\n        ||   ( (hatch = (void *)(&((Elf32_Ehdr *)phdr->p_vaddr + reloc)->e_ident[12])),\n                (phdr->p_offset==0) )\n        // Allocate and use a new page.\n        ||   (  xprot = 1, hatch = mmap(0, PAGE_SIZE, PROT_WRITE|PROT_READ,\n                MAP_PRIVATE|MAP_ANONYMOUS, -1, 0) )\n        ) {\n            // Omitting 'const' saves repeated literal in gcc.\n            unsigned /*const*/ escape = 0xc36180cd;  // \"int $0x80; popa; ret\"\n            // Don't store into read-only page if value is already there.\n            if (* (volatile unsigned*) hatch != escape) {\n                * hatch  = escape;\n            }\n            if (xprot) {\n                Pprotect(hatch, 1*sizeof(unsigned), PROT_EXEC|PROT_READ);\n            }\n            DPRINTF(\" hatch at %%p\\\\n\", hatch);\n        }\n        else {\n            hatch = 0;\n        }\n    }\n    return hatch;\n}\n#elif defined(__arm__)  /*}{*/\nextern unsigned get_sys_munmap(void);\n#define NINSTR 3\n#define NBPI 4\n\nstatic void *\nmake_hatch_arm(\n    Elf32_Phdr const *const phdr,\n    ptrdiff_t reloc\n)\n{\n    unsigned const sys_munmap = get_sys_munmap();\n    unsigned xprot = 0;\n    unsigned *hatch = 0;\n    DPRINTF(\"make_hatch %%p %%x %%x\\\\n\",phdr,reloc,sys_munmap);\n    if (phdr->p_type==PT_LOAD && phdr->p_flags & PF_X) {\n        // The format of the 'if' is\n        //  if ( ( (hatch = loc1), test_loc1 )\n        //  ||   ( (hatch = loc2), test_loc2 ) ) {\n        //      action\n        //  }\n        // which uses the comma to save bytes when test_locj involves locj\n        // and the action is the same when either test succeeds.\n\n        if (\n        // Try page fragmentation just beyond .text .\n            ( (hatch = (void *)(~3u & (3+ phdr->p_memsz + phdr->p_vaddr + reloc))),\n                ( phdr->p_memsz==phdr->p_filesz  // don't pollute potential .bss\n                &&  (NINSTR * NBPI)<=(~PAGE_MASK & -(int)hatch) ) ) // space left on page\n        // Allocate and use a new page.\n        // Linux on ARM wants PROT_EXEC or else __clear_cache does not work?\n        ||   (  xprot = 1, hatch = mmap(0, PAGE_SIZE, PROT_EXEC|PROT_WRITE|PROT_READ,\n                MAP_PRIVATE|MAP_ANONYMOUS, -1, 0) )\n        ) {\n            hatch = (unsigned *)(~3ul & (3+ (unsigned long)hatch));\n            hatch[0] = sys_munmap;  // syscall __NR_unmap\n            hatch[1] = 0xe8bd0003;  // pop {r0,r1}  ABI -static parameters\n            hatch[2] = 0xe1a0f00e;  // mov pc,lr\n            __clear_cache(&hatch[0], &hatch[NINSTR]);  // ? needed before Pprotect()\n            if (xprot) {\n                Pprotect(hatch, NINSTR * NBPI, PROT_EXEC|PROT_READ);\n            }\n        }\n        else {\n            hatch = 0;\n        }\n    }\n    return hatch;\n}\n#elif defined(__mips__)  /*}{*/\nstatic void *\nmake_hatch_mips(\n    Elf32_Phdr const *const phdr,\n    ptrdiff_t reloc,\n    unsigned const frag_mask)\n{\n    unsigned xprot = 0;\n    unsigned *hatch = 0;\n    DPRINTF(\"make_hatch %%p %%x %%x\\\\n\",phdr,reloc,frag_mask);\n    if (phdr->p_type==PT_LOAD && phdr->p_flags & PF_X) {\n        if (\n        // Try page fragmentation just beyond .text .\n            ( (hatch = (void *)(phdr->p_memsz + phdr->p_vaddr + reloc)),\n                ( phdr->p_memsz==phdr->p_filesz  // don't pollute potential .bss\n                &&  (3*4)<=(frag_mask & -(int)hatch) ) ) // space left on page\n        // Allocate and use a new page.\n        ||   (  xprot = 1, hatch = mmap(0, PAGE_SIZE, PROT_WRITE|PROT_READ,\n                MAP_PRIVATE|MAP_ANONYMOUS, -1, 0) )\n        ) {\n            hatch = (unsigned *)(~3ul & (3+ (unsigned long)hatch));\n            hatch[0]= 0x0000000c;  // syscall\n#define RS(r) ((037&(r))<<21)\n#define JR 010\n            hatch[1] = RS(30)|JR;  // jr $30  # s8\n            hatch[2] = 0x00000000;  //   nop\n            if (xprot) {\n                Pprotect(hatch, 3*sizeof(unsigned), PROT_EXEC|PROT_READ);\n            }\n        }\n        else {\n            hatch = 0;\n        }\n    }\n    return hatch;\n}\n#elif defined(__powerpc__)  /*}{*/\nstatic void *\nmake_hatch_ppc32(\n    Elf32_Phdr const *const phdr,\n    ptrdiff_t reloc,\n    unsigned const frag_mask)\n{\n    unsigned xprot = 0;\n    unsigned *hatch = 0;\n    DPRINTF(\"make_hatch %%p %%x %%x\\\\n\",phdr,reloc,frag_mask);\n    if (phdr->p_type==PT_LOAD && phdr->p_flags & PF_X) {\n        if (\n        // Try page fragmentation just beyond .text .\n            ( (hatch = (void *)(phdr->p_memsz + phdr->p_vaddr + reloc)),\n                ( phdr->p_memsz==phdr->p_filesz  // don't pollute potential .bss\n                &&  (2*4)<=(frag_mask & -(int)hatch) ) ) // space left on page\n        // Try Elf32_Ehdr.e_ident[8..15] .  warning: 'const' cast away\n        ||   ( (hatch = (void *)(&((Elf32_Ehdr *)phdr->p_vaddr + reloc)->e_ident[8])),\n                (phdr->p_offset==0) )\n        // Allocate and use a new page.\n        ||   (  xprot = 1, hatch = mmap(0, PAGE_SIZE, PROT_WRITE|PROT_READ,\n                MAP_PRIVATE|MAP_ANONYMOUS, -1, 0) )\n        ) {\n            hatch = (unsigned *)(~3ul & (3+ (unsigned long)hatch));\n            hatch[0] = 0x44000002;  // sc\n            hatch[1] = 0x4e800020;  // blr\n            if (xprot) {\n                Pprotect(hatch, 2*sizeof(unsigned), PROT_EXEC|PROT_READ);\n            }\n        }\n        else {\n            hatch = 0;\n        }\n    }\n    return hatch;\n}\n#endif  /*}*/\n\nstatic void\n#if defined(__i386__)  /*{*/\n__attribute__((regparm(2), stdcall))\n#endif  /*}*/\nupx_bzero(char *p, size_t len)\n{\n    if (len) do {\n        *p++= 0;\n    } while (--len);\n}\n#define bzero upx_bzero\n\n\nstatic void\n#if defined(__i386__)  /*{*/\n__attribute__((regparm(3), stdcall))\n#endif  /*}*/\nauxv_up(Elf32_auxv_t *av, unsigned const tag, uint32_t const value)\n{\n    if (!av || (1& (size_t)av)) { // none, or inhibited for PT_INTERP\n        return;\n    }\n    DPRINTF(\"\\\\nauxv_up %%d  %%p\\\\n\", tag, value);\n    // Multiple slots can have 'tag' which wastes space but is legal.\n    // rtld (ld-linux) uses the last one, so we must scan the whole table.\n    Elf32_auxv_t *ignore_slot = 0;\n    int found = 0;\n    for (;; ++av) {\n        DPRINTF(\"  %%d  %%p\\\\n\", av->a_type, av->a_un.a_val);\n        if (av->a_type == tag) {\n            av->a_un.a_val = value;\n            ++found;\n        }\n        else if (av->a_type == AT_IGNORE) {\n            ignore_slot = av;\n        }\n        if (av->a_type==AT_NULL) { // done scanning\n            if (found) {\n                return;\n            }\n            if (ignore_slot) {\n                ignore_slot->a_type = tag;\n                ignore_slot->a_un.a_val = value;\n                return;\n            }\n            err_exit(20);\nERR_LAB\n            return;\n        }\n    }\n}\n\n// The PF_* and PROT_* bits are {1,2,4}; the conversion table fits in 32 bits.\n#define REP8(x) \\\n    ((x)|((x)<<4)|((x)<<8)|((x)<<12)|((x)<<16)|((x)<<20)|((x)<<24)|((x)<<28))\n#define EXP8(y) \\\n    ((1&(y)) ? 0xf0f0f0f0 : (2&(y)) ? 0xff00ff00 : (4&(y)) ? 0xffff0000 : 0)\n#define PF_TO_PROT(pf) \\\n    ((PROT_READ|PROT_WRITE|PROT_EXEC) & ( \\\n        ( (REP8(PROT_EXEC ) & EXP8(PF_X)) \\\n         |(REP8(PROT_READ ) & EXP8(PF_R)) \\\n         |(REP8(PROT_WRITE) & EXP8(PF_W)) \\\n        ) >> ((pf & (PF_R|PF_W|PF_X))<<2) ))\n\n\n#if defined(__powerpc__) || defined(__arm__)   //{\nextern\nsize_t get_page_mask(void);  // variable page size AT_PAGESZ; see *-fold.S\n#elif defined(__mips__)  //}{\n    // empty\n#else  //}{  // FIXME for __mips__\nsize_t get_page_mask(void) { return PAGE_MASK; }  // compile-time constant\n#endif  //}\n\n// Find convex hull of PT_LOAD (the minimal interval which covers all PT_LOAD),\n// and mmap that much, to be sure that a kernel using exec-shield-randomize\n// won't place the first piece in a way that leaves no room for the rest.\nstatic ptrdiff_t // returns relocation constant\n#if defined(__i386__)  /*{*/\n__attribute__((regparm(3), stdcall))\n#endif  /*}*/\nxfind_pages(unsigned mflags, Elf32_Phdr const *phdr, int phnum,\n    Elf32_Addr *const p_brk\n#if defined (__mips__)  //{\n    , size_t const page_mask\n#endif  //}\n)\n{\n#if !defined(__mips__)  //{\n    size_t const page_mask = get_page_mask();\n#endif  //}\n    Elf32_Addr lo= ~0, hi= 0, addr = 0;\n    DPRINTF(\"xfind_pages  %%x  %%p  %%d  %%p\\\\n\", mflags, phdr, phnum, p_brk);\n    for (; --phnum>=0; ++phdr) if (PT_LOAD==phdr->p_type\n#if defined(__arm__)  /*{*/\n                               &&  phdr->p_memsz\n// Android < 4.1 (kernel < 3.0.31) often has PT_INTERP of /system/bin/linker\n// with bad PT_LOAD[0].  https://sourceforge.net/p/upx/bugs/221\n// Type: EXEC (Executable file)\n//\n// Program Headers:\n// Type   Offset   VirtAddr   PhysAddr FileSiz MemSiz  Flg  Align\n// LOAD 0x0000d4 0x00000000 0xb0000000 0x00000 0x00000 R   0x1000\n// LOAD 0x001000 0xb0001000 0xb0001000 0x07614 0x07614 R E 0x1000\n// LOAD 0x009000 0xb0009000 0xb0009000 0x006f8 0x0ccdc RW  0x1000\n#endif  /*}*/\n                                                ) {\n        if (phdr->p_vaddr < lo) {\n            lo = phdr->p_vaddr;\n        }\n        if (hi < (phdr->p_memsz + phdr->p_vaddr)) {\n            hi =  phdr->p_memsz + phdr->p_vaddr;\n        }\n    }\n    lo -= ~page_mask & lo;  // round down to page boundary\n    hi  =  page_mask & (hi - lo - page_mask -1);  // page length\n    DPRINTF(\"  addr=%%p  lo=%%p  hi=%%p\\\\n\", addr, lo, hi);\n    addr = (Elf32_Addr)mmap_privanon((void *)lo, hi, PROT_NONE, mflags);\n    DPRINTF(\"  addr=%%p\\\\n\", addr);\n    *p_brk = hi + addr;  // the logical value of brk(0)\n    return (ptrdiff_t)addr - lo;\n}\n\n\nstatic Elf32_Addr  // entry address\ndo_xmap(int const fdi, Elf32_Ehdr const *const ehdr, Extent *const xi,\n    Elf32_auxv_t *const av, unsigned *const p_reloc, f_unfilter *const f_unf\n#if defined(__mips__)  //{\n    , size_t const page_mask\n#endif  //}\n)\n{\n#if defined(__mips__)  //{\n    unsigned const frag_mask = ~page_mask;\n#else  //}{\n    unsigned const frag_mask = ~get_page_mask();\n#endif  //}\n    Elf32_Phdr const *phdr = (Elf32_Phdr const *)(void const *)(ehdr->e_phoff +\n        (char const *)ehdr);\n    Elf32_Addr v_brk;\n    Elf32_Addr reloc;\n    if (xi) { // compressed main program:\n        // C_BASE space reservation, C_TEXT compressed data and stub\n        Elf32_Addr  ehdr0 = *p_reloc;  // the 'hi' copy!\n        Elf32_Phdr *phdr0 = (Elf32_Phdr *)(1+ (Elf32_Ehdr *)ehdr0);  // cheats .e_phoff\n        // Clear the 'lo' space reservation for use by PT_LOADs\n        if (ET_EXEC==((Elf32_Ehdr *)ehdr0)->e_type) {\n            ehdr0 = phdr0[0].p_vaddr;\n            reloc = 0;\n        }\n        else {\n            ehdr0 -= phdr0[1].p_vaddr;\n            reloc = ehdr0;\n        }\n        v_brk = phdr0->p_memsz + ehdr0;\n    }\n    else { // PT_INTERP\n        reloc = xfind_pages(\n            ((ET_DYN!=ehdr->e_type) ? MAP_FIXED : 0), phdr, ehdr->e_phnum, &v_brk\n#if defined(__mips__)  //{\n         , page_mask\n#endif  //}\n        );\n    }\n\n    DPRINTF(\"do_xmap  fdi=%%x  ehdr=%%p  xi=%%p(%%x %%p)\\\\n\"\n          \"  av=%%p  frag_mask=%%p  reloc=%%p  p_reloc=%%p/%%p  f_unf=%%p\\\\n\",\n        fdi, ehdr, xi, (xi? xi->size: 0), (xi? xi->buf: 0),\n        av, frag_mask, reloc, p_reloc, *p_reloc, f_unf);\n    int j;\n    for (j=0; j < ehdr->e_phnum; ++phdr, ++j)\n    if (xi && PT_PHDR==phdr->p_type) {\n        auxv_up(av, AT_PHDR, phdr->p_vaddr + reloc);\n    } else\n    if (PT_LOAD==phdr->p_type && phdr->p_memsz != 0) {\n        if (xi && !phdr->p_offset /*&& ET_EXEC==ehdr->e_type*/) { // 1st PT_LOAD\n            // ? Compressed PT_INTERP must not overwrite values from compressed a.out?\n            auxv_up(av, AT_PHDR, phdr->p_vaddr + reloc + ehdr->e_phoff);\n            auxv_up(av, AT_PHNUM, ehdr->e_phnum);\n            auxv_up(av, AT_PHENT, ehdr->e_phentsize);  /* ancient kernels might omit! */\n            //auxv_up(av, AT_PAGESZ, PAGE_SIZE);  /* ld-linux.so.2 does not need this */\n        }\n        unsigned const prot = PF_TO_PROT(phdr->p_flags);\n        Extent xo;\n        size_t mlen = xo.size = phdr->p_filesz;\n        char * addr = xo.buf  =  (char *)(phdr->p_vaddr + reloc);\n        char *const haddr =     phdr->p_memsz + addr;\n        size_t frag  = (int)addr & frag_mask;\n        mlen += frag;\n        addr -= frag;\n        DPRINTF(\"  phdr type=%%x  offset=%%x  vaddr=%%x  paddr=%%x  filesz=%%x  memsz=%%x  flags=%%x  align=%%x\\\\n\",\n            phdr->p_type, phdr->p_offset, phdr->p_vaddr, phdr->p_paddr,\n            phdr->p_filesz, phdr->p_memsz, phdr->p_flags, phdr->p_align);\n        DPRINTF(\"  addr=%%x  mlen=%%x  frag=%%x  prot=%%x\\\\n\", addr, mlen, frag, prot);\n\n#if defined(__i386__)  /*{*/\n    // Decompressor can overrun the destination by 3 bytes.\n#  define LEN_OVER 3\n#else  /*}{*/\n#  define LEN_OVER 0\n#endif  /*}*/\n\n        DPRINTF(\"    prot=%%x\\n\",\n#if defined(__arm__)  //{\n                    ((PF_X & phdr->p_flags) ? PROT_EXEC : 0) |\n#endif  //}\n                    PROT_WRITE | PROT_READ);\n\n        if (xi) { // compressed source: Pprotect(,,prot) later\n            if (addr != mmap_privanon(addr, LEN_OVER + mlen,\n#if defined(__arm__)  //{\n                    ((PF_X & phdr->p_flags) ? PROT_EXEC : 0) |\n#endif  //}\n                    PROT_WRITE | PROT_READ, MAP_FIXED) )\n                err_exit(6);\n            unpackExtent(xi, &xo, (f_expand *)fdi,\n                ((PROT_EXEC & prot) ? f_unf : 0) );\n        }\n        else {  // PT_INTERP\n            if (addr != mmap(addr, mlen, prot, MAP_FIXED | MAP_PRIVATE,\n                    fdi, phdr->p_offset - frag) )\n                err_exit(8);\n        }\n        // Linux does not fixup the low end, so neither do we.\n        // Indeed, must leave it alone because some PT_GNU_RELRO\n        // dangle below PT_LOAD (but still on the low page)!\n        //if (PROT_WRITE & prot) {\n        //    bzero(addr, frag);  // fragment at lo end\n        //}\n        frag = (-mlen) & frag_mask;  // distance to next page boundary\n        if (PROT_WRITE & prot) { // note: read-only .bss not supported here\n            bzero(mlen+addr, frag);  // fragment at hi end\n        }\n        if (xi) {\n#if defined(__i386__)  /*{*/\n            void *const hatch = make_hatch_x86(phdr, reloc);\n            if (0!=hatch) {\n                /* always update AT_NULL, especially for compressed PT_INTERP */\n                auxv_up((Elf32_auxv_t *)(~1 & (int)av), AT_NULL, (unsigned)hatch);\n            }\n#elif defined(__arm__)  /*}{*/\n            void *const hatch = make_hatch_arm(phdr, reloc);\n            if (0!=hatch) {\n                auxv_up(av, AT_NULL, (unsigned)hatch);\n            }\n#elif defined(__mips__)  /*}{*/\n            void *const hatch = make_hatch_mips(phdr, reloc, frag_mask);\n            if (0!=hatch) {\n                auxv_up(av, AT_NULL, (unsigned)hatch);\n            }\n#elif defined(__powerpc__)  /*}{*/\n            void *const hatch = make_hatch_ppc32(phdr, reloc, frag_mask);\n            if (0!=hatch) {\n                auxv_up(av, AT_NULL, (unsigned)hatch);\n            }\n#endif  /*}*/\n            if (0!=Pprotect(addr, mlen, prot)) {\n                err_exit(10);\nERR_LAB\n            }\n        }\n        addr += mlen + frag;  /* page boundary on hi end */\n        if (addr < haddr) { // need pages for .bss\n            DPRINTF(\"addr=%%p  haddr=%%p\\\\n\", addr, haddr);\n            if (addr != mmap_privanon(addr, haddr - addr, prot, MAP_FIXED)) {\n                for(;;);\n                err_exit(9);\n            }\n        }\n#if defined(__i386__)  /*{*/\n        else if (xi) { // cleanup if decompressor overrun crosses page boundary\n            mlen = frag_mask & (3+ mlen);\n            if (mlen<=3) { // page fragment was overrun buffer only\n                munmap(addr, mlen);\n            }\n        }\n#endif  /*}*/\n    }\n    if (xi && ET_DYN!=ehdr->e_type) {\n        // Needed only if compressed shell script invokes compressed shell.\n        // Besides, fold.S needs _Ehdr that is tossed\n        // do_brk((void *)v_brk);\n    }\n    if (0!=p_reloc) {\n        *p_reloc = reloc;\n    }\n    return ehdr->e_entry + reloc;\n}\n\n#if 0 && defined(__arm__)  //{\nstatic uint32_t ascii5(char *p, uint32_t v, unsigned n)\n{\n    do {\n        unsigned char d = (0x1f & v) + 'A';\n        if ('Z' < d) d += '0' - (1+ 'Z');\n        *--p = d;\n        v >>= 5;\n    } while (--n > 0);\n    return v;\n}\n#endif  //}\n\n\n/*************************************************************************\n// upx_main - called by our entry code\n//\n// This function is optimized for size.\n**************************************************************************/\n\n#if defined(__mips__)  /*{*/\nvoid *upx_main(  // returns entry address\n    struct b_info const *const bi,  // 1st block header\n    size_t const sz_compressed,  // total length\n    Elf32_Ehdr *const ehdr,  // temp char[sz_ehdr] for decompressing\n    Elf32_auxv_t *const av,\n    f_expand *const f_exp,\n    f_unfilter *const f_unf,\n    Elf32_Addr const elfaddr,\n    size_t const page_mask\n) __asm__(\"upx_main\");\nvoid *upx_main(  // returns entry address\n    struct b_info const *const bi,  // 1st block header\n    size_t const sz_compressed,  // total length\n    Elf32_Ehdr *const ehdr,  // temp char[sz_ehdr] for decompressing\n    Elf32_auxv_t *const av,\n    f_expand *const f_exp,\n    f_unfilter *const f_unf,\n    Elf32_Addr const elfaddr,\n    size_t const page_mask\n)\n\n#elif defined(__powerpc__) //}{\nvoid *upx_main(  // returns entry address\n    struct b_info const *const bi,  // 1st block header\n    size_t const sz_compressed,  // total length\n    Elf32_Ehdr *const ehdr,  // temp char[sz_ehdr] for decompressing\n    Elf32_auxv_t *const av,\n    f_expand *const f_exp,\n    f_unfilter *const f_unf,\n    Elf32_Addr elfaddr\n) __asm__(\"upx_main\");\nvoid *upx_main(  // returns entry address\n    struct b_info const *const bi,  // 1st block header\n    size_t const sz_compressed,  // total length\n    Elf32_Ehdr *const ehdr,  // temp char[sz_ehdr] for decompressing\n    Elf32_auxv_t *const av,\n    f_expand *const f_exp,\n    f_unfilter *const f_unf,\n    Elf32_Addr elfaddr\n)\n\n#else  /*}{ !__mips__ && !__powerpc__ */\nvoid *upx_main(\n    Elf32_auxv_t *const av,\n    unsigned const sz_compressed,\n    f_expand *const f_exp,\n    f_unfilter * /*const*/ f_unfilter,\n    Extent xo,\n    Extent xi,\n    Elf32_Addr const volatile elfaddr\n) __asm__(\"upx_main\");\nvoid *upx_main(\n    Elf32_auxv_t *const av,\n    unsigned const sz_compressed,\n    f_expand *const f_exp,\n    f_unfilter * /*const*/ f_unf,\n    Extent xo,  // {sz_unc, ehdr}    for ELF headers\n    Extent xi,  // {sz_cpr, &b_info} for ELF headers\n    Elf32_Addr const volatile elfaddr  // value+result: compiler must not change\n)\n#endif  /*}*/\n{\n#if defined(__i386__)  //{\n    f_unf = (0xeb != *(unsigned char *)f_exp)  // 2-byte jmp around unfilter\n        ? 0\n        : (f_unfilter *)(2+ (long)f_exp);\n#endif  //}\n\n#if !defined(__mips__) && !defined(__powerpc__)  /*{*/\n    Elf32_Ehdr *const ehdr = (Elf32_Ehdr *)(void *)xo.buf;  // temp char[MAX_ELF_HDR_32+OVERHEAD]\n    // sizeof(Ehdr+Phdrs),   compressed; including b_info header\n    size_t const sz_first = xi.size;\n#endif  /*}*/\n\n#if defined(__powerpc__)  //{\n    size_t const sz_first = sizeof(*bi) + bi->sz_cpr;\n    Extent xo, xi;\n    xo.buf = (char *)ehdr;           xo.size = bi->sz_unc;\n    xi.buf = CONST_CAST(char *, bi); xi.size = sz_compressed;\n#endif  //}\n\n#if defined(__mips__)  /*{*/\n    Extent xo, xi, xj;\n    xo.buf  = (char *)ehdr;          xo.size = bi->sz_unc;\n    xi.buf = CONST_CAST(char *, bi); xi.size = sz_compressed;\n    xj.buf = CONST_CAST(char *, bi); xj.size = sizeof(*bi) + bi->sz_cpr;\n#endif  //}\n\n    DPRINTF(\"upx_main@%%p av=%%p  szc=%%x  f_exp=%%p  f_unf=%%p  \"\n            \"  xo=%%p(%%x %%p)  xi=%%p(%%x %%p)  elfaddr=%%x\\\\n\",\n        upx_main, av, sz_compressed, f_exp, f_unf, &xo, xo.size, xo.buf,\n        &xi, xi.size, xi.buf, elfaddr);\n\n#if defined(__mips__)  //{\n    // ehdr = Uncompress Ehdr and Phdrs\n    unpackExtent(&xj, &xo, f_exp, 0);\n#else  //}{ !defined(__mips__)\n    // Uncompress Ehdr and Phdrs.\n    unpackExtent(&xi, &xo, f_exp, 0);\n    // Prepare to decompress the Elf headers again, into the first PT_LOAD.\n    xi.buf  -= sz_first;\n    xi.size  = sz_compressed;\n#endif  // !__mips__ }\n\n    Elf32_Addr reloc = elfaddr;  // ET_EXEC problem!\n    DPRINTF(\"upx_main1  .e_entry=%%p  reloc=%%p\\\\n\", ehdr->e_entry, reloc);\n    Elf32_Phdr *phdr = (Elf32_Phdr *)(1+ ehdr);\n\n    // De-compress Ehdr again into actual position, then de-compress the rest.\n    Elf32_Addr entry = do_xmap((int)f_exp, ehdr, &xi, av, &reloc, f_unf\n#if defined(__mips__)  //{\n        , page_mask\n#endif  //}\n        );\n    DPRINTF(\"upx_main2  entry=%%p  reloc=%%p\\\\n\", entry, reloc);\n    auxv_up(av, AT_ENTRY , entry);\n\n  { // Map PT_INTERP program interpreter\n    int j;\n    for (j=0, phdr = (Elf32_Phdr *)(1+ ehdr); j < ehdr->e_phnum; ++phdr, ++j)\n    if (PT_INTERP==phdr->p_type) {\n        int const fdi = open(reloc + (char const *)phdr->p_vaddr, O_RDONLY, 0);\n        if (0 > fdi) {\n            err_exit(18);\n        }\n        if (MAX_ELF_HDR_32!=read(fdi, (void *)ehdr, MAX_ELF_HDR_32)) {\nERR_LAB\n            err_exit(19);\n        }\n        entry = do_xmap(fdi, ehdr, 0, av, &reloc, 0\n#if defined(__mips__)  //{\n            , page_mask\n#endif  //}\n        );\n        DPRINTF(\"upx_main3  entry=%%p  reloc=%%p\\\\n\", entry, reloc);\n        auxv_up(av, AT_BASE, reloc);  // uClibc and musl\n        close(fdi);\n        break;\n    }\n  }\n\n    return (void *)entry;\n}\n\n/* vim:set ts=4 sw=4 et: */\n","size_bytes":33019},"src/stub/src/i386-linux.elf-main2.c":{"content":"/* i386-linux.elf-main.c -- stub loader for Linux 32-bit ELF executable\n\n   This file is part of the UPX executable compressor.\n\n   Copyright (C) 1996-2025 Markus Franz Xaver Johannes Oberhumer\n   Copyright (C) 1996-2025 Laszlo Molnar\n   Copyright (C) 2000-2025 John F. Reiser\n   All Rights Reserved.\n\n   UPX and the UCL library are free software; you can redistribute them\n   and/or modify them under the terms of the GNU General Public License as\n   published by the Free Software Foundation; either version 2 of\n   the License, or (at your option) any later version.\n\n   This program is distributed in the hope that it will be useful,\n   but WITHOUT ANY WARRANTY; without even the implied warranty of\n   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n   GNU General Public License for more details.\n\n   You should have received a copy of the GNU General Public License\n   along with this program; see the file COPYING.\n   If not, write to the Free Software Foundation, Inc.,\n   59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.\n\n   Markus F.X.J. Oberhumer              Laszlo Molnar\n   <markus@oberhumer.com>               <ezerotven+github@gmail.com>\n\n   John F. Reiser\n   <jreiser@users.sourceforge.net>\n */\n\n#ifndef DEBUG  //{\n#define DEBUG 0\n#endif  //}\n\n#include \"include/linux.h\"\n\n#define MFD_EXEC 0x0010\n#define MS_SYNC 4\n#define nullptr 0\n\nextern void *memcpy(void *dst, void const *src, size_t n);\n// Pprotect is mprotect but uses page-aligned address (Linux requirement)\nextern unsigned Pprotect(void *, size_t, unsigned);\nextern int Psync(void const *, size_t, unsigned);\n//extern void *Pmap(void *, size_t, unsigned, unsigned, int, size_t);\n//extern int Punmap(void *, size_t);\nextern size_t Pwrite(unsigned, void const *, size_t);\nextern ssize_t write(int, void const *, size_t);\nextern int munmap(void *, size_t);\nextern int close(int);\nextern void exit(int code) __attribute__ ((__noreturn__));\n#  define mmap_privanon(addr,len,prot,flgs) mmap((addr),(len),(prot), \\\n        MAP_PRIVATE|MAP_ANONYMOUS|(flgs),-1,0)\n\nextern void my_bkpt(void const *, ...);\n\n#if defined(__powerpc__) //}{\n#define addr_string(string) ({ \\\n    char const *str; \\\n    asm(\"bl 0f; .string \\\"\" string \"\\\"; .balign 4; 0: mflr %0\" \\\n/*out*/ : \"=r\"(str) \\\n/* in*/ : \\\n/*und*/ : \"lr\"); \\\n    str; \\\n})\n#elif defined(__i386__) //}{\n#define addr_string(string) ({ \\\n    char const *str; \\\n    asm(\"call 0f; .asciz \\\"\" string \"\\\"; 0: pop %0\" \\\n/*out*/ : \"=r\"(str) ); \\\n    str; \\\n})\n#elif defined(__arm__) //}{\n#define addr_string(string) ({ \\\n    char const *str; \\\n    asm(\"bl 0f; .string \\\"\" string \"\\\"; .balign 4; 0: mov %0,x30\" \\\n/*out*/ : \"=r\"(str) \\\n/* in*/ : \\\n/*und*/ : \"x30\"); \\\n    str; \\\n})\n#elif defined(__mips__) //}{\n#define addr_string(string) ({ \\\n    char const *str; \\\n    asm(\"bal 0f; .string \\\"\" string \"\\\"; .balign 4; 0: move %0,ra\" \\\n/*out*/ : \"=r\"(str) \\\n/* in*/ : \\\n/*und*/ : \"ra\"); \\\n    str; \\\n})\n#else  //}{\n#error;\n#endif  //}\n#if !DEBUG //{\n#define DPRINTF(fmt, args...) /*empty*/\n#else  //}{\n// DPRINTF is defined as an expression using \"({ ... })\"\n// so that DPRINTF can be invoked inside an expression,\n// and then followed by a comma to ignore the return value.\n// The only complication is that percent and backslash\n// must be doubled in the format string, because the format\n// string is processd twice: once at compile-time by 'asm'\n// to produce the assembled value, and once at runtime to use it.\n#if defined(__powerpc__)  //{\n#define DPRINTF(fmt, args...) ({ \\\n    char const *r_fmt; \\\n    asm(\"bl 0f; .string \\\"\" fmt \"\\\"; .balign 4; 0: mflr %0\" \\\n/*out*/ : \"=r\"(r_fmt) \\\n/* in*/ : \\\n/*und*/ : \"lr\"); \\\n    dprintf(r_fmt, args); \\\n})\n#elif defined(__x86_64) || defined(__i386__) //}{\n#define DPRINTF(fmt, args...) ({ \\\n    char const *r_fmt; \\\n    asm(\"call 0f; .asciz \\\"\" fmt \"\\\"; 0: pop %0\" \\\n/*out*/ : \"=r\"(r_fmt) ); \\\n    dprintf(r_fmt, args); \\\n})\n#elif defined(__arm__)  /*}{*/\n#define DPRINTF(fmt, args...) ({ \\\n    char const *r_fmt; \\\n    asm(\"mov %0,pc; b 0f; \\\n        .asciz \\\"\" fmt \"\\\"; .balign 4; \\\n      0: \" \\\n/*out*/ : \"=r\"(r_fmt) ); \\\n    dprintf(r_fmt, args); \\\n})\n#elif defined(__mips__)  /*}{*/\n#define DPRINTF(fmt, args...) ({ \\\n    char const *r_fmt; \\\n    asm(\".set noreorder; bal L%=j; move %0,$31; .set reorder; \\\n        .asciz \\\"\" fmt \"\\\"; .balign 4; \\\n      L%=j: \" \\\n/*out*/ : \"=r\"(r_fmt) \\\n/* in*/ : \\\n/*und*/ : \"ra\"); \\\n    dprintf(r_fmt, args); \\\n})\n#endif  //}\n\nstatic int dprintf(char const *fmt, ...); // forward\n#endif  /*}*/\n\n/*************************************************************************\n// configuration section\n**************************************************************************/\n\n// In order to make it much easier to move this code at runtime and execute\n// it at an address different from it load address:  there must be no\n// static data, and no string constants.\n\n#define ElfW(sym) Elf32_ ## sym\n\n#include \"MAX_ELF_HDR.c\"\n\n/*************************************************************************\n// \"file\" util\n**************************************************************************/\n\ntypedef struct {\n    size_t size;  // must be first to match size[0] uncompressed size\n    char *buf;\n} Extent;\n\n\nstatic void\nxread(Extent *x, char *buf, size_t count)\n{\n    DPRINTF(\"xread x.size=%%x  x.buf=%%p  buf=%%p  count=%%x\\\\n\",\n        x->size, x->buf, buf, count);\n    char *p=x->buf, *q=buf;\n    size_t j;\n    if (x->size < count) {\n        exit(127);\n    }\n    for (j = count; 0!=j--; ++p, ++q) {\n        *q = *p;\n    }\n    x->buf  += count;\n    x->size -= count;\n    DPRINTF(\"xread done count=%%x\\\\n\", count);\n}\n\n\n/*************************************************************************\n// util\n**************************************************************************/\n\n#if !DEBUG  //{  save space\n#define ERR_LAB error: exit(127);\n#define err_exit(a) goto error\n#else  //}{  save debugging time\n#define ERR_LAB /*empty*/\nstatic void\nerr_exit(int a)\n{\n    (void)a;  // debugging convenience\n    DPRINTF(\"err_exit %%d\\\\n\", a);\n    exit(127);\n}\n#endif  //}\n\n/*************************************************************************\n// UPX & NRV stuff\n**************************************************************************/\n\nextern size_t get_page_mask(void);  // variable page size AT_PAGESZ; see *-fold.S\n\nint f_expand( // .globl in $(ARCH)-expand.S\n    nrv_byte const *binfo, nrv_byte *dst, size_t *dstlen);\n\nstatic void\nunpackExtent(\n    Extent *const xi,  // input includes struct b_info\n    Extent *const xo   // output\n)\n{\n    while (xo->size) {\n        DPRINTF(\"unpackExtent xi=(%%p %%p)  xo=(%%p %%p)\\\\n\",\n            xi->size, xi->buf, xo->size, xo->buf);\n        struct b_info h;\n        //   Note: if h.sz_unc == h.sz_cpr then the block was not\n        //   compressible and is stored in its uncompressed form.\n\n        // Read and check block sizes.\n        xread(xi, (char *)&h, sizeof(h));\n        DPRINTF(\"h.sz_unc=%%x  h.sz_cpr=%%x  h.b_method=%%x\\\\n\",\n            h.sz_unc, h.sz_cpr, h.b_method);\n        if (h.sz_unc == 0) {                     // uncompressed size 0 -> EOF\n            if (h.sz_cpr != UPX_MAGIC_LE32)      // h.sz_cpr must be h->magic\n                err_exit(2);\n            if (xi->size != 0)                 // all bytes must be written\n                err_exit(3);\n            break;\n        }\n        if (h.sz_cpr <= 0) {\n            err_exit(4);\nERR_LAB\n        }\n        if (h.sz_cpr > h.sz_unc\n        ||  h.sz_unc > xo->size ) {\n            err_exit(5);\n        }\n        // Now we have:\n        //   assert(h.sz_cpr <= h.sz_unc);\n        //   assert(h.sz_unc > 0 && h.sz_unc <= blocksize);\n        //   assert(h.sz_cpr > 0 && h.sz_cpr <= blocksize);\n\n        if (h.sz_cpr < h.sz_unc) { // Decompress block\n            size_t out_len = h.sz_unc;  // EOF for lzma\n            int const j = f_expand((unsigned char *)xi->buf - sizeof(h),\n                (unsigned char *)xo->buf, &out_len);\n            if (j != 0 || out_len != (nrv_uint)h.sz_unc) {\n                DPRINTF(\"  j=%%x  out_len=%%x  &h=%%p\\\\n\", j, out_len, &h);\n                err_exit(6);\n            }\n            xi->buf  += h.sz_cpr;\n            xi->size -= h.sz_cpr;\n        }\n        else { // copy literal block\n            DPRINTF(\"  copy %%p  %%p  %%p\\\\n\", xi->buf, xo->buf, h.sz_cpr);\n            xi->size += sizeof(h);  // xread(xi, &h, sizeof(h)) was a peek\n            xread(xi, xo->buf, h.sz_cpr);\n        }\n        xo->buf  += h.sz_unc;\n        xo->size -= h.sz_unc;\n    }\n}\n\nextern long upx_mmap_and_fd(  // x86_64 Android emulator of i386 is not faithful\n     void *ptr\n     , unsigned len  // also pre-allocate space in file\n     , char *pathname  // 0 ==> call get_upxfn_path, which stores if 1st time\n#if 0  //{ always 0\n     , unsigned frag_mask  // ~page_mask\n#endif  //}\n);\n#if defined(__i386__)  //\n// Create (or find) an escape hatch to use when munmapping ourselves the stub.\n// Called by do_xmap to create it; remembered in AT_NULL.d_val\nstatic char *\nmake_hatch(\n    ElfW(Phdr) const *const phdr,\n    char *next_unc,\n    unsigned page_mask\n)\n{\n    unsigned *hatch = 0;\n    unsigned frag_mask = ~page_mask;\n    unsigned code[2] = {\n        0x586180cd,  // int #0x80; popa; pop %eax\n        0x90e0ff3e,  // notrack jmp *%eax; nop\n    };\n    DPRINTF(\"make_hatch %%p %%p %%x\\\\n\", phdr, next_unc, frag_mask);\n    if (phdr->p_type==PT_LOAD && phdr->p_flags & PF_X) {\n        next_unc += phdr->p_memsz - phdr->p_filesz;  // Skip over local .bss\n        frag_mask &= -(long)next_unc;  // bytes left on page\n        if (sizeof(code) <= frag_mask) {\n            hatch = (unsigned *)next_unc;\n            hatch[0] = code[0];\n            hatch[1] = code[1];\n        }\n        else { // Does not fit at hi end of .text, so must use a new page \"permanently\"\n            unsigned long fdmap = upx_mmap_and_fd((void *)0, sizeof(code), nullptr);\n            unsigned mfd = -1+ (0xfff& fdmap);\n            write(mfd, &code, sizeof(code));\n            hatch = mmap((void *)(fdmap & ~0xffful), sizeof(code),\n              PROT_READ|PROT_EXEC, MAP_PRIVATE, mfd, 0);\n            close(mfd);\n        }\n    }\n    DPRINTF(\"hatch=%%p\\\\n\", hatch);\n    return (char *)hatch;\n}\n#elif defined(__arm__)  /*}{*/\nextern unsigned get_sys_munmap(void);\n#define NINSTR 3\n#define NBPI 4\n\nstatic void *\nmake_hatch(\n    ElfW(Phdr) const *const phdr,\n    char *next_unc,\n    unsigned page_mask\n)\n{\n    unsigned const sys_munmap = get_sys_munmap();\n    unsigned frag_mask = ~page_mask;\n    unsigned code[2] = {\n        sys_munmap,  // syscall __NR_unmap\n        0xe8bd8003,  // ldmia sp!,{r0,r1,pc}\n     };\n    unsigned *hatch = 0;\n    DPRINTF(\"make_hatch %%p %%p %%x\\\\n\", phdr, next_unc, frag_mask);\n\n    if (phdr->p_type==PT_LOAD && phdr->p_flags & PF_X) {\n        next_unc += phdr->p_memsz - phdr->p_filesz;  // Skip over local .bss\n        frag_mask &= -(long)next_unc;  // bytes left on page\n        if (2*4 <= frag_mask) {\n            hatch = (unsigned *)(void *)(~3ul & (long)(3+ next_unc));\n            hatch[0]= code[0];\n            hatch[1]= code[1];\n            //__clear_cache(&hatch[0], &hatch[2]);  subsumed by write()+mmap()\n        }\n        else { // Does not fit at hi end of .text, so must use a new page \"permanently\"\n            unsigned long fdmap = upx_mmap_and_fd((void *)0, sizeof(code), nullptr);\n            unsigned mfd = -1+ (0xfff& fdmap);\n            write(mfd, &code, sizeof(code));\n            hatch = mmap((void *)(fdmap & ~0xffful), sizeof(code),\n                PROT_READ|PROT_EXEC, MAP_PRIVATE, mfd, 0);\n            close(mfd);\n        }\n    }\n    DPRINTF(\"hatch=%%p\\\\n\", hatch);\n    return hatch;\n}\n#elif defined(__mips__)  /*}{*/\nstatic void *\nmake_hatch(\n    ElfW(Phdr) const *const phdr,\n    char *next_unc,\n    unsigned page_mask)\n{\n    unsigned frag_mask = ~page_mask;\n    unsigned code[3];\n    // avoid gcc initializing array by copying .rodata\n    code[0] = 0x0000000c;  // syscall\n#define RS(r) ((037&(r))<<21)\n#define JR 010\n    code[1] = RS(30)|JR;   // jr $30  # s8\n    code[2] = 0x00000000;  //   nop\n\n    unsigned *hatch = 0;\n    DPRINTF(\"make_hatch_mips %%p %%p %%x\\\\n\", phdr, next_unc, frag_mask);\n\n    if (phdr->p_type==PT_LOAD && phdr->p_flags & PF_X) {\n        next_unc += phdr->p_memsz - phdr->p_filesz;  // Skip over local .bss\n        frag_mask &= -(long)next_unc;  // bytes left on page\n        if (3*4 <= frag_mask) {\n            hatch = (unsigned *)(void *)(~3ul & (long)(3+ next_unc));\n            hatch[0]= code[0];\n            hatch[1]= code[1];\n            hatch[2]= code[2];\n            //__clear_cache(&hatch[0], &hatch[3]);  subsumed by write()+mmap()\n        }\n        else { // Does not fit at hi end of .text, so must use a new page \"permanently\"\n            unsigned long fdmap = upx_mmap_and_fd((void *)0, sizeof(code), nullptr);\n            unsigned mfd = -1+ (0xfff& fdmap);\n            write(mfd, &code, sizeof(code));\n            hatch = mmap((void *)(fdmap & ~0xffful), sizeof(code),\n                PROT_READ|PROT_EXEC, MAP_PRIVATE, mfd, 0);\n            close(mfd);\n        }\n    }\n    DPRINTF(\"hatch=%%p\\\\n\", hatch);\n    return hatch;\n}\n#elif defined(__powerpc__)  /*}{*/\nstatic void *\nmake_hatch(\n    ElfW(Phdr) const *const phdr,\n    char *next_unc,\n    unsigned page_mask)\n{\n    unsigned frag_mask = ~page_mask;\n    unsigned code[2];\n    // avoid gcc initializing array by copying .rodata\n    code[0] = 0x44000002;  // sc\n    code[1] = 0x4e800020;  // blr\n\n    unsigned *hatch = 0;\n    DPRINTF(\"make_hatch %%p %%p %%x\\\\n\", phdr, next_unc, frag_mask);\n\n    if (phdr->p_type==PT_LOAD && phdr->p_flags & PF_X) {\n        next_unc += phdr->p_memsz - phdr->p_filesz;  // Skip over local .bss\n        frag_mask &= -(long)next_unc;  // bytes left on page\n        if (2*4 <= frag_mask) {\n            hatch = (unsigned *)(void *)(~3ul & (long)(3+ next_unc));\n            hatch[0]= code[0];\n            hatch[1]= code[1];\n            //__clear_cache(&hatch[0], &hatch[2]);  subsumed by write()+mmap()\n        }\n        else { // Does not fit at hi end of .text, so must use a new page \"permanently\"\n            unsigned long fdmap = upx_mmap_and_fd((void *)0, sizeof(code), nullptr);\n            unsigned mfd = -1+ (0xfff& fdmap);\n            write(mfd, &code, sizeof(code));\n            hatch = mmap((void *)(fdmap & ~0xffful), sizeof(code),\n                PROT_READ|PROT_EXEC, MAP_PRIVATE, mfd, 0);\n            close(mfd);\n        }\n    }\n    DPRINTF(\"hatch=%%p\\\\n\", hatch);\n    return hatch;\n}\n#endif  /*}*/\n\n#if defined(__powerpc64__) || defined(__aarch64__)  //{ bzero\nstatic void\nupx_bzero(char *p, size_t len)\n{\n    DPRINTF(\"bzero %%x  %%x\\\\n\", p, len);\n    if (len) do {\n        *p++= 0;\n    } while (--len);\n}\n#define bzero upx_bzero\n#else  //}{\n#define bzero(a,b)  __builtin_memset(a,0,b)\n#endif  //}\n\nstatic void\nauxv_up(ElfW(auxv_t) *av, unsigned const type, uint64_t const value)\n{\n    DPRINTF(\"\\\\nauxv_up av=%%p  %%d  %%p\\\\n\", av, type, value);\n    if (!av || (1& (size_t)av)) { // none, or inhibited for PT_INTERP\n        return;\n    }\n    // Multiple slots can have 'type' which wastes space but is legal.\n    // rtld (ld-linux) uses the last one, so we must scan the whole table.\n    ElfW(auxv_t) *ignore_slot = 0;\n    int found = 0;\n    for (;; ++av) {\n        DPRINTF(\"  %%d  %%p\\\\n\", av->a_type, av->a_un.a_val);\n        if (av->a_type == type) {\n            av->a_un.a_val = value;\n            ++found;\n        }\n        else if (av->a_type == AT_IGNORE) {\n            ignore_slot = av;\n        }\n        if (av->a_type==AT_NULL) { // done scanning\n            if (found) {\n                return;\n            }\n            if (ignore_slot) {\n                ignore_slot->a_type = type;\n                ignore_slot->a_un.a_val = value;\n                return;\n            }\n            err_exit(20);\nERR_LAB\n            return;\n        }\n    }\n}\n\n// Segregate large local array, to avoid code bloat due to large displacements.\n// Not 'static' to disaable inlining, to control sizeof stack frame in callers.\n/*static*/ void\nunderlay(unsigned size, char *ptr, unsigned len)  // len <= PAGE_SIZE\n{\n    DPRINTF(\"underlay size=%%u  ptr=%%p  len=%%u\\\\n\", size, ptr, len);\n    unsigned saved[4096/sizeof(unsigned)];\n    memcpy(saved, ptr, len);\n    mmap(ptr, size, PROT_WRITE|PROT_READ,\n        MAP_FIXED|MAP_PRIVATE|MAP_ANONYMOUS, -1, 0);\n    memcpy(ptr, saved, len);\n}\n\n#if 0  //{\n// Exchange the bits with values 4 (PF_R, PROT_EXEC) and 1 (PF_X, PROT_READ)\n// Use table lookup into a PIC-string that pre-computes the result.\nunsigned PF_TO_PROT(unsigned flags)\n{\n    char const *table = addr_string(\"\\x80\\x04\\x02\\x06\\x01\\x05\\x03\\x07\");\n    return 7& table[flags & (PF_R|PF_W|PF_X)];\n}\n#else  //}{\n// The PF_* and PROT_* bits are {1,2,4}; the conversion table fits in 32 bits.\n#define REP8(x) \\\n    ((x)|((x)<<4)|((x)<<8)|((x)<<12)|((x)<<16)|((x)<<20)|((x)<<24)|((x)<<28))\n#define EXP8(y) \\\n    ((1&(y)) ? 0xf0f0f0f0 : (2&(y)) ? 0xff00ff00 : (4&(y)) ? 0xffff0000 : 0)\n#define PF_TO_PROT(pf) \\\n    ((PROT_READ|PROT_WRITE|PROT_EXEC) & ( \\\n        ( (REP8(PROT_EXEC ) & EXP8(PF_X)) \\\n         |(REP8(PROT_READ ) & EXP8(PF_R)) \\\n         |(REP8(PROT_WRITE) & EXP8(PF_W)) \\\n        ) >> ((pf & (PF_R|PF_W|PF_X))<<2) ))\n#endif  //}\n\n// Find convex hull of PT_LOAD (the minimal interval which covers all PT_LOAD),\n// and mmap that much, to be sure that a kernel using exec-shield-randomize\n// won't place the first piece in a way that leaves no room for the rest.\nstatic ptrdiff_t // returns relocation constant\n#if defined(__i386__)  /*{*/\n__attribute__((regparm(3), stdcall))\n#endif  /*}*/\nxfind_pages(unsigned mflags, Elf32_Phdr const *phdr, int phnum,\n    Elf32_Addr *const p_brk\n)\n{\n    size_t const page_mask = get_page_mask();\n    Elf32_Addr lo= ~0, hi= 0, addr = 0, p_align = 0x1000;\n    DPRINTF(\"xfind_pages  %%x  %%p  %%d  %%p  %%p\\\\n\", mflags, phdr, phnum, p_brk, page_mask);\n    for (; --phnum>=0; ++phdr) if (PT_LOAD==phdr->p_type\n#if defined(__arm__)  /*{*/\n                               &&  phdr->p_memsz\n// Android < 4.1 (kernel < 3.0.31) often has PT_INTERP of /system/bin/linker\n// with bad PT_LOAD[0].  https://sourceforge.net/p/upx/bugs/221\n// Type: EXEC (Executable file)\n//\n// Program Headers:\n// Type   Offset   VirtAddr   PhysAddr FileSiz MemSiz  Flg  Align\n// LOAD 0x0000d4 0x00000000 0xb0000000 0x00000 0x00000 R   0x1000\n// LOAD 0x001000 0xb0001000 0xb0001000 0x07614 0x07614 R E 0x1000\n// LOAD 0x009000 0xb0009000 0xb0009000 0x006f8 0x0ccdc RW  0x1000\n#endif  /*}*/\n    ) {\n        if (phdr->p_vaddr < lo) {\n            lo = phdr->p_vaddr;\n        }\n        if (hi < (phdr->p_memsz + phdr->p_vaddr)) {\n            hi =  phdr->p_memsz + phdr->p_vaddr;\n        }\n        if (p_align < phdr->p_align) {\n            p_align = phdr->p_align;\n        }\n    } // end scan of PT_LOADs\n    size_t page_size = 0u - page_mask;\n    lo &= page_mask;  // round down to page boundary\n    size_t len1 = page_mask & (hi - lo + page_size -1);  // desired length\n\n    // Linux lacks mmap_aligned(), so allocate a larger space, then trim the ends.\n    // Avoid division (p_align / page_size); both are powers of 2\n    unsigned q = 1;\n    while ((q * page_size) < p_align) q <<= 1;\n    --q;  // number of extra pages\n    unsigned len2 = len1 + (q * page_size);  // get enough space to align\n    addr = (Elf32_Addr)mmap_privanon((void *)lo, len2, PROT_NONE, mflags);\n    DPRINTF(\"  addr=%%p  lo=%%p  hi=%%p align=%%p  q=%%p  len1=%%p  len2=%%p\\\\n\",\n        addr, lo, hi, p_align, q, len1, len2, p_align);\n    if (q) {\n        size_t len3 = (-1 + p_align) & -addr;  // up to p_align boundary\n        if (len3) {\n            munmap((void *)addr, len3);  // trim the low end\n            addr += len3;\n            len2 -= len3;\n        }\n        if (len2 -= len1) {\n            munmap((void *)(addr + len1), len2); // trim the high end\n        }\n    }\n    DPRINTF(\"  addr=%%p\\\\n\", addr);\n    *p_brk = len1 + addr;  // the logical value of brk(0)\n    return (ptrdiff_t)addr - lo;\n}\n\nstatic ElfW(Addr)  // entry address\ndo_xmap(\n    ElfW(Ehdr) const *const ehdr,\n    Extent *const xi,\n    int const fdi,\n    ElfW(auxv_t) *const av,\n    ElfW(Addr) *const p_reloc\n)\n{\n    ElfW(Phdr) const *phdr = (ElfW(Phdr) const *)(void const *)(ehdr->e_phoff +\n        (char const *)ehdr);\n    ElfW(Addr) v_brk = 0;\n    ElfW(Addr) reloc = 0;\n    if (xi) { // compressed main program:\n        // C_BASE space reservation, C_TEXT compressed data and stub\n        ElfW(Addr)  ehdr0 = *p_reloc;\n        ElfW(Phdr) *phdr0 = (ElfW(Phdr) *)(1+ (ElfW(Ehdr) *)ehdr0);  // cheats .e_phoff\n        v_brk = ehdr0 + phdr0->p_vaddr + phdr0->p_memsz;\n        if (ET_DYN == ehdr->e_type) {\n            reloc = ehdr0 - phdr0[1].p_vaddr;\n        }\n        // paranoia: prevent \"hangover\" from VMA for C_BASE\n        munmap((void *)(reloc + phdr0->p_vaddr), phdr0->p_memsz);\n    }\n    else { // PT_INTERP\n        DPRINTF(\"INTERP ehdr=%%p  av=%%p\\\\n\", ehdr, av);\n        reloc = xfind_pages( ((ET_DYN!=ehdr->e_type) ? MAP_FIXED : 0),\n            phdr, ehdr->e_phnum, &v_brk);\n    }\n    DPRINTF(\"do_xmap  ehdr=%%p  xi=%%p(%%x %%p)  fdi=%%x\\\\n\"\n          \"  av=%%p  reloc=%%p  p_reloc=%%p/%%p\\\\n\",\n        ehdr, xi, (xi? xi->size: 0), (xi? xi->buf: 0), fdi,\n        av, reloc, p_reloc, *p_reloc);\n\n    size_t const page_mask = get_page_mask();\n    int j;\n    for (j=0; j < ehdr->e_phnum; ++phdr, ++j)\n    if (xi && PT_PHDR==phdr->p_type) {\n        auxv_up(av, AT_PHDR, phdr->p_vaddr + reloc);\n    } else\n    if (PT_LOAD==phdr->p_type && phdr->p_memsz != 0) {\n        unsigned const prot = PF_TO_PROT(phdr->p_flags);\n        DPRINTF(\"\\\\n\\\\nLOAD@%%p  p_offset=%%p  p_vaddr=%%p  p_filesz=%%p\"\n            \"  p_memsz=%%p  p_flags=%%x  prot=%%x\\\\n\",\n            phdr, phdr->p_offset, phdr->p_vaddr, phdr->p_filesz,\n            phdr->p_memsz, phdr->p_flags, prot);\n        if (xi && !phdr->p_offset /*&& ET_EXEC==ehdr->e_type*/) { // 1st PT_LOAD\n            // ? Compressed PT_INTERP must not overwrite values from compressed a.out?\n            auxv_up(av, AT_PHDR, phdr->p_vaddr + reloc + ehdr->e_phoff);\n            auxv_up(av, AT_PHNUM, ehdr->e_phnum);\n            auxv_up(av, AT_PHENT, ehdr->e_phentsize);  /* ancient kernels might omit! */\n            //auxv_up(av, AT_PAGESZ, PAGE_SIZE);  /* ld-linux.so.2 does not need this */\n        }\n        Extent xo;\n        size_t mlen = xo.size = phdr->p_filesz;\n        char * addr = xo.buf  = reloc + (char *)phdr->p_vaddr;\n            // xo.size, xo.buf are not changed except by unpackExtent()\n        char *const hi_addr = phdr->p_memsz + addr;  // end of local .bss\n        char *addr2 = mlen + addr;  // end of local .data\n        size_t frag  = ~page_mask & (ElfW(Addr))addr;\n        mlen += frag;\n        addr -= frag;\n\n#if defined(__powerpc64__) || defined(__aarch64__)\n        // Round up to hardware PAGE_SIZE; allows emulator with smaller.\n        // But (later) still need bzero when .p_filesz < .p_memsz .\n        mlen += -(mlen + (size_t)addr) &~ page_mask;\n        DPRINTF(\"  mlen=%%p\\\\n\", mlen);\n#endif\n\n        DPRINTF(\"mmap addr=%%p  mlen=%%p  phdr=%%p  offset=%%p  frag=%%p  prot=%%x\\\\n\",\n            addr, mlen, phdr, phdr->p_offset - frag, frag, prot);\n        int mfd = 0;\n        if (xi && phdr->p_flags & PF_X) { // SELinux\n            // Cannot set PROT_EXEC except via mmap() into a region (Linux \"vma\")\n            // that has never had PROT_WRITE.  So use a Linux-only \"memory file\"\n            // to hold the contents.\n            unsigned long val = upx_mmap_and_fd(addr, mlen, nullptr);\n            mfd = 0xfff & val;\n            val -= mfd; if ((char *)val != addr) err_exit(17);\n            --mfd;\n        }\n        else {\n            unsigned tprot = prot;\n            // Notice that first 4 args are same: mmap vs mmap_privanon\n            if (xi) {\n                tprot |=  PROT_WRITE;  // De-compression needs Write\n                tprot &= ~PROT_EXEC;  // Avoid simultaneous Write and eXecute\n                if (addr != mmap_privanon(addr, mlen, tprot, MAP_FIXED|MAP_PRIVATE)) {\n                    err_exit(11);\n                }\n            }\n            else if (addr != mmap(addr, mlen, tprot, MAP_FIXED|MAP_PRIVATE,\n                        fdi, phdr->p_offset - frag)) {\n                err_exit(8);\n            }\n        }\n        DPRINTF(\"addr= %%p\\\\n\", addr);\n\n        if (xi) {\n            DPRINTF(\"before unpack xi=(%%p %%p  xo=(%%p %%p)\\\\n\", xi->size, xi->buf, xo.size, xo.buf);\n            unpackExtent(xi, &xo);  // updates xi and xo\n            DPRINTF(\" after unpack xi=(%%p %%p  xo=(%%p %%p)\\\\n\", xi->size, xi->buf, xo.size, xo.buf);\n        }\n        if (PROT_WRITE & prot) { // note: read-only .bss not supported here\n            // Clear to end-of-page (first part of .bss or &_end)\n            unsigned hi_frag = -(long)addr2 &~ page_mask;\n            bzero(addr2, hi_frag);\n            addr2 += hi_frag;  // will be page aligned\n        }\n\n        if (xi && phdr->p_flags & PF_X) {\n            char *hatch = make_hatch(phdr, xo.buf, page_mask);\n            if (0!=hatch) {\n                // Always update AT_NULL, especially for compressed PT_INTERP.\n                // Clearing lo bit of av is for i386 only; else is superfluous.\n                auxv_up((ElfW(auxv_t) *)(~1 & (size_t)av), AT_NULL, (size_t)hatch);\n            }\n\n            // SELinux: Map the contents of mfd as per *phdr.\n            DPRINTF(\"hatch protect addr=%%p  mlen=%%p\\\\n\", addr, mlen);\n            Psync(addr, mlen, MS_SYNC);  // be sure file gets de-compressed bytes\n            munmap(addr, mlen);  // toss the VMA that has PROT_WRITE\n            if (addr != mmap(addr, mlen, prot, MAP_FIXED|MAP_SHARED, mfd, 0)) {\n                err_exit(9);\n            }\n            close(mfd);\n        }\n        else if ((PROT_WRITE|PROT_READ) != prot\n        &&  0!=Pprotect(addr, mlen, prot)) {\n            err_exit(10);\nERR_LAB\n        }\n        if (addr2 < hi_addr) { // pages for .bss beyond last page for p_filesz\n            DPRINTF(\"zmap addr2=%%p  len=%%p\\\\n\", addr2, hi_addr - addr2);\n            if (addr2 != mmap_privanon(addr2, hi_addr - addr2, prot, MAP_FIXED)) {\n                err_exit(10);\n            }\n        }\n    }\n    if (xi && ET_DYN!=ehdr->e_type) {\n        // Needed only if compressed shell script invokes compressed shell.\n        // Besides, fold.S needs _Ehdr that is tossed\n        // do_brk((void *)v_brk);\n    }\n    if (p_reloc) {\n        *p_reloc = reloc;\n    }\n    return ehdr->e_entry + reloc;\n}\n\n\nint open(char const *, int, int);\nssize_t read(int, void *, size_t);\n\n/*************************************************************************\n// upx_main - called by our entry code\n//\n// This function is optimized for size.\n**************************************************************************/\n\nvoid *\nupx_main(  // returns entry address\n/*arg1*/    struct b_info const *const bi  // 1st block header\n/*arg2*/    , size_t const sz_compressed  // total length\n/*arg3*/    , ElfW(Addr) elfaddr  // In: &ElfW(Ehdr) for stub\n/*arg4*/    , ElfW(auxv_t) *const av\n/*arg5*/    , ElfW(Ehdr) *const ehdr  // temp char[sz_ehdr] for decompressing\n)\n{\n    DPRINTF(\"upx_main  b_info=%%p  sz_compressed=%%p  ehdr=%%p  av=%%p\\\\n\",\n        bi, sz_compressed, ehdr, av);\n    Extent xo, xi1, xi2;\n    xo.buf  = (char *)ehdr;\n    xo.size = bi->sz_unc;  // can require bi aligned(4)\n    xi2.buf = CONST_CAST(char *, bi); xi2.size = bi->sz_cpr + sizeof(*bi);\n    xi1.buf = CONST_CAST(char *, bi); xi1.size = sz_compressed;\n\n    // ehdr = Uncompress Ehdr and Phdrs\n    unpackExtent(&xi2, &xo);  // never filtered?\n\n    ElfW(Addr) *const p_reloc = &elfaddr;\n    ElfW(Addr) page_mask = get_page_mask(); (void)page_mask;\n    DPRINTF(\"upx_main1  .e_entry=%%p  p_reloc=%%p  *p_reloc=%%p  page_mask=%%p\\\\n\",\n        ehdr->e_entry, p_reloc, *p_reloc, page_mask);\n    ElfW(Phdr) *phdr = (ElfW(Phdr) *)(1+ ehdr);\n\n    // De-compress Ehdr again into actual position, then de-compress the rest.\n    ElfW(Addr) entry = do_xmap(ehdr, &xi1, 0, av, p_reloc);\n    DPRINTF(\"upx_main2  entry=%%p  *p_reloc=%%p\\\\n\", entry, *p_reloc);\n    auxv_up(av, AT_ENTRY , entry);\n\n  { // Map PT_INTERP program interpreter\n    phdr = (ElfW(Phdr) *)(1+ ehdr);\n    unsigned j;\n    for (j=0; j < ehdr->e_phnum; ++phdr, ++j) if (PT_INTERP==phdr->p_type) {\n        char const *const iname = *p_reloc + (char const *)phdr->p_vaddr;\n        int const fdi = open(iname, O_RDONLY, 0);\n        if (0 > fdi) {\n            err_exit(18);\n        }\n        if (MAX_ELF_HDR_32!=read(fdi, (void *)ehdr, MAX_ELF_HDR_32)) {\nERR_LAB\n            err_exit(19);\n        }\n        // We expect PT_INTERP to be ET_DYN at 0.\n        // Thus do_xmap will set *p_reloc = slide.\n        *p_reloc = 0;  // kernel picks where PT_INTERP goes\n        entry = do_xmap(ehdr, 0, fdi, 0, p_reloc);\n        DPRINTF(\"interp p_reloc=%%p  reloc=%%p\\\\n\", p_reloc, *p_reloc);\n        auxv_up(av, AT_BASE, *p_reloc);  // musl\n        close(fdi);\n    }\n  }\n\n    return (void *)entry;\n}\n\n#if DEBUG  //{\n\nstatic int\nunsimal(unsigned x, char *ptr, int n)\n{\n    unsigned m = 10;\n    while (10 <= (x / m)) m *= 10;\n    while (10 <= x) {\n        unsigned d = x / m;\n    x -= m * d;\n        m /= 10;\n        ptr[n++] = '0' + d;\n    }\n    ptr[n++] = '0' + x;\n    return n;\n}\n\nstatic int\ndecimal(int x, char *ptr, int n)\n{\n    if (x < 0) {\n        x = -x;\n        ptr[n++] = '-';\n    }\n    return unsimal(x, ptr, n);\n}\n\nstatic int\nheximal(unsigned long x, char *ptr, int n)\n{\n    unsigned j = -1+ 2*sizeof(unsigned long);\n    unsigned long m = 0xful << (4 * j);\n    for (; j; --j, m >>= 4) { // omit leading 0 digits\n        if (m & x) break;\n    }\n    for (; m; --j, m >>= 4) {\n        unsigned d = 0xf & (x >> (4 * j));\n        ptr[n++] = ((10<=d) ? ('a' - 10) : '0') + d;\n    }\n    return n;\n}\n\n#define va_arg      __builtin_va_arg\n#define va_end      __builtin_va_end\n#define va_list     __builtin_va_list\n#define va_start    __builtin_va_start\n\nstatic int\ndprintf(char const *fmt, ...)\n{\n    int n= 0;\n    char const *literal = 0;  // NULL\n    char buf[24];  // ~0ull == 18446744073709551615 ==> 20 chars\n    va_list va; va_start(va, fmt);\n    for (;;) {\n        char c = *fmt++;\n        if (!c) { // end of fmt\n            if (literal) {\n                goto finish;\n            }\n            break;  // goto done\n        }\n        if ('%'!=c) {\n            if (!literal) {\n                literal = fmt;  // 1 beyond start of literal\n            }\n            continue;\n        }\n        // '%' == c\n        if (literal) {\nfinish:\n            n += write(2, -1+ literal, fmt - literal);\n            literal = 0;  // NULL\n            if (!c) { // fmt already ended\n               break;  // goto done\n            }\n        }\n        switch (c= *fmt++) { // deficiency: does not handle _long_\n        default: { // un-implemented conversion\n            n+= write(2, -1+ fmt, 1);\n        } break;\n        case 0: { // fmt ends with \"%\\0\" ==> ignore\n            goto done;\n        } break;\n        case 'u': {\n            n+= write(2, buf, unsimal(va_arg(va, unsigned), buf, 0));\n        } break;\n        case 'd': {\n            n+= write(2, buf, decimal(va_arg(va, int), buf, 0));\n        } break;\n        case 'p': {\n            buf[0] = '0';\n            buf[1] = 'x';\n            n+= write(2, buf, heximal((unsigned long)va_arg(va, void *), buf, 2));\n        } break;\n        case 'x': {\n            buf[0] = '0';\n            buf[1] = 'x';\n            n+= write(2, buf, heximal(va_arg(va, int), buf, 2));\n        } break;\n        } // 'switch'\n    }\ndone:\n    va_end(va);\n    return n;\n }\n#endif  //}\n\n/* vim:set ts=4 sw=4 et: */\n","size_bytes":31612},"src/stub/src/i386-linux.elf-so_main.c":{"content":"/* i386-linux.elf-so_main.c -- stub loader for compressed shared library\n\n   This file is part of the UPX executable compressor.\n\n   Copyright (C) 1996-2021 Markus Franz Xaver Johannes Oberhumer\n   Copyright (C) 1996-2021 Laszlo Molnar\n   Copyright (C) 2000-2025 John F. Reiser\n   All Rights Reserved.\n\n   UPX and the UCL library are free software; you can redistribute them\n   and/or modify them under the terms of the GNU General Public License as\n   published by the Free Software Foundation; either version 2 of\n   the License, or (at your option) any later version.\n\n   This program is distributed in the hope that it will be useful,\n   but WITHOUT ANY WARRANTY; without even the implied warranty of\n   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n   GNU General Public License for more details.\n\n   You should have received a copy of the GNU General Public License\n   along with this program; see the file COPYING.\n   If not, write to the Free Software Foundation, Inc.,\n   59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.\n\n   Markus F.X.J. Oberhumer              Laszlo Molnar\n   <markus@oberhumer.com>               <ezerotven+github@gmail.com>\n\n   John F. Reiser\n   <jreiser@users.sourceforge.net>\n */\n\n\n#include \"include/linux.h\"\n\nextern void my_bkpt(void const *arg1, ...);\n\n#define DEBUG 0\n\n// Pprotect is mprotect, but page-aligned on the lo end (Linux requirement)\nunsigned Pprotect(void *, size_t, unsigned);\nvoid *mmap(void *, size_t, int, int, int, off_t);\nvoid *Pmap(void *, size_t, int, int, int, off_t);\nint Punmap(void *, size_t);\nextern int Psync(void const *, size_t, unsigned);\n#define MS_SYNC 4\n#define EINVAL 22  /* Invalid argument */\n\n#if defined(__i386__) || defined(__mips__) || defined(__powerpc__) //{\n#  define mmap_privanon(addr,len,prot,flgs) mmap((addr),(len),(prot), \\\n        MAP_PRIVATE|MAP_ANONYMOUS|(flgs),-1,0)\n#else  //}{\n  void *mmap_privanon(void *, size_t, int, int);\n#endif  //}\nssize_t write(int, void const *, size_t);\nssize_t Pwrite(int, void const *, size_t);\n\n\n/*************************************************************************\n// configuration section\n**************************************************************************/\n\n// In order to make it much easier to move this code at runtime and execute\n// it at an address different from it load address:  there must be no\n// static data, and no string constants.\n\n#if !DEBUG //{\n#define DPRINTF(fmt, args...) /*empty*/\n#else  //}{\n// DPRINTF is defined as an expression using \"({ ... })\"\n// so that DPRINTF can be invoked inside an expression,\n// and then followed by a comma to ignore the return value.\n// The only complication is that percent and backslash\n// must be doubled in the format string, because the format\n// string is processed twice: once at compile-time by 'asm'\n// to produce the assembled value, and once at runtime to use it.\n#if defined(__powerpc__)  //{\n#define DPRINTF(fmt, args...) ({ \\\n    char const *r_fmt; \\\n    asm(\"bl 0f; .string \\\"\" fmt \"\\\"; .balign 4; 0: mflr %0\" \\\n/*out*/ : \"=r\"(r_fmt) \\\n/* in*/ : \\\n/*und*/ : \"lr\"); \\\n    dprintf(r_fmt, args); \\\n})\n#elif defined(__x86_64) || defined(__i386__) //}{\n#define DPRINTF(fmt, args...) ({ \\\n    char const *r_fmt; \\\n    asm(\"call 0f; .asciz \\\"\" fmt \"\\\"; 0: pop %0\" \\\n/*out*/ : \"=r\"(r_fmt) ); \\\n    dprintf(r_fmt, args); \\\n})\n#elif defined(__arm__)  /*}{*/\n#define DPRINTF(fmt, args...) ({ \\\n    char const *r_fmt; \\\n    asm(\"mov %0,pc; b 0f; \\\n        .asciz \\\"\" fmt \"\\\"; .balign 4; \\\n      0: \" \\\n/*out*/ : \"=r\"(r_fmt) ); \\\n    dprintf(r_fmt, args); \\\n})\n#elif defined(__mips__)  /*}{*/\n#define DPRINTF(fmt, args...) ({ \\\n    char const *r_fmt; \\\n    asm(\".set noreorder; bal L%=j; move %0,$31; .set reorder; \\\n        .asciz \\\"\" fmt \"\\\"; .balign 4; \\\n      L%=j: \" \\\n/*out*/ : \"=r\"(r_fmt) \\\n/* in*/ : \\\n/*und*/ : \"ra\"); \\\n    dprintf(r_fmt, args); \\\n})\n#endif  //}\n\nstatic int dprintf(char const *fmt, ...); // forward\n#endif  //}\n\n#ifdef __arm__  //{\nextern unsigned div10(unsigned);\n#endif  //}\n\n#if DEBUG  //{\nvoid dprint8(\n    char const *fmt,\n    void *a, void *b, void *c, void *d,\n    void *e, void *f, void *g, void *h\n)\n{\n    dprintf(fmt, a, b, c, d, e, f, g, h);\n}\n#endif  //}\n\n// In order to make it much easier to move this code at runtime and execute\n// it at an address different from it load address:  there must be no\n// static data, and no string constants.\n\n/*************************************************************************\n// util\n**************************************************************************/\n\n#if 0  //{  save space\n#define ERR_LAB error: exit(127);\n#define err_exit(a) goto error\n#else  //}{  save debugging time\n#define ERR_LAB /*empty*/\nvoid my_bkpt(void const *, ...);\n\nstatic void\nerr_exit(int a)\n{\n    (void)a;  // debugging convenience\n    DPRINTF(\"err_exit %%x\\\\n\", a);\n    my_bkpt((void const *)a);\n    exit(127);\n}\n#endif  //}\n\n/*************************************************************************\n// \"file\" util\n**************************************************************************/\n\ntypedef struct {\n    size_t size;  // must be first to match size[0] uncompressed size\n    char *buf;\n} Extent;\n\n\nstatic void\nxread(Extent *x, char *buf, size_t count)\n{\n    char *p=x->buf, *q=buf;\n    size_t j;\n    if (x->size < count) {\n        err_exit(8);\n    }\n    for (j = count; 0!=j--; ++p, ++q) {\n        *q = *p;\n    }\n    x->buf  += count;\n    x->size -= count;\n}\n\n\n/*************************************************************************\n// UPX & NRV stuff\n**************************************************************************/\n\nextern int f_expand( // .globl in $(ARCH)-linux.elf-so_fold.S\n    nrv_byte const *binfo, nrv_byte *dst, size_t *dstlen);\n\nstatic void\nunpackExtent(\n    Extent *const xi,  // input includes struct b_info\n    Extent *const xo   // output\n)\n{\n    while (xo->size) {\n        DPRINTF(\"unpackExtent xi=(%%p %%p)  xo=(%%p %%p)\\\\n\",\n            xi->size, xi->buf, xo->size, xo->buf);\n        struct b_info h;\n        //   Note: if h.sz_unc == h.sz_cpr then the block was not\n        //   compressible and is stored in its uncompressed form.\n\n        // Read and check block sizes.\n        xread(xi, (char *)&h, sizeof(h));\n        DPRINTF(\"h.sz_unc=%%x  h.sz_cpr=%%x  h.b_method=%%x\\\\n\",\n            h.sz_unc, h.sz_cpr, h.b_method);\n        if (h.sz_unc == 0) {                     // uncompressed size 0 -> EOF\n            if (h.sz_cpr != UPX_MAGIC_LE32)      // h.sz_cpr must be h->magic\n                err_exit(2);\n            if (xi->size != 0)                 // all bytes must be written\n                err_exit(3);\n            break;\n        }\n        if (h.sz_cpr <= 0) {\n            err_exit(4);\nERR_LAB\n        }\n        if (h.sz_cpr > h.sz_unc\n        ||  h.sz_unc > xo->size ) {\n            err_exit(5);\n        }\n        // Now we have:\n        //   assert(h.sz_cpr <= h.sz_unc);\n        //   assert(h.sz_unc > 0 && h.sz_unc <= blocksize);\n        //   assert(h.sz_cpr > 0 && h.sz_cpr <= blocksize);\n\n        if (h.sz_cpr < h.sz_unc) { // Decompress block\n            size_t out_len = h.sz_unc;  // EOF for lzma\n            int const j = f_expand((unsigned char *)xi->buf - sizeof(h),\n                (unsigned char *)xo->buf, &out_len);\n            if (j != 0 || out_len != (nrv_uint)h.sz_unc) {\n                DPRINTF(\"  j=%%x  out_len=%%x  &h=%%p\\\\n\", j, out_len, &h);\n                err_exit(7);\n            }\n            xi->buf  += h.sz_cpr;\n            xi->size -= h.sz_cpr;\n        }\n        else { // copy literal block\n            DPRINTF(\"  copy %%p  %%p  %%p\\\\n\", xi->buf, xo->buf, h.sz_cpr);\n            xi->size += sizeof(h);  // xread(xi, &h, sizeof(h)) was a peek\n            xread(xi, xo->buf, h.sz_cpr);\n        }\n        xo->buf  += h.sz_unc;\n        xo->size -= h.sz_unc;\n    }\n    DPRINTF(\"  end unpackExtent\\\\n\", 0);\n}\n\n#if defined(__i386__) //}{\n#define addr_string(string) ({ \\\n    char const *str; \\\n    asm(\"call 0f; .asciz \\\"\" string \"\\\"; 0: pop %0\" \\\n/*out*/ : \"=r\"(str) ); \\\n    str; \\\n})\n#elif defined(__arm__) //}{\n#define addr_string(string) ({ \\\n    char const *str; \\\n    asm(\"bl 0f; .string \\\"\" string \"\\\"; .balign 4; 0: mov %0,lr\" \\\n/*out*/ : \"=r\"(str) \\\n/* in*/ : \\\n/*und*/ : \"lr\"); \\\n    str; \\\n})\n#else  //}{\n       error;\n#endif  //}\n\n#define ElfW(sym) Elf32_ ## sym\n\nextern char *upx_mmap_and_fd(  // x86_64 Android emulator of i386 is not faithful\n     void *ptr  // desired address\n     , unsigned len  // also pre-allocate space in file\n     , char *pathname  // 0 ==> call get_upxfn_path, which stores if 1st time\n);\n\n#if defined(__i386__)  //{\n// Create (or find) an escape hatch to use when munmapping ourselves the stub.\n// Called by do_xmap to create it; remembered in AT_NULL.d_val\nstatic char *\nmake_hatch(\n    ElfW(Phdr) const *const phdr,\n    char *next_unc,\n    unsigned frag_mask\n)\n{\n    char *hatch = 0;\n    DPRINTF(\"make_hatch %%p %%p %%x\\\\n\", phdr, next_unc, frag_mask);\n    if (phdr->p_type==PT_LOAD && phdr->p_flags & PF_X) {\n        next_unc += phdr->p_memsz - phdr->p_filesz;  // Skip over local .bss\n        frag_mask &= -(long)next_unc;  // bytes left on page\n        unsigned /*const*/ escape = 0xc36180cd;  // \"int $0x80; popa; ret\"\n        if (4 <= frag_mask) {\n            hatch = next_unc;\n            *(long *)&hatch[0] = escape;\n        }\n        else { // Does not fit at hi end of .text, so must use a new page \"permanently\"\n            int mfd = memfd_create(addr_string(\"upx\"), 0);  // the directory entry\n            write(mfd, &escape, 4);\n            hatch = mmap(0, 4, PROT_READ|PROT_EXEC, MAP_PRIVATE, mfd, 0);\n            close(mfd);\n        }\n    }\n    DPRINTF(\"hatch=%%p\\\\n\", hatch);\n    return hatch;\n}\n#elif defined(__arm__)  /*}{*/\nextern unsigned get_sys_munmap(void);\nextern int upxfd_create(void);  // early 32-bit Android lacks memfd_create\n#define SEEK_SET 0\n\nstatic void *\nmake_hatch(\n    ElfW(Phdr) const *const phdr,\n    char *next_unc,\n    unsigned frag_mask\n)\n{\n    unsigned const sys_munmap = get_sys_munmap();\n    unsigned code[2] = {\n        sys_munmap,  // syscall __NR_unmap\n        0xe8bd80ff,  // ldmia sp!,{r0,r1,r2,r3,r4,r5,r6,r7,pc}\n     };\n    unsigned *hatch = 0;\n    DPRINTF(\"make_hatch %%p %%p %%x\\\\n\", phdr, next_unc, frag_mask);\n\n    if (phdr->p_type==PT_LOAD && phdr->p_flags & PF_X) {\n        next_unc += phdr->p_memsz - phdr->p_filesz;  // Skip over local .bss\n        frag_mask &= -(long)next_unc;  // bytes left on page\n        if (sizeof(code) <= frag_mask) {\n            hatch = (unsigned *)(void *)(~3ul & (long)(3+ next_unc));\n            hatch[0] = code[0];\n            hatch[1] = code[1];\n        }\n        else { // Does not fit at hi end of .text, so must use a new page \"permanently\"\n            char *fdmap = upx_mmap_and_fd((void *)0, sizeof(code), 0);\n            unsigned mfd = -1+ (0xfff& (unsigned)fdmap);\n            write(mfd, &code, sizeof(code));\n            hatch = mmap((void *)((unsigned long)fdmap & ~0xffful), sizeof(code),\n                PROT_READ|PROT_EXEC, MAP_PRIVATE, mfd, 0);\n            close(mfd);\n        }\n    }\n    DPRINTF(\"hatch=%%p\\\\n\", hatch);\n    return hatch;\n}\n#elif defined(__mips__)  /*}{*/\nstatic void *\nmake_hatch(\n    ElfW(Phdr) const *const phdr,\n    char *next_unc,\n    unsigned const frag_mask)\n{\n    unsigned xprot = 0;\n    unsigned *hatch = 0;\n    DPRINTF(\"make_hatch %%p %%x %%x\\\\n\",phdr,reloc,frag_mask);\n    if (phdr->p_type==PT_LOAD && phdr->p_flags & PF_X) {\n        if (\n        // Try page fragmentation just beyond .text .\n            ( (hatch = (void *)(phdr->p_memsz + phdr->p_vaddr + reloc)),\n                ( phdr->p_memsz==phdr->p_filesz  // don't pollute potential .bss\n                &&  (3*4)<=(frag_mask & -(int)hatch) ) ) // space left on page\n        // Allocate and use a new page.\n        ||   (  xprot = 1, hatch = mmap(0, PAGE_SIZE, PROT_WRITE|PROT_READ,\n                MAP_PRIVATE|MAP_ANONYMOUS, -1, 0) )\n        ) {\n            hatch[0]= 0x0000000c;  // syscall\n#define RS(r) ((037&(r))<<21)\n#define JR 010\n            hatch[1] = RS(30)|JR;  // jr $30  # s8\n            hatch[2] = 0x00000000;  //   nop\n            if (xprot) {\n                Pprotect(hatch, 3*sizeof(unsigned), PROT_EXEC|PROT_READ);\n            }\n        }\n        else {\n            hatch = 0;\n        }\n    }\n    return hatch;\n}\n#elif defined(__powerpc__)  /*}{*/\nstatic void *\nmake_hatch(\n    ElfW(Phdr) const *const phdr,\n    char *next_unc,\n    unsigned const frag_mask\n{\n    unsigned xprot = 0;\n    unsigned *hatch = 0;\n    DPRINTF(\"make_hatch %%p %%x %%x\\\\n\",phdr,reloc,frag_mask);\n    if (phdr->p_type==PT_LOAD && phdr->p_flags & PF_X) {\n        if (\n        // Try page fragmentation just beyond .text .\n            ( (hatch = (void *)(phdr->p_memsz + phdr->p_vaddr + reloc)),\n                ( phdr->p_memsz==phdr->p_filesz  // don't pollute potential .bss\n                &&  (2*4)<=(frag_mask & -(int)hatch) ) ) // space left on page\n        // Try ElfW(Ehdr).e_ident[8..15] .  warning: 'const' cast away\n        ||   ( (hatch = (void *)(&((ElfW(Ehdr) *)phdr->p_vaddr + reloc)->e_ident[8])),\n                (phdr->p_offset==0) )\n        // Allocate and use a new page.\n        ||   (  xprot = 1, hatch = mmap(0, PAGE_SIZE, PROT_WRITE|PROT_READ,\n                MAP_PRIVATE|MAP_ANONYMOUS, -1, 0) )\n        ) {\n            hatch[0] = 0x44000002;  // sc\n            hatch[1] = 0x4e800020;  // blr\n            if (xprot) {\n                Pprotect(hatch, 2*sizeof(unsigned), PROT_EXEC|PROT_READ);\n            }\n        }\n        else {\n            hatch = 0;\n        }\n    }\n    return hatch;\n}\n#endif  /*}*/\n\n#define bzero(a,b)  __builtin_memset(a,0,b)\n\n// The PF_* and PROT_* bits are {1,2,4}; the conversion table fits in 32 bits.\n#define REP8(x) \\\n    ((x)|((x)<<4)|((x)<<8)|((x)<<12)|((x)<<16)|((x)<<20)|((x)<<24)|((x)<<28))\n#define EXP8(y) \\\n    ((1&(y)) ? 0xf0f0f0f0 : (2&(y)) ? 0xff00ff00 : (4&(y)) ? 0xffff0000 : 0)\n#define PF_TO_PROT(pf) \\\n    ((PROT_READ|PROT_WRITE|PROT_EXEC) & ( \\\n        ( (REP8(PROT_EXEC ) & EXP8(PF_X)) \\\n         |(REP8(PROT_READ ) & EXP8(PF_R)) \\\n         |(REP8(PROT_WRITE) & EXP8(PF_W)) \\\n        ) >> ((pf & (PF_R|PF_W|PF_X))<<2) ))\n\n#define nullptr (void *)0\n\nextern unsigned get_page_mask(void);\nextern void *memcpy(void *dst, void const *src, size_t n);\nextern void *memset(void *dst, unsigned val, size_t n);\n\n#if defined(__powerpc64__) || defined(__powerpc__)  // {\n#define SAVED_SIZE (1<<16)  /* 64 KB */\n#else  // }{\n#define SAVED_SIZE (1<<14)  /* 16 KB: RaspberryPi 5 */\n#endif  // }\n\n#ifndef __arm__  // {\n// Segregate large local array, to avoid code bloat due to large displacements.\nstatic void\nunderlay(unsigned size, char *ptr, unsigned page_mask)\n{\n    unsigned frag = ~page_mask & (unsigned)(long)ptr;\n    if (frag) {\n        unsigned char saved[SAVED_SIZE];\n        ptr -= frag;\n        memcpy(saved, ptr, frag);\n        mmap(ptr, frag + size, PROT_WRITE|PROT_READ,\n            MAP_FIXED|MAP_PRIVATE|MAP_ANONYMOUS, -1, 0);\n        memcpy(ptr, saved, frag);\n    }\n    else { // already page-aligned\n        mmap(ptr, frag + size, PROT_WRITE|PROT_READ,\n            MAP_FIXED|MAP_PRIVATE|MAP_ANONYMOUS, -1, 0);\n    }\n}\n#else  //}{ // use assembler because large local array on __arm__ is horrible\nextern void\nunderlay(unsigned size, char *ptr, unsigned page_mask);\n#endif  //}\n\n// Exchange the bits with values 4 (PF_R, PROT_EXEC) and 1 (PF_X, PROT_READ)\n// Use table lookup into a PIC-string that pre-computes the result.\nunsigned PF_to_PROT(ElfW(Phdr) const *phdr)\n{\n    return 7& addr_string(\"@\\x04\\x02\\x06\\x01\\x05\\x03\\x07\")\n        [phdr->p_flags & (PF_R|PF_W|PF_X)];\n}\n\nunsigned\nfini_SELinux(\n    unsigned size,\n    char *ptr,\n    ElfW(Phdr) const *phdr,\n    unsigned mfd,\n    ElfW(Addr) base\n)\n{\n    DPRINTF(\"fini_SELinux  size=%%p  ptr=%%p  phdr=%%p  mfd=%%p  base=%%p\\\\n\",\n            size, ptr, phdr, mfd, base);\n    if (phdr->p_flags & PF_X) {\n        // Map the contents of mfd as per *phdr.\n\n        Psync(ptr, size, MS_SYNC); // be sure file gets de-compressed bytes\n            // Android 14 gets -EINVAL; ignore it\n\n        Punmap(ptr, size);\n        Pmap(ptr, size, PF_to_PROT(phdr), MAP_FIXED|MAP_PRIVATE, mfd, 0);\n        close(mfd);\n    }\n    else { // easy\n        Pprotect( (char *)(phdr->p_vaddr + base), phdr->p_memsz, PF_to_PROT(phdr));\n    }\n    return 0;\n}\n\nunsigned\nprep_SELinux(unsigned size, char *ptr, ElfW(Addr) page_mask) // returns mfd\n{\n    // Cannot set PROT_EXEC except via mmap() into a region (Linux \"vma\")\n    // that has never had PROT_WRITE.  So use a Linux-only \"memory file\"\n    // to hold the contents.\n    char saved[SAVED_SIZE];\n    char *page = (char *)(page_mask & (ElfW(Addr))ptr);\n    unsigned frag = (unsigned)(ptr - page);\n    if (frag) {\n        memcpy(saved, page, frag);\n    }\n    char *val = upx_mmap_and_fd(page, frag + size, nullptr);\n    unsigned mfd = 0xfff & (unsigned)(ElfW(Addr))val;\n    val -= mfd; --mfd;\n    if (val != page) {\n        my_bkpt((void const *)0x1262, val, page, ptr, frag);\n    }\n    if (frag)\n        write(mfd, saved, frag);  // Save lo fragment of contents on page.\n    return mfd;\n}\n\ntypedef struct {\n    long argc;\n    char **argv;\n    char **envp;\n} So_args;\n\ntypedef struct {\n    unsigned off_reloc;  // distance back to &ElfW(Ehdr)\n    unsigned off_user_DT_INIT;\n    unsigned off_xct_off;  // where un-compressed bytes end\n    unsigned off_info;  //  xct_off: {l_info; p_info; b_info; compressed data)\n} So_info;\n\n/*************************************************************************\n// upx_so_main - called by our folded entry code\n**************************************************************************/\n\nvoid *\nupx_so_main(  // returns &escape_hatch\n    So_info *so_info,\n    So_args *so_args,\n    ElfW(Ehdr) *elf_tmp  // scratch for ElfW(Ehdr) and ElfW(Phdrs)\n)\n{\n    ElfW(Addr) const page_mask = get_page_mask();\n    char *const va_load = (char *)&so_info->off_reloc - so_info->off_reloc;\n    So_info so_infc;  // So_info Copy\n    memcpy(&so_infc, so_info, sizeof(so_infc));  // before de-compression overwrites\n    unsigned const xct_off = so_infc.off_xct_off;  (void)xct_off;\n\n    char *const cpr_ptr = so_info->off_info + va_load;\n    unsigned const cpr_len = (char *)so_info - cpr_ptr;\n    typedef void (*Dt_init)(int argc, char *argv[], char *envp[]);\n    Dt_init const dt_init = (Dt_init)(void *)(so_info->off_user_DT_INIT + va_load);\n    DPRINTF(\"upx_so_main  va_load=%%p  so_info= %%p  so_infc=%%p  cpr_ptr=%%p  cpr_len=%%x  xct_off=%%x  dt_init=%%p\\\\n\",\n        va_load, so_info, &so_infc, cpr_ptr, cpr_len, xct_off, dt_init);\n    // DO NOT USE *so_info AFTER THIS!!  It gets overwritten.\n\n    // Copy compressed data before de-compression overwrites it.\n    char *const sideaddr = mmap(nullptr, cpr_len, PROT_WRITE|PROT_READ,\n        MAP_PRIVATE|MAP_ANONYMOUS, -1, 0);\n    DPRINTF(\"&sideaddr=%%p\\\\n\", &sideaddr);\n    memcpy(sideaddr, cpr_ptr, cpr_len);\n\n    // Transition to copied data\n    struct b_info *binfo = (struct b_info *)(void *)(sideaddr +\n        sizeof(struct l_info) + sizeof(struct p_info));\n    DPRINTF(\"upx_so_main  va_load=%%p  sideaddr=%%p  b_info=%%p\\\\n\",\n        va_load, sideaddr, binfo);\n\n    // All the destination page frames exist or have been reserved,\n    // but the access permissions may be wrong and the data may be compressed.\n    // Also, rtld maps the convex hull of all PT_LOAD but assumes that the\n    // file supports those pages, even though the pages might lie beyond EOF.\n    // If so, then Pprotect() is not enough: SIGBUS will occur.  Thus we\n    // must mmap anonymous pages, except for first PT_LOAD with ELF headers.\n    // So the general strategy (for each PT_LOAD) is:\n    //   Save any contents on low end of destination page (the \"prefix\" pfx).\n    //   mmap(,, PROT_WRITE|PROT_READ, MAP_FIXED|MAP_PRIVATE|MAP_ANONYMOUS, -1, 0);\n    //   Restore the prefix on the first destination page.\n    //   De-compress from remaining [sideaddr, +sidelen).\n    //   Pprotect(,, PF_TO_PROT(.p_flags));\n\n    // Get the uncompressed ElfW(Ehdr) and ElfW(Phdr)\n    // The first b_info is aligned, so direct access to fields is OK.\n    Extent x1 = {binfo->sz_unc, (char *)elf_tmp};  // destination\n    Extent x0 = {binfo->sz_cpr + sizeof(*binfo), (char *)binfo};  // source\n    unpackExtent(&x0, &x1);  // de-compress _Ehdr and _Phdrs; x0.buf is updated\n\n    ElfW(Phdr) const *phdr = (ElfW(Phdr) *)(1+ elf_tmp);\n    ElfW(Phdr) const *const phdrN = &phdr[elf_tmp->e_phnum];\n\n    // Process each read-only PT_LOAD.\n    // A read+write PT_LOAD might be relocated by rtld before de-compression,\n    // so it cannot be compressed.\n    void *hatch = nullptr;\n    ElfW(Addr) base = 0;\n    int n_load = 0;\n\n    for (; phdr < phdrN; ++phdr)\n    if (phdr->p_type == PT_LOAD && !(phdr->p_flags & PF_W)) {\n        if  (!base) {\n            base = (ElfW(Addr))va_load - phdr->p_vaddr;\n            DPRINTF(\"base= %%p\\\\n\", base);\n        }\n        unsigned const va_top = phdr->p_filesz + phdr->p_vaddr;\n        // Need un-aligned read of b_info to determine compression sizes.\n        struct b_info al_bi;  // for aligned data from binfo\n        x0.size = sizeof(struct b_info);\n        xread(&x0, (char *)&al_bi, x0.size);  // aligned binfo\n        x0.buf -= sizeof(al_bi);  // back up (the xread() was a peek)\n        x0.size = al_bi.sz_cpr;\n        x1.size = al_bi.sz_unc;\n        x1.buf = (void *)(va_top + base - al_bi.sz_unc);\n\n        DPRINTF(\"\\\\nphdr@%%p  p_offset=%%p  p_vaddr=%%p  p_filesz=%%p  p_memsz=%%p\\\\n\",\n            phdr, phdr->p_offset, phdr->p_vaddr, phdr->p_filesz, phdr->p_memsz);\n        DPRINTF(\"x0=%%p  x1=%%p\\\\n\", &x0, &x1);\n\n        if ((phdr->p_filesz + phdr->p_offset) <= xct_off) { // va_top <= xct_off\n            if (!n_load) {\n                ++n_load;\n                continue;  // 1st PT_LOAD is non-compressed loader tables ONLY!\n            }\n        }\n\n        int mfd = 0;\n        if (phdr->p_flags & PF_X) {\n            mfd = prep_SELinux(x1.size, x1.buf, page_mask);\n        }\n        else {\n            underlay(x1.size, x1.buf, page_mask);  // also makes PROT_WRITE\n        }\n        Extent xt = x1;\n        unpackExtent(&x0, &x1);  // updates *x0 and *x1\n        if (!hatch && phdr->p_flags & PF_X) {\n            hatch = make_hatch(phdr, x1.buf, ~page_mask);\n            fini_SELinux(xt.size, xt.buf, phdr, mfd, base);\n        }\n        ++n_load;\n    }\n\n    DPRINTF(\"Punmap sideaddr=%%p  cpr_len=%%p\\\\n\", sideaddr, cpr_len);\n    Punmap(sideaddr, cpr_len);\n    DPRINTF(\"calling user DT_INIT %%p\\\\n\", dt_init);\n    dt_init(so_args->argc, so_args->argv, so_args->envp);\n\n    DPRINTF(\"returning hatch=%%p\\\\n\", hatch);\n    return hatch;\n}\n\n#if DEBUG  //{\n\n#if defined(__powerpc64__) //{\n#define __NR_write 4\n\ntypedef unsigned long size_t;\n\n#if 0  //{\nstatic int\nwrite(int fd, char const *ptr, size_t len)\n{\n    register  int        sys asm(\"r0\") = __NR_write;\n    register  int         a0 asm(\"r3\") = fd;\n    register void const  *a1 asm(\"r4\") = ptr;\n    register size_t const a2 asm(\"r5\") = len;\n    __asm__ __volatile__(\"sc\"\n    : \"=r\"(a0)\n    : \"r\"(sys), \"r\"(a0), \"r\"(a1), \"r\"(a2)\n    : \"r0\", \"r4\", \"r5\", \"r6\", \"r7\", \"r8\", \"r9\", \"r10\", \"r11\", \"r12\", \"r13\"\n    );\n    return a0;\n}\n#else //}{\nssize_t\nwrite(int fd, void const *ptr, size_t len)\n{\n    register  int        sys asm(\"r0\") = __NR_write;\n    register  int         a0 asm(\"r3\") = fd;\n    register void const  *a1 asm(\"r4\") = ptr;\n    register size_t       a2 asm(\"r5\") = len;\n    __asm__ __volatile__(\"sc\"\n    : \"+r\"(sys), \"+r\"(a0), \"+r\"(a1), \"+r\"(a2)\n    :\n    : \"r6\", \"r7\", \"r8\", \"r9\", \"r10\", \"r11\", \"r12\", \"r13\"\n    );\n    return a0;\n}\n#endif  //}\n#endif  //}\n\nstatic int\nunsimal(unsigned x, char *ptr, int n)\n{\n    unsigned m = 10;\n    while (10 <= (x / m)) m *= 10;\n    while (10 <= x) {\n        unsigned d = x / m;\n        x -= m * d;\n        m /= 10;\n        ptr[n++] = '0' + d;\n    }\n    ptr[n++] = '0' + x;\n    return n;\n}\n\nstatic int\ndecimal(int x, char *ptr, int n)\n{\n    if (x < 0) {\n        ptr[n++] = '-';\n    }\n    return unsimal(-x, ptr, n);\n}\n\nstatic int\nheximal(unsigned long x, char *ptr, int n)\n{\n    unsigned j = -1+ 2*sizeof(unsigned long);\n    unsigned long m = 0xful << (4 * j);\n    for (; j; --j, m >>= 4) { // omit leading 0 digits\n        if (m & x) break;\n    }\n    for (; m; --j, m >>= 4) {\n        unsigned d = 0xf & (x >> (4 * j));\n        ptr[n++] = ((10<=d) ? ('a' - 10) : '0') + d;\n    }\n    return n;\n}\n\n#define va_arg      __builtin_va_arg\n#define va_end      __builtin_va_end\n#define va_list     __builtin_va_list\n#define va_start    __builtin_va_start\n\nstatic int\ndprintf(char const *fmt, ...)\n{\n    int n= 0;\n    char const *literal = 0;  // NULL\n    char buf[24];  // ~0ull == 18446744073709551615 ==> 20 chars\n    va_list va; va_start(va, fmt);\n    for (;;) {\n        char c = *fmt++;\n        if (!c) { // end of fmt\n            if (literal) {\n                goto finish;\n            }\n            break;  // goto done\n        }\n        if ('%'!=c) {\n            if (!literal) {\n                literal = fmt;  // 1 beyond start of literal\n            }\n            continue;\n        }\n        // '%' == c\n        if (literal) {\nfinish:\n            n += write(2, -1+ literal, fmt - literal);\n            literal = 0;  // NULL\n            if (!c) { // fmt already ended\n               break;  // goto done\n            }\n        }\n        switch (c= *fmt++) { // deficiency: does not handle _long_\n        default: { // un-implemented conversion\n            n+= write(2, -1+ fmt, 1);\n        } break;\n        case 0: { // fmt ends with \"%\\0\" ==> ignore\n            goto done;\n        } break;\n        case 'u': {\n            n+= write(2, buf, unsimal((unsigned)(unsigned long)va_arg(va, void *), buf, 0));\n        } break;\n        case 'd': {\n            n+= write(2, buf, decimal((int)(unsigned long)va_arg(va, void *), buf, 0));\n        } break;\n        case 'p': {\n            buf[0] = '0';\n            buf[1] = 'x';\n            n+= write(2, buf, heximal((unsigned long)va_arg(va, void *), buf, 2));\n        } break;\n        case 'x': {\n            buf[0] = '0';\n            buf[1] = 'x';\n            n+= write(2, buf, heximal((unsigned)(unsigned long)va_arg(va, void *), buf, 2));\n        } break;\n        } // 'switch'\n    }\ndone:\n    va_end(va);\n    return n;\n }\n#endif  //}\n\n/* vim:set ts=4 sw=4 et: */\n","size_bytes":26329},"src/stub/src/i386-linux.elf.execve-main.c":{"content":"/* i386-linux.elf.execve-main.c -- generic stub loader for Linux using execve()\n\n   This file is part of the UPX executable compressor.\n\n   Copyright (C) 1996-2025 Markus Franz Xaver Johannes Oberhumer\n   Copyright (C) 1996-2025 Laszlo Molnar\n   All Rights Reserved.\n\n   UPX and the UCL library are free software; you can redistribute them\n   and/or modify them under the terms of the GNU General Public License as\n   published by the Free Software Foundation; either version 2 of\n   the License, or (at your option) any later version.\n\n   This program is distributed in the hope that it will be useful,\n   but WITHOUT ANY WARRANTY; without even the implied warranty of\n   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n   GNU General Public License for more details.\n\n   You should have received a copy of the GNU General Public License\n   along with this program; see the file COPYING.\n   If not, write to the Free Software Foundation, Inc.,\n   59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.\n\n   Markus F.X.J. Oberhumer              Laszlo Molnar\n   <markus@oberhumer.com>               <ezerotven+github@gmail.com>\n\n   John F. Reiser\n   <jreiser@users.sourceforge.net>\n */\n\n\n#include \"include/linux.h\"\n\n\n/*************************************************************************\n// configuration section\n**************************************************************************/\n\n// mmap() the temporary output file\n#define USE_MMAP_FO 1\n\n\n/*************************************************************************\n// file util\n**************************************************************************/\n\nstruct Extent {\n    int  size;  // must be first to match size[0] uncompressed size\n    char *buf;\n};\n\n\n#if !(USE_MMAP_FO)\n#if 1\nstatic __inline__ int xwrite(int fd, const void *buf, int count)\n{\n    // note: we can assert(count > 0);\n    do {\n        int n = write(fd, buf, count);\n        if (n == -EINTR)\n            continue;\n        if (n <= 0)\n            break;\n        buf += n;               // gcc extension: add to void *\n        count -= n;\n    } while (count > 0);\n    return count;\n}\n#else\n#define xwrite(fd,buf,count)    ((count) - write(fd,buf,count))\n#endif\n#endif /* !USE_MMAP_FO */\n\n\n/*************************************************************************\n// util\n**************************************************************************/\n\n#if 1\n\nextern char *\n__attribute__((regparm(2), stdcall))  // be ruthless\nupx_itoa(unsigned long v, char *buf);\n\n#else\n\n// Some versions of gcc optimize the division and/or remainder using\n// a multiplication by (2**32)/10, and use a relocatable 32-bit address\n// to reference the constant.  We require no relocations because we move\n// the code at runtime.  See upx_itoa.S for replacement [also smaller.]\nstatic char *upx_itoa(unsigned long v, char *buf)\n{\n//    const unsigned TEN = 10;\n    volatile unsigned TEN = 10;  // an ugly way to achieve no relocation\n    char *p = buf;\n    {\n        unsigned long k = v;\n        do {\n            p++;\n            k /= TEN;\n        } while (k > 0);\n    }\n    buf = p;\n    *p = 0;\n    {\n        unsigned long k = v;\n        do {\n            *--p = '0' + k % TEN;\n            k /= TEN;\n        } while (k > 0);\n    }\n    return buf;\n}\n\n#endif\n\n\nstatic uint32_t ascii5(char *p, uint32_t v, unsigned n)\n{\n    do {\n        unsigned char d = v % 32;\n        if (d >= 26) d -= 43;       // 43 == 'Z' - '0' + 1\n        *--p = (d += 'A');\n        v /= 32;\n    } while (--n > 0);\n    return v;\n}\n\n\n#if defined(__i386__)\n#  define SET2(p, c0, c1) \\\n        * (unsigned short *) (p) = ((c1)<<8 | (c0))\n#  define SET4(p, c0, c1, c2, c3) \\\n        * (uint32_t *) (p) = ((c3)<<24 | (c2)<<16 | (c1)<<8 | (c0))\n#  define SET3(p, c0, c1, c2) \\\n        SET4(p, c0, c1, c2, 0)\n#else\n#  define SET2(p, c0, c1) \\\n        (p)[0] = c0, (p)[1] = c1\n#  define SET3(p, c0, c1, c2) \\\n        (p)[0] = c0, (p)[1] = c1, (p)[2] = c2\n#  define SET4(p, c0, c1, c2, c3) \\\n        (p)[0] = c0, (p)[1] = c1, (p)[2] = c2, (p)[3] = c3\n#endif\n\n\n// go_self is a separate subroutine to spread the burden of local arrays.\n// Otherwise the size of the stack frame in upx_main exceeds 128 bytes,\n// which causes too many offsets to expand from 1 byte to 4.\n\nstatic int\n#if (ACC_CC_GNUC >= 0x030300)\n__attribute__((__noinline__, __used__, __stdcall__))\n#endif\ngo_self(char const *tmpname, char *argv[], char *envp[])\n{\n    // Old FreeBSD does not have /proc/self, so use /proc/<pid> instead.\n\n    // Open the temp file.\n    int const fdi = open(tmpname, O_RDONLY, 0);\n\n    if (0 <= fdi) {\n        // 17 chars for \"/proc/PPPPP/fd/XX\" should be enough, but we\n        // play safe in case there will be 32-bit pid_t at some time.\n        //char procself_buf[17+1];\n        char procself_buf[31+1];\n\n        // Compute name of temp fdi.\n        SET4(procself_buf + 0, '/', 'p', 'r', 'o');\n        SET4(procself_buf + 4, 'c', '/',  0 ,  0 );\n        {\n            char *const procself = upx_itoa(getpid(), procself_buf + 6);\n            SET4(procself, '/', 'f', 'd', '/');\n            upx_itoa(fdi, procself + 4);\n        }\n\n        // Check for working /proc/self/fd/X by accessing the\n        // temp file again, now via temp fdi.\n        if (UPX2 == (unsigned) access(procself_buf, R_OK | X_OK)) {\n            // Now it's safe to unlink the temp file (as it is still open).\n            unlink(tmpname);\n            // Set the file close-on-exec.\n            fcntl(fdi, F_SETFD, FD_CLOEXEC);\n            // Execute the original program via /proc/self/fd/X.\n            execve(procself_buf, argv, envp);\n            // NOTE: if we get here we've lost.\n\n            // 2008-March: Ubuntu 7.10 linux-image-2.6.22-14.52-generic\n            // and SuSE 10.3 have a patch to fs/dcache.c which causes\n            // execve() [above] to fail with ENOENT.\n            // Fedora kernel-2.6.22.14-72.fc6 omits the patch, and works:\n// https://sourceforge.net/tracker/?func=detail&atid=102331&aid=1825006&group_id=2331\n\n            // Now we must re-create the file; it was unlink()ed!\n            // link(procself_buf, tmpname) gets EXDEV (cross-device link).\n            // Luckily we still have an open fdi to the file.\n            // Errors from {lseek, mmap, open, write} are all caught\n            // by the one check on write().\n            unsigned const lenf = lseek(fdi, 0, SEEK_END);\n            char *const buf = mmap((char *)0, lenf, PROT_READ|PROT_WRITE,\n                MAP_PRIVATE, fdi, 0);\n            int const fdo = open(tmpname, O_WRONLY | O_CREAT | O_EXCL, 0700);\n            if (lenf!=(unsigned)write(fdo, buf, lenf)) {\n                exit(127);\n            }\n            close(fdo);\n        }\n\n        // The proc filesystem isn't working. No problem.\n        close(fdi);\n    }\n    return fdi;\n}\n\n\n/*************************************************************************\n// UPX & NRV stuff\n**************************************************************************/\n\ntypedef void f_unfilter(\n    nrv_byte *,  // also addvalue\n    nrv_uint,\n    unsigned cto8  // junk in high 24 bits\n);\ntypedef int f_expand(\n    const nrv_byte *src, nrv_uint  src_len,\n          nrv_byte *dst, nrv_uint *dst_len, int method );\n\n\nvoid my_bkpt(int rv)\n{\n#if defined(__i386__)  //{\n    __asm__(\"int3\");\n#endif  //}\n    (void)rv;\n}\n#define error1(rv) {my_bkpt(rv); goto error1;}\n#define error(rv)  {my_bkpt(rv); goto error;}\n\n/*************************************************************************\n// upx_main - called by our entry code\n//\n// This function is optimized for size.\n**************************************************************************/\n\nvoid upx_main(\n    struct Extent xi,\n    f_expand *const f_decompress,\n    int junk2,\n    f_unfilter *const f_unf,\n    char *envp[],\n    char *argv[],\n    int argc\n) __asm__(\"upx_main\");\nvoid upx_main(\n    struct Extent xi,\n    f_expand *const f_decompress,\n    int junk,\n    f_unfilter *const f_unf,\n    char *envp[],\n    char *argv[],\n    int argc\n)\n{\n    // file descriptor\n    int fdo;\n\n    // decompression buffer\n    unsigned char *buf;\n\n    char *tmpname;\n    struct p_info header;\n\n    // temporary file name\n    char tmpname_buf[20];\n\n    (void)junk;\n\n    //\n    // ----- Step 0: set /proc/self using /proc/<pid> -----\n    //\n\n    //personality(PER_LINUX);\n\n\n    //\n    // ----- Step 1: prepare input file -----\n    //\n\n    // Read header.\n    {\n        register char *__d0, *__d1;\n        __asm__ __volatile__( \"movsl; movsl; movsl\"\n            : \"=&D\" (__d0), \"=&S\" (__d1)\n            : \"0\" (&header), \"1\" (xi.buf)\n            : \"memory\");\n        xi.buf   = __d1;\n        xi.size -= sizeof(header);\n    }\n\n    // Paranoia. Make sure this is actually our expected executable\n    // by checking the random program id. (The id is both stored\n    // in the header and patched into this stub.)\n    if (header.p_progid != UPX3)\n        error1(11);\n\n\n    //\n    // ----- Step 2: prepare temporary output file -----\n    //\n\n    tmpname = tmpname_buf;\n    SET4(tmpname + 0, '/', 't', 'm', 'p');\n    SET4(tmpname + 4, '/', 'u', 'p', 'x');\n\n    // Compute name of temporary output file in tmpname[].\n    // Protect against Denial-of-Service attacks.\n    {\n        char *p = tmpname_buf + sizeof(tmpname_buf) - 1;\n\n        // Compute the last 4 characters (20 bits) from getpid().\n        uint32_t r = ascii5(p, (uint32_t)getpid(), 4); *p = '\\0'; p -= 4;\n\n        // Provide 4 random bytes from our program id.\n        r ^= header.p_progid;\n        // Mix in 4 runtime random bytes.\n        // Don't consume precious bytes from /dev/urandom.\n        {\n#if 1\n            struct timeval tv;\n            gettimeofday(&tv, 0);\n            r ^= (uint32_t) tv.tv_sec;\n            r ^= ((uint32_t) tv.tv_usec) << 12;      // shift into high-bits\n#else\n            // using adjtimex() may cause portability problems\n            struct timex tx;\n            adjtimex(&tx);\n            r ^= (uint32_t) tx.time.tv_sec;\n            r ^= ((uint32_t) tx.time.tv_usec) << 12; // shift into high-bits\n            r ^= (uint32_t) tx.errcnt;\n#endif\n        }\n        // Compute 7 more characters from the 32 random bits.\n        ascii5(p, r, 7);\n    }\n\n    // Just in case, remove the file.\n    {\n        int err = unlink(tmpname);\n        if (err != -ENOENT && err != 0)\n            error1(12);\n    }\n\n    // Create the temporary output file.\n#if (USE_MMAP_FO)\n    fdo = open(tmpname, O_RDWR | O_CREAT | O_EXCL, 0700);\n#else\n    fdo = open(tmpname, O_WRONLY | O_CREAT | O_EXCL, 0700);\n#endif\n#if 0\n    // Save some bytes of code - the ftruncate() below will fail anyway.\n    if (fdo < 0)\n        error(13);\n#endif\n\n    // Set expected uncompressed file size.\n    if (ftruncate(fdo, header.p_filesize) != 0)\n        error(14);\n\n\n    //\n    // ----- Step 3: setup memory -----\n    //\n\n#if (USE_MMAP_FO)\n    // FIXME: packer could set length\n    // Ask for one page more to reserve placement.\n    buf = (unsigned char *)mmap(0, header.p_filesize -PAGE_MASK,\n        PROT_READ | PROT_WRITE, MAP_SHARED, fdo, 0);\n    if ((unsigned long) buf >= (unsigned long) -4095)\n        error(15);\n\n    // Decompressor can overrun the output by 3 bytes.\n    // Defend against SIGSEGV by using a scratch page.\n    // FIXME: packer could set address delta\n    mmap(buf + (PAGE_MASK & (header.p_filesize + ~PAGE_MASK)),\n        -PAGE_MASK, PROT_READ | PROT_WRITE,\n        MAP_FIXED | MAP_PRIVATE | MAP_ANONYMOUS, -1, 0 );\n#else\n    // Temporary decompression buffer.\n    // FIXME: packer could set length\n    buf = mmap(0, (header.p_blocksize + OVERHEAD + ~PAGE_MASK) & PAGE_MASK,\n        PROT_READ | PROT_WRITE, MAP_PRIVATE | MAP_ANONYMOUS, -1, 0 );\n    if ((unsigned long) buf >= (unsigned long) -4095)\n        error(16);\n#endif\n\n    //\n    // ----- Step 4: decompress blocks -----\n    //\n\n    for (;;)\n    {\n        struct b_info h;\n\n        // Read and check block sizes.\n        {\n            register char *__d0, *__d1;\n            __asm__ __volatile__( \"movsl; movsl; movsl\"\n                : \"=&D\" (__d0), \"=&S\" (__d1)\n                : \"0\" (&h), \"1\" (xi.buf)\n                : \"memory\");\n            xi.buf   = __d1;\n            xi.size -= sizeof(h);\n        }\n        if (h.sz_unc == 0)                      // uncompressed size 0 -> EOF\n        {\n            if (h.sz_cpr != UPX_MAGIC_LE32)     // h.sz_cpr must be h->magic\n                error(17);\n            if (header.p_filesize != 0)         // all bytes must be written\n                error(18);\n            break;\n        }\n        //   Note: if sz_unc == sz_cpr then the block was not\n        //   compressible and is stored in its uncompressed form.\n\n        if (h.sz_cpr > h.sz_unc || h.sz_cpr > header.p_blocksize)\n            error(19);\n        // Now we have:\n        //   assert(h.sz_cpr <= h.sz_unc);\n        //   assert(h.sz_unc > 0 && h.sz_unc <= blocksize);\n        //   assert(h.sz_cpr > 0 && h.sz_cpr <= blocksize);\n\n        if (h.sz_cpr < h.sz_unc) { // Decompress block.\n            nrv_uint out_len = h.sz_unc;  // EOF for lzma\n            int i = (*f_decompress)((unsigned char *)xi.buf, h.sz_cpr, buf,\n                &out_len, *(int *)(void *)&h.b_method);\n            if (i != 0 || out_len != (nrv_uint)h.sz_unc)\n                error(20);\n            // Right now, unfilter is combined with decompression.\n            // (*f_unfilter)(buf, out_len, cto8);\n            (void)f_unf;\n        }\n        else\n        {\n            // Incompressible block\n#if (USE_MMAP_FO)\n            //memcpy(buf, xi.buf, h.sz_unc);\n            register unsigned long int __d0, __d1, __d2;\n            __asm__ __volatile__( \"rep; movsb\"\n                : \"=&c\" (__d0), \"=&D\" (__d1), \"=&S\" (__d2)\n                : \"0\" (h.sz_unc), \"1\" (buf), \"2\" (xi.buf)\n                : \"memory\");\n#endif\n        }\n\n#if (USE_MMAP_FO)\n        // unmap part of the output\n        munmap(buf, h.sz_unc);\n        buf     += h.sz_unc;\n#else\n        // write output file\n        if (xwrite(fdo, buf, h.sz_unc) != 0)\n            error(21);\n#endif\n\n        header.p_filesize -= h.sz_unc;\n\n        xi.buf  += h.sz_cpr;\n        xi.size -= h.sz_cpr;\n\n        if (xi.size < 0) {\n// error exit is here in the middle to keep the jumps short.\n        error:\n            (void) unlink(tmpname);\n        error1:\n            // Note: the kernel will close all open files and\n            //       unmap any allocated memory.\n            for (;;)\n                (void) exit(127);\n        }\n    }\n\n    //\n    // ----- Step 5: release resources -----\n    //\n\n\n#if !(USE_MMAP_FO)\n    // Free our temporary decompression buffer.\n    munmap(buf, malloc_args.ma_length);\n#endif\n\n    if (close(fdo) != 0)\n        error(22);\n\n\n    //\n    // ----- Step 6: try to start program via /proc/self/fd/X -----\n    //\n\n    // Many thanks to Andi Kleen <ak@muc.de> and\n    // Jamie Lokier <nospam@cern.ch> for this nice idea.\n\n    if (0 > go_self(tmpname, argv, envp))\n        error(23);\n\n\n    //\n    // ----- Step 7: start program in /tmp  -----\n    //\n\n    // Fork off a subprocess to clean up.\n    // We have to do this double-fork trick to keep a zombie from\n    // hanging around if the spawned original program doesn't check for\n    // subprocesses (as well as to prevent the real program from getting\n    // confused about this subprocess it shouldn't have).\n    // Thanks to Adam Ierymenko <api@one.net> for this solution.\n\n    if (fork() == 0)\n    {\n        if (fork() == 0)\n        {\n            // Sleep 3 seconds, then remove the temp file.\n            struct timespec ts; ts.tv_sec = UPX4; ts.tv_nsec = 0;\n            nanosleep(&ts, 0);\n            unlink(tmpname);\n        }\n        exit(0);\n    }\n\n    // Wait for the first fork()'d process to die.\n    waitpid(-1, (int *)0, 0);\n\n    // Execute the original program.\n    (void)argc;\n    execve(tmpname, argv, envp);\n\n\n    //\n    // ----- Step 8: error exit -----\n    //\n\n    // If we return from execve() there was an error. Give up.\n    error(24);\n}\n\n/* vim:set ts=4 sw=4 et: */\n","size_bytes":15975},"src/stub/src/i386-linux.elf.interp-main.c":{"content":"/* i386-linux.elf.interp-main.c -- stub loader for Linux x86 separate PT_INTERP\n\n   This file is part of the UPX executable compressor.\n\n   Copyright (C) 1996-2025 Markus Franz Xaver Johannes Oberhumer\n   Copyright (C) 1996-2025 Laszlo Molnar\n   Copyright (C) 2000-2025 John F. Reiser\n   All Rights Reserved.\n\n   UPX and the UCL library are free software; you can redistribute them\n   and/or modify them under the terms of the GNU General Public License as\n   published by the Free Software Foundation; either version 2 of\n   the License, or (at your option) any later version.\n\n   This program is distributed in the hope that it will be useful,\n   but WITHOUT ANY WARRANTY; without even the implied warranty of\n   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n   GNU General Public License for more details.\n\n   You should have received a copy of the GNU General Public License\n   along with this program; see the file COPYING.\n   If not, write to the Free Software Foundation, Inc.,\n   59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.\n\n   Markus F.X.J. Oberhumer              Laszlo Molnar\n   <markus@oberhumer.com>               <ezerotven+github@gmail.com>\n\n   John F. Reiser\n   <jreiser@users.sourceforge.net>\n */\n\n\n#include \"include/linux.h\"\n\n\n/*************************************************************************\n// configuration section\n**************************************************************************/\n\n// In order to make it much easier to move this code at runtime and execute\n// it at an address different from it load address:  there must be no\n// static data, and no string constants.\n\n#include \"MAX_ELF_HDR.c\"\n\n\n/*************************************************************************\n// \"file\" util\n**************************************************************************/\n\nstruct Extent {\n    size_t size;  // must be first to match size[0] uncompressed size\n    char *buf;\n};\n\n\nstatic void\n#if (ACC_CC_GNUC >= 0x030300)\n__attribute__((__noinline__, __used__, regparm(3), stdcall))\n#endif\nxread(struct Extent *x, char *buf, size_t count)\n{\n    char *p=x->buf, *q=buf;\n    size_t j;\n    if (x->size < count) {\n        exit(127);\n    }\n    for (j = count; 0!=j--; ++p, ++q) {\n        *q = *p;\n    }\n    x->buf  += count;\n    x->size -= count;\n}\n\n\n/*************************************************************************\n// util\n**************************************************************************/\n\n#if 1  //{  save space\n#define ERR_LAB error: exit(127);\n#define err_exit(a) goto error\n#else  //}{  save debugging time\n#define ERR_LAB /*empty*/\nstatic void\nerr_exit(int a)\n{\n    (void)a;  // debugging convenience\n    exit(127);\n}\n#endif  //}\n\nstatic void *\ndo_brk(void *addr)\n{\n    return brk(addr);\n}\n\n/*************************************************************************\n// UPX & NRV stuff\n**************************************************************************/\n\ntypedef void f_unfilter(\n    nrv_byte *,  // also addvalue\n    nrv_uint,\n    unsigned cto8 // junk in high 24 bits\n);\ntypedef int f_expand(\n    const nrv_byte *, nrv_uint,\n          nrv_byte *, nrv_uint *, int method\n);\n\nstatic void\nunpackExtent(\n    struct Extent *const xi,  // input\n    struct Extent *const xo,  // output\n    f_expand   *(*get_fexp(int)),\n    f_unfilter *(*get_funf(int))\n)\n{\n    while (xo->size) {\n        struct b_info h;\n        //   Note: if h.sz_unc == h.sz_cpr then the block was not\n        //   compressible and is stored in its uncompressed form.\n\n        // Read and check block sizes.\n        xread(xi, (char *)&h, sizeof(h));\n        if (h.sz_unc == 0) {                     // uncompressed size 0 -> EOF\n            if (h.sz_cpr != UPX_MAGIC_LE32)      // h.sz_cpr must be h->magic\n                err_exit(2);\n            if (xi->size != 0)                 // all bytes must be written\n                err_exit(3);\n            break;\n        }\n        if (h.sz_cpr <= 0) {\n            err_exit(4);\nERR_LAB\n        }\n        if (h.sz_cpr > h.sz_unc\n        ||  h.sz_unc > xo->size ) {\n            err_exit(5);\n        }\n        // Now we have:\n        //   assert(h.sz_cpr <= h.sz_unc);\n        //   assert(h.sz_unc > 0 && h.sz_unc <= blocksize);\n        //   assert(h.sz_cpr > 0 && h.sz_cpr <= blocksize);\n\n        if (h.sz_cpr < h.sz_unc) { // Decompress block\n            nrv_uint out_len = h.sz_unc;  // EOF for lzma\n            int const j = (*get_fexp(h.b_method))((unsigned char *)xi->buf, h.sz_cpr,\n                (unsigned char *)xo->buf, &out_len, *(int *)(void *)&h.b_method);\n            if (j != 0 || out_len != (nrv_uint)h.sz_unc)\n                err_exit(7);\n            if (h.b_ftid!=0) {\n                (*get_funf(h.b_ftid))((unsigned char *)xo->buf, out_len, h.b_cto8);\n            }\n            xi->buf  += h.sz_cpr;\n            xi->size -= h.sz_cpr;\n        }\n        else { // copy literal block\n            xi->size += sizeof(h);  // xread(xi, &h, sizeof(h)) was a peek\n            xread(xi, xo->buf, h.sz_cpr);\n        }\n        xo->buf  += h.sz_unc;\n        xo->size -= h.sz_unc;\n    }\n}\n\n// Create (or find) an escape hatch to use when munmapping ourselves the stub.\n// Called by do_xmap to create it, and by assembler code to find it.\nstatic void *\nmake_hatch(Elf32_Phdr const *const phdr)\n{\n    unsigned *hatch = 0;\n    if (phdr->p_type==PT_LOAD && phdr->p_flags & PF_X) {\n        // The format of the 'if' is\n        //  if ( ( (hatch = loc1), test_loc1 )\n        //  ||   ( (hatch = loc2), test_loc2 ) ) {\n        //      action\n        //  }\n        // which uses the comma to save bytes when test_locj involves locj\n        // and the action is the same when either test succeeds.\n\n        // Try page fragmentation just beyond .text .\n        if ( ( (hatch = (void *)(phdr->p_memsz + phdr->p_vaddr)),\n                ( phdr->p_memsz==phdr->p_filesz  // don't pollute potential .bss\n                &&  4<=(~PAGE_MASK & -(int)hatch) ) ) // space left on page\n        // Try Elf32_Ehdr.e_ident[12..15] .  warning: 'const' cast away\n        ||   ( (hatch = (void *)(&((Elf32_Ehdr *)phdr->p_vaddr)->e_ident[12])),\n                (phdr->p_offset==0) ) ) {\n            // Omitting 'const' saves repeated literal in gcc.\n            unsigned /*const*/ escape = 0xc36180cd;  // \"int $0x80; popa; ret\"\n            // Don't store into read-only page if value is already there.\n            if (* (volatile unsigned*) hatch != escape) {\n                * hatch  = escape;\n            }\n        }\n    }\n    return hatch;\n}\n\nstatic void\n__attribute__((regparm(2), stdcall))\nupx_bzero(char *p, size_t len)\n{\n    if (len) do {\n        *p++= 0;\n    } while (--len);\n}\n#define bzero upx_bzero\n\n\nstatic void\n__attribute__((regparm(3), stdcall))\nauxv_up(Elf32_auxv_t *av, unsigned const type, unsigned const value)\n{\n    if (av && 0==(1&(int)av))  /* PT_INTERP usually inhibits, except for hatch */\n    for (;; ++av) {\n        if (av->a_type==type || (av->a_type==AT_IGNORE && type!=AT_NULL)) {\n            av->a_type = type;\n            av->a_un.a_val = value;\n            return;\n        }\n        if (av->a_type==AT_NULL) {\n            // We can't do this as part of the for loop because we overwrite\n            // AT_NULL too.\n            return;\n        }\n    }\n}\n\n// The PF_* and PROT_* bits are {1,2,4}; the conversion table fits in 32 bits.\n#define REP8(x) \\\n    ((x)|((x)<<4)|((x)<<8)|((x)<<12)|((x)<<16)|((x)<<20)|((x)<<24)|((x)<<28))\n#define EXP8(y) \\\n    ((1&(y)) ? 0xf0f0f0f0 : (2&(y)) ? 0xff00ff00 : (4&(y)) ? 0xffff0000 : 0)\n#define PF_TO_PROT(pf) \\\n    ((PROT_READ|PROT_WRITE|PROT_EXEC) & ( \\\n        ( (REP8(PROT_EXEC ) & EXP8(PF_X)) \\\n         |(REP8(PROT_READ ) & EXP8(PF_R)) \\\n         |(REP8(PROT_WRITE) & EXP8(PF_W)) \\\n        ) >> ((pf & (PF_R|PF_W|PF_X))<<2) ))\n\n\n// Find convex hull of PT_LOAD (the minimal interval which covers all PT_LOAD),\n// and mmap that much, to be sure that a kernel using exec-shield-randomize\n// won't place the first piece in a way that leaves no room for the rest.\nstatic unsigned long  // returns relocation constant\n__attribute__((regparm(3), stdcall))\nxfind_pages(unsigned mflags, Elf32_Phdr const *phdr, int phnum,\n    char **const p_brk\n)\n{\n    size_t lo= ~0, hi= 0, szlo= 0;\n    char *addr;\n    mflags += MAP_PRIVATE | MAP_ANONYMOUS;  // '+' can optimize better than '|'\n    for (; --phnum>=0; ++phdr) if (PT_LOAD==phdr->p_type) {\n        if (phdr->p_vaddr < lo) {\n            lo = phdr->p_vaddr;\n            szlo = phdr->p_filesz;\n        }\n        if (hi < (phdr->p_memsz + phdr->p_vaddr)) {\n            hi =  phdr->p_memsz + phdr->p_vaddr;\n        }\n    }\n    szlo += ~PAGE_MASK & lo;  // page fragment on lo edge\n    lo   -= ~PAGE_MASK & lo;  // round down to page boundary\n    hi    =  PAGE_MASK & (hi - lo - PAGE_MASK -1);  // page length\n    szlo  =  PAGE_MASK & (szlo    - PAGE_MASK -1);  // page length\n    addr = mmap((void *)lo, hi, PROT_READ|PROT_WRITE|PROT_EXEC, mflags, 0, 0);\n    *p_brk = hi + addr;  // the logical value of brk(0)\n    munmap(szlo + addr, hi - szlo);  // desirable if PT_LOAD non-contiguous\n    return (unsigned long)addr - lo;\n}\n\nstatic Elf32_Addr  // entry address\ndo_xmap(\n    int const fdi,\n    f_unfilter *(*get_funf(int)),\n    Elf32_Ehdr const *const ehdr,\n    struct Extent *const xi,\n    Elf32_auxv_t *const av)\n{\n    f_expand   *(*(*get_fexp)(int));\n    Elf32_Phdr const *phdr = (Elf32_Phdr const *) (ehdr->e_phoff +\n        (char const *)ehdr);\n    char *v_brk;\n    unsigned long const reloc = xfind_pages(\n        ((ET_DYN!=ehdr->e_type) ? MAP_FIXED : 0), phdr, ehdr->e_phnum, &v_brk);\n    int j;\n\n    *(int *)(void *)&get_fexp = fdi;\n    for (j=0; j < ehdr->e_phnum; ++phdr, ++j)\n    if (PT_PHDR==phdr->p_type) {\n        auxv_up(av, AT_PHDR, phdr->p_vaddr + reloc);\n    }\n    else if (PT_LOAD==phdr->p_type) {\n        unsigned const prot = PF_TO_PROT(phdr->p_flags);\n        struct Extent xo;\n        size_t mlen = xo.size = phdr->p_filesz;\n        char  *addr = xo.buf  =                 (char *)phdr->p_vaddr;\n        char *haddr =           phdr->p_memsz +                  addr;\n        size_t frag  = (int)addr &~ PAGE_MASK;\n        mlen += frag;\n        addr -= frag;\n        addr  += reloc;\n        haddr += reloc;\n\n        // Decompressor can overrun the destination by 3 bytes.\n        if (addr != mmap(addr, mlen + (xi ? 3 : 0), PROT_READ | PROT_WRITE,\n                MAP_FIXED | MAP_PRIVATE | (xi ? MAP_ANONYMOUS : 0),\n                fdi, phdr->p_offset - frag) ) {\n            err_exit(8);\n        }\n        if (xi) {\n            unpackExtent(xi, &xo, get_fexp, get_funf);\n        }\n        bzero(addr, frag);  // fragment at lo end\n        frag = (-mlen) &~ PAGE_MASK;  // distance to next page boundary\n        bzero(mlen+addr, frag);  // fragment at hi end\n        if (xi) {\n            void *const hatch = make_hatch(phdr);\n            if (0!=hatch) {\n                /* always update AT_NULL, especially for compressed PT_INTERP */\n                auxv_up((Elf32_auxv_t *)(~1 & (int)av), AT_NULL, (unsigned)hatch);\n            }\n        }\n        if (0!=mprotect(addr, mlen, prot)) {\n            err_exit(10);\nERR_LAB\n        }\n        addr += mlen + frag;  /* page boundary on hi end */\n        if (addr < haddr) { // need pages for .bss\n            if (addr != mmap(addr, haddr - addr, prot,\n                    MAP_FIXED | MAP_PRIVATE | MAP_ANONYMOUS, 0, 0 ) ) {\n                err_exit(9);\n            }\n        }\n        else if (xi) { // cleanup if decompressor overrun crosses page boundary\n            mlen = ~PAGE_MASK & (3+ mlen);\n            if (mlen<=3) { // page fragment was overrun buffer only\n                munmap(addr, mlen);\n            }\n        }\n    }\n    if (!xi) { // 2nd call (PT_INTERP); close()+check is smaller here\n        if (0!=close((int)fdi)) {\n            err_exit(11);\n        }\n    }\n    else { // 1st call (main); also have (0!=av) here\n        if (ET_DYN!=ehdr->e_type) {\n            // Needed only if compressed shell script invokes compressed shell.\n            do_brk(v_brk);\n        }\n    }\n    return ehdr->e_entry + reloc;\n}\n\n\n/*************************************************************************\n// pti_main - called by our entry code\n//\n// This function is optimized for size.\n**************************************************************************/\n\nvoid *pti_main(\n    Elf32_auxv_t *const av,\n    unsigned const sz_compressed,\n    f_expand *(*get_fexp(int)),\n    Elf32_Ehdr *const ehdr,\n    struct Extent xo,\n    struct Extent xi,\n    f_unfilter *(*get_funf(int))\n) __asm__(\"pti_main\");\n\nvoid *pti_main(\n    Elf32_auxv_t *const av,\n    unsigned const sz_compressed,\n    f_expand *(*get_fexp(int)),\n    Elf32_Ehdr *const ehdr,  // temp char[MAX_ELF_HDR_32+OVERHEAD]\n    struct Extent xo,  // {sz_unc, ehdr}    for ELF headers\n    struct Extent xi,  // {sz_cpr, &b_info} for ELF headers\n    f_unfilter *(*get_funf(int))\n)\n{\n    Elf32_Phdr const *phdr = (Elf32_Phdr const *)(1+ ehdr);\n    Elf32_Addr entry;\n\n    // sizeof(Ehdr+Phdrs),   compressed; including b_info header\n    size_t const sz_pckhdrs = xi.size;\n\n    // Uncompress Ehdr and Phdrs.\n    unpackExtent(&xi, &xo, get_fexp, get_funf);\n\n    // Prepare to decompress the Elf headers again, into the first PT_LOAD.\n    xi.buf  -= sz_pckhdrs;\n    xi.size  = sz_compressed;\n\n    // AT_PHDR.a_un.a_val  is set again by do_xmap if PT_PHDR is present.\n    auxv_up(av, AT_PHDR  , (unsigned)(1+(Elf32_Ehdr *)phdr->p_vaddr));\n    auxv_up(av, AT_PHENT , ehdr->e_phentsize);\n    auxv_up(av, AT_PHNUM , ehdr->e_phnum);\n    //auxv_up(av, AT_PAGESZ, PAGE_SIZE);  /* ld-linux.so.2 does not need this */\n    auxv_up(av, AT_ENTRY , (unsigned)ehdr->e_entry);\n    entry = do_xmap((int)get_fexp, get_funf, ehdr, &xi, av);\n\n  { // Map PT_INTERP program interpreter\n    int j;\n    for (j=0; j < ehdr->e_phnum; ++phdr, ++j) if (PT_INTERP==phdr->p_type) {\n        char const *const iname = (char const *)phdr->p_vaddr;\n        int const fdi = open(iname, O_RDONLY, 0);\n        if (0 > fdi) {\n            err_exit(18);\n        }\n        if (MAX_ELF_HDR_32!=read(fdi, (void *)ehdr, MAX_ELF_HDR_32)) {\nERR_LAB\n            err_exit(19);\n        }\n        entry = do_xmap(fdi, 0, ehdr, 0, 0);\n        break;\n    }\n  }\n\n    return (void *)entry;\n}\n\n/* vim:set ts=4 sw=4 et: */\n","size_bytes":14274},"src/stub/src/i386-linux.elf.shell-main.c":{"content":"/* i386-linux.elf.shell-main.c -- stub loader for Linux x86 shell script executable\n\n   This file is part of the UPX executable compressor.\n\n   Copyright (C) 1996-2025 Markus Franz Xaver Johannes Oberhumer\n   Copyright (C) 1996-2025 Laszlo Molnar\n   Copyright (C) 2000-2025 John F. Reiser\n   All Rights Reserved.\n\n   UPX and the UCL library are free software; you can redistribute them\n   and/or modify them under the terms of the GNU General Public License as\n   published by the Free Software Foundation; either version 2 of\n   the License, or (at your option) any later version.\n\n   This program is distributed in the hope that it will be useful,\n   but WITHOUT ANY WARRANTY; without even the implied warranty of\n   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n   GNU General Public License for more details.\n\n   You should have received a copy of the GNU General Public License\n   along with this program; see the file COPYING.\n   If not, write to the Free Software Foundation, Inc.,\n   59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.\n\n   Markus F.X.J. Oberhumer              Laszlo Molnar\n   <markus@oberhumer.com>               <ezerotven+github@gmail.com>\n\n   John F. Reiser\n   <jreiser@users.sourceforge.net>\n */\n\n\n#include \"include/linux.h\"\n\n\n/*************************************************************************\n// configuration section\n**************************************************************************/\n\n// In order to make it much easier to move this code at runtime and execute\n// it at an address different from it load address:  there must be no\n// static data, and no string constants.\n\n#include \"MAX_ELF_HDR.c\"\n\n\n/*************************************************************************\n// \"file\" util\n**************************************************************************/\n\nstruct Extent {\n    size_t size;  // must be first to match size[0] uncompressed size\n    char *buf;\n};\n\n\nstatic void\nxread(struct Extent *x, char *buf, size_t count)\n{\n    char *p=x->buf, *q=buf;\n    size_t j;\n    if (x->size < count) {\n        exit(127);\n    }\n    for (j = count; 0!=j--; ++p, ++q) {\n        *q = *p;\n    }\n    x->buf  += count;\n    x->size -= count;\n}\n\n\n/*************************************************************************\n// util\n**************************************************************************/\n\n#if 1  //{  save space\n#define ERR_LAB error: exit(127);\n#define err_exit(a) goto error\n#else  //}{  save debugging time\n#define ERR_LAB /*empty*/\nstatic void\nerr_exit(int a)\n{\n    (void)a;  // debugging convenience\n    exit(127);\n}\n#endif  //}\n\nstatic void *\ndo_brk(void *addr)\n{\n    return brk(addr);\n}\n\n/*************************************************************************\n// UPX & NRV stuff\n**************************************************************************/\n\ntypedef int f_expand(\n    const nrv_byte *, nrv_uint,\n          nrv_byte *, nrv_uint *, int method );\n\nstatic void\nunpackExtent(\n    struct Extent *const xi,  // input\n    struct Extent *const xo,  // output\n    f_expand *const f_decompress\n)\n{\n    while (xo->size) {\n        struct b_info h;\n        //   Note: if h.sz_unc == h.sz_cpr then the block was not\n        //   compressible and is stored in its uncompressed form.\n\n        // Read and check block sizes.\n        xread(xi, (char *)&h, sizeof(h));\n        if (h.sz_unc == 0) {                     // uncompressed size 0 -> EOF\n            if (h.sz_cpr != UPX_MAGIC_LE32)      // h.sz_cpr must be h->magic\n                err_exit(2);\n            if (xi->size != 0)                 // all bytes must be written\n                err_exit(3);\n            break;\n        }\n        if (h.sz_cpr <= 0) {\n            err_exit(4);\nERR_LAB\n        }\n        if (h.sz_cpr > h.sz_unc\n        ||  h.sz_unc > xo->size ) {\n            err_exit(5);\n        }\n        // Now we have:\n        //   assert(h.sz_cpr <= h.sz_unc);\n        //   assert(h.sz_unc > 0 && h.sz_unc <= blocksize);\n        //   assert(h.sz_cpr > 0 && h.sz_cpr <= blocksize);\n\n        if (h.sz_cpr < h.sz_unc) { // Decompress block\n            nrv_uint out_len = h.sz_unc;  // EOF for lzma\n            int const j = (*f_decompress)((unsigned char *)xi->buf, h.sz_cpr,\n                (unsigned char *)xo->buf, &out_len, *(int *)(void *)&h.b_method );\n            if (j != 0 || out_len != (nrv_uint)h.sz_unc)\n                err_exit(7);\n            xi->buf  += h.sz_cpr;\n            xi->size -= h.sz_cpr;\n        }\n        else { // copy literal block\n            xi->size += sizeof(h);  // xread(xi, &h, sizeof(h)) was a peek\n            xread(xi, xo->buf, h.sz_cpr);\n        }\n        xo->buf  += h.sz_unc;\n        xo->size -= h.sz_unc;\n    }\n}\n\nstatic void\nbzero(char *p, size_t len)\n{\n    if (len) do {\n        *p++= 0;\n    } while (--len);\n}\n\n#define REP8(x) \\\n    ((x)|((x)<<4)|((x)<<8)|((x)<<12)|((x)<<16)|((x)<<20)|((x)<<24)|((x)<<28))\n#define EXP8(y) \\\n    ((1&(y)) ? 0xf0f0f0f0 : (2&(y)) ? 0xff00ff00 : (4&(y)) ? 0xffff0000 : 0)\n#define PF_TO_PROT(pf) \\\n          (7 & (( (REP8(PROT_EXEC ) & EXP8(PF_X)) \\\n                 |(REP8(PROT_READ ) & EXP8(PF_R)) \\\n                 |(REP8(PROT_WRITE) & EXP8(PF_W)) ) \\\n               >> ((pf & (PF_R|PF_W|PF_X))<<2) ))\n\n\n// Find convex hull of PT_LOAD (the minimal interval which covers all PT_LOAD),\n// and mmap that much, to be sure that a kernel using exec-shield-randomize\n// won't place the first piece in a way that leaves no room for the rest.\nstatic unsigned long  // returns relocation constant\n__attribute__((regparm(3), stdcall))\nxfind_pages(unsigned mflags, Elf32_Phdr const *phdr, int phnum)\n{\n    size_t lo= ~0, hi= 0, szlo= 0;\n    char *addr;\n    mflags += MAP_PRIVATE | MAP_ANONYMOUS;  // '+' can optimize better than '|'\n    for (; --phnum>=0; ++phdr) if (PT_LOAD==phdr->p_type) {\n        if (phdr->p_vaddr < lo) {\n            lo = phdr->p_vaddr;\n            szlo = phdr->p_filesz;\n        }\n        if (hi < (phdr->p_memsz + phdr->p_vaddr)) {\n            hi =  phdr->p_memsz + phdr->p_vaddr;\n        }\n    }\n    if (MAP_FIXED & mflags) { // the \"shell\", and not the PT_INTERP\n        // This is a dirty hack to set the proper value for brk(0) as seen by\n        // the \"shell\" which we will mmap() soon, upon return to do_xmap().\n        // It depends on our own brk() starting out at 0x08048000, which is the\n        // default base address used by /bin/ld for an ET_EXEC.  We must brk()\n        // now.  If we wait until after mmap() of shell pages, then the kernel\n        // \"vma\" containing our original brk() of 0x08048000 will not be contiguous\n        // with  hi  [the mmap'ed pages from the shell will be in between],\n        // and various linux kernels will not move the brk() in this case;\n        // the typical symptom is SIGSEGV early in ld-linux.so.2 (the PT_INTERP).\n        do_brk((void *)hi);\n    }\n    szlo += ~PAGE_MASK & lo;  // page fragment on lo edge\n    lo   -= ~PAGE_MASK & lo;  // round down to page boundary\n    hi    =  PAGE_MASK & (hi - lo - PAGE_MASK -1);  // page length\n    szlo  =  PAGE_MASK & (szlo    - PAGE_MASK -1);  // page length\n    addr = mmap((void *)lo, hi, PROT_READ|PROT_WRITE|PROT_EXEC, mflags, -1, 0);\n\n    // Doing this may destroy the brk() that we set so carefully above.\n    // The munmap() is \"needed\" only for discontiguous PT_LOAD,\n    // and neither shells nor ld-linux.so.2 have that.\n    // munmap(szlo + addr, hi - szlo);\n\n    return (unsigned long)addr - lo;\n}\n\n// This do_xmap() has no Extent *xi input because it doesn't decompress anything;\n// it only maps the shell and its PT_INTERP.  So, it was specialized by hand\n// to reduce compiled instruction size.  gcc 2.91.66 does not notice that\n// there is only one call to this static function (from getexec(), which\n// would specify 0 for xi), so gcc does not propagate the constant parameter.\n// Notice there is no make_hatch(), either.\n\nstatic Elf32_Addr  // entry address\ndo_xmap(int const fdi, Elf32_Ehdr const *const ehdr, Elf32_auxv_t *const av)\n{\n#define EM_386           3              /* Intel 80386 */\n    if (EM_386 != ehdr->e_machine) {\n        return 1;  // not an i386 executable!\n    }\n    Elf32_Phdr const *phdr = (Elf32_Phdr const *) (ehdr->e_phoff +\n        (char const *)ehdr);\n    unsigned long const reloc = xfind_pages(\n        ((ET_DYN!=ehdr->e_type) ? MAP_FIXED : 0), phdr, ehdr->e_phnum);\n    int j;\n    for (j=0; j < ehdr->e_phnum; ++phdr, ++j)\n    if (PT_PHDR==phdr->p_type) {\n        av[AT_PHDR -1].a_un.a_val = phdr->p_vaddr;\n    }\n    else if (PT_LOAD==phdr->p_type) {\n        unsigned const prot = PF_TO_PROT(phdr->p_flags);\n        struct Extent xo;\n        size_t mlen = xo.size = phdr->p_filesz;\n        char  *addr = xo.buf  =                 (char *)phdr->p_vaddr;\n        char *haddr =           phdr->p_memsz +                  addr;\n        size_t frag  = (int)addr &~ PAGE_MASK;\n        mlen += frag;\n        addr -= frag;\n        addr  += reloc;\n        haddr += reloc;\n\n        // Decompressor can overrun the destination by 3 bytes.\n        if (addr != mmap(addr, mlen, PROT_READ | PROT_WRITE,\n                MAP_FIXED | MAP_PRIVATE,\n                fdi, phdr->p_offset - frag) ) {\n            err_exit(8);\n        }\n        bzero(addr, frag);  // fragment at lo end\n        frag = (-mlen) &~ PAGE_MASK;  // distance to next page boundary\n        bzero(mlen+addr, frag);  // fragment at hi end\n        if (0!=mprotect(addr, mlen, prot)) {\n            err_exit(10);\nERR_LAB\n        }\n        addr += mlen + frag;  /* page boundary on hi end */\n        if (addr < haddr) { // need pages for .bss\n            if (addr != mmap(addr, haddr - addr, prot,\n                    MAP_FIXED | MAP_PRIVATE | MAP_ANONYMOUS, -1, 0 ) ) {\n                err_exit(9);\n            }\n        }\n    }\n    if (0!=close(fdi)) {\n        err_exit(11);\n    }\n    return ehdr->e_entry + reloc;\n}\n\nstatic Elf32_Addr  // entry address\ngetexec(char const *const fname, Elf32_Ehdr *const ehdr, Elf32_auxv_t *const av)\n{\n    int const fdi = open(fname, O_RDONLY, 0);\n    if (0 > fdi) {\n        err_exit(18);\nERR_LAB\n    }\n    if (MAX_ELF_HDR_32!=read(fdi, (void *)ehdr, MAX_ELF_HDR_32)) {\n        err_exit(19);\n    }\n    return do_xmap(fdi, ehdr, av);\n}\n\n\n/*************************************************************************\n// upx_main - called by our entry code\n//\n// This function is optimized for size.\n**************************************************************************/\n\nvoid *upx_main(\n    Elf32_auxv_t *const av,\n    unsigned const junk,\n    f_expand *const f_decompress,\n    Elf32_Ehdr *const ehdr,  // temp char[MAX_ELF_HDR_32]\n    struct Extent xi,\n    struct Extent xo\n) __asm__(\"upx_main\");\n\nvoid *upx_main(\n    Elf32_auxv_t *const av,\n    unsigned const junk,\n    f_expand *const f_decompress,\n    Elf32_Ehdr *const ehdr,  // temp char[MAX_ELF_HDR_32]\n    struct Extent xi,\n    struct Extent xo\n)\n{\n        // 'fn' and 'efn' must not suffer constant-propagation by gcc\n        // UPX2 = offset to name_of_shell\n        // UPX3 = strlen(name_of_shell)\n    char * /*const*/ volatile  fn = UPX2 + xo.buf;  // past \"-c\" and \"#!\"\n    char * /*const*/ volatile efn = UPX3 + fn;  // &terminator\n    Elf32_Addr entry;\n\n    (void)junk;\n    unpackExtent(&xi, &xo, f_decompress);\n\n  {     // Map shell program\n    char const c = *efn;  *efn = 0;  // terminator\n    entry = getexec(fn, ehdr, av);\n    *efn = c;  // replace terminator character\n    if (1==entry) { // must execve, such as /bin/sh is amd64\n        return (void *)entry;\n    }\n\n    // av[AT_PHDR -1].a_un.a_val  is set again by do_xmap if PT_PHDR is present.\n    av[AT_PHDR   -1].a_type = AT_PHDR  ; // av[AT_PHDR-1].a_un.a_val  is set by do_xmap\n    av[AT_PHENT  -1].a_type = AT_PHENT ; av[AT_PHENT  -1].a_un.a_val = ehdr->e_phentsize;\n    av[AT_PHNUM  -1].a_type = AT_PHNUM ; av[AT_PHNUM  -1].a_un.a_val = ehdr->e_phnum;\n    av[AT_PAGESZ -1].a_type = AT_PAGESZ; av[AT_PAGESZ -1].a_un.a_val = PAGE_SIZE;\n    av[AT_ENTRY  -1].a_type = AT_ENTRY ; av[AT_ENTRY  -1].a_un.a_val = entry;\n  }\n\n  { // Map PT_INTERP program interpreter\n    Elf32_Phdr const *phdr = (Elf32_Phdr *)(1+ehdr);\n    int j;\n    for (j=0; j < ehdr->e_phnum; ++phdr, ++j) if (PT_INTERP==phdr->p_type) {\n        entry = getexec((char const *)phdr->p_vaddr, ehdr, 0);\n        break;\n    }\n  }\n\n    return (void *)entry;\n}\n\n/* vim:set ts=4 sw=4 et: */\n","size_bytes":12354},"src/stub/src/i386-openbsd.elf-main.c":{"content":"/* i386-openbsd.elf-main.c -- stub loader for OpenBSD x86 ELF executable\n\n   This file is part of the UPX executable compressor.\n\n   Copyright (C) 1996-2025 Markus Franz Xaver Johannes Oberhumer\n   Copyright (C) 1996-2025 Laszlo Molnar\n   Copyright (C) 2000-2025 John F. Reiser\n   All Rights Reserved.\n\n   UPX and the UCL library are free software; you can redistribute them\n   and/or modify them under the terms of the GNU General Public License as\n   published by the Free Software Foundation; either version 2 of\n   the License, or (at your option) any later version.\n\n   This program is distributed in the hope that it will be useful,\n   but WITHOUT ANY WARRANTY; without even the implied warranty of\n   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n   GNU General Public License for more details.\n\n   You should have received a copy of the GNU General Public License\n   along with this program; see the file COPYING.\n   If not, write to the Free Software Foundation, Inc.,\n   59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.\n\n   Markus F.X.J. Oberhumer              Laszlo Molnar\n   <markus@oberhumer.com>               <ezerotven+github@gmail.com>\n\n   John F. Reiser\n   <jreiser@users.sourceforge.net>\n */\n\n\n#include \"include/bsd.h\"\n\n\n/*************************************************************************\n// configuration section\n**************************************************************************/\n\n// In order to make it much easier to move this code at runtime and execute\n// it at an address different from it load address:  there must be no\n// static data, and no string constants.\n\n#if 1  /*{*/\n#define DPRINTF(a) /* empty: no debug drivel */\n#else  /*}{*/\n#include \"stdarg.h\"\n\nstatic int\nunsimal(unsigned x, char *ptr, int n)\n{\n    if (10<=x) {\n        n = unsimal(x/10, ptr, n);\n        x %= 10;\n    }\n    ptr[n] = '0' + x;\n    return 1+ n;\n}\n\nstatic int\ndecimal(int x, char *ptr, int n)\n{\n    if (x < 0) {\n        x = -x;\n        ptr[n++] = '-';\n    }\n    return unsimal(x, ptr, n);\n}\n\nextern char const *STR_hex();\n\nstatic int\nheximal(unsigned x, char *ptr, int n)\n{\n    if (16<=x) {\n        n = heximal(x>>4, ptr, n);\n        x &= 0xf;\n    }\n    ptr[n] = STR_hex()[x];\n    return 1+ n;\n}\n\n\n#define DPRINTF(a) dprintf a\nextern char const *STR_0x();\nextern char const *STR_xread();\nextern char const *STR_unpackExtent();\nextern char const *STR_make_hatch_arm();\nextern char const *STR_auxv_up();\nextern char const *STR_xfind_pages();\nextern char const *STR_do_xmap();\nextern char const *STR_upx_main();\n\nstatic int\ndprintf(char const *fmt, ...)\n{\n    char c;\n    int n= 0;\n    char *ptr;\n    char buf[20];\n    va_list va; va_start(va, fmt);\n    ptr= &buf[0];\n    while (0!=(c= *fmt++)) if ('%'!=c) goto literal;\n    else switch (c= *fmt++) {\n    default: {\nliteral:\n        n+= write(2, fmt-1, 1);\n    } break;\n    case 0: goto done;  /* early */\n    case 'u': {\n        n+= write(2, buf, unsimal(va_arg(va, unsigned), buf, 0));\n    } break;\n    case 'd': {\n        n+= write(2, buf, decimal(va_arg(va, int), buf, 0));\n    } break;\n    case 'p':  /* same as 'x'; relies on sizeof(int)==sizeof(void *) */\n    case 'x': {\n        buf[0] = '0';\n        buf[1] = 'x';\n        n+= write(2, buf, heximal(va_arg(va, int), buf, 2));\n    } break;\n    }\ndone:\n    va_end(va);\n    return n;\n}\n#endif  /*}*/\n\n#include \"MAX_ELF_HDR.c\"\n\n\n/*************************************************************************\n// \"file\" util\n**************************************************************************/\n\nstruct Extent {\n    size_t size;  // must be first to match size[0] uncompressed size\n    char *buf;\n};\n\n\nstatic void\n#if (ACC_CC_GNUC >= 0x030300) && defined(__i386__)  /*{*/\n__attribute__((__noinline__, __used__, regparm(3), stdcall))\n#endif  /*}*/\nxread(struct Extent *x, char *buf, size_t count)\n{\n    char *p=x->buf, *q=buf;\n    size_t j;\n    DPRINTF((STR_xread(), x, x->size, x->buf, buf, count));\n    if (x->size < count) {\n        exit(127);\n    }\n    for (j = count; 0!=j--; ++p, ++q) {\n        *q = *p;\n    }\n    x->buf  += count;\n    x->size -= count;\n}\n\n\n/*************************************************************************\n// util\n**************************************************************************/\n\n#if 1  //{  save space\n#define ERR_LAB error: exit(127);\n#define err_exit(a) goto error\n#else  //}{  save debugging time\n#define ERR_LAB /*empty*/\nstatic void\nerr_exit(int a) __attribute__ ((__noreturn__));\n{\n    (void)a;  // debugging convenience\n    exit(127);\n}\n#endif  //}\n\n/*************************************************************************\n// UPX & NRV stuff\n**************************************************************************/\n\ntypedef void f_unfilter(\n    nrv_byte *,  // also addvalue\n    nrv_uint,\n    unsigned cto8, // junk in high 24 bits\n    unsigned ftid\n);\ntypedef int f_expand(\n    const nrv_byte *, nrv_uint,\n          nrv_byte *, nrv_uint *, unsigned );\n\nstatic void\nunpackExtent(\n    struct Extent *const xi,  // input\n    struct Extent *const xo,  // output\n    f_expand *const f_decompress,\n    f_unfilter *f_unf\n)\n{\n    DPRINTF((STR_unpackExtent(),\n        xi, xi->size, xi->buf, xo, xo->size, xo->buf, f_decompress, f_unf));\n    while (xo->size) {\n        struct b_info h;\n        //   Note: if h.sz_unc == h.sz_cpr then the block was not\n        //   compressible and is stored in its uncompressed form.\n\n        // Read and check block sizes.\n        xread(xi, (char *)&h, sizeof(h));\n        if (h.sz_unc == 0) {                     // uncompressed size 0 -> EOF\n            if (h.sz_cpr != UPX_MAGIC_LE32)      // h.sz_cpr must be h->magic\n                err_exit(2);\n            if (xi->size != 0)                 // all bytes must be written\n                err_exit(3);\n            break;\n        }\n        if (h.sz_cpr <= 0) {\n            err_exit(4);\nERR_LAB\n        }\n        if (h.sz_cpr > h.sz_unc\n        ||  h.sz_unc > xo->size ) {\n            err_exit(5);\n        }\n        // Now we have:\n        //   assert(h.sz_cpr <= h.sz_unc);\n        //   assert(h.sz_unc > 0 && h.sz_unc <= blocksize);\n        //   assert(h.sz_cpr > 0 && h.sz_cpr <= blocksize);\n\n        if (h.sz_cpr < h.sz_unc) { // Decompress block\n            nrv_uint out_len = h.sz_unc;  // EOF for lzma\n            int const j = (*f_decompress)((unsigned char *)xi->buf, h.sz_cpr,\n                (unsigned char *)xo->buf, &out_len, *(int *)(void *)&h.b_method );\n            if (j != 0 || out_len != (nrv_uint)h.sz_unc)\n                err_exit(7);\n            // Skip Ehdr+Phdrs: separate 1st block, not filtered\n            if (h.b_ftid!=0 && f_unf  // have filter\n            &&  ((512 < out_len)  // this block is longer than Ehdr+Phdrs\n              || (xo->size==(unsigned)h.sz_unc) )  // block is last in Extent\n            ) {\n                (*f_unf)((unsigned char *)xo->buf, out_len, h.b_cto8, h.b_ftid);\n            }\n            xi->buf  += h.sz_cpr;\n            xi->size -= h.sz_cpr;\n        }\n        else { // copy literal block\n            xi->size += sizeof(h);  // xread(xi, &h, sizeof(h)) was a peek\n            xread(xi, xo->buf, h.sz_cpr);\n        }\n        xo->buf  += h.sz_unc;\n        xo->size -= h.sz_unc;\n    }\n}\n\n#if defined(__i386__)  /*{*/\n// Create (or find) an escape hatch to use when munmapping ourselves the stub.\n// Called by do_xmap to create it; remembered in AT_NULL.d_val\nstatic void *\nmake_hatch_x86(Elf32_Phdr const *const phdr, unsigned const reloc)\n{\n    unsigned *hatch = 0;\n    if (phdr->p_type==PT_LOAD && phdr->p_flags & PF_X) {\n        // The format of the 'if' is\n        //  if ( ( (hatch = loc1), test_loc1 )\n        //  ||   ( (hatch = loc2), test_loc2 ) ) {\n        //      action\n        //  }\n        // which uses the comma to save bytes when test_locj involves locj\n        // and the action is the same when either test succeeds.\n\n        // Try page fragmentation just beyond .text .\n        if ( ( (hatch = (void *)(phdr->p_memsz + phdr->p_vaddr + reloc)),\n                ( phdr->p_memsz==phdr->p_filesz  // don't pollute potential .bss\n                &&  4<=(~PAGE_MASK & -(int)hatch) ) ) // space left on page\n        // Try Elf32_Ehdr.e_ident[12..15] .  warning: 'const' cast away\n        ||   ( (hatch = (void *)(&((Elf32_Ehdr *)phdr->p_vaddr + reloc)->e_ident[12])),\n                (phdr->p_offset==0) ) ) {\n            // Omitting 'const' saves repeated literal in gcc.\n            unsigned /*const*/ escape = 0xc3c980cd;  // \"int $0x80; leave; ret\"\n            // Don't store into read-only page if value is already there.\n            if (* (volatile unsigned*) hatch != escape) {\n                * hatch  = escape;\n            }\n        }\n    }\n    return hatch;\n}\n#elif defined(__arm__)  /*}{*/\nstatic void *\nmake_hatch_arm(Elf32_Phdr const *const phdr, unsigned const reloc)\n{\n    unsigned *hatch = 0;\n    DPRINTF((STR_make_hatch_arm(),phdr,reloc));\n    if (phdr->p_type==PT_LOAD && phdr->p_flags & PF_X) {\n        // The format of the 'if' is\n        //  if ( ( (hatch = loc1), test_loc1 )\n        //  ||   ( (hatch = loc2), test_loc2 ) ) {\n        //      action\n        //  }\n        // which uses the comma to save bytes when test_locj involves locj\n        // and the action is the same when either test succeeds.\n\n        // Try page fragmentation just beyond .text .\n        if ( ( (hatch = (void *)(phdr->p_memsz + phdr->p_vaddr + reloc)),\n                ( phdr->p_memsz==phdr->p_filesz  // don't pollute potential .bss\n                &&  8<=(~PAGE_MASK & -(int)hatch) ) ) // space left on page\n        // Try Elf32_Ehdr.e_ident[8..15] .  warning: 'const' cast away\n        ||   ( (hatch = (void *)(&((Elf32_Ehdr *)phdr->p_vaddr + reloc)->e_ident[8])),\n                (phdr->p_offset==0) ) )\n        {\n            hatch[0]= 0xef90005b;  // syscall __NR_unmap\n            hatch[1]= 0xe1a0f00e;  // mov pc,lr\n        }\n    }\n    return hatch;\n}\n#endif  /*}*/\n\nstatic void\n#if defined(__i386__)  /*{*/\n__attribute__((regparm(2), stdcall))\n#endif  /*}*/\nupx_bzero(char *p, size_t len)\n{\n    if (len) do {\n        *p++= 0;\n    } while (--len);\n}\n#define bzero upx_bzero\n\n\nstatic void\n#if defined(__i386__)  /*{*/\n__attribute__((regparm(3), stdcall))\n#endif  /*}*/\nauxv_up(Elf32_auxv_t *av, unsigned const type, unsigned const value)\n{\n    DPRINTF((STR_auxv_up(),av,type,value));\n    if (av\n#if defined(__i386__)  /*{*/\n    && 0==(1&(int)av)  /* PT_INTERP usually inhibits, except for hatch */\n#endif  /*}*/\n    )\n    for (;; ++av) {\n        if (av->a_type==type || (av->a_type==AT_IGNORE && type!=AT_NULL)) {\n            av->a_type = type;\n            av->a_un.a_val = value;\n            return;\n        }\n        if (av->a_type==AT_NULL) {\n            // We can't do this as part of the for loop because we overwrite\n            // AT_NULL too.\n            return;\n        }\n    }\n}\n\n// The PF_* and PROT_* bits are {1,2,4}; the conversion table fits in 32 bits.\n#define REP8(x) \\\n    ((x)|((x)<<4)|((x)<<8)|((x)<<12)|((x)<<16)|((x)<<20)|((x)<<24)|((x)<<28))\n#define EXP8(y) \\\n    ((1&(y)) ? 0xf0f0f0f0 : (2&(y)) ? 0xff00ff00 : (4&(y)) ? 0xffff0000 : 0)\n#define PF_TO_PROT(pf) \\\n    ((PROT_READ|PROT_WRITE|PROT_EXEC) & ( \\\n        ( (REP8(PROT_EXEC ) & EXP8(PF_X)) \\\n         |(REP8(PROT_READ ) & EXP8(PF_R)) \\\n         |(REP8(PROT_WRITE) & EXP8(PF_W)) \\\n        ) >> ((pf & (PF_R|PF_W|PF_X))<<2) ))\n\n\nstatic unsigned\numax(unsigned a, unsigned b)\n{\n    return ((a<=b) ? b : a);\n}\n\n// OpenBSD 3.9 wants all .text from all modules together, then (above that)\n// all .data from all modules together, in order to maximize the effectiveness\n// of lowering the segment limit on %cs as an implementation of \"no-execute\n// .data\".  Thus OpenBSD 3.9 puts a gap of 0x20000000 (512 MiB) between the\n// origins of .text and .data in each module.  So, mapping ET_DYN must \"level\"\n// the excursion in .text and .data of anything which preceded it,\n// then add the new PT_LOAD.\n\nstatic unsigned long  // returns relocation constant\n#if defined(__i386__)  /*{*/\n__attribute__((regparm(3), stdcall))\n#endif  /*}*/\nxfind_pages(unsigned const e_type, Elf32_Phdr const *phdr, int phnum,\n    Elf32_Addr old_hi[2])\n{\n    size_t sz[2]= { 0u,  0u};  // [0] is .data;  [1] is .text\n    size_t hi[2]= { 0u,  0u};\n    size_t lo[2]= {~0u, ~0u};\n    char *addr[2];\n    unsigned level= 0;\n    int j;\n\n    DPRINTF((STR_xfind_pages(), mflags, phdr, phnum, p_brk));\n    for (; --phnum>=0; ++phdr) if (PT_LOAD==phdr->p_type) {\n        unsigned const td = PF_X & phdr->p_flags;  // requires 1==PF_X\n        if (lo[td] > phdr->p_vaddr) {\n            lo[td] = phdr->p_vaddr;\n            sz[td] = phdr->p_filesz;\n        }\n        if (hi[td] < (phdr->p_memsz + phdr->p_vaddr)) {\n            hi[td] =  phdr->p_memsz + phdr->p_vaddr;\n        }\n    }\n    if ((ET_EXEC!=e_type) && 0x20000000u<=hi[0]) { // is split\n        level=  (0xfc000000u & old_hi[1]) +  // \"segment base\" of old .text\n            umax(0x03ffffffu & old_hi[1],\n                 0x03ffffffu & old_hi[0] );\n        level= PAGE_MASK & (level - PAGE_MASK -1);  // ALIGN_UP\n    }\n    for (j=0; j<=1; ++j) {\n        sz[j] += ~PAGE_MASK & lo[j];  // page fragment on lo edge\n        lo[j] -= ~PAGE_MASK & lo[j];  // round down to page boundary\n        old_hi[j] = level + hi[j];\n        hi[j]  =  PAGE_MASK & (hi[j] - lo[j] - PAGE_MASK -1);  // page length\n        sz[j]  =  PAGE_MASK & (sz[j]         - PAGE_MASK -1);  // page length\n        addr[j] = mmap((void *)(level + lo[j]), hi[j], PROT_NONE,\n            MAP_FIXED | MAP_PRIVATE | MAP_ANONYMOUS, -1, 0);\n    }\n    return (unsigned long)addr[0] - lo[0];\n}\n\nstatic Elf32_Addr  // entry address\ndo_xmap(int const fdi, Elf32_Ehdr const *const ehdr,\n    Elf32_Addr old_hi[2], struct Extent *const xi,\n    Elf32_auxv_t *const av, unsigned *p_reloc, f_unfilter *const f_unf)\n{\n    Elf32_Phdr const *phdr = (Elf32_Phdr const *) (ehdr->e_phoff +\n        (void const *)ehdr);\n    unsigned const reloc = xfind_pages(ehdr->e_type, phdr, ehdr->e_phnum, old_hi);\n    int j;\n\n    DPRINTF((STR_do_xmap(),\n        fdi, ehdr, xi, (xi? xi->size: 0), (xi? xi->buf: 0), av, p_reloc, f_unf));\n    for (j=0; j < ehdr->e_phnum; ++phdr, ++j)\n    if (PT_PHDR==phdr->p_type) {\n        if (xi) {\n            auxv_up(av, AT_PHDR, phdr->p_vaddr + reloc);\n        }\n    }\n    else if (PT_LOAD==phdr->p_type && phdr->p_memsz != 0) {\n        unsigned const prot = PF_TO_PROT(phdr->p_flags);\n        struct Extent xo;\n        size_t mlen = xo.size = phdr->p_filesz;\n        char  *addr = xo.buf  =  (char *)(phdr->p_vaddr + reloc);\n        char *haddr =           phdr->p_memsz + addr;\n        size_t frag  = (int)addr &~ PAGE_MASK;\n        mlen += frag;\n        addr -= frag;\n\n        if (addr != mmap(addr, mlen\n#if defined(__i386__)  /*{*/\n            // Decompressor can overrun the destination by 3 bytes.\n            + (xi ? 3 : 0)\n#endif  /*}*/\n                , prot | (xi ? PROT_WRITE : 0),\n                MAP_FIXED | MAP_PRIVATE | (xi ? MAP_ANONYMOUS : 0),\n                (xi ? -1 : fdi), phdr->p_offset - frag) ) {\n            err_exit(8);\n        }\n        if (xi) {\n            unpackExtent(xi, &xo, (f_expand *)fdi,\n                ((PROT_EXEC & prot) ? f_unf : 0) );\n        }\n        // Linux does not fixup the low end, so neither do we.\n        //if (PROT_WRITE & prot) {\n        //    bzero(addr, frag);  // fragment at lo end\n        //}\n        frag = (-mlen) &~ PAGE_MASK;  // distance to next page boundary\n        if (PROT_WRITE & prot) { // note: read-only .bss not supported here\n            bzero(mlen+addr, frag);  // fragment at hi end\n        }\n        if (xi) {\n#if defined(__i386__)  /*{*/\n            void *const hatch = make_hatch_x86(phdr, reloc);\n            if (0!=hatch) {\n                /* always update AT_NULL, especially for compressed PT_INTERP */\n                auxv_up((Elf32_auxv_t *)(~1 & (int)av), AT_NULL, (unsigned)hatch);\n            }\n#elif defined(__arm__)  /*}{*/\n            void *const hatch = make_hatch_arm(phdr, reloc);\n            if (0!=hatch) {\n                auxv_up((Elf32_auxv_t *)(void *)av, AT_NULL, (unsigned)hatch);\n            }\n#endif  /*}*/\n            if (0!=mprotect(addr, mlen, prot)) {\n                err_exit(10);\nERR_LAB\n            }\n        }\n        addr += mlen + frag;  /* page boundary on hi end */\n        if (addr < haddr) { // need pages for .bss\n            if (addr != mmap(addr, haddr - addr, prot,\n                    MAP_FIXED | MAP_PRIVATE | MAP_ANONYMOUS, -1, 0 ) ) {\n                err_exit(9);\n            }\n        }\n#if defined(__i386__)  /*{*/\n        else if (xi) { // cleanup if decompressor overrun crosses page boundary\n            mlen = ~PAGE_MASK & (3+ mlen);\n            if (mlen<=3) { // page fragment was overrun buffer only\n                munmap(addr, mlen);\n            }\n        }\n#endif  /*}*/\n    }\n    if (!xi) { // 2nd call (PT_INTERP); close()+check is smaller here\n        if (0!=close(fdi)) {\n            err_exit(11);\n        }\n    }\n    if (0!=p_reloc) {\n        *p_reloc = reloc;\n    }\n    return ehdr->e_entry + reloc;\n}\n\n\n/*************************************************************************\n// upx_main - called by our entry code\n//\n// This function is optimized for size.\n**************************************************************************/\n\nvoid *upx_main(\n    Elf32_auxv_t *const av,\n    unsigned const sz_compressed,\n    f_expand *const f_decompress,\n    f_unfilter */*const*/ f_unfilter,\n    struct Extent xo,\n    struct Extent xi,\n    unsigned const volatile dynbase\n) __asm__(\"upx_main\");\n\nvoid *upx_main(\n    Elf32_auxv_t *const av,\n    unsigned const sz_compressed,\n    f_expand *const f_decompress,\n    f_unfilter */*const*/ f_unf,\n    struct Extent xo,  // {sz_unc, ehdr}    for ELF headers\n    struct Extent xi,  // {sz_cpr, &b_info} for ELF headers\n    unsigned const volatile dynbase  // value+result: compiler must not change\n)\n{\n    Elf32_Ehdr *const ehdr = (Elf32_Ehdr *)(void *)xo.buf;  // temp char[MAX_ELF_HDR_32+OVERHEAD]\n    Elf32_Phdr const *phdr = (Elf32_Phdr const *)(1+ ehdr);\n    Elf32_Addr old_hi[2]= {0u, 0u};\n    Elf32_Addr reloc;\n    Elf32_Addr entry;\n\n    // sizeof(Ehdr+Phdrs),   compressed; including b_info header\n    size_t const sz_pckhdrs = xi.size;\n\n    DPRINTF((STR_upx_main(),\n        av, sz_compressed, f_decompress, f_unf, &xo, xo.size, xo.buf,\n        &xi, xi.size, xi.buf, dynbase));\n#if defined(__i386__)  /*{*/\n    f_unf = (f_unfilter *)(2+ (long)f_decompress);\n#endif  /*}*/\n\n    // Uncompress Ehdr and Phdrs.\n    unpackExtent(&xi, &xo, f_decompress, 0);\n\n    // Prepare to decompress the Elf headers again, into the first PT_LOAD.\n    xi.buf  -= sz_pckhdrs;\n    xi.size  = sz_compressed;\n\n    // Some kernels omit AT_PHNUM,AT_PHENT,AT_PHDR because this stub has no PT_INTERP.\n    // That is \"too much\" optimization.  Linux 2.6.x seems to give all AT_*.\n    auxv_up(av, AT_PAGESZ, PAGE_SIZE);\n    auxv_up(av, AT_PHNUM , ehdr->e_phnum);\n    auxv_up(av, AT_PHENT , ehdr->e_phentsize);\n    auxv_up(av, AT_PHDR  , dynbase + (unsigned)(1+(Elf32_Ehdr *)phdr->p_vaddr));\n    // AT_PHDR.a_un.a_val  is set again by do_xmap if PT_PHDR is present.\n    // This is necessary for ET_DYN if|when we override a prelink address.\n\n    entry = do_xmap((int)f_decompress, ehdr, old_hi, &xi, av, &reloc, f_unf);\n    auxv_up(av, AT_ENTRY , entry);  // might not be necessary?\n\n  { // Map PT_INTERP program interpreter\n    int j;\n    for (j=0; j < ehdr->e_phnum; ++phdr, ++j) if (PT_INTERP==phdr->p_type) {\n        int const fdi = open(reloc + (char const *)phdr->p_vaddr, O_RDONLY, 0);\n        if (0 > fdi) {\n            err_exit(18);\n        }\n        if (MAX_ELF_HDR_32!=read(fdi, (void *)ehdr, MAX_ELF_HDR_32)) {\nERR_LAB\n            err_exit(19);\n        }\n        entry = do_xmap(fdi, ehdr, old_hi, 0, 0, &reloc, 0);\n        auxv_up(av, AT_BASE, reloc);\n        break;\n    }\n  }\n\n    return (void *)entry;\n}\n\n/* vim:set ts=4 sw=4 et: */\n","size_bytes":19928},"src/stub/src/mips.r3000-linux.elf-main.c":{"content":"#include \"i386-linux.elf-main.c\"\n\n/* vim:set ts=4 sw=4 et: */\n","size_bytes":62},"src/stub/src/mips.r3000-linux.elf-main2.c":{"content":"#include \"../src/i386-linux.elf-main2.c\"\n","size_bytes":41},"src/stub/src/mipsel.r3000-linux.elf-main.c":{"content":"#include \"i386-linux.elf-main.c\"\n\n/* vim:set ts=4 sw=4 et: */\n","size_bytes":62},"src/stub/src/mipsel.r3000-linux.elf-main2.c":{"content":"#include \"../src/i386-linux.elf-main2.c\"\n","size_bytes":41},"src/stub/src/powerpc-darwin.macho-main.c":{"content":"/* powerpc-darwin.macho-main.c -- loader stub for Mach-o PowerPC32\n\n   This file is part of the UPX executable compressor.\n\n   Copyright (C) 1996-2025 Markus Franz Xaver Johannes Oberhumer\n   Copyright (C) 1996-2025 Laszlo Molnar\n   Copyright (C) 2000-2025 John F. Reiser\n   All Rights Reserved.\n\n   UPX and the UCL library are free software; you can redistribute them\n   and/or modify them under the terms of the GNU General Public License as\n   published by the Free Software Foundation; either version 2 of\n   the License, or (at your option) any later version.\n\n   This program is distributed in the hope that it will be useful,\n   but WITHOUT ANY WARRANTY; without even the implied warranty of\n   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n   GNU General Public License for more details.\n\n   You should have received a copy of the GNU General Public License\n   along with this program; see the file COPYING.\n   If not, write to the Free Software Foundation, Inc.,\n   59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.\n\n   Markus F.X.J. Oberhumer              Laszlo Molnar\n   <markus@oberhumer.com>               <ezerotven+github@gmail.com>\n\n   John F. Reiser\n   <jreiser@users.sourceforge.net>\n */\n\n\n#define __WORDSIZE 32\n#include \"include/darwin.h\"\n\n\n/*************************************************************************\n// configuration section\n**************************************************************************/\n\n// In order to make it much easier to move this code at runtime and execute\n// it at an address different from it load address:  there must be no\n// static data, and no string constants.\n\n\n/*************************************************************************\n// \"file\" util\n**************************************************************************/\n\ntypedef struct {\n    size_t size;  // must be first to match size[0] uncompressed size\n    char *buf;\n} Extent;\n\n\nstatic void\nxread(Extent *x, char *buf, size_t count)\n{\n    char *p=x->buf, *q=buf;\n    size_t j;\n    if (x->size < count) {\n        exit(127);\n    }\n    for (j = count; 0!=j--; ++p, ++q) {\n        *q = *p;\n    }\n    x->buf  += count;\n    x->size -= count;\n}\n\n\n/*************************************************************************\n// util\n**************************************************************************/\n\n#if 1  //{  save space\n#define ERR_LAB error: exit(127);\n#define err_exit(a) goto error\n#else  //}{  save debugging time\n#define ERR_LAB /*empty*/\nstatic void\nerr_exit(int a)\n{\n    (void)a;  // debugging convenience\n    exit(127);\n}\n#endif  //}\n\n\n/*************************************************************************\n// UPX & NRV stuff\n**************************************************************************/\n\nstruct l_info { // 12-byte trailer for loader (after macho headers)\n    unsigned l_checksum;\n    unsigned l_magic;  // UPX_MAGIC_LE32\n    unsigned short l_lsize;\n    unsigned char l_version;\n    unsigned char l_format;\n};\nstruct p_info { // 12-byte packed program header\n    unsigned p_progid;\n    unsigned p_filesize;\n    unsigned p_blocksize;\n};\n\nstruct b_info { // 12-byte header before each compressed block\n    unsigned sz_unc;  // uncompressed_size\n    unsigned sz_cpr;  //   compressed_size\n    unsigned char b_method;  // compression algorithm\n    unsigned char b_ftid;  // filter id\n    unsigned char b_cto8;  // filter parameter\n    unsigned char b_unused;\n};\n\ntypedef void f_unfilter(\n    nrv_byte *,  // also addvalue\n    nrv_uint,\n    unsigned cto8, // junk in high 24 bits\n    unsigned ftid\n);\ntypedef int f_expand(\n    const nrv_byte *, nrv_uint,\n          nrv_byte *, nrv_uint *, unsigned );\n\nstatic void\nunpackExtent(\n    Extent *const xi,  // input\n    Extent *const xo,  // output\n    f_expand *const f_decompress,\n    f_unfilter *f_unf\n)\n{\n    while (xo->size) {\n        struct b_info h;\n        //   Note: if h.sz_unc == h.sz_cpr then the block was not\n        //   compressible and is stored in its uncompressed form.\n\n        // Read and check block sizes.\n        xread(xi, (char *)&h, sizeof(h));\n        if (h.sz_unc == 0) {                     // uncompressed size 0 -> EOF\n            if (h.sz_cpr != UPX_MAGIC_LE32)      // h.sz_cpr must be h->magic\n                err_exit(2);\n            if (xi->size != 0)                 // all bytes must be written\n                err_exit(3);\n            break;\n        }\n        if (h.sz_cpr <= 0) {\n            err_exit(4);\nERR_LAB\n        }\n        if (h.sz_cpr > h.sz_unc\n        ||  h.sz_unc > xo->size ) {\n            err_exit(5);\n        }\n        // Now we have:\n        //   assert(h.sz_cpr <= h.sz_unc);\n        //   assert(h.sz_unc > 0 && h.sz_unc <= blocksize);\n        //   assert(h.sz_cpr > 0 && h.sz_cpr <= blocksize);\n\n        if (h.sz_cpr < h.sz_unc) { // Decompress block\n            nrv_uint out_len = h.sz_unc;  // EOF for lzma\n            int const j = (*f_decompress)((unsigned char *)xi->buf, h.sz_cpr,\n                (unsigned char *)xo->buf, &out_len, h.b_method);\n            if (j != 0 || out_len != (nrv_uint)h.sz_unc)\n                err_exit(7);\n            if (h.b_ftid!=0 && f_unf) {  // have filter\n                (*f_unf)((unsigned char *)xo->buf, out_len, h.b_cto8, h.b_ftid);\n            }\n            xi->buf  += h.sz_cpr;\n            xi->size -= h.sz_cpr;\n        }\n        else { // copy literal block\n            xi->size += sizeof(h);  // xread(xi, &h, sizeof(h)) was a peek\n            xread(xi, xo->buf, h.sz_cpr);\n        }\n        xo->buf  += h.sz_unc;\n        xo->size -= h.sz_unc;\n    }\n}\n\nstatic void\nupx_bzero(char *p, size_t len)\n{\n    if (len) do {\n        *p++= 0;\n    } while (--len);\n}\n#define bzero upx_bzero\n\n\n// The PF_* and PROT_* bits are {1,2,4}; the conversion table fits in 32 bits.\n#define REP8(x) \\\n    ((x)|((x)<<4)|((x)<<8)|((x)<<12)|((x)<<16)|((x)<<20)|((x)<<24)|((x)<<28))\n#define EXP8(y) \\\n    ((1&(y)) ? 0xf0f0f0f0 : (2&(y)) ? 0xff00ff00 : (4&(y)) ? 0xffff0000 : 0)\n#define PF_TO_PROT(pf) \\\n    ((PROT_READ|PROT_WRITE|PROT_EXEC) & ( \\\n        ( (REP8(PROT_EXEC ) & EXP8(PF_X)) \\\n         |(REP8(PROT_READ ) & EXP8(PF_R)) \\\n         |(REP8(PROT_WRITE) & EXP8(PF_W)) \\\n        ) >> ((pf & (PF_R|PF_W|PF_X))<<2) ))\n\ntypedef struct {\n    unsigned magic;\n    unsigned nfat_arch;\n} Fat_header;\ntypedef struct {\n    unsigned cputype;\n    unsigned cpusubtype;\n    unsigned offset;\n    unsigned size;\n    unsigned align;  /* power of 2 */\n} Fat_arch;\n    enum e8 {\n        FAT_MAGIC = 0xcafebabe\n    };\n    enum e9 {\n        CPU_TYPE_I386      =          7,\n        CPU_TYPE_POWERPC   = 0x00000012,\n        CPU_TYPE_POWERPC64 = 0x01000012\n    };\n\ntypedef struct {\n    unsigned magic;\n    unsigned cputype;\n    unsigned cpysubtype;\n    unsigned filetype;\n    unsigned ncmds;\n    unsigned sizeofcmds;\n    unsigned flags;\n} Mach_header;\n        enum e0 {\n            MH_MAGIC = 0xfeedface\n        };\n        enum e2 {\n            MH_EXECUTE = 2\n        };\n        enum e3 {\n            MH_NOUNDEFS = 1\n        };\n\ntypedef struct {\n    unsigned cmd;\n    unsigned cmdsize;\n} Mach_load_command;\n        enum e4 {\n            LC_SEGMENT       = 0x1,\n            LC_THREAD        = 0x4,\n            LC_UNIXTHREAD    = 0x5,\n            LC_LOAD_DYLINKER = 0xe\n        };\n\ntypedef struct {\n    unsigned cmd;\n    unsigned cmdsize;\n    char segname[16];\n    unsigned vmaddr;\n    unsigned vmsize;\n    unsigned fileoff;\n    unsigned filesize;\n    unsigned maxprot;\n    unsigned initprot;\n    unsigned nsects;\n    unsigned flags;\n} Mach_segment_command;\n        enum e5 {\n            VM_PROT_READ = 1,\n            VM_PROT_WRITE = 2,\n            VM_PROT_EXECUTE = 4\n        };\n\ntypedef struct {\n    unsigned srr0;      /* Instruction address register (PC; entry addr) */\n    unsigned srr1;      /* Machine state register (supervisor) */\n    unsigned  r0, r1, r2, r3, r4, r5, r6, r7;\n    unsigned  r8, r9,r10,r11,r12,r13,r14,r15;\n    unsigned r16,r17,r18,r19,r20,r21,r22,r23;\n    unsigned r24,r25,r26,r27,r28,r29,r30,r31;\n\n    unsigned cr;        /* Condition register */\n    unsigned xer;       /* User's integer exception register */\n    unsigned lr;        /* Link register */\n    unsigned ctr;       /* Count register */\n    unsigned mq;        /* MQ register (601 only) */\n\n    unsigned vrsave;    /* Vector Save Register */\n} Mach_ppc_thread_state;\n\ntypedef struct {\n    unsigned cmd;            /* LC_THREAD or  LC_UNIXTHREAD */\n    unsigned cmdsize;        /* total size of this command */\n    unsigned flavor;\n    unsigned count;          /* sizeof(following_thread_state)/4 */\n    Mach_ppc_thread_state state;\n} Mach_thread_command;\n        enum e6 {\n            PPC_THREAD_STATE = 1\n        };\n        enum e7 {\n            PPC_THREAD_STATE_COUNT = sizeof(Mach_ppc_thread_state)/4\n        };\n\ntypedef union {\n    unsigned long offset;  /* from start of load command to string */\n    char *ptr;\n} Mach_lc_str;\n\n#define MAP_FIXED     0x10\n#define MAP_PRIVATE   0x02\n#define MAP_ANON    0x1000\n#define PROT_READ      1\n#define PROT_WRITE     2\n#define PROT_EXEC      4\n\n/* bug in crosstool/powerpc-750-linux-gnu/gcc-3.4.1-glibc-20040827:\n   unsigned long long off_t goes into registers (9,10) instead of (8,9).\n   Adjust in mmap(), pread(), and include/darwin.h .\n*/\nextern char *mmap(char *, size_t, unsigned, unsigned, int, off_t_upx_stub);\nssize_t pread(int, void *, size_t, off_t_upx_stub);\n\nstatic Mach_ppc_thread_state const *\ndo_xmap(\n    Mach_header const *const mhdr,\n    off_t_upx_stub const fat_offset,\n    Extent *const xi,\n    int const fdi,\n    Mach_header **mhdrpp,\n    f_expand *const f_decompress,\n    f_unfilter *const f_unf\n)\n{\n    Mach_segment_command const *sc = (Mach_segment_command const *)(1+ mhdr);\n    Mach_ppc_thread_state const *entry = 0;\n    unsigned j;\n\n    for ( j=0; j < mhdr->ncmds; ++j,\n        (sc = (Mach_segment_command const *)(sc->cmdsize + (char const *)sc))\n    ) if (LC_SEGMENT==sc->cmd) {\n        Extent xo;\n        size_t mlen = xo.size = sc->filesize;\n        char  *addr = xo.buf  =                 (char *)sc->vmaddr;\n        char *haddr =           sc->vmsize +                  addr;\n        size_t frag = (int)addr &~ PAGE_MASK;\n        addr -= frag;\n        mlen += frag;\n\n        if (0!=mlen && addr != mmap(addr, mlen, VM_PROT_READ | VM_PROT_WRITE,\n                MAP_FIXED | MAP_PRIVATE |\n                    ((xi || 0==sc->filesize) ? MAP_ANON : 0),\n                ((0==sc->filesize) ? -1 : fdi), sc->fileoff + fat_offset) ) {\n            err_exit(8);\n        }\n        if (xi && 0!=sc->filesize) {\n            if (0==sc->fileoff /*&& 0!=mhdrpp*/) {\n                *mhdrpp = (Mach_header *)addr;\n            }\n            unpackExtent(xi, &xo, f_decompress, f_unf);\n        }\n        /*bzero(addr, frag);*/  // fragment at lo end\n        frag = (-mlen) &~ PAGE_MASK;  // distance to next page boundary\n        bzero(mlen+addr, frag);  // fragment at hi end\n        if (0!=mlen && 0!=mprotect(addr, mlen, sc->initprot)) {\n            err_exit(10);\nERR_LAB\n        }\n        addr += mlen + frag;  /* page boundary on hi end */\n        if (addr < haddr) { // need pages for .bss\n            if (addr != mmap(addr, haddr - addr, sc->initprot,\n                    MAP_FIXED | MAP_PRIVATE | MAP_ANON, -1, 0 ) ) {\n                err_exit(9);\n            }\n        }\n    }\n    else if (LC_UNIXTHREAD==sc->cmd || LC_THREAD==sc->cmd) {\n        Mach_thread_command const *const thrc = (Mach_thread_command const *)sc;\n        if (PPC_THREAD_STATE      ==thrc->flavor\n        &&  PPC_THREAD_STATE_COUNT==thrc->count ) {\n            entry = &thrc->state;\n        }\n    }\n    return entry;\n}\n\n\n/*************************************************************************\n// upx_main - called by our entry code\n//\n**************************************************************************/\n\nMach_ppc_thread_state const *\nupx_main(\n    struct l_info const *const li,\n    size_t volatile sz_compressed,  // total length\n    Mach_header *const mhdr,  // temp char[sz_mhdr] for decompressing\n    size_t const sz_mhdr,\n    f_expand *const f_decompress,\n    f_unfilter *const f_unf,\n    Mach_header **const mhdrpp  // Out: *mhdrpp= &real Mach_header\n)\n{\n    Mach_ppc_thread_state const *entry;\n    off_t_upx_stub fat_offset = 0;\n    Extent xi, xo, xi0;\n    xi.buf  = CONST_CAST(char *, 1+ (struct p_info const *)(1+ li));  // &b_info\n    xi.size = sz_compressed - (sizeof(struct l_info) + sizeof(struct p_info));\n    xo.buf  = (char *)mhdr;\n    xo.size = ((struct b_info const *)xi.buf)->sz_unc;\n    xi0 = xi;\n\n    // Uncompress Macho headers\n    unpackExtent(&xi, &xo, f_decompress, 0);  // never filtered?\n\n    entry = do_xmap(mhdr, fat_offset, &xi0, -1, mhdrpp, f_decompress, f_unf);\n\n  { // Map dyld dynamic loader\n    Mach_load_command const *lc = (Mach_load_command const *)(1+ mhdr);\n    unsigned j;\n\n    for (j=0; j < mhdr->ncmds; ++j,\n        (lc = (Mach_load_command const *)(lc->cmdsize + (char const *)lc))\n    ) if (LC_LOAD_DYLINKER==lc->cmd) {\n        char const *const dyld_name = ((Mach_lc_str const *)(1+ lc))->offset +\n            (char const *)lc;\n        int const fdi = open(dyld_name, O_RDONLY, 0);\n        if (0 > fdi) {\n            err_exit(18);\n        }\nfat:\n        if ((ssize_t)sz_mhdr!=pread(fdi, (void *)mhdr, sz_mhdr, fat_offset)) {\nERR_LAB\n            err_exit(19);\n        }\n        switch (mhdr->magic) {\n        case MH_MAGIC: break;\n        case FAT_MAGIC: {\n            // stupid Apple: waste code and a page fault on EVERY execve\n            Fat_header const *const fh = (Fat_header const *)mhdr;\n            Fat_arch const *fa = (Fat_arch const *)(1+ fh);\n            for (j= 0; j < fh->nfat_arch; ++j, ++fa) {\n                if (CPU_TYPE_POWERPC==fa->cputype) {\n                    fat_offset= fa->offset;\n                    goto fat;\n                }\n            }\n        } break;\n        } // switch\n        entry = do_xmap(mhdr, fat_offset, 0, fdi, 0, 0, 0);\n        close(fdi);\n        break;\n    }\n  }\n\n    return entry;\n}\n\n/* vim:set ts=4 sw=4 et: */\n","size_bytes":14032},"src/stub/src/powerpc-darwin.macho-upxmain.c":{"content":"/* powerpc-darwin.macho-upxmain.c -- loader hack for Mach-o powerpc\n\n   This file is part of the UPX executable compressor.\n\n   Copyright (C) 1996-2025 Markus Franz Xaver Johannes Oberhumer\n   Copyright (C) 1996-2025 Laszlo Molnar\n   Copyright (C) 2000-2025 John F. Reiser\n   All Rights Reserved.\n\n   UPX and the UCL library are free software; you can redistribute them\n   and/or modify them under the terms of the GNU General Public License as\n   published by the Free Software Foundation; either version 2 of\n   the License, or (at your option) any later version.\n\n   This program is distributed in the hope that it will be useful,\n   but WITHOUT ANY WARRANTY; without even the implied warranty of\n   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n   GNU General Public License for more details.\n\n   You should have received a copy of the GNU General Public License\n   along with this program; see the file COPYING.\n   If not, write to the Free Software Foundation, Inc.,\n   59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.\n\n   Markus F.X.J. Oberhumer              Laszlo Molnar\n   <markus@oberhumer.com>               <ml1050@users.sourceforge.net>\n\n   John F. Reiser\n   <jreiser@users.sourceforge.net>\n */\n\n#define __WORDSIZE 32\n#include <stdio.h>\n#include <stdlib.h>\n#include \"include/darwin.h\"\n\n#ifndef DEBUG  /*{*/\n#define DEBUG 0\n#endif  /*}*/\n\n/*************************************************************************\n// configuration section\n**************************************************************************/\n\n// In order to make it much easier to move this code at runtime and execute\n// it at an address different from it load address:  there must be no\n// static data, and no string constants.\n\n#if !DEBUG  /*{*/\n#define DPRINTF(a) /* empty: no debug drivel */\n#define DEBUG_STRCON(name, value) /* empty */\n#else  /*}{ DEBUG */\nextern int write(int, void const *, size_t);\n#if 0\n#include \"stdarg.h\"\n#else\n#define va_arg      __builtin_va_arg\n#define va_end      __builtin_va_end\n#define va_list     __builtin_va_list\n#define va_start    __builtin_va_start\n#endif\n\n#if defined(__i386__) || defined(__x86_64__) /*{*/\n#define PIC_STRING(value, var) \\\n    __asm__ __volatile__ ( \\\n        \"call 0f; .asciz \\\"\" value \"\\\"; \\\n      0: pop %0;\" : \"=r\"(var) : \\\n    )\n#elif defined(__arm__)  /*}{*/\n#define PIC_STRING(value, var) \\\n    __asm__ __volatile__ ( \\\n        \"mov %0,pc; b 0f; \\\n        .asciz \\\"\" value \"\\\"; .balign 4; \\\n      0: \" : \"=r\"(var) \\\n    )\n#elif defined(__mips__)  /*}{*/\n#define PIC_STRING(value, var) \\\n    __asm__ __volatile__ ( \\\n        \".set noreorder; bal 0f; move %0,$31; .set reorder; \\\n        .asciz \\\"\" value \"\\\"; .balign 4; \\\n      0: \" \\\n        : \"=r\"(var) : : \"ra\" \\\n    )\n#endif  /*}*/\n\n\n#define DEBUG_STRCON(name, strcon) \\\n    static char const *name(void) { \\\n        register char const *rv; PIC_STRING(strcon, rv); \\\n        return rv; \\\n    }\n\n\n#ifdef __arm__  /*{*/\nextern unsigned div10(unsigned);\n#else  /*}{*/\nstatic unsigned\ndiv10(unsigned x)\n{\n    return x / 10u;\n}\n#endif  /*}*/\n\nstatic int\nunsimal(unsigned x, char *ptr, int n)\n{\n    if (10<=x) {\n        unsigned const q = div10(x);\n        x -= 10 * q;\n        n = unsimal(q, ptr, n);\n    }\n    ptr[n] = '0' + x;\n    return 1+ n;\n}\n\nstatic int\ndecimal(int x, char *ptr, int n)\n{\n    if (x < 0) {\n        x = -x;\n        ptr[n++] = '-';\n    }\n    return unsimal(x, ptr, n);\n}\n\nDEBUG_STRCON(STR_hex, \"0123456789abcdef\");\n\nstatic int\nheximal(unsigned long x, char *ptr, int n)\n{\n    if (16<=x) {\n        n = heximal(x>>4, ptr, n);\n        x &= 0xf;\n    }\n    ptr[n] = STR_hex()[x];\n    return 1+ n;\n}\n\n\n#define DPRINTF(a) my_printf a\n\nstatic int\nmy_printf(char const *fmt, ...)\n{\n    char c;\n    int n= 0;\n    char *ptr;\n    char buf[20];\n    va_list va; va_start(va, fmt);\n    ptr= &buf[0];\n    while (0!=(c= *fmt++)) if ('%'!=c) goto literal;\n    else switch (c= *fmt++) {\n    default: {\nliteral:\n        n+= write(2, fmt-1, 1);\n    } break;\n    case 0: goto done;  /* early */\n    case 'u': {\n        n+= write(2, buf, unsimal(va_arg(va, unsigned), buf, 0));\n    } break;\n    case 'd': {\n        n+= write(2, buf, decimal(va_arg(va, int), buf, 0));\n    } break;\n    case 'p': {\n        buf[0] = '0';\n        buf[1] = 'x';\n        n+= write(2, buf, heximal((unsigned long)va_arg(va, void *), buf, 2));\n    } break;\n    case 'x': {\n        buf[0] = '0';\n        buf[1] = 'x';\n        n+= write(2, buf, heximal(va_arg(va, int), buf, 2));\n    } break;\n    }\ndone:\n    va_end(va);\n    return n;\n}\n#endif  /*}*/\n\n\n/*************************************************************************\n// \"file\" util\n**************************************************************************/\n\ntypedef struct {\n    size_t size;  // must be first to match size[0] uncompressed size\n    void *buf;\n} Extent;\n\nDEBUG_STRCON(STR_xread, \"xread %%p(%%x %%p) %%p %%x\\\\n\")\nDEBUG_STRCON(STR_xreadfail, \"xreadfail %%p(%%x %%p) %%p %%x\\\\n\")\n\nstatic void\nxread(Extent *x, void *buf, size_t count)\n{\n    unsigned char *p=x->buf, *q=buf;\n    size_t j;\n    DPRINTF((STR_xread(), x, x->size, x->buf, buf, count));\n    if (x->size < count) {\n        DPRINTF((STR_xreadfail(), x, x->size, x->buf, buf, count));\n        exit(127);\n    }\n    for (j = count; 0!=j--; ++p, ++q) {\n        *q = *p;\n    }\n    x->buf  += count;\n    x->size -= count;\n}\n\n\n/*************************************************************************\n// util\n**************************************************************************/\n\n#if 1  //{  save space\n#define ERR_LAB error: exit(127);\n#define err_exit(a) goto error\n#else  //}{  save debugging time\n#define ERR_LAB /*empty*/\nDEBUG_STRCON(STR_exit, \"err_exit %%x\\\\n\");\n\nstatic void\nerr_exit(int a)\n{\n    DPRINTF((STR_exit(), a));\n    (void)a;  // debugging convenience\n    exit(127);\n}\n#endif  //}\n\n\n/*************************************************************************\n// UPX & NRV stuff\n**************************************************************************/\n\nstruct l_info { // 12-byte trailer for loader (after macho headers)\n    unsigned l_checksum;\n    unsigned l_magic;  // UPX_MAGIC_LE32\n    unsigned short l_lsize;\n    unsigned char l_version;\n    unsigned char l_format;\n};\nstruct p_info { // 12-byte packed program header\n    unsigned p_progid;\n    unsigned p_filesize;\n    unsigned p_blocksize;\n};\n\nstruct b_info { // 12-byte header before each compressed block\n    unsigned sz_unc;  // uncompressed_size\n    unsigned sz_cpr;  //   compressed_size\n    unsigned char b_method;  // compression algorithm\n    unsigned char b_ftid;  // filter id\n    unsigned char b_cto8;  // filter parameter\n    unsigned char b_unused;\n};\n\ntypedef void f_unfilter(\n    nrv_byte *,  // also addvalue\n    nrv_uint,\n    unsigned cto8, // junk in high 24 bits\n    unsigned ftid\n);\ntypedef int f_expand(\n    const nrv_byte *, nrv_uint,\n          nrv_byte *, nrv_uint *, unsigned );\n\nDEBUG_STRCON(STR_unpackExtent,\n        \"unpackExtent in=%%p(%%x %%p)  out=%%p(%%x %%p)  %%p %%p\\\\n\");\nDEBUG_STRCON(STR_err5, \"sz_cpr=%%x  sz_unc=%%x  xo->size=%%x\\\\n\");\n\nstatic void\nunpackExtent(\n    Extent *const xi,  // input\n    Extent *const xo,  // output\n    f_expand *const f_decompress,\n    f_unfilter *f_unf\n)\n{\n    DPRINTF((STR_unpackExtent(),\n        xi, xi->size, xi->buf, xo, xo->size, xo->buf, f_decompress, f_unf));\n    while (xo->size) {\n        struct b_info h;\n        //   Note: if h.sz_unc == h.sz_cpr then the block was not\n        //   compressible and is stored in its uncompressed form.\n\n        // Read and check block sizes.\n        xread(xi, (unsigned char *)&h, sizeof(h));\n        if (h.sz_unc == 0) {                     // uncompressed size 0 -> EOF\n            if (h.sz_cpr != UPX_MAGIC_LE32)      // h.sz_cpr must be h->magic\n                err_exit(2);\n            if (xi->size != 0)                 // all bytes must be written\n                err_exit(3);\n            break;\n        }\n        if (h.sz_cpr <= 0) {\n            err_exit(4);\nERR_LAB\n        }\n        if (h.sz_cpr > h.sz_unc\n        ||  h.sz_unc > xo->size ) {\n            DPRINTF((STR_err5(), h.sz_cpr, h.sz_unc, xo->size));\n            err_exit(5);\n        }\n        // Now we have:\n        //   assert(h.sz_cpr <= h.sz_unc);\n        //   assert(h.sz_unc > 0 && h.sz_unc <= blocksize);\n        //   assert(h.sz_cpr > 0 && h.sz_cpr <= blocksize);\n\n        if (h.sz_cpr < h.sz_unc) { // Decompress block\n            nrv_uint out_len = h.sz_unc;  // EOF for lzma\n            int const j = (*f_decompress)(xi->buf, h.sz_cpr,\n                xo->buf, &out_len, h.b_method);\n            if (j != 0 || out_len != (nrv_uint)h.sz_unc)\n                err_exit(7);\n            if (h.b_ftid!=0 && f_unf) {  // have filter\n                (*f_unf)(xo->buf, out_len, h.b_cto8, h.b_ftid);\n            }\n            xi->buf  += h.sz_cpr;\n            xi->size -= h.sz_cpr;\n        }\n        else { // copy literal block\n            xi->size += sizeof(h);  // xread(xi, &h, sizeof(h)) was a peek\n            xread(xi, xo->buf, h.sz_cpr);\n        }\n        xo->buf  += h.sz_unc;\n        xo->size -= h.sz_unc;\n    }\n}\n\nstatic void\nupx_bzero(unsigned char *p, size_t len)\n{\n    if (len) do {\n        *p++= 0;\n    } while (--len);\n}\n#define bzero upx_bzero\n\n\n// The PF_* and PROT_* bits are {1,2,4}; the conversion table fits in 32 bits.\n#define REP8(x) \\\n    ((x)|((x)<<4)|((x)<<8)|((x)<<12)|((x)<<16)|((x)<<20)|((x)<<24)|((x)<<28))\n#define EXP8(y) \\\n    ((1&(y)) ? 0xf0f0f0f0 : (2&(y)) ? 0xff00ff00 : (4&(y)) ? 0xffff0000 : 0)\n#define PF_TO_PROT(pf) \\\n    ((PROT_READ|PROT_WRITE|PROT_EXEC) & ( \\\n        ( (REP8(PROT_EXEC ) & EXP8(PF_X)) \\\n         |(REP8(PROT_READ ) & EXP8(PF_R)) \\\n         |(REP8(PROT_WRITE) & EXP8(PF_W)) \\\n        ) >> ((pf & (PF_R|PF_W|PF_X))<<2) ))\n\ntypedef struct {\n    unsigned magic;\n    unsigned nfat_arch;\n} Fat_header;\ntypedef struct {\n    unsigned cputype;\n    unsigned cpusubtype;\n    unsigned offset;\n    unsigned size;\n    unsigned align;  /* shift count (log base 2) */\n} Fat_arch;\n    enum e8 {\n        FAT_MAGIC = 0xcafebabe,\n        FAT_CIGAM = 0xbebafeca\n    };\n    enum e9 {\n        CPU_TYPE_I386      =          7,\n        CPU_TYPE_AMD64     = 0x01000007,\n        CPU_TYPE_ARM       =         12,\n        CPU_TYPE_POWERPC   = 0x00000012,\n        CPU_TYPE_POWERPC64 = 0x01000012\n    };\n\ntypedef struct {\n    unsigned magic;\n    unsigned cputype;\n    unsigned cpysubtype;\n    unsigned filetype;\n    unsigned ncmds;\n    unsigned sizeofcmds;\n    unsigned flags;\n} Mach_header;\n        enum e0 {\n            MH_MAGIC   =   0xfeedface,\n            MH_MAGIC64 = 1+0xfeedface\n        };\n        enum e2 {\n            MH_EXECUTE = 2\n        };\n        enum e3 {\n            MH_NOUNDEFS = 1\n        };\n\ntypedef struct {\n    unsigned cmd;\n    unsigned cmdsize;\n} Mach_load_command;\n        enum e4 {\n            LC_REQ_DYLD      = 0x80000000,  // OR'ed ==> must not ignore\n            LC_SEGMENT       = 0x1,\n            LC_SEGMENT_64    = 0x19,\n            LC_THREAD        = 0x4,\n            LC_UNIXTHREAD    = 0x5,\n            LC_LOAD_DYLINKER = 0xe,\n            LC_MAIN          = (0x28|LC_REQ_DYLD)\n        };\n\ntypedef struct {\n    unsigned cmd;\n    unsigned cmdsize;\n    char segname[16];\n    uint32_t vmaddr;\n    uint32_t vmsize;\n    uint32_t fileoff;\n    uint32_t filesize;\n    unsigned maxprot;\n    unsigned initprot;\n    unsigned nsects;\n    unsigned flags;\n} Mach_segment_command;\n        enum e5 {\n            VM_PROT_READ = 1,\n            VM_PROT_WRITE = 2,\n            VM_PROT_EXECUTE = 4\n        };\n\ntypedef struct {\n    char sectname[16];\n    char segname[16];\n    uint32_t addr;   /* memory address */\n    uint32_t size;   /* size in bytes */\n    unsigned offset; /* file offset */\n    unsigned align;  /* power of 2 */\n    unsigned reloff; /* file offset of relocation entries */\n    unsigned nreloc; /* number of relocation entries */\n    unsigned flags;  /* section type and attributes */\n    unsigned reserved1;  /* for offset or index */\n    unsigned reserved2;  /* for count or sizeof */\n} Mach_section_command;\n\ntypedef struct {\n    uint32_t cmd;  // LC_MAIN;  MH_EXECUTE only\n    uint32_t cmdsize;  // 24\n    uint64_t entryoff;  // file offset of main() [expected in __TEXT]\n    uint64_t stacksize;  // non-default initial stack size\n} Mach_main_command;\n\ntypedef struct {\n    uint32_t srr0;      /* Instruction address register (PC; entry addr) */\n    uint32_t srr1;      /* Machine state register (supervisor) */\n    uint32_t  r0, r1, r2, r3, r4, r5, r6, r7;\n    uint32_t  r8, r9,r10,r11,r12,r13,r14,r15;\n    uint32_t r16,r17,r18,r19,r20,r21,r22,r23;\n    uint32_t r24,r25,r26,r27,r28,r29,r30,r31;\n\n    uint32_t cr;        /* Condition register */  // FIXME: Word?\n    uint32_t xer;       /* User's integer exception register */\n    uint32_t lr;        /* Link register */\n    uint32_t ctr;       /* Count register */\n    uint32_t mq;        /* MQ register (601 only) */\n\n    uint32_t vrsave;    /* Vector Save Register */\n} Mach_ppc_thread_state;\n\ntypedef struct {\n    unsigned cmd;            /* LC_THREAD or  LC_UNIXTHREAD */\n    unsigned cmdsize;        /* total size of this command */\n    unsigned flavor;\n    unsigned count;          /* sizeof(following_thread_state)/4 */\n    Mach_ppc_thread_state state;\n} Mach_thread_command;\n        enum e6 {\n            PPC_THREAD_STATE = 1\n        };\n        enum e7 {\n            PPC_THREAD_STATE_COUNT = sizeof(Mach_ppc_thread_state)/4\n        };\n\ntypedef union {\n    unsigned offset;  /* from start of load command to string */\n} Mach_lc_str;\n\n#define MAP_FIXED     0x10\n#define MAP_PRIVATE   0x02\n#define MAP_ANON    0x1000\n//#define MAP_ANON  0x20  // x86 DEBUG ONLY\n#define PROT_READ      1\n#define PROT_WRITE     2\n#define PROT_EXEC      4\n#define MAP_ANON_FD    -1\n#define MAP_FAILED ((void *) -1)\n\nextern void *mmap(void *, size_t, unsigned, unsigned, int, off_t);\nssize_t pread(int, void *, size_t, off_t);\n//extern void bswap(void *, unsigned);\n\nDEBUG_STRCON(STR_mmap,\n    \"mmap  addr=%%p  len=%%p  prot=%%x  flags=%%x  fd=%%d  off=%%p\\\\n\");\nDEBUG_STRCON(STR_do_xmap,\n    \"do_xmap  fdi=%%x  mhdr=%%p  xi=%%p(%%x %%p) f_unf=%%p\\\\n\")\n\nstatic uint32_t  // entry address\ndo_xmap(\n    Mach_header const *const mhdr,\n    off_t const fat_offset,\n    Extent *const xi,\n    int const fdi,\n    Mach_header **mhdrpp,\n    f_expand *const f_decompress,\n    f_unfilter *const f_unf\n)\n{\n    Mach_segment_command const *sc = (Mach_segment_command const *)(1+ mhdr);\n    Mach_segment_command const *segTEXT = 0;\n    uint32_t entry = 0;\n    unsigned long base = 0;\n    unsigned j;\n\n    DPRINTF((STR_do_xmap(),\n        fdi, mhdr, xi, (xi? xi->size: 0), (xi? xi->buf: 0), f_unf));\n\n    for ( j=0; j < mhdr->ncmds; ++j,\n        (sc = (Mach_segment_command const *)(sc->cmdsize + (void const *)sc))\n    ) if (LC_SEGMENT==sc->cmd && sc->vmsize!=0) {\n        Extent xo;\n        size_t mlen = xo.size = sc->filesize;\n        unsigned char  *addr = xo.buf  = base + (unsigned char *)sc->vmaddr;\n        unsigned char *haddr =     sc->vmsize +                        addr;\n        size_t frag = (int)(uint32_t)addr &~ PAGE_MASK;\n        addr -= frag;\n        mlen += frag;\n\n        if (0!=mlen) { // In particular, omitted for __PAGEZERO\n            unsigned const prot = VM_PROT_READ | VM_PROT_WRITE;\n            unsigned const flags = (addr ? MAP_FIXED : 0) | MAP_PRIVATE |\n                        ((xi || 0==sc->filesize) ? MAP_ANON : 0);\n            int const fdm = ((0==sc->filesize) ? MAP_ANON_FD : fdi);\n            off_t const offset = sc->fileoff + fat_offset;\n\n            DPRINTF((STR_mmap(),       addr, mlen, prot, flags, fdm, offset));\n            unsigned char *mapa = mmap(addr, mlen, prot, flags, fdm, offset);\n            if (MAP_FAILED == mapa) {\n                err_exit(8);\n            }\n            if (0 == addr) { // dyld auto-relocate\n                base = (unsigned long)mapa;  // relocation constant\n            }\n            addr = mapa;\n        }\n        if (xi && 0!=sc->filesize) {\n            if (0==sc->fileoff /*&& 0!=mhdrpp*/) {\n                segTEXT = sc;\n                *mhdrpp = (Mach_header *)(void *)addr;\n            }\n            unpackExtent(xi, &xo, f_decompress, f_unf);\n        }\n        /*bzero(addr, frag);*/  // fragment at lo end\n        frag = (-mlen) &~ PAGE_MASK;  // distance to next page boundary\n        bzero(mlen+addr, frag);  // fragment at hi end\n        if (0!=mlen && 0!=mprotect(addr, mlen, sc->initprot)) {\n            err_exit(10);\nERR_LAB\n        }\n        addr += mlen + frag;  /* page boundary on hi end */\n        if (\n#if defined(SIMULATE_ON_DEBIAN_EABI4)  /*{*/\n            0!=addr &&\n#endif  /*}*/\n                        addr < haddr) { // need pages for .bss\n            if (0!=addr && addr != mmap(addr, haddr - addr, sc->initprot,\n                    MAP_FIXED | MAP_PRIVATE | MAP_ANON, MAP_ANON_FD, 0 ) ) {\n                err_exit(9);\n            }\n        }\n    }\n    else if (LC_UNIXTHREAD==sc->cmd || LC_THREAD==sc->cmd) {\n        Mach_thread_command const *const thrc = (Mach_thread_command const *)sc;\n        if (PPC_THREAD_STATE       ==thrc->flavor\n        &&  PPC_THREAD_STATE_COUNT ==thrc->count ) {\n            entry = thrc->state.srr0 + base;  // JMP\n        }\n    }\n    else if (LC_MAIN==sc->cmd) {\n        entry = ((Mach_main_command const *)sc)->entryoff;\n        if (segTEXT->fileoff <= entry && entry < segTEXT->filesize) {\n            entry += segTEXT->vmaddr;  // CALL\n        }\n        // XXX FIXME TODO: if entry not in segTEXT?\n        // XXX FIXME TODO: LC_MAIN is a CALL; LC_*THREAD is a JMP\n    }\n    return entry;\n}\n\nstatic off_t\nfat_find(Fat_header *fh) // *fh suffers bswap()\n{\n    Fat_arch *fa = (Fat_arch *)(1+ fh);\n    //POWERPC NATIVE; do not need:  bswap(fh, sizeof(*fh) + (fh->nfat_arch>>24)*sizeof(*fa));\n    unsigned j;\n    for (j= 0; j < fh->nfat_arch; ++j, ++fa) {\n        if (CPU_TYPE_POWERPC==fa->cputype) {\n            return fa->offset;  // should not be 0 because of header\n        }\n    }\n    return 0;\n}\n\n/*************************************************************************\n// upx_main - called by our entry code\n//\n**************************************************************************/\n\nDEBUG_STRCON(STR_upx_main,\n    \"upx_main szc=%%x  f_dec=%%p  f_unf=%%p  \"\n    \"  xo=%%p(%%x %%p)  xi=%%p(%%x %%p)  mhdrpp=%%p\\\\n\")\n\nuint32_t // entry address\nupx_main(\n    struct l_info const *const li,\n    size_t volatile sz_compressed,  // total length\n    Mach_header *const mhdr,  // temp char[sz_mhdr] for decompressing\n    size_t const sz_mhdr,\n    f_expand *const f_decompress,\n    f_unfilter *const f_unf,\n    Mach_header **const mhdrpp  // Out: *mhdrpp= &real Mach_header\n)\n{\n    uint32_t entry;\n    off_t fat_offset = 0;\n    Extent xi, xo, xi0;\n    xi.buf  = CONST_CAST(unsigned char *, 1+ (struct p_info const *)(1+ li));  // &b_info\n    xi.size = sz_compressed - (sizeof(struct l_info) + sizeof(struct p_info));\n    xo.buf  = (unsigned char *)mhdr;\n    xo.size = ((struct b_info const *)(void const *)xi.buf)->sz_unc;\n    xi0 = xi;\n\n    DPRINTF((STR_upx_main(),\n        sz_compressed, f_decompress, f_unf, &xo, xo.size, xo.buf,\n        &xi, xi.size, xi.buf, mhdrpp));\n\n    // Uncompress Macho headers\n    unpackExtent(&xi, &xo, f_decompress, 0);  // never filtered?\n\n    entry = do_xmap(mhdr, fat_offset, &xi0, MAP_ANON_FD, mhdrpp, f_decompress, f_unf);\n\n  { // Map dyld dynamic loader\n    Mach_load_command const *lc = (Mach_load_command const *)(1+ mhdr);\n    unsigned j;\n\n    for (j=0; j < mhdr->ncmds; ++j,\n        (lc = (Mach_load_command const *)(lc->cmdsize + (void const *)lc))\n    ) if (LC_LOAD_DYLINKER==lc->cmd) {\n        char const *const dyld_name = ((Mach_lc_str const *)(1+ lc))->offset +\n            (char const *)lc;\n        int const fdi = open(dyld_name, O_RDONLY, 0);\n        if (0 > fdi) {\n            err_exit(18);\n        }\n        for (;;) { // possibly 2 times for 'fat' binary\n            if (sz_mhdr!=pread(fdi, (void *)mhdr, sz_mhdr, fat_offset)) {\nERR_LAB\n                err_exit(19);\n            }\n            switch (mhdr->magic) {\n            case MH_MAGIC: break;  // i686 on x86_64 ?\n            case MH_MAGIC64: break;\n\n            case FAT_CIGAM:\n            case FAT_MAGIC: {\n                // stupid Apple: waste code and a page fault on EVERY execve\n                fat_offset = fat_find((Fat_header *)mhdr);\n                if (fat_offset) {\n                    continue;  // the 'for' loop\n                }\n                err_exit(20);  // no other choice\n            } break;\n            } // switch\n            break;\n        }\n        entry = do_xmap(mhdr, fat_offset, 0, fdi, 0, 0, 0);\n        close(fdi);\n        break;\n    }\n  }\n\n    return entry;\n}\n\ntypedef struct {\n    uint32_t cmd;\n    uint32_t cmdsize;\n    uint32_t data[2];  // because cmdsize >= 16\n} Mach_command;  // generic prefix\n\n// Build on PowerPC Macintosh:\n// gcc -c -v -save-temps \\\n//    powerpc-darwin.macho-upxsubr.S \\\n//    powerpc-darwin.macho-upxmain.c\n//\n// /usr/libexec/gcc/powerpc-apple-darwin8/4.0.0/collect2 -arch ppc -weak_reference_mismatches non-weak \\\n//    -o powerpc-darwin.macho-upxmain.exe \\\n//    powerpc-darwin.macho-upxsubr.o \\\n//    powerpc-darwin.macho-upxmain.o \\\n//    -pagezero_size 0x1000 -bind_at_load -headerpad 0x300\n//# -unexported_symbols_list unexport-upxload.txt\n//\n//  strip -u -r powerpc-darwin.macho-upxmain.exe\n\nint\nmain(int argc, char *argv[])\n{\n    Mach_header const *mhdr0 = (Mach_header const *)((~0ul<<12) & (unsigned long)&main);\n    Mach_command const *ptr = (Mach_command const *)(1+ mhdr0);\n    f_unfilter *f_unf;\n    f_expand *f_exp;\n    char *payload;\n    size_t paysize;\n\n    unsigned j;\n    for (j=0; j < mhdr0->ncmds; ++j,\n            ptr = (Mach_command const *)(ptr->cmdsize + (char const *)ptr))\n    if (LC_SEGMENT==ptr->cmd) {\n        Mach_segment_command const *const seg = (Mach_segment_command const *)ptr;\n        // Compare 8 characters\n        if (*(uint64_t const *)(&\"__LINKEDIT\"[2]) == *(uint64_t const *)(&seg->segname[2])) {\n            f_unf = (f_unfilter *)(sizeof(unsigned)             + seg->vmaddr);\n            f_exp = (f_expand *)(*(unsigned const *)seg->vmaddr + seg->vmaddr);\n            unsigned const *q = (unsigned const *)seg->vmaddr;\n            while (!(paysize = *--q)) /*empty*/ ;\n            payload = (char *)(-paysize + (char const *)q);\n            break;\n        }\n    }\n    char mhdr[32768];\n    uint32_t entry = upx_main((struct l_info const *)payload, paysize,\n        (Mach_header *)mhdr, sizeof(mhdr),\n        f_exp, f_unf, (Mach_header **)&argv[-2]);\n\n    //bzero(mhdr, sizeof(mhdr));  // paranoia\n    munmap(payload, paysize);  // leaving __LINKEDIT\n    return entry;\n}\n\n/* vim:set ts=4 sw=4 et: */\n","size_bytes":22736},"src/stub/src/powerpc-linux.elf-main.c":{"content":"#include \"i386-linux.elf-main.c\"\n","size_bytes":33},"src/stub/src/powerpc-linux.elf-main2.c":{"content":"#include \"i386-linux.elf-main2.c\"\n","size_bytes":34},"src/stub/src/powerpc64-darwin.macho-main.c":{"content":"/* powerpc64-darwin.macho-main.c -- loader stub for Mach-o PowerPC64\n\n   This file is part of the UPX executable compressor.\n\n   Copyright (C) 1996-2025 Markus Franz Xaver Johannes Oberhumer\n   Copyright (C) 1996-2025 Laszlo Molnar\n   Copyright (C) 2000-2025 John F. Reiser\n   All Rights Reserved.\n\n   UPX and the UCL library are free software; you can redistribute them\n   and/or modify them under the terms of the GNU General Public License as\n   published by the Free Software Foundation; either version 2 of\n   the License, or (at your option) any later version.\n\n   This program is distributed in the hope that it will be useful,\n   but WITHOUT ANY WARRANTY; without even the implied warranty of\n   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n   GNU General Public License for more details.\n\n   You should have received a copy of the GNU General Public License\n   along with this program; see the file COPYING.\n   If not, write to the Free Software Foundation, Inc.,\n   59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.\n\n   Markus F.X.J. Oberhumer              Laszlo Molnar\n   <markus@oberhumer.com>               <ezerotven+github@gmail.com>\n\n   John F. Reiser\n   <jreiser@users.sourceforge.net>\n */\n\n\n#define __WORDSIZE 64\n#include \"include/darwin.h\"\n\n\n/*************************************************************************\n// configuration section\n**************************************************************************/\n\n// In order to make it much easier to move this code at runtime and execute\n// it at an address different from it load address:  there must be no\n// static data, and no string constants.\n\n\n/*************************************************************************\n// \"file\" util\n**************************************************************************/\n\ntypedef struct {\n    size_t size;  // must be first to match size[0] uncompressed size\n    char *buf;\n} Extent;\n\n\nstatic void\nxread(Extent *x, char *buf, size_t count)\n{\n    char *p=x->buf, *q=buf;\n    size_t j;\n    if (x->size < count) {\n        exit(127);\n    }\n    for (j = count; 0!=j--; ++p, ++q) {\n        *q = *p;\n    }\n    x->buf  += count;\n    x->size -= count;\n}\n\n\n/*************************************************************************\n// util\n**************************************************************************/\n\n#if 1  //{  save space\n#define ERR_LAB error: exit(127);\n#define err_exit(a) goto error\n#else  //}{  save debugging time\n#define ERR_LAB /*empty*/\nstatic void\nerr_exit(int a)\n{\n    (void)a;  // debugging convenience\n    exit(127);\n}\n#endif  //}\n\n\n/*************************************************************************\n// UPX & NRV stuff\n**************************************************************************/\n\nstruct l_info { // 12-byte trailer for loader (after macho headers)\n    unsigned l_checksum;\n    unsigned l_magic;  // UPX_MAGIC_LE32\n    unsigned short l_lsize;\n    unsigned char l_version;\n    unsigned char l_format;\n};\nstruct p_info { // 12-byte packed program header\n    unsigned p_progid;\n    unsigned p_filesize;\n    unsigned p_blocksize;\n};\n\nstruct b_info { // 12-byte header before each compressed block\n    unsigned sz_unc;  // uncompressed_size\n    unsigned sz_cpr;  //   compressed_size\n    unsigned char b_method;  // compression algorithm\n    unsigned char b_ftid;  // filter id\n    unsigned char b_cto8;  // filter parameter\n    unsigned char b_unused;\n};\n\ntypedef void f_unfilter(\n    nrv_byte *,  // also addvalue\n    nrv_uint,\n    unsigned cto8, // junk in high 24 bits\n    unsigned ftid\n);\ntypedef int f_expand(\n    const nrv_byte *, nrv_uint,\n          nrv_byte *, nrv_uint *, unsigned );\n\nstatic void\nunpackExtent(\n    Extent *const xi,  // input\n    Extent *const xo,  // output\n    f_expand *const f_decompress,\n    f_unfilter *f_unf\n)\n{\n    while (xo->size) {\n        struct b_info h;\n        //   Note: if h.sz_unc == h.sz_cpr then the block was not\n        //   compressible and is stored in its uncompressed form.\n\n        // Read and check block sizes.\n        xread(xi, (char *)&h, sizeof(h));\n        if (h.sz_unc == 0) {                     // uncompressed size 0 -> EOF\n            if (h.sz_cpr != UPX_MAGIC_LE32)      // h.sz_cpr must be h->magic\n                err_exit(2);\n            if (xi->size != 0)                 // all bytes must be written\n                err_exit(3);\n            break;\n        }\n        if (h.sz_cpr <= 0) {\n            err_exit(4);\nERR_LAB\n        }\n        if (h.sz_cpr > h.sz_unc\n        ||  h.sz_unc > xo->size ) {\n            err_exit(5);\n        }\n        // Now we have:\n        //   assert(h.sz_cpr <= h.sz_unc);\n        //   assert(h.sz_unc > 0 && h.sz_unc <= blocksize);\n        //   assert(h.sz_cpr > 0 && h.sz_cpr <= blocksize);\n\n        if (h.sz_cpr < h.sz_unc) { // Decompress block\n            nrv_uint out_len = h.sz_unc;  // EOF for lzma\n            int const j = (*f_decompress)((const unsigned char *)xi->buf, h.sz_cpr,\n                (unsigned char *)xo->buf, &out_len, h.b_method);\n            if (j != 0 || out_len != (nrv_uint)h.sz_unc)\n                err_exit(7);\n            if (h.b_ftid!=0 && f_unf) {  // have filter\n                (*f_unf)((unsigned char *)xo->buf, out_len, h.b_cto8, h.b_ftid);\n            }\n            xi->buf  += h.sz_cpr;\n            xi->size -= h.sz_cpr;\n        }\n        else { // copy literal block\n            xi->size += sizeof(h);  // xread(xi, &h, sizeof(h)) was a peek\n            xread(xi, xo->buf, h.sz_cpr);\n        }\n        xo->buf  += h.sz_unc;\n        xo->size -= h.sz_unc;\n    }\n}\n\nstatic void\nupx_bzero(char *p, size_t len)\n{\n    if (len) do {\n        *p++= 0;\n    } while (--len);\n}\n#define bzero upx_bzero\n\n\n// The PF_* and PROT_* bits are {1,2,4}; the conversion table fits in 32 bits.\n#define REP8(x) \\\n    ((x)|((x)<<4)|((x)<<8)|((x)<<12)|((x)<<16)|((x)<<20)|((x)<<24)|((x)<<28))\n#define EXP8(y) \\\n    ((1&(y)) ? 0xf0f0f0f0 : (2&(y)) ? 0xff00ff00 : (4&(y)) ? 0xffff0000 : 0)\n#define PF_TO_PROT(pf) \\\n    ((PROT_READ|PROT_WRITE|PROT_EXEC) & ( \\\n        ( (REP8(PROT_EXEC ) & EXP8(PF_X)) \\\n         |(REP8(PROT_READ ) & EXP8(PF_R)) \\\n         |(REP8(PROT_WRITE) & EXP8(PF_W)) \\\n        ) >> ((pf & (PF_R|PF_W|PF_X))<<2) ))\n\ntypedef struct {\n    unsigned magic;\n    unsigned nfat_arch;\n} Fat_header;\ntypedef struct {\n    unsigned cputype;\n    unsigned cpusubtype;\n    unsigned offset;\n    unsigned size;\n    unsigned align;  /* power of 2 */\n} Fat_arch;\n    enum e8 {\n        FAT_MAGIC = 0xcafebabe\n    };\n    enum e9 {\n        CPU_TYPE_I386      =          7,\n        CPU_TYPE_POWERPC   = 0x00000012,\n        CPU_TYPE_POWERPC64 = 0x01000012\n    };\n\ntypedef struct {\n    unsigned magic;\n    unsigned cputype;\n    unsigned cpysubtype;\n    unsigned filetype;\n    unsigned ncmds;\n    unsigned sizeofcmds;\n    unsigned flags;\n} Mach_header;\n        enum e0 {\n            MH_MAGIC = 0xfeedface\n        };\n        enum e2 {\n            MH_EXECUTE = 2\n        };\n        enum e3 {\n            MH_NOUNDEFS = 1\n        };\n\ntypedef struct {\n    unsigned cmd;\n    unsigned cmdsize;\n} Mach_load_command;\n        enum e4 {\n            LC_SEGMENT       = 0x1,\n            LC_THREAD        = 0x4,\n            LC_UNIXTHREAD    = 0x5,\n            LC_LOAD_DYLINKER = 0xe\n        };\n\ntypedef struct {\n    unsigned cmd;\n    unsigned cmdsize;\n    char segname[16];\n    unsigned vmaddr;\n    unsigned vmsize;\n    unsigned fileoff;\n    unsigned filesize;\n    unsigned maxprot;\n    unsigned initprot;\n    unsigned nsects;\n    unsigned flags;\n} Mach_segment_command;\n        enum e5 {\n            VM_PROT_READ = 1,\n            VM_PROT_WRITE = 2,\n            VM_PROT_EXECUTE = 4\n        };\n\ntypedef struct {\n    unsigned srr0;      /* Instruction address register (PC; entry addr) */\n    unsigned srr1;      /* Machine state register (supervisor) */\n    unsigned  r0, r1, r2, r3, r4, r5, r6, r7;\n    unsigned  r8, r9,r10,r11,r12,r13,r14,r15;\n    unsigned r16,r17,r18,r19,r20,r21,r22,r23;\n    unsigned r24,r25,r26,r27,r28,r29,r30,r31;\n\n    unsigned cr;        /* Condition register */\n    unsigned xer;       /* User's integer exception register */\n    unsigned lr;        /* Link register */\n    unsigned ctr;       /* Count register */\n    unsigned mq;        /* MQ register (601 only) */\n\n    unsigned vrsave;    /* Vector Save Register */\n} Mach_ppcle_thread_state64;\n\ntypedef struct {\n    unsigned cmd;            /* LC_THREAD or  LC_UNIXTHREAD */\n    unsigned cmdsize;        /* total size of this command */\n    unsigned flavor;\n    unsigned count;          /* sizeof(following_thread_state)/4 */\n    Mach_ppcle_thread_state64 state;\n} Mach_thread_command;\n        enum e6 {\n            PPC_THREAD_STATE = 1\n        };\n        enum e7 {\n            PPC_THREAD_STATE_COUNT = sizeof(Mach_ppcle_thread_state64)/4\n        };\n\ntypedef union {\n    unsigned long offset;  /* from start of load command to string */\n    char *ptr;\n} Mach_lc_str;\n\n#define MAP_FIXED     0x10\n#define MAP_PRIVATE   0x02\n#define MAP_ANON    0x1000\n#define PROT_READ      1\n#define PROT_WRITE     2\n#define PROT_EXEC      4\n\n/* bug in crosstool/powerpc-750-linux-gnu/gcc-3.4.1-glibc-20040827:\n   unsigned long long off_t goes into registers (9,10) instead of (8,9).\n   Adjust in mmap(), pread(), and include/darwin.h .\n*/\nextern char *mmap(char *, size_t, unsigned, unsigned, int, off_t_upx_stub);\nssize_t pread(int, void *, size_t, off_t_upx_stub);\n\nstatic Mach_ppcle_thread_state64 const *\ndo_xmap(\n    Mach_header const *const mhdr,\n    off_t_upx_stub const fat_offset,\n    Extent *const xi,\n    int const fdi,\n    Mach_header **mhdrpp,\n    f_expand *const f_decompress,\n    f_unfilter *const f_unf\n)\n{\n    Mach_segment_command const *sc = (Mach_segment_command const *)(1+ mhdr);\n    Mach_ppcle_thread_state64 const *entry = 0;\n    unsigned j;\n\n    for ( j=0; j < mhdr->ncmds; ++j,\n        (sc = (Mach_segment_command const *)(void const *)(sc->cmdsize + (char const *)sc))\n    ) if (LC_SEGMENT==sc->cmd) {\n        Extent xo;\n        size_t mlen = xo.size = sc->filesize;\n        char  *addr = xo.buf  =                 (char *)(long)sc->vmaddr;\n        char *haddr =           sc->vmsize +                  addr;\n        size_t frag = (long)addr &~ PAGE_MASK;\n        addr -= frag;\n        mlen += frag;\n\n        if (0!=mlen && addr != mmap(addr, mlen, VM_PROT_READ | VM_PROT_WRITE,\n                MAP_FIXED | MAP_PRIVATE |\n                    ((xi || 0==sc->filesize) ? MAP_ANON : 0),\n                ((0==sc->filesize) ? -1 : fdi), sc->fileoff + fat_offset) ) {\n            err_exit(8);\n        }\n        if (xi && 0!=sc->filesize) {\n            if (0==sc->fileoff /*&& 0!=mhdrpp*/) {\n                *mhdrpp = (Mach_header *)(void *)addr;\n            }\n            unpackExtent(xi, &xo, f_decompress, f_unf);\n        }\n        /*bzero(addr, frag);*/  // fragment at lo end\n        frag = (-mlen) &~ PAGE_MASK;  // distance to next page boundary\n        bzero(mlen+addr, frag);  // fragment at hi end\n        if (0!=mlen && 0!=mprotect(addr, mlen, sc->initprot)) {\n            err_exit(10);\nERR_LAB\n        }\n        addr += mlen + frag;  /* page boundary on hi end */\n        if (addr < haddr) { // need pages for .bss\n            if (addr != mmap(addr, haddr - addr, sc->initprot,\n                    MAP_FIXED | MAP_PRIVATE | MAP_ANON, -1, 0 ) ) {\n                err_exit(9);\n            }\n        }\n    }\n    else if (LC_UNIXTHREAD==sc->cmd || LC_THREAD==sc->cmd) {\n        Mach_thread_command const *const thrc = (Mach_thread_command const *)sc;\n        if (PPC_THREAD_STATE      ==thrc->flavor\n        &&  PPC_THREAD_STATE_COUNT==thrc->count ) {\n            entry = &thrc->state;\n        }\n    }\n    return entry;\n}\n\n\n/*************************************************************************\n// upx_main - called by our entry code\n//\n**************************************************************************/\n\nMach_ppcle_thread_state64 const *\nupx_main(\n    struct l_info const *const li,\n    size_t volatile sz_compressed,  // total length\n    Mach_header *const mhdr,  // temp char[sz_mhdr] for decompressing\n    size_t const sz_mhdr,\n    f_expand *const f_decompress,\n    f_unfilter *const f_unf,\n    Mach_header **const mhdrpp  // Out: *mhdrpp= &real Mach_header\n)\n{\n    Mach_ppcle_thread_state64 const *entry;\n    off_t_upx_stub fat_offset = 0;\n    Extent xi, xo, xi0;\n    xi.buf  = CONST_CAST(char *, 1+ (struct p_info const *)(1+ li));  // &b_info\n    xi.size = sz_compressed - (sizeof(struct l_info) + sizeof(struct p_info));\n    xo.buf  = (char *)mhdr;\n    xo.size = ((struct b_info const *)(void const *)xi.buf)->sz_unc;\n    xi0 = xi;\n\n    // Uncompress Macho headers\n    unpackExtent(&xi, &xo, f_decompress, 0);  // never filtered?\n\n    entry = do_xmap(mhdr, fat_offset, &xi0, -1, mhdrpp, f_decompress, f_unf);\n\n  { // Map dyld dynamic loader\n    Mach_load_command const *lc = (Mach_load_command const *)(1+ mhdr);\n    unsigned j;\n\n    for (j=0; j < mhdr->ncmds; ++j,\n        (lc = (Mach_load_command const *)(void const *)(lc->cmdsize + (char const *)lc))\n    ) if (LC_LOAD_DYLINKER==lc->cmd) {\n        char const *const dyld_name = ((Mach_lc_str const *)(void const *)(1+ lc))->offset +\n            (char const *)lc;\n        int const fdi = open(dyld_name, O_RDONLY, 0);\n        if (0 > fdi) {\n            err_exit(18);\n        }\nfat:\n        if ((ssize_t)sz_mhdr!=pread(fdi, (void *)mhdr, sz_mhdr, fat_offset)) {\nERR_LAB\n            err_exit(19);\n        }\n        switch (mhdr->magic) {\n        case MH_MAGIC: break;\n        case FAT_MAGIC: {\n            // stupid Apple: waste code and a page fault on EVERY execve\n            Fat_header const *const fh = (Fat_header const *)mhdr;\n            Fat_arch const *fa = (Fat_arch const *)(1+ fh);\n            for (j= 0; j < fh->nfat_arch; ++j, ++fa) {\n                if (CPU_TYPE_POWERPC==fa->cputype) {\n                    fat_offset= fa->offset;\n                    goto fat;\n                }\n            }\n        } break;\n        } // switch\n        entry = do_xmap(mhdr, fat_offset, 0, fdi, 0, 0, 0);\n        close(fdi);\n        break;\n    }\n  }\n\n    return entry;\n}\n\n/* vim:set ts=4 sw=4 et: */\n","size_bytes":14139},"src/stub/src/powerpc64-linux.elf-main.c":{"content":"#ifndef BIG_ENDIAN  //{\n#define BIG_ENDIAN 1\n#endif  //}\n#include \"powerpc64le-linux.elf-main.c\"\n","size_bytes":97},"src/stub/src/powerpc64-linux.elf-main2.c":{"content":"#include \"amd64-linux.elf-main2.c\"\n","size_bytes":35},"src/stub/src/powerpc64le-linux.elf-main.c":{"content":"#ifndef BIG_ENDIAN  //{\n#define BIG_ENDIAN 0\n#endif  //}\n#include \"amd64-linux.elf-main.c\"\n","size_bytes":91},"src/stub/src/powerpc64le-linux.elf-main2.c":{"content":"#include \"amd64-linux.elf-main2.c\"\n","size_bytes":35},"src/stub/src/upxfd_android.c":{"content":"/* upxfd_android.c -- workaround memfd_create for 32-bit Android\n\n   This file is part of the UPX executable compressor.\n\n   Copyright (C) 2023 John F. Reiser\n   All Rights Reserved.\n */\n\nvoid my_bkpt(void const *, ...);\n\n#if defined(__i386__) //}{\n#define ANDROID_FRIEND 1\n#define addr_string(string) ({ \\\n    char const *str; \\\n    asm(\"call 0f; .asciz \\\"\" string \"\\\"; 0: pop %0\" \\\n/*out*/ : \"=r\"(str) ); \\\n    str; \\\n})\n#elif defined(__arm__) //}{\n#define ANDROID_FRIEND 1\n#define addr_string(string) ({ \\\n    char const *str; \\\n    asm(\"bl 0f; .string \\\"\" string \"\\\"; .balign 4; 0: mov %0,lr\" \\\n/*out*/ : \"=r\"(str) \\\n/* in*/ : \\\n/*und*/ : \"lr\"); \\\n    str; \\\n})\n#elif defined(__mips__) //}{\n#define ANDROID_FRIEND 0\n#define addr_string(string) ({ \\\n    char const *str; \\\n    asm(\".set noreorder; bal 0f; nop; .asciz \\\"\" string \"\\\"; .balign 4\\n0: move %0,$31; .set reorder\" \\\n/*out*/ : \"=r\"(str) \\\n/* in*/ : \\\n/*und*/ : \"ra\"); \\\n    str; \\\n})\n#elif defined(__powerpc__)  /*}{*/\n#define ANDROID_FRIEND 0\n#define addr_string(string) ({ \\\n    char const *str; \\\n    asm(\"bl 0f; .asciz \\\"\" string \"\\\"; .balign 4; 0: mflr %0\" \\\n/*out*/ : \"=r\"(str) \\\n/* in*/ : \\\n/*und*/ : \"lr\"); \\\n    str; \\\n})\n#elif defined(__powerpc64__) //}{\n#define ANDROID_FRIEND 0\n#define addr_string(string) ({ \\\n    char const *str; \\\n    asm(\"bl 0f; .string \\\"\" string \"\\\"; .balign 4; 0: mflr %0\" \\\n/*out*/ : \"=r\"(str) \\\n/* in*/ : \\\n/*und*/ : \"lr\"); \\\n    str; \\\n})\n#elif defined(__x86_64) //}{\n#define ANDROID_FRIEND 0\n#define addr_string(string) ({ \\\n    char const *str; \\\n    asm(\"lea 9f(%%rip),%0; .section STRCON; 9:.asciz \\\"\" string \"\\\"; .previous\" \\\n/*out*/ : \"=r\"(str) ); \\\n    str; \\\n})\n#elif defined(__aarch64__) //}{\n#define ANDROID_FRIEND 0\n#define addr_string(string) ({ \\\n    char const *str; \\\n    asm(\"bl 0f; .string \\\"\" string \"\\\"; .balign 4; 0: mov %0,x30\" \\\n/*out*/ : \"=r\"(str) \\\n/* in*/ : \\\n/*und*/ : \"x30\"); \\\n    str; \\\n})\n#else  //}{\n#define ANDROID_FRIEND 0\n#error  addr_string\n#endif  //}\n\n#if defined(__x86_64) || defined(__i386__) //}{\n#define DPRINTF(fmt, args...) ({ \\\n    char const *r_fmt; \\\n    asm(\"call 0f; .asciz \\\"\" fmt \"\\\"; 0: pop %0\" \\\n/*out*/ : \"=r\"(r_fmt) ); \\\n    dprintf(r_fmt, args); \\\n})\n#else  //}{\n#define DPRINTF(fmt, args...) /*empty*/\n#endif  //}\n\n#define dprintf my_bkpt\n\n//#include <fcntl.h>\n//#include <sys/stat.h>\ntypedef unsigned long long u64_t;\ntypedef unsigned int   u32_t;\ntypedef unsigned short u16_t;\n// Observed by gdb for libc-bin 2.31-13+deb11u6 on Debian 5.10.158-2 (2022-12-13) armv7l\nstruct stat { // __NR_stat = 106 + NR_SYSCALL_BASE\n    u32_t st_dev;\n    u32_t st_ino;\n    u16_t st_mode;\n    u16_t st_nlink;\n    u16_t st_uid;\n    u16_t st_gid;\n// 0x10\n    u32_t st_rdev;\n    u32_t st_size;\n    u32_t st_blksize;\n    u32_t st_blocks;\n// 0x20\n    u32_t st_atime;\n    u32_t st_atime_nsec;\n    u32_t st_mtime;\n    u32_t st_mtime_nsec;\n// 0x30\n    u32_t st_ctime;\n    u32_t st_ctime_nsec;\n    u32_t pad1;\n    u32_t pad2;\n// 0x40\n};\n#define S_IFMT  00170000\n#define S_IFDIR  0040000\n#define S_IRWXU 00700\n#define AT_FDCWD -100\n#define restrict /**/\n\n#include \"include/linux.h\"  // syscalls; i386 inlines via \"int 0x80\"\nextern int open(char const *, int, int);\n\nextern int fstatat(int dirfd, const char *restrict pathname,\n    struct stat *restrict statbuf, int flags);\n\n#define ENOENT 2   /* no such name */\n#define EACCES 13  /* permission denied */\n#define EINVAL 22  /* invalid arguemnt */\n#define ENOSPC 28  /* no space left on device */\n#define ENOSYS 38  /* no such system call */\n\n// ANDROID_TEST: Set to 1 for testing Android implmentation using Linux on\n// Raspberry Pi (arm32, perhaps running on actual arm64); else set to 0.\n#define ANDROID_TEST 0\n\n#define MFD_EXEC 0x10\n//#define O_RDWR 2\n\n#if defined(__aarch64__)  //{\n// linux/arch/arm64/include/uapi/asm/fcntl.h:\n#define O_DIRECTORY  040000 /* must be a directory */\n\n#elif defined(__arm__)  //}{\n// linux/arch/arm/include/uapi/asm/fcntl.h:\n#define O_DIRECTORY  040000 /* must be a directory */\n\n#elif defined(__powerpc__) || defined(__powerpc64__)  //}{\n// linux/arch/powerpc/include/uapi/asm/fcntl.h:\n#define O_DIRECTORY      040000 /* must be a directory */\n\n#else  //}{ i386, amd64, mips\n// linux/include/uapi/asm-generic/fcntl.h:\n#define O_DIRECTORY 00200000 /* must be a directory */\n\n#endif  //}\n\n// linux/include/uapi/asm-generic/fcntl.h:\n#define __O_TMPFILE 020000000\n#define O_TMPFILE (__O_TMPFILE | O_DIRECTORY)\n\n\n#define PATH_MAX 4096  /* linux/include/uapi/linux/limits.h */\n\nextern int memfd_create(char const *name, unsigned flags);\nextern int ftruncate(int fd, size_t length);\nextern ssize_t write(int fd, void const *buf, size_t length);\n\n// upx_mmap_and_fd_android() must be first in the .o when compiled,\n// so prototype 'static' functions but put their definitions later.\n#if ANDROID_FRIEND  //{\nstatic int strncmplc(char const *s1, char const *s2, unsigned n);\nstatic int create_upxfn_path(char *name, char *buf);\nstatic unsigned sixbit(unsigned x);\nstatic int dir_check(char const *path, int fatal);\n#endif  //}\n\nstruct utsname {\n    char sysname[65];\n    char nodename[65];\n    char release[65];\n    char version[65];\n    char machine[65];\n    char domainname[65];\n};\nextern void *memset(void *dst, int val, size_t n);\nextern int stat(char const *path, struct stat *statbuf);\nextern int mkdir(char const *path, unsigned mode);\nextern int uname(struct utsname *);\nextern char * get_upxfn_path(void);\nextern long get_page_mask(void);\n\nunsigned long upx_mmap_and_fd_android( // returns (mapped_addr | (1+ fd))\n    void *ptr  // desired address\n    , unsigned datlen  // mapped length\n    , char *pathname  // 0 ==> get_upxfn_path()\n)\n{\n    unsigned long addr = 0;  // for result\n    // Early 32-bit Android did not implement memfd_create\n    int fd = -ENOSYS;\n    if (!ANDROID_TEST) {\n        char const *name = addr_string(\"upx\");\n        fd = memfd_create(name, MFD_EXEC);\n        if (-EINVAL == fd) { // MFD_EXEC unknown to ubuntu-20.04\n            fd = memfd_create(name, 0);  // try again\n        }\n        if (fd < 0) { // last chance for Linux\n            fd = open(addr_string(\"/dev/shm\"), O_RDWR | O_DIRECTORY | O_TMPFILE, 0700);\n            if (fd < 0) {\n                my_bkpt(addr_string(\"memfd_create\"));\n            }\n        }\n    }\n\n#if ANDROID_FRIEND  //{\n    // Varying __NR_ftruncate on Android can hurt even if memfd_create() succeeds.\n    // On Linux, struct utsname has 6 arrays of size 65; but size can be larger.\n#define BUFLEN PATH_MAX\n    union {\n        struct utsname uts;\n        char buf[BUFLEN];\n    } u;\n\n    uname(&u.uts);\n    int const not_android = (ANDROID_TEST ? 0\n        : (    0 != strncmplc(addr_string(\"and\"), &u.uts.sysname[0], 3)\n            && 0 == strncmplc(addr_string(\"Lin\"), &u.uts.sysname[0], 3)\n            && '4'<  u.uts.release[0] ));\n          // 2024-08-01: TermUX on Android 14 arm64 running 32-bit program:\n          // claims it is Linux, but kernel is 4.19, and ftruncate() {__NR_ 93}\n          // gets signal SIGSYS instead of errno ENOSYS; so is not really Linux!\n\n    // Work-around for missing memfd_create syscall on early 32-bit Android.\n    if (!not_android && !pathname) { // must ask\n        pathname = get_upxfn_path();\n        if (!pathname) { // persistence not desired, so use this->u.buf;\n            pathname = &u.buf[0];\n            pathname[0] = '\\0';\n        }\n    }\n    if (!not_android && -ENOSYS == fd && pathname) {\n        if ('\\0' == pathname[0]) { // first time; create the pathname and file\n            int rv = create_upxfn_path(pathname, &u.buf[BUFLEN / 2]);\n            if (rv < 0) {\n                return rv;\n            }\n        }\n        // Use the constructed path.\n        fd = open(pathname, O_CREAT|O_EXCL|O_RDWR, S_IRWXU);\n        if (fd < 0) {\n            return fd;\n        }\n        unlink(pathname);\n    }\n#else  //}{ !ANDROID_FRIEND: simple!\n    int not_android = 1;\n    (void)pathname;  // dead: obviated by memfd_create()\n#endif  //}\n\n    // Set the file length\n    if (ptr) {\n        unsigned const page_mask = get_page_mask();\n        unsigned const frag = ~page_mask & (unsigned)(long)ptr;\n        ptr -= frag;  // becomes page-aligned\n        datlen += frag;\n    }\n    if (datlen) {\n        if (not_android) { // Linux ftruncate() is well-behaved\n            int rv = ftruncate(fd, datlen);\n            if (rv < 0) {\n                return rv;\n            }\n        }\n#if ANDROID_FRIEND  //{\n        else { // !not_android: ftruncate has varying system call number on 32-bit\n            lseek(fd, -1+ datlen, SEEK_SET);  // last byte\n            char zero = 0;\n            write(fd, &zero, 1);  // force allocation\n            lseek(fd, 0, SEEK_SET);  // go back to the beginning\n        }\n#endif  //}\n    }\n    if (ptr) {\n        unsigned const page_mask = get_page_mask();\n        if (~page_mask & (unsigned)(long)ptr) {\n            // Preserve entire page that contains *ptr\n            write(fd, ptr, -page_mask);\n        }\n    }\n    addr = (unsigned long)mmap(ptr, datlen , PROT_WRITE | PROT_READ,\n        MAP_SHARED | (ptr ? MAP_FIXED : 0), fd, 0);\n    if ((~0ul<<12) < addr) { // error\n        return addr;\n    }\n    return addr | (1+ fd);\n}\n\n#if ANDROID_FRIEND  //{\n\n__attribute__((__noinline__))\nstatic int dir_check(char const *path, int fatal)\n{\n    struct stat sb;\n    memset(&sb,0xff, sizeof(sb));  // DEBUG aid\n    int rv = stat(path, &sb);\n    if (0 <= rv) {\n        if (S_IFDIR == (sb.st_mode & S_IFMT)) {\n            return 0;\n        }\n    }\n    if (-ENOENT == rv) {\n        rv = mkdir(path, S_IRWXU);\n    }\n    if (rv < 0 && fatal) {\n        my_bkpt(path, rv);  // required path not available\n    }\n    return rv;\n}\n\n//#define S_IRWXU 00700  /* rwx------ User Read-Write-eXecute */\nextern void *alloca(unsigned size);\n//#include <string.h>  // we use \"typedef unsigned size_t;\"\n//#include <sys/utsname.h>\n\nextern unsigned getpid(void);\nextern void *mempcpy(void *dst, void const *src, unsigned len);\n\n// Upper half of ASCII (chars 0100-0177) are all legal in a Linux filename.\n// So the shortest code is \" return 0100 + (077 & x); \"\n// But the 5 chars which follow 'Z' (\"[\\\\]^_\") or 'z' (\"{|}~\\x7F\")\n// look ugly, so substitute digits.\n__attribute__((__noinline__))\nstatic unsigned sixbit(unsigned x)\n{\n    unsigned y = 037 & x;  // \"upper case\"\n    x &= 077;\n    if (033 <= y) { // last 5 chars in each 32 are ugly\n        if (040 & x)  // \"lower case\"\n            x += '4' - 'z';  // \"56789\" follows 'z';\n        else\n            x += '/' - 'Z';  // \"01234\" follows 'Z';\n    }\n    x += 0100;  // upper half ASCII: \"@ABC\"...\n    return x;\n}\n\n// Where to put temp file when memfd_create() fails on early 32-bit Android\n__attribute__((__noinline__))\nstatic int create_upxfn_path(char *name, char *buf)\n{\n    // Construct path \"/data/data/$APP_NAME/cache/upxAAA\".\n    // Note 'mempcpy' [with 'p' in the middle!] returns the end-of-string.\n    char *p =  mempcpy(&name[0], addr_string(\"/data/data/\"), 11);  // '/' sentinel at end\n    p[0] = '\\0'; dir_check(name, 1);\n\n    // Append the name of the app\n    char const *q = addr_string(\"/proc/self/cmdline\");\n    int fd = open(q, O_RDONLY, 0);\n    int rlen = read(fd, p= buf, -1+ PATH_MAX);\n    close(fd);\n    if (rlen < 0) {\n        my_bkpt(q);\n    }\n    p[rlen] = '\\0';  // insurance sentinel\n    // Kernel-parsed arguments are separated by '\\0'.\n    while (*p) ++p;  // advance to end of argv[0]\n\n    {\n        char *app_end = p;\n        // Sentinel '/' at name[10] provides safety for backing up.\n        while ('/' != *p) --p;  // find last component of argv[0]\n        q = p;\n        p = mempcpy(&name[10], p, app_end - p);\n        p[0] = '\\0';\n        if (-EACCES == dir_check(name, 0)) {\n            p = mempcpy(&name[11], addr_string(\"com.termux/files\"), 16);\n            p = mempcpy(p, q, app_end - q);\n            p[0] = '\\0';\n            dir_check(name, 1);\n        }\n    }\n\n    p = mempcpy(p, addr_string(\"/cache\"), 6);\n    p[0] = '\\0'; dir_check(name, 1);\n    p = mempcpy(p, addr_string(\"/upx\"), 4);\n    pid_t pid = getpid();\n    p[0] = sixbit(pid >> 0*6);\n    p[1] = sixbit(pid >> 1*6);\n    p[2] = sixbit(pid >> 2*6);\n    p[3]='\\0';\n    return 0;  // success\n}\n\n// memfd_create() gets ENOSYS on early Android.  There are 32-bit x86 Android\n// such as Zenfone 2 (discontinued 2018?), x86 Chromebooks (2019 and later),\n// FydeOS, Windows subsystem for Android.  But the main use is for developing,\n// to make Android emulator running on x86_64 (Linux or Windows) run faster\n// by emulating x86 instead of ARM.\n//\n// Try /data/data/$APP_NAME/cache/upxAAA\n// where APP_NAME is discovered as basename(argv[0])\n// and argv[0] is guessed from /proc/self/cmdline.\n// Also 32-bit Android has inconsistent __NR_ftruncate,\n// so use direct write()\n//\n// To work around bug in \"i386-linux-gcc-3.4.6 -m32 -march=i386\" .\n// gcc optimized out this code:\n//      uname((struct utsname *)buf);\n//      int const is_android = ( (('r'<<3*8)|('d'<<2*8)|('n'<<1*8)|('a'<<0*8))\n//          == (0x20202020 | *(int *)buf) );\n// Specialized: does NOT consider early termination of either string, etc.\n__attribute__((__noinline__))\nstatic int strncmplc(char const *s1, char const *s2, unsigned n)\n{\n    while (n--) {\n        int rv = (0x20 | *s1++) - (0x20 | *s2++);\n        if (rv) return rv;\n    }\n    return 0;\n}\n\n#endif  //}  ANDROID_FRIEND\n\n#if 0  //{ test\nchar name[1000];\n\nint main(int argc, char *argv[])\n{\n    upx_mmap_and_fd(0, 5000, 0);\n}\n\nvoid *mempcpy(void *adst, void const *asrc, unsigned len)\n{\n    char *dst = adst;\n    char const *src = asrc;\n    if (len) do {\n        *dst++ = *src++;\n    } while (--len);\n    return dst;\n}\n\nvoid *memset(void *adst, unsigned val, unsigned len)\n{\n    char *dst = adst;\n    if (len) do {\n        *dst++ = val;\n    } while (--len);\n    return adst;\n}\n#endif  //}\n\n","size_bytes":13800},"src/stub/src/upxfd_linux.c":{"content":"/* upxfd_create.c -- simplify upx_mmap_and_fd_linux for non-Android\n\n   This file is part of the UPX executable compressor.\n\n   Copyright (C) 2023 John F. Reiser\n   All Rights Reserved.\n */\n\nextern void my_bkpt(void const *, ...);\n\n#if defined(__i386__) //}{\n#define ANDROID_FRIEND 1\n#define addr_string(string) ({ \\\n    char const *str; \\\n    asm(\"call 0f; .asciz \\\"\" string \"\\\"; 0: pop %0\" \\\n/*out*/ : \"=r\"(str) ); \\\n    str; \\\n})\n#elif defined(__arm__) //}{\n#define ANDROID_FRIEND 1\n#define addr_string(string) ({ \\\n    char const *str; \\\n    asm(\"bl 0f; .string \\\"\" string \"\\\"; .balign 4; 0: mov %0,lr\" \\\n/*out*/ : \"=r\"(str) \\\n/* in*/ : \\\n/*und*/ : \"lr\"); \\\n    str; \\\n})\n#elif defined(__mips__) //}{\n#define ANDROID_FRIEND 0\n#define addr_string(string) ({ \\\n    char const *str; \\\n    asm(\".set noreorder; bal 0f; nop; .asciz \\\"\" string \"\\\"; .balign 4\\n0: move %0,$31; .set reorder\" \\\n/*out*/ : \"=r\"(str) \\\n/* in*/ : \\\n/*und*/ : \"ra\"); \\\n    str; \\\n})\n#elif defined(__powerpc__)  /*}{*/\n#define ANDROID_FRIEND 0\n#define addr_string(string) ({ \\\n    char const *str; \\\n    asm(\"bl 0f; .asciz \\\"\" string \"\\\"; .balign 4; 0: mflr %0\" \\\n/*out*/ : \"=r\"(str) \\\n/* in*/ : \\\n/*und*/ : \"lr\"); \\\n    str; \\\n})\n#elif defined(__powerpc64__) //}{\n#define ANDROID_FRIEND 0\n#define addr_string(string) ({ \\\n    char const *str; \\\n    asm(\"bl 0f; .string \\\"\" string \"\\\"; .balign 4; 0: mflr %0\" \\\n/*out*/ : \"=r\"(str) \\\n/* in*/ : \\\n/*und*/ : \"lr\"); \\\n    str; \\\n})\n#elif defined(__x86_64) //}{\n#define ANDROID_FRIEND 0\n#define addr_string(string) ({ \\\n    char const *str; \\\n    asm(\"lea 9f(%%rip),%0; .section STRCON; 9:.asciz \\\"\" string \"\\\"; .previous\" \\\n/*out*/ : \"=r\"(str) ); \\\n    str; \\\n})\n#elif defined(__aarch64__) //}{\n#define ANDROID_FRIEND 0\n#define addr_string(string) ({ \\\n    char const *str; \\\n    asm(\"bl 0f; .string \\\"\" string \"\\\"; .balign 4; 0: mov %0,x30\" \\\n/*out*/ : \"=r\"(str) \\\n/* in*/ : \\\n/*und*/ : \"x30\"); \\\n    str; \\\n})\n#else  //}{\n#define ANDROID_FRIEND 0\n#error  addr_string\n#endif  //}\n\n#include \"include/linux.h\"  // syscall decls; i386 inlines via \"int 0x80\"\n\n#define MFD_EXEC 0x10\n//#define O_RDWR 2\n\n#if defined(__aarch64__)  //{\n// linux/arch/arm64/include/uapi/asm/fcntl.h:\n#define O_DIRECTORY  040000 /* must be a directory */\n\n#elif defined(__arm__)  //}{\n// linux/arch/arm/include/uapi/asm/fcntl.h:\n#define O_DIRECTORY  040000 /* must be a directory */\n\n#elif defined(__powerpc__) || defined(__powerpc64__)  //}{\n// linux/arch/powerpc/include/uapi/asm/fcntl.h:\n#define O_DIRECTORY      040000 /* must be a directory */\n\n#else  //}{ i386, amd64, mips\n// linux/include/uapi/asm-generic/fcntl.h:\n#define O_DIRECTORY 00200000 /* must be a directory */\n\n#endif  //}\n\n// linux/include/uapi/asm-generic/fcntl.h:\n#define __O_TMPFILE 020000000\n#define O_TMPFILE (__O_TMPFILE | O_DIRECTORY)\n\n#define EISDIR 21 /* directory mismatch */\n#define EINVAL 22 /* asm-generic/errno-base.h */\n\nextern int memfd_create(char const *, unsigned);\nextern int ftruncate(int, size_t);\nextern int open(char const *, int, int);\nextern unsigned long get_page_mask(void);\nextern ssize_t write(int, void const *, size_t);\nvoid exit(int) __attribute__((__noreturn__,__nothrow__));\n\n// Implementation for Linux-native, where memfd_create\n// (or /dev/shm) works.  Saves space in contrast to\n// upxfd_android (or Android emulator), which must\n// fall back to  /data/data/$APP_NAME/cache/upxAAA ,\n// and also must work around inconsistent __NR_ftruncate.\n// 1. Try memfd_create\n// 2. Try /dev/shm\nunsigned long upx_mmap_and_fd_linux( // returns (mapped_addr | (1+ fd))\n    void *ptr  // desired address\n    , unsigned datlen  // mapped length\n    , char *pathname  // 0 ==> get_upxfn_path()\n)\n{\n    (void)pathname;  // FIXME NYI\n    char const *const name = addr_string(\"upx\");\n    int fd = memfd_create(name, MFD_EXEC);\n    if (-EINVAL == fd) { // 2024-10-15 MFD_EXEC unknown to ubuntu-20.04\n        fd = memfd_create(name, 0);  // try again\n    }\n    if (fd < 0) { // such as ENOSYS for memfd_create on Linux < 3.17 (2014-10-05)\n        // last chance for Linux; using /tmp often hits 'noexec' etc.\n        fd = open(addr_string(\"/dev/shm\"), O_RDWR | O_DIRECTORY | O_TMPFILE, 0700);\n        if (fd < 0) {\n            if (-EISDIR == fd) { // no memfd_create often lacks O_TMPFILE, too\n                write(2, addr_string(\n                    \"UPX-5.0 wants memfd_create(), or needs /dev/shm(,O_TMPFILE,)\\\\n\"), 61);\n                exit(127);\n            }\n            // Error from open() is unknown. Cause later SIGSEGV.\n            return (unsigned long)(long)fd;  // -errno; high bits are all 1\n        }\n        // Beware: /dev/shm might limit write() to 8KiB at a time.\n    }\n    int rv = ftruncate(fd, datlen);\n    if (rv < 0) {\n        return (unsigned long)(long)rv;\n    }\n    ptr = mmap(ptr, datlen, PROT_READ|PROT_WRITE,\n        (ptr ? MAP_FIXED : 0)|MAP_SHARED, fd, 0);\n    unsigned long const page_mask = get_page_mask();\n    if (page_mask <= (unsigned long)ptr) {\n        return (unsigned long)ptr;  // -errno\n    }\n    return (unsigned long)ptr + (1+ (unsigned)fd);\n}\n","size_bytes":5071},"src/stub/src/c/Makevars-lzma.mk":{"content":"# UPX unconditionally uses its own version in vendor/lzma-sdk because\n# that version works fine since 2006 and that is the only version\n# that is actually sufficiently tested!!!\n\nifeq ($(wildcard $(top_srcdir)/vendor/lzma-sdk/C/.),)\n  $(error ERROR: missing git submodule; run 'git submodule update --init')\nendif\n\noverride UPX_LZMADIR := $(top_srcdir)/vendor/lzma-sdk\noverride UPX_LZMA_VERSION := 0x443\n","size_bytes":404},"src/stub/src/c/lzma_d_c.c":{"content":"/* lzma_d.c --\n\n   This file is part of the UPX executable compressor.\n\n   Copyright (C) 2006-2025 Markus Franz Xaver Johannes Oberhumer\n   All Rights Reserved.\n\n   UPX and the UCL library are free software; you can redistribute them\n   and/or modify them under the terms of the GNU General Public License as\n   published by the Free Software Foundation; either version 2 of\n   the License, or (at your option) any later version.\n\n   This program is distributed in the hope that it will be useful,\n   but WITHOUT ANY WARRANTY; without even the implied warranty of\n   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n   GNU General Public License for more details.\n\n   You should have received a copy of the GNU General Public License\n   along with this program; see the file COPYING.\n   If not, write to the Free Software Foundation, Inc.,\n   59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.\n\n   Markus F.X.J. Oberhumer\n   <markus@oberhumer.com>\n */\n\n\n/*************************************************************************\n//\n**************************************************************************/\n\n#define ACC_LIBC_NAKED 1\n/*#define ACC_OS_FREESTANDING 1*/\n#include \"util/miniacc.h\"\n\n#define UPX_LZMA_COMPAT 1\n\n#if 0\n#undef _LZMA_IN_CB\n#undef _LZMA_OUT_READ\n#undef _LZMA_PROB32\n#undef _LZMA_LOC_OPT\n#endif\n#if (ACC_ARCH_I086)\n#  define Byte  unsigned char\n#  define _7ZIP_BYTE_DEFINED 1\n#endif\n#if !defined(_LZMA_UINT32_IS_ULONG)\n#  if defined(__INT_MAX__) && ((__INT_MAX__)+0 == 32767)\n#    define _LZMA_UINT32_IS_ULONG 1\n#  endif\n#endif\n#if !defined(_LZMA_NO_SYSTEM_SIZE_T)\n#  define _LZMA_NO_SYSTEM_SIZE_T 1\n#endif\n\n#if 0\n\n#include \"C/7zip/Compress/LZMA_C/LzmaDecode.h\"\n#if (ACC_ABI_LP64)\n#else\nACC_COMPILE_TIME_ASSERT_HEADER(sizeof(CLzmaDecoderState) == 16)\n#endif\n#include \"C/7zip/Compress/LZMA_C/LzmaDecode.c\"\n\n#else\n\n#define CLzmaDecoderState       CLzmaDecoderState_dummy\n#define LzmaDecodeProperties    LzmaDecodeProperties_dummy\n#define LzmaDecode              LzmaDecode_dummy\n#if (ACC_CC_BORLANDC)\n#include \"LzmaDecode.h\"\n#else\n#if (WITH_LZMA >= 0x449)\n#  include \"C/Compress/Lzma/LzmaDecode.h\"\n#else\n#  include \"C/7zip/Compress/LZMA_C/LzmaDecode.h\"\n#endif\n#endif\n#undef CLzmaDecoderState\n#undef LzmaDecodeProperties\n#undef LzmaDecode\ntypedef struct {\n    struct { unsigned char lc, lp, pb, dummy; } Properties;\n#ifdef _LZMA_PROB32\n    CProb Probs[8191];\n#else\n    CProb Probs[16382];\n#endif\n} CLzmaDecoderState;\nACC_COMPILE_TIME_ASSERT_HEADER(sizeof(CLzmaDecoderState) == 32768u)\nACC_COMPILE_TIME_ASSERT_HEADER(sizeof(SizeT) >= 4)\n\n#if (ACC_ARCH_I086)\n#  define char  char __huge\n#elif (ACC_CC_WATCOMC)\n#endif\nint LzmaDecodeProperties(CLzmaProperties *, const unsigned char *, int);\nint LzmaDecode(CLzmaDecoderState *, const unsigned char *, SizeT, SizeT *, unsigned char *, SizeT, SizeT *);\n#if (ACC_CC_BORLANDC)\n#include \"LzmaDecode.c\"\n#else\n#if (WITH_LZMA >= 0x449)\n#  include \"C/Compress/Lzma/LzmaDecode.c\"\n#else\n#  include \"C/7zip/Compress/LZMA_C/LzmaDecode.c\"\n#endif\n#endif\n#undef char\n#undef CLzmaDecoderState\n\n#endif\n\n/* vim:set ts=4 sw=4 et: */\n","size_bytes":3097},"src/stub/tools/armpe/armpe_tester.c":{"content":"/* armpe_tester.c -- ARM/PE loader/tester for arm linux\n\n   This file is part of the UPX executable compressor.\n\n   Copyright (C) 1996-2025 Markus Franz Xaver Johannes Oberhumer\n   Copyright (C) 1996-2025 Laszlo Molnar\n   Copyright (C) 2000-2025 John F. Reiser\n   All Rights Reserved.\n\n   UPX and the UCL library are free software; you can redistribute them\n   and/or modify them under the terms of the GNU General Public License as\n   published by the Free Software Foundation; either version 2 of\n   the License, or (at your option) any later version.\n\n   This program is distributed in the hope that it will be useful,\n   but WITHOUT ANY WARRANTY; without even the implied warranty of\n   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n   GNU General Public License for more details.\n\n   You should have received a copy of the GNU General Public License\n   along with this program; see the file COPYING.\n   If not, write to the Free Software Foundation, Inc.,\n   59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.\n\n   Markus F.X.J. Oberhumer              Laszlo Molnar\n   <markus@oberhumer.com>               <ezerotven+github@gmail.com>\n\n   John F. Reiser\n   <jreiser@users.sourceforge.net>\n*/\n\n/*\n The stub of a compressed wince file can be tested on an android\n phone. Compress a wince file using \"--strip-relocs=0\", then copy it\n to the phone using \"adb push test.exe /data/local/tmp\".\n Cross compile this file using the \"gcc-arm-linux-gnueabi\",\n \"libc6-dev-armel-cross\" and related debian packages.\n Copy armpe_tester.out into /data/local/tmp/ too. Then use \"adb shell\"\n to run the test program, and watch the output.\n\n*/\n\n// arm-wince-pe-gcc -Wl,--image-base,0x400000\n\n#include <stddef.h>\n#include <stdarg.h>\n#include <string.h>\n#include <stdio.h>\n#include <errno.h>\n\n#ifdef __i386__\n#define UPX_MMAP_ADDRESS 0x20000000\n#else\n#define UPX_MMAP_ADDRESS 0x410000 // 0x10000\n#endif\n\n#ifdef __linux__\n#include <sys/mman.h>\n#else\nvoid *VirtualAlloc(void *address, unsigned size, unsigned type, unsigned protect);\n#define MEM_COMMIT             0x1000\n#define PAGE_EXECUTE_READWRITE 0x0040\n#endif\n\ntypedef unsigned short LE16;\ntypedef unsigned int LE32;\n#define get_le32(p)    (*(const unsigned *) (p))\n#define set_le32(p, v) (*(unsigned *) (p) = (v))\n#define get_le16(p)    (*(const unsigned short *) (p))\n\n#if !defined(packed_struct)\n#define packed_struct(s) struct s\n#endif\n\npacked_struct(ddirs_t) {\n    LE32 vaddr;\n    LE32 size;\n};\n\npacked_struct(pe_header_t) {\n    // 0x0\n    char _[4];\n    LE16 cpu;\n    LE16 objects;\n    char __[12];\n    LE16 opthdrsize;\n    LE16 flags;\n    // optional header\n    char ___[4];\n    LE32 codesize;\n    // 0x20\n    LE32 datasize;\n    LE32 bsssize;\n    LE32 entry;\n    LE32 codebase;\n    // 0x30\n    LE32 database;\n    // nt specific fields\n    LE32 imagebase;\n    LE32 objectalign;\n    LE32 filealign;\n    // 0x40\n    char ____[16];\n    // 0x50\n    LE32 imagesize;\n    LE32 headersize;\n    LE32 chksum;\n    LE16 subsystem;\n    LE16 dllflags;\n    // 0x60\n    char _____[20];\n    // 0x74\n    LE32 ddirsentries;\n    //\n    struct ddirs_t ddirs[16];\n};\n\npacked_struct(pe_section_t) {\n    char name[8];\n    LE32 vsize;\n    LE32 vaddr;\n    LE32 size;\n    LE32 rawdataptr;\n    char _[12];\n    LE32 flags;\n};\n\npacked_struct(exe_header_t) {\n    LE16 mz;\n    LE16 m512;\n    LE16 p512;\n    char _[18];\n    LE16 relocoffs;\n    char __[34];\n    LE32 nexepos;\n};\n\nenum {\n    PEDIR_EXPORT = 0,\n    PEDIR_IMPORT = 1,\n    PEDIR_RESOURCE = 2,\n    PEDIR_EXCEPTION = 3, // Exception table\n    PEDIR_SECURITY = 4,  // Certificate table (file pointer)\n    PEDIR_BASERELOC = 5,\n    PEDIR_DEBUG = 6,\n    PEDIR_ARCHITECTURE = 7, // Architecture-specific data\n    PEDIR_GLOBALPTR = 8,    // Global pointer\n    PEDIR_TLS = 9,\n    PEDIR_LOAD_CONFIG = 10, // Load Config Table\n    PEDIR_BOUND_IMPORT = 11,\n    PEDIR_IAT = 12,\n    PEDIR_DELAY_IMPORT = 13,  // Delay Import Descriptor\n    PEDIR_COM_DESCRIPTOR = 14 // Com+ Runtime Header\n};\n\nstatic struct pe_header_t ih;\nstatic struct pe_section_t isections[4];\nstatic FILE *f;\nstatic void *vaddr;\nstatic FILE *out;\n\n#if 0\nstatic int print(const char *format, ...)\n{\n    va_list ap;\n    int ret;\n\n    va_start(ap, format);\n    ret = fprintf(out, format, ap);\n    fflush(out);\n    va_end(ap);\n    return ret;\n}\n#else\n#define print printf\n#endif\n\nstatic int load(const char *file) {\n    struct exe_header_t h;\n    int ic;\n    unsigned pe_offset = 0;\n\n    if ((f = fopen(file, \"rb\")) == NULL)\n        return print(\"can not open file: %s\\n\", file);\n\n    for (ic = 0; ic < 20; ic++) {\n        if (fseek(f, pe_offset, SEEK_SET) || fread(&h, sizeof(h), 1, f) != 1)\n            return print(\"read error at %u\\n\", pe_offset);\n\n        if (h.mz == 'M' + 'Z' * 256) // dos exe\n        {\n            if (h.relocoffs >= 0x40) // new format exe\n                pe_offset += h.nexepos;\n            else\n                pe_offset += h.p512 * 512 + h.m512 - h.m512 ? 512 : 0;\n        } else if (get_le32(&h) == 'P' + 'E' * 256)\n            break;\n        else\n            return print(\"bad header at %u\\n\", pe_offset);\n    }\n    if (ic == 20)\n        return print(\"pe header not found\\n\");\n    printf(\"pe header found at offset: %u\\n\", pe_offset);\n    if (fseek(f, pe_offset, SEEK_SET) || fread(&ih, sizeof(ih), 1, f) != 1)\n        return print(\"can not load pe header\\n\");\n\n    print(\"ih.imagesize=0x%x\\n\", ih.imagesize);\n    if (ih.cpu != 0x1c0 && ih.cpu != 0x1c2)\n        return print(\"unsupported processor type: %x\\n\", ih.cpu);\n\n    if ((ih.objects != 3 && ih.objects != 4) || fread(isections, sizeof(isections), 1, f) != 1)\n        return print(\"error reading section descriptors\\n\");\n\n    return 0;\n}\n\nstatic int read(void) {\n    unsigned ic;\n#ifdef __linux__\n    vaddr = mmap((void *) UPX_MMAP_ADDRESS, ih.imagesize, PROT_WRITE | PROT_READ | PROT_EXEC,\n                 MAP_PRIVATE | MAP_ANONYMOUS | MAP_FIXED, -1, 0);\n    if (((int) vaddr) == -1)\n        return print(\"mmap() failed: %d\\n\", errno);\n    print(\"mmap for %p (size %x) successful\\n\", vaddr, ih.imagesize);\n#else\n    if ((vaddr = VirtualAlloc(0, ih.imagesize, MEM_COMMIT, PAGE_EXECUTE_READWRITE)) == 0)\n        return print(\"VirtualAlloc() failed\\n\");\n    print(\"VirtualAlloc() ok %x\\n\", vaddr);\n#endif\n    for (ic = 1; ic <= (unsigned) ih.objects - 1; ic++)\n        if (fseek(f, isections[ic].rawdataptr, SEEK_SET) ||\n            fread(vaddr + isections[ic].vaddr, isections[ic].vsize, 1, f) != 1)\n            return print(\"error reading section %u\\n\", ic);\n    return 0;\n}\n\nstatic void dump(char n) {\n    char buf[100];\n#ifdef __linux__\n    snprintf(buf, sizeof(buf), \"a.dump%c\", n);\n#else\n    snprintf(buf, sizeof(buf), \"/a.dump%c\", n);\n#endif\n    FILE *f2 = fopen(buf, \"wb\");\n    fwrite(vaddr + 0x1000, ih.imagesize - 0x1000, 1, f2);\n    fclose(f2);\n}\n\nstatic int loadlibraryw(const unsigned short *name) {\n    return name[0] + name[1] * 0x100 + name[2] * 0x10000;\n}\n\nstatic int getprocaddressa(unsigned h, const char *proc) {\n    unsigned p = (unsigned) proc;\n    if (p < 0x10000) {\n        print(\"getprocaddressa called %c%c%c, ordinal %u\\n\", h, h >> 8, h >> 16, p);\n        return h + p * 0x10000;\n    }\n    print(\"getprocaddressa called %c%c%c, name %s\\n\", h, h >> 8, h >> 16, proc);\n    return h + proc[0] * 0x10000 + proc[1] * 0x1000000;\n}\n\nstatic void cachesync(unsigned v) { print(\"cachesync called %u\\n\", v); }\n\nstatic int import(void) {\n    if (ih.ddirs[PEDIR_IMPORT].vaddr == 0)\n        return print(\"no imports?\\n\");\n    print(\"loadlibraryw=%p,getprocaddressa=%p,cachesync=%p\\n\", loadlibraryw, getprocaddressa,\n          cachesync);\n    void *imports = vaddr + ih.ddirs[PEDIR_IMPORT].vaddr;\n    while (get_le32(imports + 12)) {\n        if (strcasecmp(vaddr + get_le32(imports + 12), \"coredll.dll\") == 0) {\n            void *coredll_imports = vaddr + get_le32(imports + 16);\n            print(\"coredll_imports=%p\\n\", coredll_imports);\n            void *oft = vaddr + get_le32(imports);\n            unsigned pos = 0;\n            while (get_le32(oft + pos)) {\n                void *name = vaddr + get_le32(oft + pos) + 2;\n                print(\"name=%s\\n\", (char *) name);\n                if (strcasecmp(name, \"loadlibraryw\") == 0)\n                    set_le32(coredll_imports + pos, (unsigned) loadlibraryw);\n                else if (strcasecmp(name, \"getprocaddressa\") == 0)\n                    set_le32(coredll_imports + pos, (unsigned) getprocaddressa);\n                else if (strcasecmp(name, \"cachesync\") == 0)\n                    set_le32(coredll_imports + pos, (unsigned) cachesync);\n                pos += 4;\n            }\n            return 0;\n        }\n        imports += 20;\n    }\n\n    print(\"coredll.dll not found\");\n    return 1;\n}\n\nstatic int reloc(void) {\n    if (ih.ddirs[PEDIR_BASERELOC].vaddr == 0)\n        return 0;\n    void *relocs = vaddr + ih.ddirs[PEDIR_BASERELOC].vaddr;\n    void *page = vaddr + get_le32(relocs);\n    unsigned size = get_le32(relocs + 4);\n    if (size != ih.ddirs[PEDIR_BASERELOC].size)\n        return print(\"only 1 page can be relocated\\n\");\n    unsigned num = (size - 8) / 2;\n    while (num--) {\n        unsigned pos = get_le16(relocs + 8 + num * 2);\n        if (pos == 0)\n            continue;\n        if ((pos & 0xF000) != 0x3000)\n            return print(\"unknown relocation type: %x\\n\", pos);\n\n        void *r = page + (pos & 0xFFF);\n        set_le32(r, get_le32(r) - ih.imagebase + (unsigned) vaddr);\n    }\n    return 0;\n}\n\n#ifndef __i386__\nstatic void dump2(int c) {\n    print(\"dump2 %c\\n\", c);\n    dump(c);\n}\n#endif\n\nstatic void call(void) {\n#ifndef __i386__\n    void (*entry)(void (*)(int), unsigned) = vaddr + ih.entry;\n    entry(dump2, 1);\n    dump('z');\n#endif\n}\n\nstatic int main2(int argc, char **argv) {\n    if (argc != 2)\n        return print(\"usage: %s arm_pe_file\\n\", argv[0]), 1;\n    if (load(argv[1]))\n        return 2;\n    if (read())\n        return 3;\n    dump('0');\n    if (import())\n        return 4;\n    dump('1');\n    if (reloc())\n        return 5;\n    dump('2');\n\n    call();\n    print(\"ok.\\n\");\n    return 0;\n}\n\nint main(int argc, char **argv) {\n    out = stdout;\n#ifndef __linux__\n    out = fopen(\"/wtest.log\", \"wt\");\n#endif\n    int ret = main2(argc, argv);\n    fclose(out);\n    return ret;\n}\n\n/* vim:set ts=4 sw=4 et: */\n","size_bytes":10243},"src/stub/tools/macho-snip/macho-snip.c":{"content":"// SPDX-License-Identifier: GPL-2.0-or-later\n// Copyright 2022 BitWagon Software LLC.  All rights reserved.\n\n/* clang-format off */\n\n#include <errno.h>\n#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n\n#include <sys/stat.h>\n#include <unistd.h>\n#include <fcntl.h>\n#include <sys/mman.h>\n\n#ifdef __APPLE__  //{\n// /Applications/Xcode.app/Contents/Developer/Platforms/MacOSX.platform/Developer/SDKs/MacOSX.sdk/usr/include/mach-o/loader.h\n#include <mach-o/loader.h>\n#include <mach-o/nlist.h>\n#else  //}{\n    enum { // cmd\n        LC_REQ_DYLD      = 0x80000000,  // OR'ed ==> must not ignore\n        LC_SEGMENT       = 0x1,\n        LC_SYMTAB        = 0x2,\n        LC_THREAD        = 0x4,\n        LC_UNIXTHREAD    = 0x5,\n        LC_DYSYMTAB      = 0xb,\n        LC_LOAD_DYLIB    = 0xc,\n        LC_ID_DYLIB      = 0xd,\n        LC_LOAD_DYLINKER = 0xe,\n        LC_ID_DYLINKER   = 0xf,\n        LC_ROUTINES      = 0x11,\n        LC_TWOLEVEL_HINTS= 0x16,\n        LC_LOAD_WEAK_DYLIB= (0x18 | LC_REQ_DYLD),\n        LC_SEGMENT_64    = 0x19,\n        LC_ROUTINES_64   = 0x1a,\n        LC_UUID          = 0x1b,\n        LC_RPATH         = 0x1c,\n        LC_CODE_SIGNATURE = 0x1d,\n        LC_SEGMENT_SPLIT_INFO = 0x1e,\n        LC_REEXPORT_DYLIB = (0x1f | LC_REQ_DYLD),\n        LC_LAZY_LOAD_DYLIB= 0x20,\n        LC_ENCRYPTION_INFO= 0x21,\n        LC_DYLD_INFO      = 0x22,  // compressed dyld information (10.6.x)\n        LC_DYLD_INFO_ONLY = (0x22|LC_REQ_DYLD),\n        LC_VERSION_MIN_MACOSX= 0x24,\n        LC_VERSION_MIN_IPHONEOS= 0x25,\n        LC_FUNCTION_STARTS= 0x26,\n        LC_DYLD_ENVIRONMENT= 0x27,  // string as environment variable\n        LC_MAIN           = (0x28|LC_REQ_DYLD),\n        LC_DATA_IN_CODE   = 0x29,\n        LC_SOURCE_VERSION = 0x2a,\n        LC_DYLIB_CODE_SIGN_DRS= 0x2B,\n        LC_ENCRYPTION_INFO_64= 0x2C,\n        LC_LINKER_OPTIMIZATION_HINT = 0x2E,\n        LC_VERSION_MIN_TVOS= 0x2F,\n        LC_VERSION_MIN_WATCHOS= 0x30,\n        LC_NOTE           = 0x31,\n        LC_BUILD_VERSION  = 0x32,\n        LC_DYLD_EXPORTS_TRIE   = (0x33|LC_REQ_DYLD),\n        LC_DYLD_CHAINED_FIXUPS = (0x34|LC_REQ_DYLD),\n        LC_FILESET_ENTRY       = (0x35|LC_REQ_DYLD),\n    };\n\n#include <stdint.h>\nstruct mach_header_64 {\n    uint32_t magic;\n    uint32_t cputype;\n    uint32_t cpusubtype;\n    uint32_t filetype;\n    uint32_t ncmds;\n    uint32_t sizeofcmds;\n    uint32_t flags;\n    uint32_t reserved;\n};\nstruct load_command {\n    uint32_t cmd;\n    uint32_t cmdsize;\n};\nstruct segment_command_64 {\n    uint32_t cmd;\n    uint32_t cmdsize;\n    char     segname[16];\n    uint64_t vmaddr;\n    uint64_t vmsize;\n    uint64_t fileoff;\n    uint64_t filesize;\n    uint32_t maxprot;\n    uint32_t initprot;\n    uint32_t nsects;\n    uint32_t flags;\n};\nstruct linkedit_data_command {\n    uint32_t cmd;\n    uint32_t cmdsize;\n    uint32_t dataoff;\n    uint32_t datasize;\n};\nstruct symtab_command {\n    uint32_t cmd;\n    uint32_t cmdsize;\n    uint32_t symoff;\n    uint32_t nsyms;\n    uint32_t stroff;\n    uint32_t strsize;\n};\nstruct dysymtab_command {\n    uint32_t cmd;\n    uint32_t cmdsize;\n\n    uint32_t ilocalsym;\n    uint32_t nlocalsym;\n\n    uint32_t iextdefsym;\n    uint32_t nextdefsym;\n\n    uint32_t iundefsym;\n    uint32_t nundefsym;\n\n    uint32_t tocoff;\n    uint32_t ntoc;\n\n    uint32_t modtaboff;\n    uint32_t nmodtab;\n\n    uint32_t extrefsymoff;\n    uint32_t nextrefsyms;\n\n    uint32_t indirectsymoff;\n    uint32_t nindirectsyms;\n\n    uint32_t extreloff;\n    uint32_t nextrel;\n\n    uint32_t locreloff;\n    uint32_t nlocrel;\n};\nstruct nlist_64 {\n    union {\n        uint32_t  n_strx;\n    } n_un;\n    uint8_t n_type;\n    uint8_t n_sect;\n    uint16_t n_desc;\n    uint64_t n_value;\n};\n#endif  //}\n\nstruct Cmd_names {\n    unsigned char val;\n    char name[23];\n} const cmd_names[] = {\n    [ 0x1]  = { 0x1, \"LC_SEGMENT\"},\n    [ 0x2]  = { 0x2, \"LC_SYMTAB\"},\n    [ 0x4]  = { 0x4, \"LC_THREAD\"},\n    [ 0x5]  = { 0x5, \"LC_UNIXTHREAD\"},\n    [ 0xb]  = { 0xb, \"LC_DYSYMTAB\"},\n    [ 0xc]  = { 0xc, \"LC_LOAD_DYLIB\"},\n    [ 0xd]  = { 0xd, \"LC_ID_DYLIB\"},\n    [ 0xe]  = { 0xe, \"LC_LOAD_DYLINKER\"},\n    [ 0xf]  = { 0xf, \"LC_ID_DYLINKER\"},\n    [ 0x11]  = { 0x11, \"LC_ROUTINES\"},\n    [ 0x16]  = { 0x16, \"LC_TWOLEVEL_HINTS\"},\n    [ (0x18 /*|LC_REQ_DYLD*/ )] = {0x18, \"LC_LOAD_WEAK_DYLIB\"},\n    [ 0x19]  = { 0x19, \"LC_SEGMENT_64\"},\n    [ 0x1a]  = { 0x1a, \"LC_ROUTINES_64\"},\n    [ 0x1b]  = { 0x1b, \"LC_UUID\"},\n    [ 0x1c]  = { 0x1c, \"LC_RPATH\"},\n    [ 0x1d]  = { 0x1d, \"LC_CODE_SIGNATURE\"},\n    [ 0x1e]  = { 0x1e, \"LC_SEGMENT_SPLIT_INFO\"},\n    [ (0x1f /*|LC_REQ_DYLD*/ )] = { 0x1f, \"LC_REEXPORT_DYLIB\"},\n    [ 0x20]  = { 0x20, \"LC_LAZY_LOAD_DYLIB\"},\n    [ 0x21]  = { 0x21, \"LC_ENCRYPTION_INFO\"},\n//  [ 0x22]  = { 0x22, \"LC_DYLD_INFO\"  // compressed dyld information (10.6.x)\n    [ (0x22 /*|LC_REQ_DYLD*/ )]  = { 0x22, \"LC_DYLD_INFO_ONLY\"},\n    [ 0x24]  = { 0x24, \"LC_VERSION_MIN_MACOSX\"},\n    [ 0x25]  = { 0x25, \"LC_VERSION_MIN_IPHONEOS\"},\n    [ 0x26]  = { 0x26, \"LC_FUNCTION_STARTS\"},\n    [ 0x27]  = { 0x27, \"LC_DYLD_ENVIRONMENT\"},  // string as environment variable\n    [ (0x28 /*|LC_REQ_DYLD*/ )]  = { 0x28, \"LC_MAIN\"},\n    [ 0x29]  = { 0x29, \"LC_DATA_IN_CODE\"},\n    [ 0x2a]  = { 0x2a, \"LC_SOURCE_VERSION\"},\n    [ 0x2B]  = { 0x2B, \"LC_DYLIB_CODE_SIGN_DRS\"},\n    [ 0x2C]  = { 0x2C, \"LC_ENCRYPTION_INFO_64\"},\n    [ 0x2F]  = { 0x2F, \"LC_VERSION_MIN_TVOS\"},\n    [ 0x30]  = { 0x30, \"LC_VERSION_MIN_WATCHOS\"},\n    [ 0x31]  = { 0x31, \"LC_NOTE\"},\n    [ 0x32]  = { 0x32, \"LC_BUILD_VERSION\"},\n    [(0x33 /*|LC_REQ_DYLD*/ )]  = {0x33, \"LC_DYLD_EXPORTS_TRIE\"},\n    [(0x34 /*|LC_REQ_DYLD*/ )]  = {0x34, \"LC_DYLD_CHAINED_FIXUPS\"},\n    [(0x35 /*|LC_REQ_DYLD*/ )]  = {0x35, \"LC_FILESET_ENTRY\"},\n};\n\n// Remove (cut out, \"snip\") named loader_commands from a Macho-O file.\n// Try to enable success of running \"codesign -s - file\" afterwards.\n// Note that LC_CODE_SIGNATURE should be removed before snipping:\n//   codesign --remove-signature file\n//\n// This is EXPERIMENTAL to aid in finding a \"minimal\" executable\n// on Apple MacOS Big Sur, particularly Apple M1 hardware (aarch64).\nint\nmain(int argc, char const * /*const*/ *const argv, char const *const *const envp)\n{\n    struct stat st;\n    int fd;\n    int err1;\n    int res2;\n    int err2;\n    int prot = PROT_READ | PROT_WRITE;\n    int flags = MAP_FIXED | MAP_SHARED;\n    void *const awant = (void *)(0x18L << 28);  // above user, below dylibs\n    char *addr;\n\n    if (argc < 3) {\n        fprintf(stderr, \"Usage: macho-snip file loader_cmd...\\n\");\n        exit(1);\n    }\n    fd = open(argv[1], O_RDWR, 0);\n    err1 = errno;\n    if (fd < 0) {\n        perror(argv[1]);\n        fprintf(stderr, \"Trying readonly...\\n\");\n        flags = MAP_FIXED | MAP_PRIVATE;\n        fd = open(argv[1], O_RDONLY, 0);\n    }\n    res2 = fstat(fd, &st);\n    err2 = errno;\n\n    if (fd < 0) {\n        errno = err1;\n        perror(argv[1]);\n        exit(1);\n    }\n    if (0!=res2) {\n        errno = err2;\n        perror(argv[1]);\n        exit(1);\n    }\n    addr = mmap(awant, st.st_size, prot, flags, fd, 0);\n    if (awant!=addr) {\n        perror(argv[1]);\n        exit(1);\n    }\n    fprintf(stderr,\"%zd (%#zx) bytes at %p\\n\", (long)st.st_size, (long)st.st_size, addr);\n\n    unsigned long argv_done = 0;  // set of bits\n    struct segment_command_64 *linkedit = 0;\n    struct mach_header_64 *const mhdr = (struct mach_header_64 *)addr;\n    unsigned ncmds = mhdr->ncmds;\n    unsigned headway = mhdr->sizeofcmds;\n    struct load_command *cmd = (struct load_command *)(1+ mhdr);\n    struct load_command *cmd_next;\n    unsigned delta_dataoff = 0;\n    for (; ncmds; --ncmds, cmd = cmd_next) {\n        unsigned end_dataoff = 0;\n        unsigned end_datasize = 0;\nagain: ;\n        fprintf(stderr, \"cmd@%p %s %d(%#x)\\n\",\n            cmd, cmd_names[cmd->cmd&0xFF].name, cmd->cmd&0xFF, cmd->cmd);\n        unsigned const cmdsize = cmd->cmdsize;\n        if (headway < cmdsize ) {\n        }\n        else {\n            headway -= cmdsize;\n            cmd_next = (struct load_command *)(cmdsize + (void *)cmd);\n        }\n        switch (cmd->cmd &~ LC_REQ_DYLD) {\n            int jargv;\n\n        case LC_SEGMENT_64: {\n            struct segment_command_64 *seg = (struct segment_command_64 *)cmd;\n            if (!strcmp(\"__LINKEDIT\", seg->segname)) {\n                linkedit = seg;\n            }\n        } break;\n        case LC_CODE_SIGNATURE: {\n            fprintf(stderr, \"macho-snip: use 'codesign --remove-signature' to remove LC_CODE_SIGNATURE\\n\");\n        } break;\n\n//struct nlist_64 {\n//    union {\n//        uint32_t  n_strx; /* index into the string table */\n//    } n_un;\n//    uint8_t n_type;        /* type flag, see below */\n//    uint8_t n_sect;        /* section number or NO_SECT */\n//    uint16_t n_desc;       /* see <mach-o/stab.h> */\n//    uint64_t n_value;      /* value of this symbol (or stab offset) */\n//};\n//\n// The string table has an extra entry at the front: \" \" (one space)\n// so that the first actual string has an index of 2.\n// See the comment which follows the definition of struct nlist_64 in\n// /Applications/Xcode.app/Contents/Developer/Platforms/MacOSX.platform/Developer/SDKs/MacOSX.sdk/usr/include/mach-o/nlist.h\n//\n// The string table must be zero-padded to a multiple of 8 bytes.\n// codesign requires that the string table must be last in __LINKEDIT:\n// (__LINKEDIT.filesize + .fileoff) == (LC_SYMTAB.strsize + .stroff)\n// [The LC_CODE_SIGNATURE.dataoff also aligns itself to (0 mod 16),\n// which is peculiar because the data array of sha256 values (one 32-byte\n// value per 4KB page) has offset (4 mod 16) instead of (0 mod 16).]\n\n        case LC_SYMTAB: {\n            fprintf(stderr, \"macho-snip: LC_SYMTAB skipped\\n\");\n            continue;\n            struct symtab_command *symcmd = (struct symtab_command *)cmd;\n            if ((  symcmd->strsize +    symcmd->stroff)\n            != (linkedit->filesize + linkedit->fileoff)) {\n                fprintf(stderr,\"macho-snip: bad LC_SYMTAB string table\\n\");\n            }\n            // find beginning of last name string\n            unsigned j;\n            struct nlist_64 *const symp = (struct nlist_64 *)(symcmd->symoff + addr);\n            char *const namp0 = symcmd->stroff + addr;\n            char *namp;\n            for (j=0, namp = namp0; j < symcmd->nsyms; ++j) {\n                namp += 1+ strlen(namp);\n                if (symp[j].n_un.n_strx != (namp - namp0)) {\n                    fprintf(stderr, \"macho-snip: bad .n_strx\\n\");\n                }\n            }\n            unsigned pad = 7& -(unsigned long)namp;\n            memset(namp, 0, pad); namp += pad;  // zero pad to (0 mod 8)\n            symcmd->strsize = namp - namp0;\n            linkedit->filesize = (namp - addr) - linkedit->fileoff;\n            symcmd->nsyms -= 1;  // lop last symbol  FIXME: generalize\n        } break;\n        case LC_DYSYMTAB: {\n            fprintf(stderr, \"macho-snip: LD_DYSYMTAB skipped\\n\");\n            continue;\n            struct dysymtab_command *dysym = (struct dysymtab_command *)cmd;\n            if (0==(dysym->nundefsym -= 1)) { // FIXME: generalize\n                dysym->iundefsym = 0;\n            }\n        } break;\n\n        case LC_BUILD_VERSION:\n        case LC_DYLD_INFO:  // also LC_DYLD_INFO_ONLY because low 8 bits\n        case LC_LOAD_DYLIB:\n        case LC_LOAD_DYLINKER:\n        case LC_MAIN:\n        case LC_SOURCE_VERSION:\n        case LC_UUID:\n        {\n            for (jargv = 2; jargv < argc; ++jargv) {\n                if (argv[jargv] && !strcmp(cmd_names[cmd->cmd & 0xFF].name, argv[jargv])) {\n                    argv_done |= 1uL << jargv;\n                    fprintf(stderr, \"macho-snip: %#x, %s\\n\",\n                        cmd_names[cmd->cmd & 0xFF].val, cmd_names[cmd->cmd & 0xFF].name);\n                    // EXPERIMENT:\n                    if (cmd->cmd == LC_DYLD_INFO_ONLY) { // the \"must process\" case\n                        struct dyld_info_command *dyldcmd = (struct dyld_info_command *)cmd;\n                        dyldcmd->export_off = 0;\n                        dyldcmd->export_size = 0;\n                        goto next;  // EXPERIMENT\n                    }\n                    goto snip;\n                }\n            }\n        } break;\n\n        case LC_DATA_IN_CODE: {\n        case LC_DYLD_EXPORTS_TRIE:\n        case LC_DYLD_CHAINED_FIXUPS:\n        case LC_DYLIB_CODE_SIGN_DRS:\n        case LC_FUNCTION_STARTS:\n        case LC_LINKER_OPTIMIZATION_HINT:\n        case LC_SEGMENT_SPLIT_INFO: {\n            for (jargv = 2; jargv < argc; ++jargv) {\n                if (argv[jargv] && !strcmp(cmd_names[cmd->cmd & 0xFF].name, argv[jargv])) {\n                    argv_done |= 1uL << jargv;\n                    fprintf(stderr, \"macho-snip: %#x, %s\\n\",\n                        cmd_names[cmd->cmd & 0xFF].val, cmd_names[cmd->cmd & 0xFF].name);\n                    goto snip_linkedit_data_command;\n                }\n            }\n        } break;\n        }\n        continue;  // no changes ==> advance\nsnip_linkedit_data_command: ;\n        struct linkedit_data_command *ldc = (struct linkedit_data_command *)cmd;\n        end_datasize = ldc->datasize;\n        end_dataoff  = ldc->datasize + ldc->dataoff;\n        memset(addr + ldc->dataoff, 0, end_datasize);  // the linkedit_data\n        if ((linkedit->fileoff + linkedit->filesize) == end_dataoff) {\n            linkedit->filesize -= end_datasize;  // trim\n        }\nsnip: ;\n        memmove(cmd, cmd_next, headway);\n        memset(headway + (char *)cmd, 0, cmdsize);  // space that was vacated\n        cmd_next = cmd;  // we moved tail at *cmd_next to *cmd\n        mhdr->sizeofcmds -= cmdsize;\n        mhdr->ncmds -= 1;\n        argv[jargv] = 0;  // snip only once per argv[]\n        }  // switch\nnext: ;\n    }  // ncmds\n    argv_done |= (1<<1) | (1<<0);  // argv[0,1] do not name linker_commands\n    if (~(~0uL << argc) != argv_done) {\n        int j;\n        for (j=2; j < argc; ++j) {\n            if (!((1uL << j) & argv_done)) {\n                fprintf(stderr, \"macho-snip warning: %s not processed\\n\", argv[j]);\n            }\n        }\n    }\n    if (!(MAP_SHARED & flags)) {\n        write(1, addr, st.st_size);\n    }\n    return 0;  // success\n}\n\n/* vim:set ts=4 sw=4 et: */\n","size_bytes":14117},"src/stub/tools/sstrip/sstrip.c":{"content":"/* http://www.muppetlabs.com/~breadbox/software/elfkickers.html */\n\n/* clang-format off */\n\n/* sstrip: Copyright (C) 1999-2001 by Brian Raiter, under the GNU\n * General Public License. No warranty. See COPYING for details.\n *\n * Aug 23, 2004 Hacked by Manuel Novoa III <mjn3@codepoet.org> to\n * handle targets of different endianness and/or elf class, making\n * it more useful in a cross-devel environment.\n */\n\n/* ============== original README ===================\n *\n * sstrip is a small utility that removes the contents at the end of an\n * ELF file that are not part of the program's memory image.\n *\n * Most ELF executables are built with both a program header table and a\n * section header table. However, only the former is required in order\n * for the OS to load, link and execute a program. sstrip attempts to\n * extract the ELF header, the program header table, and its contents,\n * leaving everything else in the bit bucket. It can only remove parts of\n * the file that occur at the end, after the parts to be saved. However,\n * this almost always includes the section header table, and occasionally\n * a few random sections that are not used when running a program.\n *\n * It should be noted that the GNU bfd library is (understandably)\n * dependent on the section header table as an index to the file's\n * contents. Thus, an executable file that has no section header table\n * cannot be used with gdb, objdump, or any other program based upon the\n * bfd library, at all. In fact, the program will not even recognize the\n * file as a valid executable. (This limitation is noted in the source\n * code comments for bfd, and is marked \"FIXME\", so this may change at\n * some future date. However, I would imagine that it is a pretty\n * low-priority item, as executables without a section header table are\n * rare in the extreme.) This probably also explains why strip doesn't\n * offer the option to do this.\n *\n * Shared library files may also have their section header table removed.\n * Such a library will still function; however, it will no longer be\n * possible for a compiler to link a new program against it.\n *\n * As an added bonus, sstrip also tries to removes trailing zero bytes\n * from the end of the file. (This normally cannot be done with an\n * executable that has a section header table.)\n *\n * sstrip is a very simplistic program. It depends upon the common\n * practice of putting the parts of the file that contribute to the\n * memory image at the front, and the remaining material at the end. This\n * permits it to discard the latter material without affecting file\n * offsets and memory addresses in what remains. Of course, the ELF\n * standard permits files to be organized in almost any order, so if a\n * pathological linker decided to put its section headers at the top,\n * sstrip would be useless on such executables.\n */\n\n#include    <stdio.h>\n#include    <stdlib.h>\n#include    <string.h>\n#include    <errno.h>\n#include    <unistd.h>\n#include    <fcntl.h>\n#include    <elf.h>\n#include    <endian.h>\n#include    <byteswap.h>\n\n#ifndef TRUE\n#define TRUE        1\n#define FALSE       0\n#endif\n\n/* The name of the program.\n */\nstatic char const   *progname;\n\n/* The name of the current file.\n */\nstatic char const   *filename;\n\n\n/* A simple error-handling function. FALSE is always returned for the\n * convenience of the caller.\n */\nstatic int err(char const *errmsg)\n{\n    fprintf(stderr, \"%s: %s: %s\\n\", progname, filename, errmsg);\n    return FALSE;\n}\n\n/* A flag to signal the need for endian reversal.\n */\nstatic int do_reverse_endian;\n\n/* Get a value from the elf header, compensating for endianness.\n */\n#define EGET(X) \\\n    (__extension__ ({ \\\n        uint64_t __res; \\\n        if (!do_reverse_endian) { \\\n            __res = (X); \\\n        } else if (sizeof(X) == 1) { \\\n            __res = (X); \\\n        } else if (sizeof(X) == 2) { \\\n            __res = bswap_16((X)); \\\n        } else if (sizeof(X) == 4) { \\\n            __res = bswap_32((X)); \\\n        } else if (sizeof(X) == 8) { \\\n            __res = bswap_64((X)); \\\n        } else { \\\n            fprintf(stderr, \"%s: %s: EGET failed for size %ld\\n\", \\\n                    progname, filename, (long) sizeof(X)); \\\n            exit(EXIT_FAILURE); \\\n        } \\\n        __res; \\\n    }))\n\n/* Set a value 'Y' in the elf header to 'X', compensating for endianness.\n */\n#define ESET(Y,X) \\\n        do if (!do_reverse_endian) { \\\n            Y = (X); \\\n        } else if (sizeof(Y) == 1) { \\\n            Y = (X); \\\n        } else if (sizeof(Y) == 2) { \\\n            Y = bswap_16((uint16_t)(X)); \\\n        } else if (sizeof(Y) == 4) { \\\n            Y = bswap_32((uint32_t)(X)); \\\n        } else if (sizeof(Y) == 8) { \\\n            Y = bswap_64((uint64_t)(X)); \\\n        } else { \\\n            fprintf(stderr, \"%s: %s: ESET failed for size %ld\\n\", \\\n                    progname, filename, (long) sizeof(Y)); \\\n            exit(EXIT_FAILURE); \\\n        } while (0)\n\n\n/* A macro for I/O errors: The given error message is used only when\n * errno is not set.\n */\n#define ferr(msg)   (err(errno ? strerror(errno) : (msg)))\n\n\n\n#define HEADER_FUNCTIONS(CLASS) \\\n \\\n/* readelfheader() reads the ELF header into our global variable, and \\\n * checks to make sure that this is in fact a file that we should be \\\n * munging. \\\n */ \\\nstatic int readelfheader ## CLASS (int fd, Elf ## CLASS ## _Ehdr *ehdr) \\\n{ \\\n     if (read(fd, ((char *)ehdr)+EI_NIDENT, sizeof(*ehdr) - EI_NIDENT) \\\n        != (ssize_t)sizeof(*ehdr) - EI_NIDENT) \\\n        return ferr(\"missing or incomplete ELF header.\"); \\\n \\\n    /* Verify the sizes of the ELF header and the program segment \\\n     * header table entries. \\\n     */ \\\n    if (EGET(ehdr->e_ehsize) != sizeof(Elf ## CLASS ## _Ehdr)) \\\n        return err(\"unrecognized ELF header size.\"); \\\n    if (EGET(ehdr->e_phentsize) != sizeof(Elf ## CLASS ## _Phdr)) \\\n        return err(\"unrecognized program segment header size.\"); \\\n \\\n    /* Finally, check the file type. \\\n     */ \\\n    if (EGET(ehdr->e_type) != ET_EXEC && EGET(ehdr->e_type) != ET_DYN) \\\n        return err(\"not an executable or shared-object library.\"); \\\n \\\n    return TRUE; \\\n} \\\n \\\n/* readphdrtable() loads the program segment header table into memory. \\\n */ \\\nstatic int readphdrtable ## CLASS (int fd, Elf ## CLASS ## _Ehdr const *ehdr, \\\n                                   Elf ## CLASS ## _Phdr **phdrs) \\\n{ \\\n    size_t  size; \\\n \\\n    if (!EGET(ehdr->e_phoff) || !EGET(ehdr->e_phnum) \\\n)       return err(\"ELF file has no program header table.\"); \\\n \\\n    size = EGET(ehdr->e_phnum) * sizeof **phdrs; \\\n    if (!(*phdrs = malloc(size))) \\\n        return err(\"Out of memory!\"); \\\n \\\n    errno = 0; \\\n    if (read(fd, *phdrs, size) != (ssize_t)size) \\\n        return ferr(\"missing or incomplete program segment header table.\"); \\\n \\\n    return TRUE; \\\n} \\\n \\\n/* getmemorysize() determines the offset of the last byte of the file \\\n * that is referenced by an entry in the program segment header table. \\\n * (Anything in the file after that point is not used when the program \\\n * is executing, and thus can be safely discarded.) \\\n */ \\\nstatic int getmemorysize ## CLASS (Elf ## CLASS ## _Ehdr const *ehdr, \\\n                                   Elf ## CLASS ## _Phdr const *phdrs, \\\n                         unsigned long *newsize) \\\n{ \\\n    Elf ## CLASS ## _Phdr const   *phdr; \\\n    unsigned long   size, n; \\\n    size_t          i; \\\n \\\n    /* Start by setting the size to include the ELF header and the \\\n     * complete program segment header table. \\\n     */ \\\n    size = EGET(ehdr->e_phoff) + EGET(ehdr->e_phnum) * sizeof *phdrs; \\\n    if (size < sizeof *ehdr) \\\n        size = sizeof *ehdr; \\\n \\\n    /* Then keep extending the size to include whatever data the \\\n     * program segment header table references. \\\n     */ \\\n    for (i = 0, phdr = phdrs ; i < EGET(ehdr->e_phnum) ; ++i, ++phdr) { \\\n        if (EGET(phdr->p_type) != PT_NULL) { \\\n            n = EGET(phdr->p_offset) + EGET(phdr->p_filesz); \\\n            if (n > size) \\\n                size = n; \\\n        } \\\n    } \\\n \\\n    *newsize = size; \\\n    return TRUE; \\\n} \\\n \\\n/* modifyheaders() removes references to the section header table if \\\n * it was stripped, and reduces program header table entries that \\\n * included truncated bytes at the end of the file. \\\n */ \\\nstatic int modifyheaders ## CLASS (Elf ## CLASS ## _Ehdr *ehdr, \\\n                                   Elf ## CLASS ## _Phdr *phdrs, \\\n                                   unsigned long newsize) \\\n{ \\\n    Elf ## CLASS ## _Phdr *phdr; \\\n    size_t  i; \\\n \\\n    /* If the section header table is gone, then remove all references \\\n     * to it in the ELF header. \\\n     */ \\\n    if (EGET(ehdr->e_shoff) >= newsize) { \\\n        ESET(ehdr->e_shoff,0); \\\n        ESET(ehdr->e_shnum,0); \\\n        ESET(ehdr->e_shentsize,sizeof(Elf ## CLASS ## _Shdr)); \\\n        ESET(ehdr->e_shstrndx,0); \\\n    } \\\n \\\n    /* The program adjusts the file size of any segment that was \\\n     * truncated. The case of a segment being completely stripped out \\\n     * is handled separately. \\\n     */ \\\n    for (i = 0, phdr = phdrs ; i < EGET(ehdr->e_phnum) ; ++i, ++phdr) { \\\n        if (EGET(phdr->p_offset) >= newsize) { \\\n            ESET(phdr->p_offset,newsize); \\\n            ESET(phdr->p_filesz,0); \\\n        } else if (EGET(phdr->p_offset) + EGET(phdr->p_filesz) > newsize) { \\\n            newsize -= EGET(phdr->p_offset); \\\n            ESET(phdr->p_filesz, newsize); \\\n        } \\\n    } \\\n \\\n    return TRUE; \\\n} \\\n \\\n/* commitchanges() writes the new headers back to the original file \\\n * and sets the file to its new size. \\\n */ \\\nstatic int commitchanges ## CLASS (int fd, Elf ## CLASS ## _Ehdr const *ehdr, \\\n                                   Elf ## CLASS ## _Phdr *phdrs, \\\n                                   unsigned long newsize) \\\n{ \\\n    size_t  n; \\\n \\\n    /* Save the changes to the ELF header, if any. \\\n     */ \\\n    if (lseek(fd, 0, SEEK_SET)) \\\n        return ferr(\"could not rewind file\"); \\\n    errno = 0; \\\n    if (write(fd, ehdr, sizeof *ehdr) != (ssize_t)sizeof *ehdr) \\\n        return err(\"could not modify file\"); \\\n \\\n    /* Save the changes to the program segment header table, if any. \\\n     */ \\\n    if (lseek(fd, EGET(ehdr->e_phoff), SEEK_SET) == (off_t)-1) { \\\n        err(\"could not seek in file.\"); \\\n        goto warning; \\\n    } \\\n    n = EGET(ehdr->e_phnum) * sizeof *phdrs; \\\n    if (write(fd, phdrs, n) != (ssize_t)n) { \\\n        err(\"could not write to file\"); \\\n        goto warning; \\\n    } \\\n \\\n    /* Eleventh-hour sanity check: don't truncate before the end of \\\n     * the program segment header table. \\\n     */ \\\n    if (newsize < EGET(ehdr->e_phoff) + n) \\\n        newsize = EGET(ehdr->e_phoff) + n; \\\n \\\n    /* Chop off the end of the file. \\\n     */ \\\n    if (ftruncate(fd, newsize)) { \\\n        err(\"could not resize file\"); \\\n        goto warning; \\\n    } \\\n \\\n    return TRUE; \\\n \\\n warning: \\\n    return err(\"ELF file may have been corrupted!\"); \\\n}\n\n\n/* First elements of Elf32_Ehdr and Elf64_Ehdr are common.\n */\nstatic int readelfheaderident(int fd, Elf32_Ehdr *ehdr)\n{\n    errno = 0;\n    if (read(fd, ehdr, EI_NIDENT) != EI_NIDENT)\n        return ferr(\"missing or incomplete ELF header.\");\n\n    /* Check the ELF signature.\n     */\n    if (!(ehdr->e_ident[EI_MAG0] == ELFMAG0 &&\n          ehdr->e_ident[EI_MAG1] == ELFMAG1 &&\n          ehdr->e_ident[EI_MAG2] == ELFMAG2 &&\n          ehdr->e_ident[EI_MAG3] == ELFMAG3))\n    {\n        err(\"missing ELF signature.\");\n        return -1;\n    }\n\n    /* Compare the file's class and endianness with the program's.\n     */\n#if __BYTE_ORDER == __LITTLE_ENDIAN\n    if (ehdr->e_ident[EI_DATA] == ELFDATA2LSB) {\n        do_reverse_endian = 0;\n    } else if (ehdr->e_ident[EI_DATA] == ELFDATA2MSB) {\n/*      fprintf(stderr, \"ELF file has different endianness.\\n\"); */\n        do_reverse_endian = 1;\n    }\n#elif __BYTE_ORDER == __BIG_ENDIAN\n    if (ehdr->e_ident[EI_DATA] == ELFDATA2LSB) {\n/*      fprintf(stderr, \"ELF file has different endianness.\\n\"); */\n        do_reverse_endian = 1;\n    } else if (ehdr->e_ident[EI_DATA] == ELFDATA2MSB) {\n        do_reverse_endian = 0;\n    }\n#else\n#error unknown endianness\n#endif\n    else {\n        err(\"Unsupported endianness\");\n        return -1;\n    }\n\n    /* Check the target architecture.\n     */\n/*   if (EGET(ehdr->e_machine) != ELF_ARCH) { */\n/*      /\\* return err(\"ELF file created for different architecture.\"); *\\/ */\n/*      fprintf(stderr, \"ELF file created for different architecture.\\n\"); */\n/*  } */\n    return ehdr->e_ident[EI_CLASS];\n}\n\n\nHEADER_FUNCTIONS(32)\n\nHEADER_FUNCTIONS(64)\n\n/* truncatezeros() examines the bytes at the end of the file's\n * size-to-be, and reduces the size to exclude any trailing zero\n * bytes.\n */\nstatic int truncatezeros(int fd, unsigned long *newsize)\n{\n    unsigned char   contents[1024];\n    unsigned long   size, n;\n\n    size = *newsize;\n    do {\n        n = sizeof contents;\n        if (n > size)\n            n = size;\n        if (lseek(fd, size - n, SEEK_SET) == (off_t)-1)\n            return ferr(\"cannot seek in file.\");\n        if (read(fd, contents, n) != (ssize_t)n)\n            return ferr(\"cannot read file contents\");\n        while (n && !contents[--n])\n            --size;\n    } while (size && !n);\n\n    /* Sanity check.\n     */\n    if (!size)\n        return err(\"ELF file is completely blank!\");\n\n    *newsize = size;\n    return TRUE;\n}\n\n/* main() loops over the cmdline arguments, leaving all the real work\n * to the other functions.\n */\nint main(int argc, char *argv[])\n{\n    int             fd;\n    union {\n        Elf32_Ehdr  ehdr32;\n        Elf64_Ehdr  ehdr64;\n    } e;\n    union {\n        Elf32_Phdr  *phdrs32;\n        Elf64_Phdr  *phdrs64;\n    } p;\n    unsigned long   newsize;\n    char            **arg;\n    int             failures = 0;\n\n    if (argc < 2 || argv[1][0] == '-') {\n        printf(\"Usage: sstrip FILE...\\n\"\n               \"sstrip discards all nonessential bytes from an executable.\\n\\n\"\n               \"Version 2.0-X Copyright (C) 2000,2001 Brian Raiter.\\n\"\n               \"Cross-devel hacks Copyright (C) 2004 Manuel Novoa III.\\n\"\n               \"This program is free software, licensed under the GNU\\n\"\n               \"General Public License. There is absolutely no warranty.\\n\");\n        return EXIT_SUCCESS;\n    }\n\n    progname = argv[0];\n\n    for (arg = argv + 1 ; *arg != NULL ; ++arg) {\n        filename = *arg;\n\n        fd = open(*arg, O_RDWR);\n        if (fd < 0) {\n            ferr(\"can't open\");\n            ++failures;\n            continue;\n        }\n\n        switch (readelfheaderident(fd, &e.ehdr32)) {\n            case ELFCLASS32:\n                if (!(readelfheader32(fd, &e.ehdr32)                    &&\n                      readphdrtable32(fd, &e.ehdr32, &p.phdrs32)        &&\n                      getmemorysize32(&e.ehdr32, p.phdrs32, &newsize)   &&\n                      truncatezeros(fd, &newsize)                       &&\n                      modifyheaders32(&e.ehdr32, p.phdrs32, newsize)    &&\n                      commitchanges32(fd, &e.ehdr32, p.phdrs32, newsize)))\n                    ++failures;\n                break;\n            case ELFCLASS64:\n                if (!(readelfheader64(fd, &e.ehdr64)                    &&\n                      readphdrtable64(fd, &e.ehdr64, &p.phdrs64)        &&\n                      getmemorysize64(&e.ehdr64, p.phdrs64, &newsize)   &&\n                      truncatezeros(fd, &newsize)                       &&\n                      modifyheaders64(&e.ehdr64, p.phdrs64, newsize)    &&\n                      commitchanges64(fd, &e.ehdr64, p.phdrs64, newsize)))\n                    ++failures;\n                break;\n            default:\n                ++failures;\n                break;\n        }\n        close(fd);\n    }\n\n    return failures ? EXIT_FAILURE : EXIT_SUCCESS;\n}\n\n/*\nvi:ts=4:et:nowrap\n*/\n\n","size_bytes":15890},"src/stub/src/arch/i086/cc_test.c":{"content":"/* cc_test.c -- examine compiler-generated library calls\n\n   This file is part of the UPX executable compressor.\n\n   Copyright (C) 2006-2025 Markus Franz Xaver Johannes Oberhumer\n   All Rights Reserved.\n\n   UPX and the UCL library are free software; you can redistribute them\n   and/or modify them under the terms of the GNU General Public License as\n   published by the Free Software Foundation; either version 2 of\n   the License, or (at your option) any later version.\n\n   This program is distributed in the hope that it will be useful,\n   but WITHOUT ANY WARRANTY; without even the implied warranty of\n   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n   GNU General Public License for more details.\n\n   You should have received a copy of the GNU General Public License\n   along with this program; see the file COPYING.\n   If not, write to the Free Software Foundation, Inc.,\n   59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.\n\n   Markus F.X.J. Oberhumer\n   <markus@oberhumer.com>\n */\n\n\n#if 0 && defined(__WATCOMC__)\n#define __cdecl __watcall\n#endif\n\n\n/*************************************************************************\n//\n**************************************************************************/\n\ntypedef short           int16_t;\ntypedef unsigned short  uint16_t;\ntypedef long            int32_t;\ntypedef unsigned long   uint32_t;\n\n#if 1\n// simulated 32-bit pointer\ntypedef char __huge*    hptr;\ntypedef long            hptrdiff_t;\ntypedef unsigned long   hsize_t;\n#elif 1\n// ignore segment overflow\ntypedef char __far*     hptr;\ntypedef long            hptrdiff_t;\ntypedef unsigned long   hsize_t;\n#else\n// no segment\ntypedef char __near*    hptr;\ntypedef short           hptrdiff_t;\ntypedef unsigned short  hsize_t;\n#endif\n\n// pia - pointer add\nhptr __cdecl pia(hptr a, hsize_t d) { return a + d; }\nhptr __cdecl pia1(hptr a)           { return a + 1; }\n\n// pis - pointer subtract\nhptr __cdecl pis(hptr a, hsize_t d) { return a - d; }\nhptr __cdecl pis1(hptr a)           { return a - 1; }\n\n// pts - pointer diff\nhptrdiff_t __cdecl pts(hptr a, hptr b) { return a - b; }\n\n// ptc - pointer compare (__PTC sets zero and carry flags)\nint __cdecl ptc_eq(hptr a, hptr b) { return a == b; }\nint __cdecl ptc_ne(hptr a, hptr b) { return a != b; }\nint __cdecl ptc_lt(hptr a, hptr b) { return a < b; }\nint __cdecl ptc_le(hptr a, hptr b) { return a <= b; }\nint __cdecl ptc_gt(hptr a, hptr b) { return a > b; }\nint __cdecl ptc_ge(hptr a, hptr b) { return a >= b; }\n\n// u4m - unsigned multiplication\nuint32_t __cdecl u4m(uint32_t a, uint32_t b) { return a * b; }\nuint32_t __pascal u4m_p(uint32_t a, uint32_t b) { return b * a; }\n\n// i4m - signed multiplication\nint32_t  __cdecl i4m(int32_t  a, int32_t  b) { return a * b; }\nint32_t  __pascal i4m_p(int32_t a, int32_t b) { return b * a; }\n\n// just for testing\nuint16_t __cdecl u2m(uint16_t a, uint16_t b) { return a * b; }\nint16_t  __cdecl i2m(int16_t  a, int16_t  b) { return a * b; }\nuint32_t __cdecl u2m4(uint16_t a, uint16_t b) { return a * b; }\nint32_t  __cdecl i2m4(int16_t  a, int16_t  b) { return a * b; }\n\nuint16_t __cdecl u2shl8 (uint16_t a) { return a <<  8; }\nuint32_t __cdecl u4shl8 (uint32_t a) { return a <<  8; }\nuint16_t __cdecl u2shl12(uint16_t a) { return a << 12; }\nuint32_t __cdecl u4shl12(uint32_t a) { return a << 12; }\nuint32_t __cdecl u4shl16(uint32_t a) { return a << 16; }\nuint32_t __cdecl u4shl24(uint32_t a) { return a << 24; }\nuint16_t __cdecl u2shlv(uint16_t a, unsigned v) { return a << v; }\nuint32_t __cdecl u4shlv(uint32_t a, unsigned v) { return a << v; }\n\nvoid __pascal p4nshlv_v(unsigned char v, uint32_t __near *a) { *a <<= v; }\nvoid __pascal p4fshlv_v(unsigned char v, uint32_t __far *a) { *a <<= v; }\nuint32_t __pascal p4nshlv(unsigned char v, uint32_t __near *a) { return *a <<= v; }\nuint32_t __pascal p4fshlv(unsigned char v, uint32_t __far *a) { return *a <<= v; }\n\nhptrdiff_t __cdecl hptr2int(hptr a) { return (hptrdiff_t) a; }\nhptr __cdecl int2hptr(hptrdiff_t a) { return (hptr) a; }\n\n\n/* vim:set ts=4 et: */\n","size_bytes":4027},"src/stub/src/arch/i086/cleanasm.py":{"content":"#! /usr/bin/env python2\n## vim:set ts=4 sw=4 et: -*- coding: utf-8 -*-\n#\n#  cleanasm.py --\n#\n#  This file is part of the UPX executable compressor.\n#\n#  Copyright (C) 1996-2025 Markus Franz Xaver Johannes Oberhumer\n#  All Rights Reserved.\n#\n#  UPX and the UCL library are free software; you can redistribute them\n#  and/or modify them under the terms of the GNU General Public License as\n#  published by the Free Software Foundation; either version 2 of\n#  the License, or (at your option) any later version.\n#\n#  This program is distributed in the hope that it will be useful,\n#  but WITHOUT ANY WARRANTY; without even the implied warranty of\n#  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n#  GNU General Public License for more details.\n#\n#  You should have received a copy of the GNU General Public License\n#  along with this program; see the file COPYING.\n#  If not, write to the Free Software Foundation, Inc.,\n#  59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.\n#\n#  Markus F.X.J. Oberhumer              Laszlo Molnar\n#  <markus@oberhumer.com>               <ezerotven+github@gmail.com>\n#\n\n\nimport getopt, os, re, string, sys\n\n\nclass opts:\n    label_prefix = \".L\"\n    verbose = 0\n    # optimizer flags\n    auto_inline = 1\n    call_rewrite = 1\n    loop_rewrite = 1\n    mov_rewrite = 1\n\n\ninline_map = {\n    \"__aNNalshl\":    [\"M_aNNalshl\", 1],\n    \"__aNahdiff\":    [\"M_aNahdiff\", 1],\n    \"__PIA\":         [\"M_PIA\", 999],\n    \"__PTS\":         [\"M_PTS\", 999],\n    \"__PTC\":         [\"M_PTC\", 999],\n    \"__U4M\":         [\"M_U4M\", 999],\n}\n\n\n# /***********************************************************************\n# // main\n# ************************************************************************/\n\ndef main(argv):\n    shortopts, longopts = \"qv\", [\n        \"label-prefix=\", \"quiet\", \"verbose\"\n    ]\n    xopts, args = getopt.gnu_getopt(argv[1:], shortopts, longopts)\n    for opt, optarg in xopts:\n        if 0: pass\n        elif opt in [\"-q\", \"--quiet\"]: opts.verbose = opts.verbose - 1\n        elif opt in [\"-v\", \"--verbose\"]: opts.verbose = opts.verbose + 1\n        elif opt in [\"--label-prefix\"]: opts.label_prefix = optarg\n        else: assert 0, (\"getopt problem:\", opt, optarg, xopts, args)\n\n    #\n    assert opts.label_prefix\n    assert len(args) == 2\n    ifile = args[0]\n    ofile = args[1]\n    # read ifile\n    lines = open(ifile, \"rb\").readlines()\n    lines = filter(None, map(string.rstrip, lines))\n    #\n    #\n    def inst_has_label(inst):\n        return inst in [\n            \"call\", \"ja\", \"jae\", \"jb\", \"jbe\", \"jcxz\", \"je\",\n            \"jg\", \"jge\", \"jl\", \"jle\", \"jmp\", \"jne\", \"loop\",\n        ]\n    labels = {}\n    def parse_label(inst, args):\n        k = v = None\n        m = re.search(r\"^(.*?)\\b(2|R_386_PC16)\\s+(__\\w+)$\", args)\n        if m and k is None:\n            # external 2-byte label\n            k, v = m.group(3).strip(), [1, 2, None, 0]\n        m = re.search(\"^0x([0-9a-z]+)$\", args)\n        if m and k is None:\n            # local label\n            k, v = m.group(1).strip(), [0, 0, None, 0]\n        m = re.search(\"^([0-9a-z]+)\\s+<\", args)\n        if m and k is None:\n            # local label\n            k, v = m.group(1).strip(), [0, 0, None, 0]\n        assert k and v, (inst, args)\n        v[2] = k                # new name\n        if labels.has_key(k):\n            assert labels[k][:2] == v[:2]\n        return k, v\n    def add_label(k, v):\n        if labels.has_key(k):\n            assert labels[k][:2] == v[:2]\n        else:\n            labels[k] = v\n        labels[k][3] += 1       # usage counter\n        return k\n\n    olines = []\n    def omatch(pos, mlen, m, debug=0):\n        assert len(m) >= abs(mlen)\n        def sgn(x):\n            if x < 0: return -1\n            if x > 0: return  1\n            return 0\n        def match(a, b):\n            if b is None:\n                return False\n            if \"^\" in a or \"*\" in a or \"$\" in a:\n                # regexp\n                return re.search(a, b.lower())\n            else:\n                return a.lower() == b.lower()\n        mpos = []\n        while len(mpos) != abs(mlen):\n            if pos < 0 or pos >= len(olines):\n                return []\n            o = olines[pos]\n            if o[1] != \"*DEL*\":\n                mpos.append(pos)\n            pos += sgn(mlen)\n        if mlen < 0:\n            mpos.reverse()\n        if debug and 1: print mlen, m, [olines[x] for x in mpos]\n        dpos = []\n        i = -abs(mlen)\n        while i < 0:\n            pos = mpos[i]\n            o = olines[pos]\n            assert o[1] != \"*DEL*\"\n            assert len(m[i]) == 2, (i, m)\n            m0 = match(m[i][0], o[1])\n            m1 = match(m[i][1], o[2])\n            if not m0 or not m1:\n                return []\n            dpos.append([pos, m0, m1])\n            i += 1\n        assert len(dpos) == abs(mlen)\n        return dpos\n    def orewrite_inst(i, inst, args, dpos):\n        for pos, m0, m1 in dpos:\n            olines[pos][1] = \"*DEL*\"\n        olines[i][1] = inst\n        olines[i][2] = args\n        olines[i][3] = None\n    def orewrite_call(i, k, v, dpos):\n        for pos, m0, m1 in dpos:\n            olines[pos][1] = \"*DEL*\"\n        v[2] = k\n        olines[i][2] = None\n        olines[i][3] = add_label(k, v)\n\n    #\n    # pass 1\n    func = None\n    for i in range(len(lines)):\n        l = lines[i]\n        m = re.search(r\"^0{8,16}\\s*<(\\.text\\.)?(\\w+)>:\", l)\n        if m:\n            func = re.sub(r\"^_+|_+$\", \"\", m.group(2))\n        if not func in [\"LzmaDecode\"]:\n            continue\n        m = re.search(r\"^(\\s*[0-9a-z]+):\\s+(\\w+)(.*)\", l)\n        if not m:\n            continue\n        label = m.group(1).strip()\n        inst = m.group(2).strip()\n        args = \"\"\n        if m.group(3):\n            args = m.group(3).strip()\n        if not inst_has_label(inst):\n            def hex2int(m): return str(int(m.group(0), 16))\n            args = re.sub(r\"\\b0x[0-9a-fA-F]+\\b\", hex2int, args)\n        #\n        if 1 and inst in [\"movl\",] and re.search(r\"\\b[de]s\\b\", args):\n            # work around a bug in objdump 2.17 (fixed in binutils 2.18)\n            inst = \"mov\"\n        m = re.search(r\"^(.+?)\\b(0|0x0)\\s+(\\w+):\\s+(1|2|R_386_16|R_386_PC16)\\s+(__\\w+)$\", args)\n        if m:\n            # 1 or 2 byte reloc\n            args = m.group(1) + m.group(5)\n        olines.append([label, inst, args, None])\n    #\n    # pass 2\n    for i in range(len(olines)):\n        label, inst, args, args_label = olines[i]\n        #\n        if inst == \"*DEL*\":\n            continue\n        #\n        if opts.call_rewrite and inst in [\"call\"]:\n            k, v = parse_label(inst, args)\n            if v[:2] == [1, 2]:     # external 2-byte\n                if k == \"__aNahdiff\":\n                    s = [\n                        [\"push\", \"word ptr [bp+8]\"],\n                        [\"push\", \"word ptr [bp+6]\"],\n                        [\"push\", r\"word ptr \\[bp([+-](\\d+))\\]$\"],\n                        [\"push\", r\"word ptr \\[bp([+-](\\d+))\\]$\"],\n                    ]\n                    dpos = omatch(i-1, -4, s)\n                    if dpos:\n                        orewrite_inst(i, \"*DEL*\", \"\", dpos)\n                        continue\n                if k in [\"__LMUL\", \"__U4M\",]:\n                    s1 = [\n                        [\"mov\",  \"bx,768\"],     # 0x300\n                        [\"xor\",  \"cx,cx\"],\n                    ]\n                    s2 = [\n                        [\"shl\",  \"ax,1\"],\n                        [\"rcl\",  \"dx,1\"],\n                    ]\n                    dpos1 = omatch(i-1, -2, s1)\n                    dpos2 = omatch(i+1,  2, s2)\n                    if dpos1 and dpos2:\n                        orewrite_inst(i, \"M_U4M_dxax_0x0600\", \"\", dpos1 + dpos2)\n                        continue\n                    s = [\n                        [\"mov\",  \"bx,word ptr [bx]\"],\n                        [\"xor\",  \"cx,cx\"],\n                    ]\n                    dpos = omatch(i-1, -2, s, debug=0)\n                    if 0 and dpos:\n                        orewrite_inst(i, \"M_U4M_dxax_00bx_ptr\", \"\", dpos)\n                        continue\n                    dpos = omatch(i-1, -1, s)\n                    if dpos:\n                        orewrite_inst(i, \"M_U4M_dxax_00bx\", \"\", dpos)\n                        continue\n                if k == \"__PIA\":\n                    s = [\n                        [\"mov\",  \"bx,1\"],\n                        [\"xor\",  \"cx,cx\"],\n                    ]\n                    dpos = omatch(i-1, -2, s)\n                    if dpos:\n                        orewrite_inst(i, \"M_PIA1\", \"\", dpos)\n                        continue\n                if k == \"__PTC\":\n                    s = [\n                        [\"jne\",  \"(.*)\"],\n                    ]\n                    dpos = omatch(i+1, 1, s)\n                    if dpos:\n                        olines[i][1] = \"M_PTC_JNE\"\n                        k, v = parse_label(\"jne\", dpos[0][2].group(1))\n                        orewrite_call(i, k, v, dpos)\n                        continue\n        if opts.loop_rewrite and inst in [\"loop\"]:\n            s = [\n                [\"mov\",  r\"^c[lx],11$\"],\n                [\"shr\",  \"dx,1\"],\n                [\"rcr\",  \"ax,1\"],\n            ]\n            dpos = omatch(i-1, -3, s)\n            if dpos:\n                orewrite_inst(i, \"M_shrd_11\", \"\", dpos)\n                continue\n            s = [\n                [\"mov\",  r\"^c[lx],8$\"],\n                [\"shl\",  \"ax,1\"],\n                [\"rcl\",  \"dx,1\"],\n            ]\n            dpos = omatch(i-1, -3, s)\n            if dpos:\n                orewrite_inst(i, \"M_shld_8\", \"\", dpos)\n                continue\n            s1 = [\n                [\"mov\",  r\"^c[lx],8$\"],\n                [\"shl\",  \"si,1\"],\n                [\"rcl\",  \"di,1\"],\n            ]\n            s2 = [\n                [\"les\",  r\"^bx,dword ptr \\[bp([+-](\\d+))\\]$\"],\n            ]\n            dpos1 = omatch(i-1, -3, s1)\n            dpos2 = omatch(i+1,  1, s2)\n            if 1 and dpos1 and dpos2:\n                # bx and cx are free for use\n                orewrite_inst(i, \"M_shld_disi_8_bxcx\", \"\", dpos1)\n                continue\n            s1 = [\n                [\"mov\",  \"ax,si\"],\n                [\"mov\",  r\"^c[lx],8$\"],\n                [\"shl\",  \"ax,1\"],\n                [\"rcl\",  \"di,1\"],\n            ]\n            s2 = [\n                [\"mov\",  \"si,ax\"],\n                [\"les\",  r\"^bx,dword ptr \\[bp([+-](\\d+))\\]$\"],\n            ]\n            dpos1 = omatch(i-1, -4, s1)\n            dpos2 = omatch(i+1,  2, s2)\n            if 1 and dpos1 and dpos2:\n                # bx and cx are free for use\n                orewrite_inst(i, \"M_shld_diax_8_bxcx\", \"\", dpos1[-3:])\n                continue\n            s1 = [\n                [\"mov\",  r\"^c[lx],8$\"],\n                [\"shl\",  r\"^word ptr \\[bp([+-](\\d+))\\],1$\"],\n                [\"rcl\",  r\"^word ptr \\[bp([+-](\\d+))\\],1$\"],\n            ]\n            s2 = [\n                [\"mov\",  r\"^dx,word ptr\"],\n                [\"mov\",  r\"^ax,word ptr\"],\n            ]\n            s3 = [\n                [\"mov\",  r\"^ax,word ptr\"],\n                [\"mov\",  r\"^dx,word ptr\"],\n            ]\n            dpos1 = omatch(i-1, -3, s1)\n            dpos2 = omatch(i+1,  2, s2)\n            dpos3 = omatch(i+1,  2, s3)\n            if dpos1 and (dpos2 or dos3):\n                bp_dx, bp_ax = dpos1[-1][2].group(1), dpos1[-2][2].group(1)\n                m = \"M_shld_8_bp %s %s\" % (bp_dx, bp_ax)\n                orewrite_inst(i, m, \"\", dpos1)\n                continue\n            s1 = [\n                [\"mov\",  r\"^word ptr \\[bp([+-](\\d+))\\],si$\"],\n                [\"mov\",  r\"^word ptr \\[bp([+-](\\d+))\\],di$\"],\n                [\"mov\",  r\"^c[lx],11$\"],\n                [\"shr\",  r\"^word ptr \\[bp([+-](\\d+))\\],1$\"],\n                [\"rcr\",  r\"^word ptr \\[bp([+-](\\d+))\\],1$\"],\n            ]\n            s2 = [\n                [\"mov\",  r\"^bx,word ptr\"],\n                [\"mov\",  r\"^bx,word ptr\"],\n                [\"mov\",  r\"^ax,word ptr \\[bp([+-](\\d+))\\]$\"],\n                [\"mov\",  r\"^dx,word ptr \\[bp([+-](\\d+))\\]$\"],\n            ]\n            dpos1 = omatch(i-1, -5, s1)\n            dpos2 = omatch(i+1,  4, s2)\n            if dpos1 and dpos2:\n                bp_dx, bp_ax = dpos1[-2][2].group(1), dpos1[-1][2].group(1)\n                bp_di, bp_si = dpos1[-4][2].group(1), dpos1[-5][2].group(1)\n                assert bp_dx == dpos2[-1][2].group(1)\n                assert bp_ax == dpos2[-2][2].group(1)\n                assert bp_dx == bp_di\n                assert bp_ax == bp_si\n                m = \"M_shrd_11_disi_bp %s %s\" % (bp_dx, bp_ax)\n                orewrite_inst(i, m, \"\", dpos1 + dpos2[-2:])\n                continue\n        if opts.mov_rewrite and inst in [\"mov\"]:\n            s = [\n                [\"mov\",  r\"^al,byte ptr \\[(di|si)\\]$\"],\n                [\"xor\",  r\"^ah,ah$\"],\n                [\"mov\",  r\"^word ptr \\[bp([+-](\\d+))\\],ax$\"],\n                [\"mov\",  r\"^word ptr \\[bp([+-](\\d+))\\],(0|1)$\"],\n                [\"mov\",  r\"^word ptr \\[bp([+-](\\d+))\\],(0|1)$\"],\n                [\"mov\",  r\"^word ptr \\[bp([+-](\\d+))\\],(0|1)$\"],\n                [\"mov\",  r\"^word ptr \\[bp([+-](\\d+))\\],(0|1)$\"],\n                [\"mov\",  r\"^word ptr \\[bp([+-](\\d+))\\],(0|1)$\"],\n                [\"mov\",  r\"^word ptr \\[bp([+-](\\d+))\\],(0|1)$\"],\n                [\"mov\",  r\"^word ptr \\[bp([+-](\\d+))\\],(0|1)$\"],\n                [\"mov\",  r\"^word ptr \\[bp([+-](\\d+))\\],(0|1)$\"],\n                [\"mov\",  r\"^word ptr \\[bp([+-](\\d+))\\],(0|1)$\"],\n                [\"mov\",  r\"^bx,word ptr \\[bp([+-](\\d+))\\]$\"],\n                [\"mov\",  r\"^word ptr \\[bx\\],(0)$\"],\n                [\"mov\",  r\"^word ptr \\[bx([+-](\\d+))\\],(0)$\"],\n                [\"mov\",  r\"^bx,word ptr \\[bp([+-](\\d+))\\]$\"],\n                [\"mov\",  r\"^word ptr \\[bx\\],(0)$\"],\n                [\"mov\",  r\"^word ptr \\[bx([+-](\\d+))\\],(0)$\"],\n                [\"mov\",  r\"^dl,byte ptr \\[(di|si)([+-](\\d+))\\]$\"],\n                [\"xor\",  r\"^dh,dh$\"],\n                [\"mov\",  r\"^cx,ax$\"],\n            ]\n            dpos = omatch(i, -len(s), s)\n            if dpos:\n                ipos, n_del = 16, 0\n                pos0 = dpos[0][0]\n                r = []\n                for pos, m0, m1 in dpos:\n                    assert pos == pos0 + len(r)\n                    r.append([olines[pos][1], olines[pos][2]])\n                z0 = r[0]; z1 = r[2]; del r[:3]\n                r.insert(0, [\"xor\", \"ax,ax\"])\n                r.insert(ipos, z0); r.insert(ipos + 1, z1)\n                i = 0\n                while i < len(r):\n                    inst, args = r[i]\n                    if inst == \"mov\" and args.endswith(\",0\"):\n                        r[i] = [inst, args[:-1] + \"ax\"]\n                    elif inst == \"mov\" and args.endswith(\",1\"):\n                        assert i < ipos\n                        r.insert(ipos, [inst, args[:-1] + \"ax\"])\n                        del r[i]; i -= 1; n_del += 1\n                    i += 1\n                assert len(r) == len(dpos)\n                pos = pos0\n                for inst, args in r:\n                    ##print pos-pos0, inst, args\n                    olines[pos][1] = inst\n                    olines[pos][2] = args\n                    pos += 1\n                if n_del:\n                    olines.insert(pos0 + ipos - n_del, [None, \"inc\", \"ax\", None])\n                continue\n        #\n        if inst_has_label(inst):\n            k, v = parse_label(inst, args)\n            olines[i][2] = None\n            olines[i][3] = add_label(k, v)\n    #\n    # pass 3\n    digits, i = 1, len(labels)\n    while i >= 10:\n        digits += 1\n        i /= 10\n    format = \"%s0%dd\" % (\"%\", digits)\n    counter = 0\n    for i in range(len(olines)):\n        label, inst, args, args_label = olines[i]\n        # rewrite local labels\n        v = labels.get(label)\n        if v is not None:\n            assert v[:3] == [0, 0, label], (label, v)\n            v[2] = opts.label_prefix + format % counter\n            counter += 1\n        # handle inlining\n        if opts.auto_inline and inst == \"call\":\n            v = labels[args_label]\n            if v[:2] == [1, 2]:     # external 2-byte\n                x = inline_map.get(v[2])\n                if x and v[3] <= x[1]:       # max. number of calls\n                    ##print \"inline\", v, x\n                    if x:\n                        olines[i][1] = x[0]\n                        olines[i][2] = \"/* inlined */\"\n                        olines[i][2] = \"\"\n                        olines[i][3] = None\n    #\n    # write ofile\n    ofp = open(ofile, \"wb\")\n    current_label = None\n    for label, inst, args, args_label in olines:\n        if labels.has_key(label):\n            current_label = labels[label][2]\n            if opts.verbose:\n                ofp.write(\"%s: /* %d */\\n\" % (labels[label][2], labels[label][3]))\n            else:\n                ofp.write(\"%s:\\n\" % (labels[label][2]))\n        if inst == \"*DEL*\":\n            continue\n        if 1 and current_label in [\".Lf122\", \".Lf123\", \".Lf124\", \".Ls122\", \".Ls123\", \".Ls124\"]:\n            continue\n        if args_label:\n            if opts.verbose:\n                args = \"%s /* %d */\" % (labels[args_label][2], labels[args_label][3])\n            else:\n                args = labels[args_label][2]\n        if 0:\n            # remove unneeded \"byte/word/dword ptr\"\n            # [this works, but disabled for now as we gain nothing]\n            if re.search(r\"\\bbyte ptr \", args):\n                if re.search(r\"^[abcd][hl],\", args): args = args.replace(\"byte ptr \", \"\")\n                if re.search(r\",[abcd][hl]$\", args): args = args.replace(\"byte ptr \", \"\")\n            if re.search(r\"\\bword ptr \", args):\n                if re.search(r\"^[abcds][ix],\", args): args = args.replace(\"word ptr \", \"\")\n                if re.search(r\",[abcds][ix]$\", args): args = args.replace(\"word ptr \", \"\")\n            if re.search(r\"\\bdword ptr \", args):\n                if re.search(r\"^[abcd][x],\",  args): args = args.replace(\"dword ptr \", \"\")\n        l = \"%8s%-7s %s\" % (\"\", inst, args)\n        ofp.write(l.rstrip() + \"\\n\")\n    ofp.close()\n    ##print olines\n\n\nif __name__ == \"__main__\":\n    sys.exit(main(sys.argv))\n\n","size_bytes":18062},"src/stub/src/arch/i086/l_test.c":{"content":"/* l_test.c --\n\n   This file is part of the UPX executable compressor.\n\n   Copyright (C) 2007-2025 Markus Franz Xaver Johannes Oberhumer\n   All Rights Reserved.\n\n   UPX and the UCL library are free software; you can redistribute them\n   and/or modify them under the terms of the GNU General Public License as\n   published by the Free Software Foundation; either version 2 of\n   the License, or (at your option) any later version.\n\n   This program is distributed in the hope that it will be useful,\n   but WITHOUT ANY WARRANTY; without even the implied warranty of\n   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n   GNU General Public License for more details.\n\n   You should have received a copy of the GNU General Public License\n   along with this program; see the file COPYING.\n   If not, write to the Free Software Foundation, Inc.,\n   59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.\n\n   Markus F.X.J. Oberhumer\n   <markus@oberhumer.com>\n */\n\n\n#include \"stub/src/c/lzma_d_c.c\"\n\n#if (ACC_ARCH_I086)\n#define bytep unsigned char __huge *\ntypedef unsigned long   uint32_t;\n#else\n#define bytep unsigned char *\ntypedef unsigned int    uint32_t;\n#endif\n\n\n#if (ACC_OS_DOS16)\n#  if (ACC_CC_BORLANDC || ACC_CC_TURBOC)\n     int __cdecl printf(const char *, ...);\n     void * __cdecl malloc(unsigned);\n     void __far * __cdecl farmalloc(unsigned long);\n#    define acc_halloc(x)   ((void __huge *) farmalloc(x))\n#  elif (ACC_CC_DMC || ACC_CC_MSC)\n#    include <stdio.h>\n#    include <malloc.h>\n#    define acc_halloc(x)   _halloc(x,1)\n#  elif (ACC_CC_WATCOMC)\n     int __watcall printf(const char *, ...);\n     void * __watcall malloc(unsigned);\n     void __huge * __watcall halloc(long, unsigned);\n#    define acc_halloc(x)   halloc(x,1)\n#  else\n#  endif\n#else\n#  define printf            __builtin_printf\n#  define malloc(x)         __builtin_malloc(x)\n#  define acc_halloc(x)     malloc(x)\n#endif\n\n\n/*************************************************************************\n//\n**************************************************************************/\n\n/*\n>>> import pylzma; d=\"\\1\" + \"\\0\"*131070 + \"\\2\"; print len(d)\n>>> c=pylzma.compress(d, eos=0)[5:]; print len(c), map(ord, c)\n*/\nstatic const unsigned char c_data[92] = {\n0, 0, 128, 65, 72, 1, 140, 46, 188, 80, 161, 51, 135, 75, 212, 2, 20, 181, 241, 145, 230, 34, 107, 72, 201, 86, 118, 176, 70, 120, 214, 184, 247, 212, 250, 132, 59, 160, 44, 112, 185, 177, 245, 126, 103, 190, 14, 145, 73, 36, 148, 246, 166, 58, 41, 192, 68, 167, 144, 98, 122, 42, 61, 195, 135, 248, 98, 136, 254, 191, 96, 21, 192, 75, 86, 63, 228, 231, 15, 70, 52, 239, 169, 194, 249, 109, 126, 11, 123, 48, 0, 0\n};\n\n\n\nint main()\n{\n    uint32_t i;\n    int r;\n    uint32_t src_len = sizeof(c_data);\n    uint32_t dst_len = 131072ul;\n    uint32_t src_out = 0;\n    uint32_t dst_out = 0;\n    const bytep src;\n    bytep dst;\n    CLzmaDecoderState *s;\n\n    printf(\"Decompress %lu %lu\\n\", (long)src_len, (long)dst_len);\n    s = (CLzmaDecoderState *) malloc(32768u);\n    src = c_data;\n    dst = (bytep) acc_halloc(dst_len);\n    if (!s || !dst) {\n        printf(\"ERROR: Out of memory!\\n\");\n        return 1;\n    }\n    for (i = 0; i != dst_len; ++i)\n        dst[i] = 255;\n\n    s->Properties.lc = 3; s->Properties.lp = 0; s->Properties.pb = 2;\n    r = LzmaDecode(s, src, src_len, &src_out, dst, dst_len, &dst_out);\n\n    if (r != 0 || src_out != src_len || dst_out != dst_len)\n    {\n        printf(\"ERROR: Decompression error %d %lu %lu\\n\", r, (long)src_out, (long)dst_out);\n        return 1;\n    }\n\n    i = 0;\n    if (dst[i] != 1)\n        goto data_error;\n    while (++i != dst_len - 1)\n        if (dst[i] != 0)\n            goto data_error;\n    if (dst[i] != 2)\n        goto data_error;\n\n    printf(\"Decompression test passed. All done.\\n\");\n    return 0;\n\ndata_error:\n    printf(\"ERROR: Decompression data error at offset %lu.\\n\", (long)i);\n    return 1;\n}\n\n\n/* vim:set ts=4 et: */\n","size_bytes":3919},"src/stub/src/arch/i086/wdis2gas.py":{"content":"#! /usr/bin/env python2\n## vim:set ts=4 sw=4 et: -*- coding: utf-8 -*-\n#\n#  wdis2gas.py --\n#\n#  This file is part of the UPX executable compressor.\n#\n#  Copyright (C) 1996-2025 Markus Franz Xaver Johannes Oberhumer\n#  All Rights Reserved.\n#\n#  UPX and the UCL library are free software; you can redistribute them\n#  and/or modify them under the terms of the GNU General Public License as\n#  published by the Free Software Foundation; either version 2 of\n#  the License, or (at your option) any later version.\n#\n#  This program is distributed in the hope that it will be useful,\n#  but WITHOUT ANY WARRANTY; without even the implied warranty of\n#  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n#  GNU General Public License for more details.\n#\n#  You should have received a copy of the GNU General Public License\n#  along with this program; see the file COPYING.\n#  If not, write to the Free Software Foundation, Inc.,\n#  59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.\n#\n#  Markus F.X.J. Oberhumer              Laszlo Molnar\n#  <markus@oberhumer.com>               <ezerotven+github@gmail.com>\n#\n\n\nimport getopt, os, re, string, sys\n\n\nclass opts:\n    arch = \"i086\"\n    label_prefix = \".L\"\n    verbose = 0\n\n\n# /***********************************************************************\n# // main\n# ************************************************************************/\n\ndef main(argv):\n    shortopts, longopts = \"qv\", [\n        \"arch\", \"label-prefix=\", \"quiet\", \"verbose\"\n    ]\n    xopts, args = getopt.gnu_getopt(argv[1:], shortopts, longopts)\n    for opt, optarg in xopts:\n        if 0: pass\n        elif opt in [\"-q\", \"--quiet\"]: opts.verbose = opts.verbose - 1\n        elif opt in [\"-v\", \"--verbose\"]: opts.verbose = opts.verbose + 1\n        elif opt in [\"--arch\"]: opts.arch = optarg\n        elif opt in [\"--label-prefix\"]: opts.label_prefix = optarg\n        else: assert 0, (\"getopt problem:\", opt, optarg, xopts, args)\n\n    #\n    assert len(args) == 2\n    ifile = args[0]\n    ofile = args[1]\n    # read ifile\n    lines = open(ifile, \"rb\").readlines()\n    lines = map(string.rstrip, lines)\n    #\n    section = None\n    func = None\n    olines = []\n    for i in range(len(lines)):\n        l = lines[i]\n        if not l: continue\n        m = re.search(r\"^No disassembly errors\", l)\n        if m: continue\n        m = re.search(r\"^Module:\", l)\n        if m: continue\n        m = re.search(r\"^GROUP:\", l)\n        if m: continue\n        m = re.search(r\"^(BSS|Routine) Size:\", l)\n        if m: continue\n        m = re.search(r\"^Segment:\\s+(.+)\\s+([0-9a-fA-F]+)\\s+bytes$\", l)\n        if m:\n            s = re.split(r\"\\s+\", m.group(1))\n            assert len(s) == 3, (i, l, s, m.groups())\n            section = s\n            func = None\n            continue\n        m = re.search(r\"^Comdat:\\s+(.+)\\s+SEGMENT NONE '(\\w+)'\\s+([0-9a-fA-F]+)\\s+bytes$\", l)\n        if m:\n            section = [m.group(2)]\n            assert section[0].endswith(\"_TEXT\"), (i, l, section)\n            func = re.sub(r\"^[_@]+|[_@]+$\", \"\", m.group(1))\n            olines.append(\".section .text.\" + func)\n            continue\n        assert section, (i, l)\n        m = re.search(r\"^0000\\s+(\\w+):$\", l)\n        if m:\n            assert section[0].endswith(\"_TEXT\"), (i, l, section)\n            func = re.sub(r\"^[_@]+|[_@]+$\", \"\", m.group(1))\n            olines.append(\".section .text.\" + func)\n            continue\n        assert func, (i, l, section)\n        m = re.search(r\"^[0-9a-fA-F]{4}\\s+L\\$(\\d+):$\", l)\n        if m:\n            olines.append(opts.label_prefix + m.group(1) + \":\")\n            continue\n        m = re.search(r\"^[0-9a-fA-F]{4}    (([0-9a-fA-F]{2} )+)\\s+(.+)$\", l)\n        assert m, (i, l)\n        if m.group(3).startswith(\"call\"):\n            s = re.split(r\"\\s+\", m.group(3))\n            assert len(s) == 2, (i, l, s, m.groups())\n            f = re.sub(r\"^[@]+|[@]+$\", \"\", s[1])\n            olines.append(\"  call \" + f)\n        elif 1:\n            s = m.group(3).strip()\n            s = re.sub(r\"L\\$(\\d+)\", opts.label_prefix + r\"\\g<1>\", s)\n            olines.append(\"  \" + s)\n        else:\n            s = re.split(r\"\\s+\", m.group(1).strip())\n            assert 1 <= len(s) <= 5, (i, l, s, m.groups())\n            s = [\"0x\" + x for x in s]\n            olines.append(\"  .byte \" + \",\".join(s))\n\n\n    # write ofile\n    ofp = open(ofile, \"wb\")\n    ofp.write(\".code16\\n\")\n    ofp.write(\".intel_syntax noprefix\\n\")\n    if opts.arch in [\"i086\", \"8086\", \"i8086\"]:\n        ofp.write(\".arch i8086, jumps\\n\")\n    elif opts.arch in [\"i286\"]:\n        ofp.write(\".arch i286, jumps\\n\")\n    else:\n        assert 0, (\"invalid arch\", opts.arch)\n    if 0:\n        for sym in [\"__AHSHIFT\", \"__AHINCR\", \"__LMUL\", \"__aNahdiff\"]:\n            ofp.write(\".extern %s\\n\" % (sym))\n            ofp.write(\".type %s,@function\\n\" % (sym))\n            ofp.write(\".size %s,2\\n\" % (sym))\n    for l in olines:\n        ofp.write(l.rstrip() + \"\\n\")\n    ofp.close()\n    ##print olines\n\n\nif __name__ == \"__main__\":\n    sys.exit(main(sys.argv))\n\n","size_bytes":5021},"run_dev.sh":{"content":"#!/bin/bash\n\n# UPX Development Environment\n# Script untuk setup development environment untuk UPX\n\necho \"===================================\"\necho \"  UPX Development Environment\"\necho \"===================================\"\necho\n\n# Periksa apakah dependencies sudah lengkap\necho \"Checking UPX dependencies...\"\n\nif [ -d \"vendor/ucl/src\" ]; then\n    echo \" UCL library: OK\"\nelse\n    echo \" UCL library: MISSING\"\nfi\n\nif [ -d \"vendor/zlib\" ]; then\n    echo \" zlib library: OK\"\nelse\n    echo \" zlib library: MISSING\"\nfi\n\nif [ -d \"vendor/doctest\" ]; then\n    echo \" doctest: OK\"\nelse\n    echo \" doctest: MISSING\"\nfi\n\nif [ -d \"vendor/lzma-sdk\" ]; then\n    echo \" LZMA SDK: OK\"\nelse\n    echo \" LZMA SDK: MISSING\"\nfi\n\necho\necho \"Build tools available:\"\nwhich cmake > /dev/null && echo \" CMake: $(cmake --version | head -n1)\" || echo \" CMake: NOT FOUND\"\nwhich make > /dev/null && echo \" Make: $(make --version | head -n1)\" || echo \" Make: NOT FOUND\"\nwhich clang++ > /dev/null && echo \" C++ Compiler: $(clang++ --version | head -n1)\" || echo \" C++ Compiler: NOT FOUND\"\n\necho\necho \"Project struktur:\"\necho \"- src/          : Source code UPX utama\"\necho \"- vendor/       : Dependencies (UCL, zlib, dll)\"\necho \"- build/        : Build directory\"\necho \"- doc/          : Dokumentasi\"\necho\n\necho \"Untuk memulai development:\"\necho \"1. Modifikasi source code di direktori src/\"\necho \"2. Build menggunakan: cd build/release && cmake --build .\"\necho \"3. Test binary yang dihasilkan: ./build/release/upx --help\"\necho\n\necho \"Catatan:\"\necho \"- Proyek ini adalah UPX - Ultimate Packer for eXecutables\"\necho \"- Dependencies sudah didownload secara manual\"\necho \"- Beberapa build configuration mungkin perlu disesuaikan\"\necho\n\necho \"Happy coding! \"","size_bytes":1766},".ccls-cache/@home@runner@workspace/src@work.cpp":{"content":"/* work.cpp -- main work driver\n\n   This file is part of the Resize executable compressor.\n\n   Copyright (C) 2025 WHO-AM-I-404\n   Based on UPX - Ultimate Packer for eXecutables\n   Copyright (C) 1996-2025 Markus Franz Xaver Johannes Oberhumer\n   Copyright (C) 1996-2025 Laszlo Molnar\n   All Rights Reserved.\n\n   Resize and the UCL library are free software; you can redistribute them\n   and/or modify them under the terms of the GNU General Public License as\n   published by the Free Software Foundation; either version 2 of\n   the License, or (at your option) any later version.\n\n   This program is distributed in the hope that it will be useful,\n   but WITHOUT ANY WARRANTY; without even the implied warranty of\n   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n   GNU General Public License for more details.\n\n   You should have received a copy of the GNU General Public License\n   along with this program; see the file COPYING.\n   If not, write to the Free Software Foundation, Inc.,\n   59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.\n\n   WHO-AM-I-404 <who-am-i-404@proton.me>\n   Based on original work by:\n   Markus F.X.J. Oberhumer <markus@oberhumer.com>\n   Laszlo Molnar <ezerotven+github@gmail.com>\n */\n\n// This file implements the central loop, and it uses class PackMaster to\n// dispatch. PackMaster by itself will instantiate a concrete subclass of\n// class PackerBase which then does the actual work; search for \"HERE\".\n// And see p_com.cpp for a simple executable format.\n//\n// Additionally this file also has the burden to deal with all those pesky\n// low-level file handling issues.\n\n#define WANT_WINDOWS_LEAN_H 1 // _get_osfhandle, GetFileTime, SetFileTime\n#include \"util/system_headers.h\"\n#if USE_UTIMENSAT\n#include <sys/types.h>\n#include <fcntl.h>\n#include <sys/stat.h>\n#endif\n#include \"conf.h\"\n#include \"file.h\"\n#include \"packmast.h\"\n#include \"ui.h\"\n#include \"util/membuffer.h\"\n\n#if USE_UTIMENSAT && defined(AT_FDCWD)\n#elif defined(_WIN32) || defined(__CYGWIN__)\n#define USE_SETFILETIME 1\n#elif (ACC_OS_DOS32) && defined(__DJGPP__)\n#define USE_FTIME 1\n#elif ((ACC_OS_WIN32 || ACC_OS_WIN64) && (ACC_CC_INTELC || ACC_CC_MSC))\n#define USE__FUTIME 1\n#elif HAVE_UTIME\n#define USE_UTIME 1\n#endif\n\n#if !defined(SH_DENYRW)\n#define SH_DENYRW (-1)\n#endif\n#if !defined(SH_DENYWR)\n#define SH_DENYWR (-1)\n#endif\n\n/*************************************************************************\n// file util\n**************************************************************************/\n\nnamespace {\n\nstruct XStat final {\n    struct stat st;\n#if USE_SETFILETIME\n    FILETIME ft_atime;\n    FILETIME ft_mtime;\n#elif USE_FTIME\n    struct ftime ft_ftime;\n#endif\n};\n\n// ignore errors in some cases and silence __attribute__((__warn_unused_result__))\n#define IGNORE_ERROR(var) ACC_UNUSED(var)\n\nenum OpenMode { RO_MUST_EXIST, WO_MUST_EXIST_TRUNCATE, WO_MUST_CREATE, WO_CREATE_OR_TRUNCATE };\n\nstatic constexpr int get_open_flags(OpenMode om) noexcept {\n    constexpr int wo_flags = O_WRONLY | O_BINARY;\n    if (om == WO_MUST_EXIST_TRUNCATE)\n        return wo_flags | O_TRUNC; // will cause an error if file does not exist\n    if (om == WO_MUST_CREATE)\n        return wo_flags | O_CREAT | O_EXCL; // will cause an error if file already exists\n    if (om == WO_CREATE_OR_TRUNCATE)\n        return wo_flags | O_CREAT | O_TRUNC; // create if not exists, otherwise truncate\n    // RO_MUST_EXIST\n    return O_RDONLY | O_BINARY; // will cause an error if file does not exist\n}\n\n// set file time of an open file\nstatic void set_fd_timestamp(int fd, const XStat *xst) noexcept {\n#if USE_SETFILETIME\n    BOOL r = SetFileTime((HANDLE) _get_osfhandle(fd), nullptr, &xst->ft_atime, &xst->ft_mtime);\n    IGNORE_ERROR(r);\n#elif USE_FTIME\n    struct ftime ft_ftime = xst->ft_ftime; // djgpp2 libc bug/feature: not const, so use a copy\n    int r = setftime(fd, &ft_ftime);\n    IGNORE_ERROR(r);\n#elif USE__FUTIME\n    struct _utimbuf u = {};\n    u.actime = xst->st.st_atime;\n    u.modtime = xst->st.st_mtime;\n    int r = _futime(fd, &u);\n    IGNORE_ERROR(r);\n#endif\n    // maybe unused\n    UNUSED(fd);\n    UNUSED(xst);\n}\n\nstatic void copy_file_contents(const char *iname, const char *oname, OpenMode om,\n                               const XStat *oname_timestamp) may_throw {\n    InputFile fi;\n    fi.sopen(iname, get_open_flags(RO_MUST_EXIST), SH_DENYWR);\n    fi.seek(0, SEEK_SET);\n    int flags = get_open_flags(om);\n    int shmode = SH_DENYWR;\n    int omode = 0600; // affected by umask; ignored unless O_CREAT\n    OutputFile fo;\n    fo.sopen(oname, flags, shmode, omode);\n    fo.seek(0, SEEK_SET);\n    MemBuffer buf(256 * 1024 * 1024);\n    for (;;) {\n        size_t bytes = fi.read(buf, buf.getSize());\n        if (bytes == 0)\n            break;\n        fo.write(buf, bytes);\n    }\n    if (oname_timestamp != nullptr)\n        set_fd_timestamp(fo.getFd(), oname_timestamp);\n    fi.closex();\n    fo.closex();\n}\n\nstatic void copy_file_attributes(const XStat *xst, const char *oname, bool preserve_mode,\n                                 bool preserve_ownership, bool preserve_timestamp) noexcept {\n    const struct stat *const st = &xst->st;\n    // copy time stamp\n    if (preserve_timestamp) {\n#if USE_UTIMENSAT && defined(AT_FDCWD)\n        struct timespec times[2] = {};\n#if HAVE_STRUCT_STAT_ST_MTIMESPEC_TV_NSEC\n        // macOS\n        times[0] = st->st_atimespec;\n        times[1] = st->st_mtimespec;\n#else\n        // POSIX.1-2008\n        times[0] = st->st_atim;\n        times[1] = st->st_mtim;\n#endif\n        int r = utimensat(AT_FDCWD, oname, &times[0], 0);\n        IGNORE_ERROR(r);\n#elif USE_UTIME\n        struct utimbuf u = {};\n        u.actime = st->st_atime;\n        u.modtime = st->st_mtime;\n        int r = utime(oname, &u);\n        IGNORE_ERROR(r);\n#endif\n    }\n#if HAVE_CHOWN\n    // copy the group ownership\n    if (preserve_ownership) {\n        int r = chown(oname, -1, st->st_gid);\n        IGNORE_ERROR(r);\n    }\n#endif\n#if HAVE_CHMOD\n    // copy permissions\n    if (preserve_mode) {\n        int r = chmod(oname, st->st_mode);\n        IGNORE_ERROR(r);\n    }\n#endif\n#if HAVE_CHOWN\n    // copy the user ownership\n    if (preserve_ownership) {\n        int r = chown(oname, st->st_uid, -1);\n        IGNORE_ERROR(r);\n    }\n#endif\n    // maybe unused\n    UNUSED(xst);\n    UNUSED(st);\n    UNUSED(oname);\n    UNUSED(preserve_mode);\n    UNUSED(preserve_ownership);\n    UNUSED(preserve_timestamp);\n}\n\n} // namespace\n\n/*************************************************************************\n// process one file\n**************************************************************************/\n\nvoid do_one_file(const char *const iname, char *const oname) may_throw {\n    oname[0] = 0; // make empty\n\n    // check iname stat\n    XStat xst = {};\n    struct stat &st = xst.st;\n#if HAVE_LSTAT\n    int rr = lstat(iname, &st);\n#else\n    int rr = stat(iname, &st);\n#endif\n    if (rr != 0) {\n        if (errno == ENOENT)\n            throw FileNotFoundException(iname, errno);\n        else\n            throwIOException(iname, errno);\n    }\n#if HAVE_LSTAT\n    if (S_ISLNK(st.st_mode))\n        throwIOException(\"is a symlink -- skipped\");\n#endif\n    if (S_ISDIR(st.st_mode))\n        throwIOException(\"is a directory -- skipped\");\n    if (!(S_ISREG(st.st_mode)))\n        throwIOException(\"not a regular file -- skipped\");\n#if defined(__unix__)\n    // no special bits may be set\n    if ((st.st_mode & (S_ISUID | S_ISGID | S_ISVTX)) != 0)\n        throwIOException(\"file has special permissions -- skipped\");\n#endif\n    if (st.st_size <= 0)\n        throwIOException(\"empty file -- skipped\");\n    if (st.st_size < 512)\n        throwIOException(\"file is too small -- skipped\");\n    if (!mem_size_valid_bytes(st.st_size))\n        throwIOException(\"file is too large -- skipped\");\n    if ((st.st_mode & S_IWUSR) == 0) {\n        bool skip = true;\n        if (opt->output_name)\n            skip = false;\n        else if (opt->to_stdout)\n            skip = false;\n        else if (opt->backup)\n            skip = false;\n        if (skip)\n            throwIOException(\"file is write protected -- skipped\");\n    }\n\n    // open input file\n    InputFile fi;\n    fi.sopen(iname, get_open_flags(RO_MUST_EXIST), SH_DENYWR);\n\n    if (opt->preserve_timestamp) {\n#if USE_SETFILETIME\n        if (GetFileTime((HANDLE) _get_osfhandle(fi.getFd()), nullptr, &xst.ft_atime,\n                        &xst.ft_mtime) == 0)\n            throwIOException(\"cannot determine file timestamp\");\n#elif USE_FTIME\n        if (getftime(fi.getFd(), &xst.ft_ftime) != 0)\n            throwIOException(\"cannot determine file timestamp\");\n#endif\n    }\n\n    // open output file\n    // NOTE: only use \"preserve_link\" if you really need it, e.g. it can fail\n    //   with ETXTBSY and other unexpected errors; renaming files is much safer\n    OutputFile fo;\n    bool preserve_link = opt->preserve_link;\n    bool copy_timestamp_only = false;\n    if (opt->cmd == CMD_COMPRESS || opt->cmd == CMD_DECOMPRESS) {\n        if (opt->to_stdout) {\n            preserve_link = false; // not needed\n            if (!fo.openStdout(1, opt->force ? true : false))\n                throwIOException(\"data not written to a terminal; Use '-f' to force.\");\n        } else {\n            char tname[ACC_FN_PATH_MAX + 1];\n            if (opt->output_name) {\n                strcpy(tname, opt->output_name);\n                if ((opt->force_overwrite || opt->force >= 2) && !preserve_link)\n                    (void) FileBase::unlink_noexcept(tname); // IGNORE_ERROR\n            } else {\n                if (st.st_nlink < 2)\n                    preserve_link = false; // not needed\n                if (!maketempname(tname, sizeof(tname), iname, \".upx\"))\n                    throwIOException(\"could not create a temporary file name\");\n            }\n            int flags = get_open_flags(WO_MUST_CREATE); // don't overwrite files by default\n            if (opt->output_name && preserve_link) {\n                flags = get_open_flags(WO_CREATE_OR_TRUNCATE);\n#if HAVE_LSTAT\n                struct stat ost = {};\n                int r = lstat(tname, &ost);\n                if (r == 0 && S_ISREG(ost.st_mode)) {\n                    preserve_link = ost.st_nlink >= 2;\n                } else if (r == 0 && S_ISLNK(ost.st_mode)) {\n                    // output_name is a symlink (valid or dangling)\n                    (void) FileBase::unlink_noexcept(tname); // IGNORE_ERROR\n                    preserve_link = false;                   // not needed\n                } else {\n                    preserve_link = false; // not needed\n                }\n#endif\n                if (preserve_link) {\n                    flags = get_open_flags(WO_MUST_EXIST_TRUNCATE);\n                    copy_timestamp_only = true;\n                }\n            } else if (opt->force_overwrite || opt->force) {\n                flags = get_open_flags(WO_CREATE_OR_TRUNCATE);\n            }\n            int shmode = SH_DENYWR;\n#if (ACC_ARCH_M68K && ACC_OS_TOS && ACC_CC_GNUC) && defined(__MINT__)\n            // TODO later: check current mintlib if this hack is still needed\n            flags |= O_TRUNC;\n            shmode = O_DENYRW;\n#endif\n            // cannot rely on open() because of umask\n            // int omode = st.st_mode | 0600;\n            int omode = opt->preserve_mode ? 0600 : 0666; // affected by umask; only for O_CREAT\n            fo.sopen(tname, flags, shmode, omode);\n            // open succeeded - now set oname[]\n            strcpy(oname, tname);\n        }\n    }\n\n    // handle command - actual work starts HERE\n    PackMaster pm(&fi, opt);\n    if (opt->cmd == CMD_COMPRESS)\n        pm.pack(&fo);\n    else if (opt->cmd == CMD_DECOMPRESS)\n        pm.unpack(&fo);\n    else if (opt->cmd == CMD_TEST)\n        pm.test();\n    else if (opt->cmd == CMD_LIST)\n        pm.list();\n    else if (opt->cmd == CMD_FILEINFO)\n        pm.fileInfo();\n    else\n        throwInternalError(\"invalid command\");\n\n    // copy time stamp\n    if (oname[0] && opt->preserve_timestamp && fo.isOpen())\n        set_fd_timestamp(fo.getFd(), &xst);\n\n    // close files\n    fi.closex();\n    fo.closex();\n\n    // rename or copy files\n    if (oname[0] && !opt->output_name) {\n        // both iname and oname do exist; rename oname to iname\n        if (opt->backup) {\n            char bakname[ACC_FN_PATH_MAX + 1];\n            if (!makebakname(bakname, sizeof(bakname), iname))\n                throwIOException(\"could not create a backup file name\");\n            if (preserve_link) {\n                copy_file_contents(iname, bakname, WO_MUST_CREATE, &xst);\n                copy_file_attributes(&xst, bakname, true, true, true);\n                const XStat *xstamp = opt->preserve_timestamp ? &xst : nullptr;\n                copy_file_contents(oname, iname, WO_MUST_EXIST_TRUNCATE, xstamp);\n                FileBase::unlink(oname);\n                copy_timestamp_only = true;\n            } else {\n                FileBase::rename(iname, bakname);\n                FileBase::rename(oname, iname);\n            }\n        } else if (preserve_link) {\n            const XStat *xstamp = opt->preserve_timestamp ? &xst : nullptr;\n            copy_file_contents(oname, iname, WO_MUST_EXIST_TRUNCATE, xstamp);\n            FileBase::unlink(oname);\n            copy_timestamp_only = true;\n        } else {\n            FileBase::unlink(iname);\n            FileBase::rename(oname, iname);\n        }\n        // now iname is the new packed/unpacked file and oname does not exist any longer\n    }\n\n    // copy file attributes\n    if (oname[0]) {\n        oname[0] = 0; // done with oname\n        const char *name = opt->output_name ? opt->output_name : iname;\n        if (copy_timestamp_only)\n            copy_file_attributes(&xst, name, false, false, opt->preserve_timestamp);\n        else\n            copy_file_attributes(&xst, name, opt->preserve_mode, opt->preserve_ownership,\n                                 opt->preserve_timestamp);\n    }\n\n    UiPacker::uiConfirmUpdate();\n}\n\n/*************************************************************************\n// process all files from the commandline\n**************************************************************************/\n\nstatic void unlink_ofile(char *oname) noexcept {\n    if (oname && oname[0]) {\n        (void) FileBase::unlink_noexcept(oname); // IGNORE_ERROR\n        oname[0] = 0;                            // done with oname\n    }\n}\n\nint do_files(int i, int argc, char *argv[]) may_throw {\n    upx_compiler_sanity_check();\n    if (opt->verbose >= 1) {\n        show_header();\n        UiPacker::uiHeader();\n    }\n\n    for (; i < argc; i++) {\n        infoHeader();\n\n        const char *const iname = argv[i];\n        char oname[ACC_FN_PATH_MAX + 1];\n        oname[0] = 0;\n\n        try {\n            do_one_file(iname, oname);\n        } catch (const Exception &e) {\n            unlink_ofile(oname);\n            if (opt->verbose >= 1 || (opt->verbose >= 0 && !e.isWarning()))\n                printErr(iname, e);\n            main_set_exit_code(e.isWarning() ? EXIT_WARN : EXIT_ERROR);\n            // this is not fatal, continue processing more files\n        } catch (const Error &e) {\n            unlink_ofile(oname);\n            printErr(iname, e);\n            main_set_exit_code(EXIT_ERROR);\n            return -1; // fatal error\n        } catch (std::bad_alloc *e) {\n            unlink_ofile(oname);\n            printErr(iname, \"out of memory\");\n            UNUSED(e);\n            // delete e;\n            main_set_exit_code(EXIT_ERROR);\n            return -1; // fatal error\n        } catch (const std::bad_alloc &) {\n            unlink_ofile(oname);\n            printErr(iname, \"out of memory\");\n            main_set_exit_code(EXIT_ERROR);\n            return -1; // fatal error\n        } catch (std::exception *e) {\n            unlink_ofile(oname);\n            printUnhandledException(iname, e);\n            // delete e;\n            main_set_exit_code(EXIT_ERROR);\n            return -1; // fatal error\n        } catch (const std::exception &e) {\n            unlink_ofile(oname);\n            printUnhandledException(iname, &e);\n            main_set_exit_code(EXIT_ERROR);\n            return -1; // fatal error\n        } catch (...) {\n            unlink_ofile(oname);\n            printUnhandledException(iname, nullptr);\n            main_set_exit_code(EXIT_ERROR);\n            return -1; // fatal error\n        }\n    }\n\n    if (opt->cmd == CMD_COMPRESS)\n        UiPacker::uiPackTotal();\n    else if (opt->cmd == CMD_DECOMPRESS)\n        UiPacker::uiUnpackTotal();\n    else if (opt->cmd == CMD_LIST)\n        UiPacker::uiListTotal();\n    else if (opt->cmd == CMD_TEST)\n        UiPacker::uiTestTotal();\n    else if (opt->cmd == CMD_FILEINFO)\n        UiPacker::uiFileInfoTotal();\n    return 0;\n}\n\n/* vim:set ts=4 sw=4 et: */\n","size_bytes":16725},"INSTALL.md":{"content":"#  Panduan Instalasi Resize\n\n## Daftar Isi\n1. [Quick Install](#quick-install)\n2. [System Requirements](#system-requirements)\n3. [Build dari Source](#build-dari-source)\n4. [Platform-Specific Instructions](#platform-specific-instructions)\n5. [Post-Installation](#post-installation)\n6. [Troubleshooting](#troubleshooting)\n\n## Quick Install\n\n### Method 1: Auto Install Script\n```bash\n# Download dan jalankan install script\ncurl -fsSL https://raw.githubusercontent.com/your-username/resize/main/install.sh | bash\n\n# Atau dengan wget\nwget -qO- https://raw.githubusercontent.com/your-username/resize/main/install.sh | bash\n```\n\n### Method 2: Pre-built Binaries\n```bash\n# Download binary untuk Linux x64\nwget https://github.com/your-username/resize/releases/latest/download/resize-linux-x64.tar.gz\ntar -xzf resize-linux-x64.tar.gz\nsudo cp resize /usr/local/bin/\n```\n\n### Method 3: Package Managers\n```bash\n# Ubuntu/Debian (via PPA)\nsudo add-apt-repository ppa:resize/stable\nsudo apt update\nsudo apt install resize\n\n# Fedora/CentOS (via COPR)\nsudo dnf copr enable resize/stable\nsudo dnf install resize\n\n# macOS (via Homebrew)\nbrew tap resize/tap\nbrew install resize\n\n# Arch Linux (via AUR)\nyay -S resize-bin\n```\n\n## System Requirements\n\n### Minimum Requirements\n| Component | Requirement |\n|-----------|-------------|\n| OS | Linux (64-bit), Windows 10+, macOS 10.14+ |\n| RAM | 512 MB available |\n| Storage | 50 MB free space |\n| CPU | Intel/AMD x64 atau ARM64 |\n\n### Recommended Requirements\n| Component | Recommendation |\n|-----------|----------------|\n| RAM | 2 GB atau lebih |\n| Storage | 200 MB free space |\n| CPU | Multi-core processor |\n\n### Build Requirements\n| Component | Version |\n|-----------|---------|\n| GCC | 8.0+ |\n| Clang | 5.0+ |\n| CMake | 3.8+ |\n| Make | 4.0+ |\n| Git | 2.0+ |\n\n## Build dari Source\n\n### Step 1: Install Dependencies\n\n#### Ubuntu/Debian\n```bash\n# Update package list\nsudo apt update\n\n# Install build essentials\nsudo apt install -y \\\n    build-essential \\\n    cmake \\\n    git \\\n    pkg-config \\\n    zlib1g-dev \\\n    libbz2-dev \\\n    libzstd-dev\n\n# Optional: install additional tools\nsudo apt install -y \\\n    clang \\\n    clang-format \\\n    clang-tidy \\\n    valgrind\n```\n\n#### CentOS/RHEL/Fedora\n```bash\n# For CentOS/RHEL 8+\nsudo dnf groupinstall \"Development Tools\"\nsudo dnf install cmake git pkgconfig zlib-devel bzip2-devel libzstd-devel\n\n# For older CentOS/RHEL\nsudo yum groupinstall \"Development Tools\"\nsudo yum install cmake git pkgconfig zlib-devel bzip2-devel\n\n# Enable EPEL untuk packages tambahan\nsudo dnf install epel-release  # CentOS 8+\nsudo yum install epel-release  # CentOS 7\n```\n\n#### Fedora\n```bash\nsudo dnf install \\\n    gcc-c++ \\\n    cmake \\\n    git \\\n    pkgconfig \\\n    zlib-devel \\\n    bzip2-devel \\\n    libzstd-devel \\\n    clang \\\n    clang-tools-extra\n```\n\n#### openSUSE\n```bash\nsudo zypper install \\\n    gcc-c++ \\\n    cmake \\\n    git \\\n    pkg-config \\\n    zlib-devel \\\n    libbz2-devel \\\n    libzstd-devel\n```\n\n#### Arch Linux\n```bash\nsudo pacman -S \\\n    base-devel \\\n    cmake \\\n    git \\\n    pkgconfig \\\n    zlib \\\n    bzip2 \\\n    zstd\n```\n\n#### Alpine Linux\n```bash\nsudo apk add \\\n    build-base \\\n    cmake \\\n    git \\\n    pkgconfig \\\n    zlib-dev \\\n    bzip2-dev \\\n    zstd-dev\n```\n\n#### macOS\n```bash\n# Install Xcode Command Line Tools\nxcode-select --install\n\n# Install Homebrew (if not installed)\n/bin/bash -c \"$(curl -fsSL https://raw.githubusercontent.com/Homebrew/install/HEAD/install.sh)\"\n\n# Install dependencies\nbrew install cmake git pkg-config zlib bzip2 zstd\n\n# Optional: install additional tools\nbrew install clang-format\n```\n\n### Step 2: Clone Repository\n```bash\n# Clone repository\ngit clone https://github.com/your-username/resize.git\ncd resize\n\n# Check repository structure\nls -la\n\n# Verify vendor dependencies\nls -la vendor/\n```\n\n### Step 3: Configure Build Environment\n\n#### Set Compiler (Optional)\n```bash\n# Use GCC\nexport CC=gcc\nexport CXX=g++\n\n# Or use Clang (recommended)\nexport CC=clang\nexport CXX=clang++\n\n# For cross-compilation (example: ARM64)\nexport CC=aarch64-linux-gnu-gcc\nexport CXX=aarch64-linux-gnu-g++\n```\n\n#### Set Build Flags (Optional)\n```bash\n# Optimization flags\nexport CFLAGS=\"-O3 -march=native -mtune=native\"\nexport CXXFLAGS=\"-O3 -march=native -mtune=native\"\n\n# Debug flags (untuk development)\nexport CFLAGS=\"-O0 -g3 -fsanitize=address\"\nexport CXXFLAGS=\"-O0 -g3 -fsanitize=address\"\n```\n\n### Step 4: Configure dengan CMake\n\n#### Release Build (Production)\n```bash\nmkdir -p build/release\ncd build/release\n\ncmake ../.. \\\n    -DCMAKE_BUILD_TYPE=Release \\\n    -DCMAKE_INSTALL_PREFIX=/usr/local \\\n    -DRES_CONFIG_DISABLE_WERROR=ON \\\n    -DRES_CONFIG_DISABLE_GITREV=OFF\n```\n\n#### Debug Build (Development)\n```bash\nmkdir -p build/debug\ncd build/debug\n\ncmake ../.. \\\n    -DCMAKE_BUILD_TYPE=Debug \\\n    -DCMAKE_INSTALL_PREFIX=/usr/local \\\n    -DUSE_STRICT_DEFAULTS=ON \\\n    -DRES_CONFIG_DISABLE_WERROR=OFF\n```\n\n#### Custom Configuration\n```bash\n# Static build (no shared libraries)\ncmake ../.. \\\n    -DCMAKE_BUILD_TYPE=Release \\\n    -DBUILD_SHARED_LIBS=OFF \\\n    -DCMAKE_EXE_LINKER_FLAGS=\"-static\"\n\n# Cross-compile untuk Windows dari Linux\ncmake ../.. \\\n    -DCMAKE_BUILD_TYPE=Release \\\n    -DCMAKE_TOOLCHAIN_FILE=../cmake/mingw-w64.cmake \\\n    -DCMAKE_INSTALL_PREFIX=/usr/local/cross-tools/\n\n# Dengan custom prefix\ncmake ../.. \\\n    -DCMAKE_BUILD_TYPE=Release \\\n    -DCMAKE_INSTALL_PREFIX=$HOME/.local\n```\n\n### Step 5: Build\n\n#### Standard Build\n```bash\n# Build dengan semua CPU cores\nmake -j$(nproc)\n\n# Untuk macOS\nmake -j$(sysctl -n hw.ncpu)\n\n# Manual (single thread)\nmake\n\n# Dengan verbose output\nmake VERBOSE=1\n```\n\n#### Advanced Build Options\n```bash\n# Build specific target\nmake resize\n\n# Build dengan timing info\ntime make -j$(nproc)\n\n# Build dengan progress\nmake -j$(nproc) --progress=short\n\n# Clean build\nmake clean && make -j$(nproc)\n```\n\n### Step 6: Test Build\n\n#### Basic Tests\n```bash\n# Test binary exists dan executable\nls -la resize\nfile resize\n\n# Test basic functionality\n./resize --version\n./resize --help\n\n# Test dengan file kecil\necho \"test\" > test.txt\n./resize test.txt\n./resize -d test.txt\n```\n\n#### Comprehensive Tests\n```bash\n# Run test suite\nctest --output-on-failure\n\n# Run specific tests\nctest -R resize-version\n\n# Run tests dengan verbose\nctest --output-on-failure --verbose\n\n# Run tests paralel\nctest -j$(nproc)\n```\n\n#### Manual Testing\n```bash\n# Test compression/decompression cycle\ncp /bin/ls test_binary\n./resize --best test_binary\n./test_binary --help\n./resize -d test_binary\n./test_binary --help\n\n# Performance test\ntime ./resize --brute /bin/bash\n\n# Memory test (jika valgrind installed)\nvalgrind --leak-check=full ./resize --test /bin/ls\n```\n\n### Step 7: Install\n\n#### System-wide Installation\n```bash\n# Install to /usr/local (requires sudo)\nsudo make install\n\n# Verify installation\nwhich resize\nresize --version\n```\n\n#### User-specific Installation\n```bash\n# Install to home directory\ncmake ../.. -DCMAKE_INSTALL_PREFIX=$HOME/.local\nmake install\n\n# Add to PATH (tambahkan ke ~/.bashrc atau ~/.zshrc)\nexport PATH=\"$HOME/.local/bin:$PATH\"\n```\n\n#### Custom Installation\n```bash\n# Install to custom directory\nINSTALL_DIR=\"/opt/resize\"\nsudo mkdir -p \"$INSTALL_DIR\"\nsudo cmake ../.. -DCMAKE_INSTALL_PREFIX=\"$INSTALL_DIR\"\nsudo make install\n\n# Create symlink\nsudo ln -sf \"$INSTALL_DIR/bin/resize\" /usr/local/bin/resize\n```\n\n## Platform-Specific Instructions\n\n### Linux Distributions\n\n#### Ubuntu 20.04 LTS\n```bash\n# Update system\nsudo apt update && sudo apt upgrade -y\n\n# Install dependencies\nsudo apt install -y build-essential cmake git pkg-config \\\n    zlib1g-dev libbz2-dev libzstd-dev\n\n# Clone dan build\ngit clone https://github.com/your-username/resize.git\ncd resize\nmkdir -p build/release && cd build/release\ncmake ../.. -DCMAKE_BUILD_TYPE=Release\nmake -j$(nproc)\nsudo make install\n```\n\n#### CentOS 8 Stream\n```bash\n# Enable PowerTools repository\nsudo dnf config-manager --set-enabled powertools\n\n# Install dependencies\nsudo dnf groupinstall \"Development Tools\"\nsudo dnf install cmake git pkgconfig zlib-devel bzip2-devel libzstd-devel\n\n# Build\ngit clone https://github.com/your-username/resize.git\ncd resize\nmkdir -p build/release && cd build/release\ncmake ../.. -DCMAKE_BUILD_TYPE=Release\nmake -j$(nproc)\nsudo make install\n```\n\n#### Debian 11 (Bullseye)\n```bash\n# Install dependencies\nsudo apt update\nsudo apt install -y build-essential cmake git pkg-config \\\n    zlib1g-dev libbz2-dev libzstd-dev\n\n# Build\ngit clone https://github.com/your-username/resize.git\ncd resize\nmkdir -p build/release && cd build/release\ncmake ../.. -DCMAKE_BUILD_TYPE=Release\nmake -j$(nproc)\nsudo make install\n```\n\n### Windows\n\n#### Using MSYS2/MinGW-w64\n```bash\n# Install MSYS2 dari https://www.msys2.org/\n\n# Update package database\npacman -Syu\n\n# Install build tools\npacman -S mingw-w64-x86_64-gcc \\\n          mingw-w64-x86_64-cmake \\\n          mingw-w64-x86_64-make \\\n          mingw-w64-x86_64-pkg-config \\\n          git\n\n# Build\ngit clone https://github.com/your-username/resize.git\ncd resize\nmkdir -p build/release && cd build/release\ncmake ../.. -G \"MinGW Makefiles\" -DCMAKE_BUILD_TYPE=Release\nmingw32-make -j$(nproc)\n```\n\n#### Using Visual Studio\n```cmd\nREM Install Visual Studio Community 2019+ dengan C++ workload\nREM Install CMake dari https://cmake.org/\nREM Install Git dari https://git-scm.com/\n\nREM Clone repository\ngit clone https://github.com/your-username/resize.git\ncd resize\n\nREM Configure dan build\nmkdir build\\release\ncd build\\release\ncmake ..\\.. -G \"Visual Studio 16 2019\" -A x64\ncmake --build . --config Release --parallel\n```\n\n### macOS\n\n#### Using Homebrew\n```bash\n# Install Homebrew dependencies\nbrew install cmake git pkg-config zlib bzip2 zstd\n\n# Build\ngit clone https://github.com/your-username/resize.git\ncd resize\nmkdir -p build/release && cd build/release\ncmake ../.. -DCMAKE_BUILD_TYPE=Release\nmake -j$(sysctl -n hw.ncpu)\nsudo make install\n```\n\n#### Universal Binary (Intel + Apple Silicon)\n```bash\n# Build for both architectures\nmkdir -p build/intel build/arm64\n\n# Intel build\ncd build/intel\ncmake ../.. -DCMAKE_BUILD_TYPE=Release -DCMAKE_OSX_ARCHITECTURES=x86_64\nmake -j$(sysctl -n hw.ncpu)\n\n# ARM64 build\ncd ../arm64\ncmake ../.. -DCMAKE_BUILD_TYPE=Release -DCMAKE_OSX_ARCHITECTURES=arm64\nmake -j$(sysctl -n hw.ncpu)\n\n# Create universal binary\nlipo -create build/intel/resize build/arm64/resize -output resize-universal\n```\n\n### Android (Cross-compile)\n\n#### Using Android NDK\n```bash\n# Download Android NDK\nwget https://dl.google.com/android/repository/android-ndk-r25c-linux.zip\nunzip android-ndk-r25c-linux.zip\nexport ANDROID_NDK_HOME=$PWD/android-ndk-r25c\n\n# Configure toolchain\nmkdir -p build/android && cd build/android\ncmake ../.. \\\n    -DCMAKE_TOOLCHAIN_FILE=$ANDROID_NDK_HOME/build/cmake/android.toolchain.cmake \\\n    -DANDROID_ABI=arm64-v8a \\\n    -DANDROID_PLATFORM=android-21 \\\n    -DCMAKE_BUILD_TYPE=Release\n\n# Build\nmake -j$(nproc)\n```\n\n## Post-Installation\n\n### Verification\n```bash\n# Check installation\nwhich resize\nresize --version\nresize --help\n\n# Test basic functionality\necho \"test data\" > test.txt\nresize test.txt\nresize -d test.txt\ncat test.txt\nrm test.txt\n```\n\n### Shell Integration\n\n#### Bash Completion\n```bash\n# Create completion script\nsudo tee /etc/bash_completion.d/resize << 'EOF'\n_resize_completion() {\n    local cur prev opts\n    COMPREPLY=()\n    cur=\"${COMP_WORDS[COMP_CWORD]}\"\n    prev=\"${COMP_WORDS[COMP_CWORD-1]}\"\n    \n    opts=\"--help --version --test --decompress --best --fast --brute --verbose --quiet --force --backup --output\"\n    \n    if [[ ${cur} == -* ]]; then\n        COMPREPLY=( $(compgen -W \"${opts}\" -- ${cur}) )\n        return 0\n    fi\n    \n    COMPREPLY=( $(compgen -f -- ${cur}) )\n}\n\ncomplete -F _resize_completion resize\nEOF\n\n# Reload bash completion\nsource /etc/bash_completion.d/resize\n```\n\n#### Zsh Completion\n```bash\n# Create completion script\nsudo mkdir -p /usr/share/zsh/vendor-completions\nsudo tee /usr/share/zsh/vendor-completions/_resize << 'EOF'\n#compdef resize\n\n_resize() {\n    local context state line\n    \n    _arguments \\\n        '--help[Show help]' \\\n        '--version[Show version]' \\\n        '--test[Test compressed file]' \\\n        '--decompress[Decompress file]' \\\n        '--best[Best compression]' \\\n        '--fast[Fast compression]' \\\n        '--brute[Brute force compression]' \\\n        '--verbose[Verbose output]' \\\n        '--quiet[Quiet mode]' \\\n        '--force[Force overwrite]' \\\n        '--backup[Create backup]' \\\n        '--output[Output file]:file:_files' \\\n        '*:file:_files'\n}\n\n_resize \"$@\"\nEOF\n```\n\n### System Integration\n\n#### Desktop Entry (Linux)\n```bash\n# Create desktop entry\nsudo tee /usr/share/applications/resize.desktop << 'EOF'\n[Desktop Entry]\nVersion=1.0\nType=Application\nName=Resize\nComment=Advanced file compression tool\nExec=resize %F\nIcon=resize\nTerminal=true\nMimeType=application/x-executable;application/x-sharedlib;\nCategories=Utility;Archiving;Compression;\nEOF\n\n# Update desktop database\nsudo update-desktop-database\n```\n\n#### File Manager Integration\n\n##### Nautilus (GNOME)\n```bash\n# Create Nautilus script\nmkdir -p ~/.local/share/nautilus/scripts\ncat > ~/.local/share/nautilus/scripts/Compress\\ with\\ Resize << 'EOF'\n#!/bin/bash\n# Nautilus script for Resize compression\n\nfor file in \"$@\"; do\n    if [ -x \"$file\" ]; then\n        gnome-terminal -- bash -c \"resize --best '$file'; echo 'Press Enter to close'; read\"\n    fi\ndone\nEOF\n\nchmod +x ~/.local/share/nautilus/scripts/Compress\\ with\\ Resize\n```\n\n##### Dolphin (KDE)\n```bash\n# Create service menu\nmkdir -p ~/.local/share/kservices5/ServiceMenus\ncat > ~/.local/share/kservices5/ServiceMenus/resize.desktop << 'EOF'\n[Desktop Entry]\nType=Service\nServiceTypes=KonqPopupMenu/Plugin\nMimeType=application/x-executable;\nActions=compress;decompress;test;\n\n[Desktop Action compress]\nName=Compress with Resize\nIcon=archive-insert\nExec=konsole -e bash -c \"resize --best '%f'; echo 'Press Enter to close'; read\"\n\n[Desktop Action decompress]\nName=Decompress with Resize\nIcon=archive-extract\nExec=konsole -e bash -c \"resize -d '%f'; echo 'Press Enter to close'; read\"\n\n[Desktop Action test]\nName=Test with Resize\nIcon=archive-test\nExec=konsole -e bash -c \"resize --test '%f'; echo 'Press Enter to close'; read\"\nEOF\n```\n\n### Configuration\n\n#### Global Configuration\n```bash\n# Create global config\nsudo mkdir -p /etc/resize\nsudo tee /etc/resize/resize.conf << 'EOF'\n# Global Resize configuration\n[compression]\ndefault_level = best\nbackup = true\nverify_after = true\n\n[output]\nlog_level = info\nprogress = true\n\n[memory]\nlimit = 512m\nEOF\n```\n\n#### User Configuration\n```bash\n# Create user config\nmkdir -p ~/.config/resize\ncat > ~/.config/resize/resize.conf << 'EOF'\n# User Resize configuration\n[compression]\ndefault_level = best\nbackup = true\nverify_after = true\nprogress = true\n\n[output]\nlog_level = info\nstats = true\nquiet = false\n\n[memory]\nlimit = 1g\ntemp_dir = /tmp\nEOF\n```\n\n## Troubleshooting\n\n### Build Issues\n\n#### CMake Issues\n```bash\n# CMake version too old\n# Solution: Install newer CMake\nwget https://github.com/Kitware/CMake/releases/latest/download/cmake-3.25.0-linux-x86_64.tar.gz\ntar -xzf cmake-3.25.0-linux-x86_64.tar.gz\nexport PATH=$PWD/cmake-3.25.0-linux-x86_64/bin:$PATH\n\n# Missing CMake modules\n# Solution: Install development packages\nsudo apt install cmake-extras  # Ubuntu/Debian\nsudo dnf install cmake         # Fedora\n```\n\n#### Compiler Issues\n```bash\n# GCC/Clang too old\n# Solution: Install newer compiler\nsudo apt install gcc-9 g++-9  # Ubuntu/Debian\nexport CC=gcc-9 CXX=g++-9\n\n# Missing C++17 support\n# Solution: Check compiler version\ngcc --version\nclang++ --version\n\n# Force C++17\nexport CXXFLAGS=\"-std=c++17\"\n```\n\n#### Dependency Issues\n```bash\n# Missing zlib\nsudo apt install zlib1g-dev     # Ubuntu/Debian\nsudo dnf install zlib-devel     # Fedora/CentOS\nbrew install zlib               # macOS\n\n# Missing pkg-config\nsudo apt install pkg-config     # Ubuntu/Debian\nsudo dnf install pkgconfig      # Fedora/CentOS\nbrew install pkg-config         # macOS\n```\n\n### Runtime Issues\n\n#### Permission Issues\n```bash\n# Cannot execute resize\nchmod +x resize\nsudo chmod +x /usr/local/bin/resize\n\n# Cannot access files\n# Check file permissions dan ownership\nls -la target_file\nsudo chown $USER:$USER target_file\n```\n\n#### Library Issues\n```bash\n# Missing shared libraries\nldd resize  # Check dependencies\n\n# Add library path\nexport LD_LIBRARY_PATH=\"/usr/local/lib:$LD_LIBRARY_PATH\"\n\n# Update library cache\nsudo ldconfig\n```\n\n#### Memory Issues\n```bash\n# Out of memory during compression\n# Solution: Reduce memory usage\nresize --memory=256m large_file.exe\n\n# Use swap space\nsudo fallocate -l 2G /swapfile\nsudo chmod 600 /swapfile\nsudo mkswap /swapfile\nsudo swapon /swapfile\n```\n\n### Platform-Specific Issues\n\n#### Linux\n```bash\n# SELinux issues\nsudo setsebool -P allow_execmod 1\nsudo restorecon -R /usr/local/bin/resize\n\n# AppArmor issues\nsudo aa-complain /usr/local/bin/resize\n```\n\n#### macOS\n```bash\n# Code signing issues\ncodesign --force --deep --sign - resize\n\n# Gatekeeper issues\nsudo spctl --master-disable  # Temporary\nxattr -dr com.apple.quarantine resize\n```\n\n#### Windows\n```cmd\nREM Antivirus false positives\nREM Add resize.exe to antivirus exclusions\n\nREM PATH issues\nset PATH=%PATH%;C:\\Program Files\\Resize\\bin\n```\n\n### Getting Help\n\n#### Diagnostic Information\n```bash\n# Generate diagnostic report\nresize --sysinfo > diagnostic.txt\nresize --version >> diagnostic.txt\nldd resize >> diagnostic.txt  # Linux\notool -L resize >> diagnostic.txt  # macOS\n\n# Include in bug report\n```\n\n#### Community Support\n- **GitHub Issues**: [Create new issue](https://github.com/your-username/resize/issues)\n- **Discussions**: [Community forum](https://github.com/your-username/resize/discussions)\n- **Documentation**: [Wiki](https://github.com/your-username/resize/wiki)\n\n---\n\n*Jika mengalami masalah yang tidak tercakup dalam dokumentasi ini, silakan buat issue di GitHub repository dengan informasi diagnostic lengkap.*","size_bytes":17925},"README.md":{"content":"# Resize (RES) - Advanced File Compression Tool\n\n```\n           \n                                \n                   \n                                \n             \n```\n\n**Resize** adalah alat kompresi file yang canggih, berdasarkan teknologi UPX (Ultimate Packer for eXecutables) dengan peningkatan dan rebranding lengkap. Tool ini dirancang untuk mengompres file executable dengan tingkat kompresi tinggi sambil mempertahankan fungsionalitas penuh.\n\n---\n\n##  Fitur Utama\n\n- **Kompresi Tingkat Tinggi**: Mengurangi ukuran file executable hingga 50-70%\n- **Self-Contained**: File yang dikompres berjalan mandiri tanpa ketergantungan eksternal\n- **Multi-Platform**: Mendukung berbagai format executable (Windows PE, Linux ELF, macOS Mach-O)\n- **Zero Runtime Overhead**: Tidak ada penalty performa saat runtime\n- **Reversible**: Dapat dikembalikan ke ukuran asli kapan saja\n- **Batch Processing**: Mendukung pemrosesan multiple file sekaligus\n\n##  Persyaratan Sistem\n\n### Minimum Requirements:\n- **OS**: Linux (64-bit), Windows 10+, macOS 10.14+\n- **RAM**: 512 MB tersedia\n- **Storage**: 50 MB ruang kosong\n- **CPU**: Intel/AMD x64 atau ARM64\n\n### Build Requirements (untuk kompilasi):\n- **Compiler**: GCC 8+ atau Clang 5+ dengan dukungan C++17 penuh\n- **CMake**: Versi 3.8 atau lebih baru\n- **Make**: GNU Make 4.0+\n- **Git**: Untuk cloning dependencies\n\n##  Instalasi\n\n### Method 1: Quick Install (Recommended)\n```bash\n# Clone repository\ngit clone https://github.com/your-username/resize.git\ncd resize\n\n# Build dengan script otomatis\nchmod +x install.sh\n./install.sh\n```\n\n### Method 2: Manual Build\n```bash\n# 1. Clone repository\ngit clone https://github.com/your-username/resize.git\ncd resize\n\n# 2. Persiapkan direktori build\nmkdir -p build/release\ncd build/release\n\n# 3. Configure dengan CMake\ncmake ../.. -DCMAKE_BUILD_TYPE=Release\n\n# 4. Compile\nmake -j$(nproc)\n\n# 5. Install (optional)\nsudo make install\n```\n\n### Method 3: Developer Build\n```bash\n# Untuk developer yang ingin berkontribusi\ngit clone https://github.com/your-username/resize.git\ncd resize\n\n# Build dengan semua optimasi dan debug info\nmkdir -p build/debug\ncd build/debug\ncmake ../.. -DCMAKE_BUILD_TYPE=Debug -DUSE_STRICT_DEFAULTS=ON\nmake -j$(nproc)\n```\n\n##  Penggunaan Dasar\n\n### Syntax Umum\n```bash\nresize [OPTIONS] [FILE(S)]\n```\n\n### Contoh Penggunaan Sederhana\n\n#### 1. Kompresi File Tunggal\n```bash\n# Kompresi basic\nresize myprogram.exe\n\n# Kompresi dengan tingkat maksimal\nresize --best myprogram.exe\n\n# Kompresi dengan algoritma brute force (paling optimal)\nresize --brute myprogram.exe\n```\n\n#### 2. Kompresi Multiple Files\n```bash\n# Kompresi semua file .exe di direktori\nresize *.exe\n\n# Kompresi dengan pattern specific\nresize program1.exe program2.exe program3.exe\n```\n\n#### 3. Decompresi (Restore)\n```bash\n# Kembalikan ke ukuran asli\nresize -d compressed_program.exe\n\n# Decompresi dengan verifikasi\nresize --decompress --test compressed_program.exe\n```\n\n##  Opsi dan Parameter Lengkap\n\n### Opsi Kompresi\n| Opsi | Deskripsi | Contoh |\n|------|-----------|---------|\n| `--best` | Kompresi terbaik (lambat tapi optimal) | `resize --best app.exe` |\n| `--brute` | Algoritma brute force (sangat lambat, hasil terbaik) | `resize --brute app.exe` |\n| `--fast` | Kompresi cepat (hasil kurang optimal) | `resize --fast app.exe` |\n| `--ultra-brute` | Mode ultra kompresi (sangat lambat) | `resize --ultra-brute app.exe` |\n\n### Opsi Output\n| Opsi | Deskripsi | Contoh |\n|------|-----------|---------|\n| `-o, --output` | Specify output file | `resize -o result.exe input.exe` |\n| `--backup` | Buat backup file asli | `resize --backup app.exe` |\n| `-f, --force` | Overwrite file yang sudah ada | `resize -f app.exe` |\n| `--keep-backup` | Simpan backup setelah kompresi | `resize --keep-backup app.exe` |\n\n### Opsi Informasi\n| Opsi | Deskripsi | Contoh |\n|------|-----------|---------|\n| `-l, --list` | Tampilkan info file yang dikompres | `resize -l app.exe` |\n| `-t, --test` | Test integritas file | `resize -t app.exe` |\n| `-v, --verbose` | Output detail | `resize -v app.exe` |\n| `-q, --quiet` | Mode silent | `resize -q app.exe` |\n\n### Opsi Lanjutan\n| Opsi | Deskripsi | Contoh |\n|------|-----------|---------|\n| `--overlay=skip` | Skip overlay data | `resize --overlay=skip app.exe` |\n| `--strip-relocs=0` | Preserve relocations | `resize --strip-relocs=0 app.exe` |\n| `--compress-exports=0` | Jangan kompres export table | `resize --compress-exports=0 app.exe` |\n| `--compress-icons=0` | Jangan kompres icons | `resize --compress-icons=0 app.exe` |\n\n##  Panduan Penggunaan Detail\n\n###  Skenario Penggunaan Umum\n\n#### 1. Mengompres Aplikasi Desktop\n```bash\n# Untuk aplikasi Windows\nresize --best --backup MyApp.exe\n\n# Untuk aplikasi Linux\nresize --best --backup ./myapp\n\n# Untuk aplikasi macOS\nresize --best --backup MyApp.app/Contents/MacOS/MyApp\n```\n\n#### 2. Optimasi untuk Distribusi\n```bash\n# Kompresi untuk distribusi online (prioritas ukuran)\nresize --brute --compress-icons=1 --compress-exports=1 installer.exe\n\n# Kompresi untuk distribusi offline (balanced)\nresize --best --keep-backup setup.exe\n```\n\n#### 3. Batch Processing untuk Developer\n```bash\n# Kompresi semua executable dalam project\nfind . -name \"*.exe\" -exec resize --best {} \\;\n\n# Kompresi dengan filter size minimum\nfind . -name \"*.exe\" -size +1M -exec resize --brute {} \\;\n```\n\n#### 4. CI/CD Integration\n```bash\n# Script untuk pipeline\n#!/bin/bash\nfor file in dist/*.exe; do\n    if [ -f \"$file\" ]; then\n        echo \"Compressing $file...\"\n        resize --best --backup \"$file\"\n        echo \"Original: $(du -h \"$file.backup\" | cut -f1)\"\n        echo \"Compressed: $(du -h \"$file\" | cut -f1)\"\n        echo \"---\"\n    fi\ndone\n```\n\n###  Advanced Configuration\n\n#### 1. Custom Compression Levels\n```bash\n# Level 1-9 (1=fastest, 9=best)\nresize --compress-level=9 app.exe\n\n# Dengan memory limit\nresize --memory=256m --best app.exe\n```\n\n#### 2. Platform-Specific Options\n```bash\n# Windows PE specific\nresize --compress-resources=1 --strip-dos-stub=1 app.exe\n\n# Linux ELF specific  \nresize --preserve-build-id --compress-dwarf=1 ./app\n\n# macOS Mach-O specific\nresize --preserve-uuid --compress-linkedit=1 ./app\n```\n\n#### 3. Security Considerations\n```bash\n# Preserve code signing (jika ada)\nresize --keep-signature app.exe\n\n# Verify after compression\nresize --test-after-compress app.exe\n```\n\n##  Performance dan Statistik\n\n### Typical Compression Rates:\n- **Small executables (< 1MB)**: 40-60% reduction\n- **Medium executables (1-10MB)**: 50-70% reduction  \n- **Large executables (> 10MB)**: 55-75% reduction\n\n### Speed Benchmarks (pada CPU modern):\n- **--fast**: ~10MB/second\n- **--best**: ~2MB/second\n- **--brute**: ~500KB/second\n- **--ultra-brute**: ~100KB/second\n\n##  Troubleshooting\n\n### Error Messages dan Solusi\n\n#### \"Cannot pack: file is already packed\"\n```bash\n# File sudah dikompres, decompress dulu\nresize -d packed_file.exe\nresize --best packed_file.exe\n```\n\n#### \"Cannot pack: file has overlay\"\n```bash\n# Handle overlay data\nresize --overlay=copy app.exe    # Copy overlay\nresize --overlay=skip app.exe    # Skip overlay\nresize --overlay=strip app.exe   # Remove overlay\n```\n\n#### \"Cannot pack: executable format not supported\"\n```bash\n# Check format\nfile myapp.exe\nresize --format=pe myapp.exe     # Force format\n```\n\n#### \"Out of memory during compression\"\n```bash\n# Reduce memory usage\nresize --memory=128m app.exe\nresize --fast app.exe            # Use faster method\n```\n\n### Recovery Commands\n```bash\n# Jika kompresi gagal dan file rusak\ncp app.exe.backup app.exe       # Restore from backup\n\n# Test file integrity\nresize --test app.exe           # Verify compressed file\n```\n\n##  Testing dan Verification\n\n### Pre-compression Checks\n```bash\n# Verify file sebelum kompresi\nfile myapp.exe\nldd myapp                      # Check dependencies (Linux)\notool -L myapp                 # Check dependencies (macOS)\n```\n\n### Post-compression Verification\n```bash\n# Test compressed file\nresize --test compressed_app.exe\n\n# Compare functionality\n./original_app --version\n./compressed_app --version\n\n# Performance test\ntime ./compressed_app benchmark\n```\n\n##  Build dari Source Code\n\n### Prerequisites Check\n```bash\n# Check compiler\ngcc --version\nclang++ --version\n\n# Check CMake\ncmake --version\n\n# Check dependencies\npkg-config --list-all | grep -E \"(zlib|bzip2)\"\n```\n\n### Detailed Build Process\n```bash\n# 1. Persiapan environment\nexport CC=clang\nexport CXX=clang++\nexport CFLAGS=\"-O3 -march=native\"\nexport CXXFLAGS=\"-O3 -march=native\"\n\n# 2. Configure untuk production\nmkdir -p build/production\ncd build/production\ncmake ../.. \\\n    -DCMAKE_BUILD_TYPE=Release \\\n    -DCMAKE_INSTALL_PREFIX=/usr/local \\\n    -DRES_CONFIG_DISABLE_WERROR=ON \\\n    -DRES_CONFIG_DISABLE_GITREV=OFF\n\n# 3. Build dengan optimasi maksimal\nmake -j$(nproc) VERBOSE=1\n\n# 4. Run tests\nctest --output-on-failure\n\n# 5. Install\nsudo make install\n```\n\n### Custom Build Options\n```bash\n# Debug build\ncmake ../.. -DCMAKE_BUILD_TYPE=Debug -DUSE_STRICT_DEFAULTS=ON\n\n# Static build (no dependencies)\ncmake ../.. -DBUILD_SHARED_LIBS=OFF -DCMAKE_EXE_LINKER_FLAGS=\"-static\"\n\n# Cross-compile untuk Windows (dari Linux)\ncmake ../.. -DCMAKE_TOOLCHAIN_FILE=mingw-w64.cmake\n```\n\n##  Platform-Specific Notes\n\n### Windows\n```cmd\nREM Kompresi untuk Windows\nresize.exe --best --compress-resources=1 MyApp.exe\n\nREM Preserve digital signature\nresize.exe --keep-signature SignedApp.exe\n\nREM Handle .NET assemblies (experimental)\nresize.exe --dotnet-compress Assembly.exe\n```\n\n### Linux\n```bash\n# Preserve debugging symbols\nresize --keep-debug-info ./myapp\n\n# Handle position-independent executables\nresize --pie-compatible ./modern_app\n\n# Compress shared libraries\nresize --shared-lib libmylib.so\n```\n\n### macOS\n```bash\n# Compress macOS app bundle\nresize --macos-bundle MyApp.app\n\n# Preserve code signature\nresize --preserve-codesign ./signed_app\n\n# Handle universal binaries\nresize --universal-binary ./universal_app\n```\n\n##  Integration dengan Build Systems\n\n### Makefile Integration\n```makefile\n# Tambahkan ke Makefile\ncompress: $(TARGET)\n\t@echo \"Compressing executable...\"\n\tresize --best --backup $(TARGET)\n\t@echo \"Compression complete.\"\n\n.PHONY: compress\n```\n\n### CMake Integration\n```cmake\n# Tambahkan custom target\nadd_custom_target(compress\n    COMMAND resize --best --backup $<TARGET_FILE:myapp>\n    DEPENDS myapp\n    COMMENT \"Compressing executable\"\n)\n```\n\n### GitHub Actions\n```yaml\n# .github/workflows/build.yml\n- name: Compress executables\n  run: |\n    chmod +x resize\n    ./resize --best --backup dist/*.exe\n    \n- name: Upload compressed artifacts\n  uses: actions/upload-artifact@v3\n  with:\n    name: compressed-binaries\n    path: dist/*.exe\n```\n\n##  Monitoring dan Logging\n\n### Enable Detailed Logging\n```bash\n# Full verbose output\nresize --verbose --log-level=debug app.exe\n\n# Log to file\nresize --verbose --log-file=compression.log app.exe\n\n# Progress monitoring untuk file besar\nresize --progress --best large_app.exe\n```\n\n### Log Analysis\n```bash\n# Analyze compression statistics\ngrep \"compression ratio\" compression.log\ngrep \"time elapsed\" compression.log\ngrep \"memory usage\" compression.log\n```\n\n##  Security Best Practices\n\n### 1. Verification Workflow\n```bash\n# Always verify setelah kompresi\nresize --test compressed_file.exe\n\n# Check hash integrity\nsha256sum original_file.exe > original.sha256\nsha256sum compressed_file.exe > compressed.sha256\n```\n\n### 2. Backup Strategy\n```bash\n# Automated backup\nresize --backup --backup-dir=./backups app.exe\n\n# Timestamp backups\nresize --backup --backup-suffix=.$(date +%Y%m%d) app.exe\n```\n\n### 3. Safe Batch Processing\n```bash\n#!/bin/bash\n# Safe batch compression script\nfor file in *.exe; do\n    if [ -f \"$file\" ]; then\n        echo \"Processing $file...\"\n        \n        # Create backup\n        cp \"$file\" \"$file.backup\"\n        \n        # Compress\n        if resize --best \"$file\"; then\n            echo \" Successfully compressed $file\"\n            \n            # Verify\n            if resize --test \"$file\"; then\n                echo \" Verification passed\"\n            else\n                echo \" Verification failed, restoring backup\"\n                mv \"$file.backup\" \"$file\"\n            fi\n        else\n            echo \" Compression failed for $file\"\n            mv \"$file.backup\" \"$file\"\n        fi\n    fi\ndone\n```\n\n##  Support dan Kontribusi\n\n### Mendapatkan Bantuan\n- **GitHub Issues**: [Create new issue](https://github.com/your-username/resize/issues)\n- **Discussions**: [Community forum](https://github.com/your-username/resize/discussions)\n- **Documentation**: [Wiki](https://github.com/your-username/resize/wiki)\n\n### Berkontribusi\n```bash\n# Fork dan clone\ngit clone https://github.com/your-username/resize.git\ncd resize\n\n# Create feature branch\ngit checkout -b feature/amazing-feature\n\n# Make changes dan test\nmake test\n\n# Commit dan push\ngit commit -m \"Add amazing feature\"\ngit push origin feature/amazing-feature\n\n# Create Pull Request\n```\n\n### Development Setup\n```bash\n# Install development dependencies\nsudo apt-get install -y \\\n    build-essential \\\n    cmake \\\n    git \\\n    clang-format \\\n    clang-tidy \\\n    valgrind\n\n# Setup pre-commit hooks\ncp hooks/pre-commit .git/hooks/\nchmod +x .git/hooks/pre-commit\n```\n\n##  License dan Copyright\n\n**Resize** adalah software open source berdasarkan UPX dengan lisensi GPL v2+.\n\n```\nCopyright (c) 2025 WHO-AM-I-404\nBased on UPX - Ultimate Packer for eXecutables\nCopyright (C) 2025 WHO-AM-I-404\nBased on UPX Copyright (C) 1996-2025 Laszlo Molnar & John Reiser\n\nThis program is free software; you can redistribute it and/or modify\nit under the terms of the GNU General Public License as published by\nthe Free Software Foundation; either version 2 of the License, or\n(at your option) any later version.\n```\n\n##  Acknowledgments\n\n- **UPX Team**: Untuk teknologi dasar yang luar biasa\n- **Contributors**: Semua yang telah berkontribusi pada proyek ini\n- **Community**: Untuk feedback dan bug reports\n\n---\n\n**Made with  by WHO-AM-I-404**\n\n*Resize - Making executables smaller, one byte at a time.*","size_bytes":14497},"USAGE_GUIDE.md":{"content":"#  Panduan Penggunaan Lengkap Resize\n\n## Daftar Isi\n1. [Quick Start](#quick-start)\n2. [Instalasi Detail](#instalasi-detail)\n3. [Command Line Interface](#command-line-interface)\n4. [Skenario Penggunaan](#skenario-penggunaan)\n5. [Troubleshooting](#troubleshooting)\n6. [Best Practices](#best-practices)\n7. [Advanced Features](#advanced-features)\n\n## Quick Start\n\n### Langkah 1: Verifikasi Instalasi\n```bash\n# Check apakah resize sudah terinstall\nwhich resize\n\n# Tampilkan versi\nresize --version\n\n# Tampilkan help\nresize --help\n```\n\n### Langkah 2: Kompresi Pertama\n```bash\n# Siapkan file test\ncp /bin/ls test_program\n\n# Kompresi basic\nresize test_program\n\n# Check hasil\nls -la test_program*\n```\n\n### Langkah 3: Verifikasi Hasil\n```bash\n# Test file yang dikompres\n./test_program\n\n# Decompresi jika perlu\nresize -d test_program\n```\n\n## Instalasi Detail\n\n### Prerequisites\n```bash\n# Ubuntu/Debian\nsudo apt update\nsudo apt install -y build-essential cmake git\n\n# CentOS/RHEL/Fedora\nsudo yum groupinstall \"Development Tools\"\nsudo yum install cmake git\n\n# macOS (dengan Homebrew)\nbrew install cmake git\n\n# Windows (dengan MinGW-w64)\n# Install MSYS2 dari https://www.msys2.org/\npacman -S mingw-w64-x86_64-gcc mingw-w64-x86_64-cmake\n```\n\n### Build dari Source - Langkah Demi Langkah\n\n#### Step 1: Download Source Code\n```bash\n# Clone repository\ngit clone https://github.com/your-username/resize.git\ncd resize\n\n# Check struktur project\nls -la\n```\n\n#### Step 2: Persiapan Dependencies\n```bash\n# Check vendor dependencies\nls -la vendor/\n\n# Jika kosong, init submodules\ngit submodule update --init --recursive\n```\n\n#### Step 3: Configure Build\n```bash\n# Buat direktori build\nmkdir -p build/release\ncd build/release\n\n# Configure untuk release build\ncmake ../.. \\\n    -DCMAKE_BUILD_TYPE=Release \\\n    -DCMAKE_INSTALL_PREFIX=/usr/local \\\n    -DRES_CONFIG_DISABLE_WERROR=ON\n\n# Untuk debug build (optional)\nmkdir -p ../debug\ncd ../debug\ncmake ../.. \\\n    -DCMAKE_BUILD_TYPE=Debug \\\n    -DUSE_STRICT_DEFAULTS=ON\n```\n\n#### Step 4: Kompilasi\n```bash\n# Build (gunakan semua CPU cores)\nmake -j$(nproc)\n\n# Atau dengan verbose output\nmake -j$(nproc) VERBOSE=1\n\n# Check hasil build\nls -la resize\nfile resize\n```\n\n#### Step 5: Testing\n```bash\n# Basic test\n./resize --version\n./resize --help\n\n# Advanced testing\nctest --output-on-failure\n\n# Manual test\n./resize /bin/echo\n./echo \"Hello World\"\n```\n\n#### Step 6: Installation\n```bash\n# Install system-wide (optional)\nsudo make install\n\n# Atau copy manual\nsudo cp resize /usr/local/bin/\nsudo chmod +x /usr/local/bin/resize\n\n# Verify installation\nwhich resize\nresize --version\n```\n\n## Command Line Interface\n\n### Syntax Lengkap\n```\nresize [GLOBAL_OPTIONS] [ACTION] [ACTION_OPTIONS] [FILE(S)]\n```\n\n### Global Options\n\n#### Basic Options\n```bash\n-v, --verbose         # Tampilkan output detail\n-q, --quiet          # Mode silent (minimal output)\n-f, --force          # Force overwrite existing files\n--version            # Tampilkan versi program\n--help               # Tampilkan bantuan\n--license            # Tampilkan informasi lisensi\n```\n\n#### Advanced Options\n```bash\n--memory=SIZE        # Limit penggunaan memory (contoh: --memory=256m)\n--threads=N          # Jumlah thread untuk processing (default: auto)\n--temp-dir=DIR       # Direktori temporary (default: /tmp)\n--config-file=FILE   # Load konfigurasi dari file\n```\n\n### Actions (Mode Operasi)\n\n#### 1. Kompresi (Default)\n```bash\n# Basic compression\nresize myapp.exe\n\n# Dengan level kompresi\nresize --best myapp.exe\nresize --fast myapp.exe\nresize --brute myapp.exe\n\n# Dengan output file specific\nresize -o compressed_app.exe myapp.exe\n```\n\n#### 2. Decompresi\n```bash\n# Decompress file\nresize -d compressed_app.exe\n\n# Decompress dengan verifikasi\nresize -d --test compressed_app.exe\n\n# Decompress ke file lain\nresize -d -o original_app.exe compressed_app.exe\n```\n\n#### 3. Testing dan Info\n```bash\n# Test integritas file\nresize -t compressed_app.exe\n\n# Tampilkan informasi file\nresize -l compressed_app.exe\n\n# Detail info dengan verbose\nresize -l -v compressed_app.exe\n```\n\n### Compression Options\n\n#### Level Kompresi\n```bash\n--fast               # Fastest compression (level 1)\n--best               # Best compression (level 9)\n--brute              # Brute force (very slow, best result)\n--ultra-brute        # Ultra compression (extremely slow)\n\n# Manual level (1-9)\n--compress-level=5\n```\n\n#### Algorithm Options\n```bash\n--method=nrv2b       # Use NRV2B algorithm\n--method=nrv2d       # Use NRV2D algorithm  \n--method=nrv2e       # Use NRV2E algorithm\n--method=lzma        # Use LZMA algorithm (best)\n```\n\n#### Platform-Specific Options\n```bash\n# Windows PE\n--compress-exports=0    # Don't compress export table\n--compress-icons=0      # Don't compress icons\n--compress-resources=1  # Compress resources\n--strip-relocs=0        # Keep relocations\n\n# Linux ELF\n--preserve-build-id     # Keep build ID\n--strip-debug=0         # Keep debug info\n\n# macOS Mach-O  \n--preserve-uuid         # Keep UUID\n--preserve-codesign     # Keep code signature\n```\n\n### Output Options\n\n#### File Handling\n```bash\n-o, --output=FILE       # Specify output filename\n--backup               # Create backup of original\n--backup-suffix=SUFFIX # Backup filename suffix (default: .backup)\n--backup-dir=DIR       # Directory for backups\n--keep-backup          # Keep backup after successful compression\n```\n\n#### Progress dan Logging\n```bash\n--progress             # Show progress bar (untuk file besar)\n--log-file=FILE        # Log output ke file\n--log-level=LEVEL      # Log level: error, warn, info, debug\n--stats                # Show compression statistics\n```\n\n## Skenario Penggunaan\n\n### 1. Developer Workflow\n\n#### Kompresi Build Artifacts\n```bash\n#!/bin/bash\n# build_and_compress.sh\n\n# Build project\nmake clean && make release\n\n# Compress all executables\necho \"Compressing executables...\"\nfor exe in bin/*.exe bin/*; do\n    if [ -x \"$exe\" ] && [ ! -d \"$exe\" ]; then\n        echo \"Compressing $exe...\"\n        resize --best --backup \"$exe\"\n        \n        # Show compression ratio\n        original_size=$(stat -f%z \"$exe.backup\" 2>/dev/null || stat -c%s \"$exe.backup\")\n        compressed_size=$(stat -f%z \"$exe\" 2>/dev/null || stat -c%s \"$exe\")\n        ratio=$(echo \"scale=2; (1 - $compressed_size/$original_size) * 100\" | bc)\n        echo \"  Compression: ${ratio}%\"\n    fi\ndone\n\necho \"Compression complete!\"\n```\n\n#### Testing Compressed Executables\n```bash\n#!/bin/bash\n# test_compressed.sh\n\nfailed=0\n\nfor exe in bin/*; do\n    if [ -x \"$exe\" ] && [ ! -d \"$exe\" ]; then\n        echo \"Testing $exe...\"\n        \n        # Test integrity\n        if ! resize --test \"$exe\"; then\n            echo \" Integrity test failed for $exe\"\n            failed=1\n            continue\n        fi\n        \n        # Test execution (jika ada --version flag)\n        if $exe --version >/dev/null 2>&1; then\n            echo \" $exe works correctly\"\n        else\n            echo \"  $exe may have issues (no --version support)\"\n        fi\n    fi\ndone\n\nif [ $failed -eq 1 ]; then\n    echo \"Some tests failed!\"\n    exit 1\nelse\n    echo \"All tests passed!\"\nfi\n```\n\n### 2. CI/CD Integration\n\n#### GitHub Actions\n```yaml\n# .github/workflows/build-and-compress.yml\nname: Build and Compress\n\non: [push, pull_request]\n\njobs:\n  build:\n    runs-on: ubuntu-latest\n    \n    steps:\n    - uses: actions/checkout@v3\n    \n    - name: Install dependencies\n      run: |\n        sudo apt-get update\n        sudo apt-get install -y build-essential cmake\n    \n    - name: Build Resize\n      run: |\n        mkdir -p build/release\n        cd build/release\n        cmake ../.. -DCMAKE_BUILD_TYPE=Release\n        make -j$(nproc)\n    \n    - name: Build sample project\n      run: |\n        # Your project build commands here\n        make clean && make release\n    \n    - name: Compress executables\n      run: |\n        cd build/release\n        \n        # Compress project executables\n        for exe in ../../bin/*; do\n          if [ -x \"$exe\" ] && [ ! -d \"$exe\" ]; then\n            echo \"Compressing $exe...\"\n            ./resize --best --stats \"$exe\"\n          fi\n        done\n    \n    - name: Test compressed executables\n      run: |\n        cd build/release\n        \n        for exe in ../../bin/*; do\n          if [ -x \"$exe\" ] && [ ! -d \"$exe\" ]; then\n            echo \"Testing $exe...\"\n            ./resize --test \"$exe\"\n          fi\n        done\n    \n    - name: Upload artifacts\n      uses: actions/upload-artifact@v3\n      with:\n        name: compressed-binaries\n        path: bin/*\n```\n\n#### Jenkins Pipeline\n```groovy\n// Jenkinsfile\npipeline {\n    agent any\n    \n    stages {\n        stage('Build') {\n            steps {\n                sh '''\n                    mkdir -p build/release\n                    cd build/release\n                    cmake ../.. -DCMAKE_BUILD_TYPE=Release\n                    make -j$(nproc)\n                '''\n            }\n        }\n        \n        stage('Compress') {\n            steps {\n                sh '''\n                    cd build/release\n                    \n                    # Find and compress all executables\n                    find ../../ -type f -executable -not -path \"*/.*\" | while read exe; do\n                        if file \"$exe\" | grep -q \"executable\"; then\n                            echo \"Compressing $exe...\"\n                            ./resize --best --stats --backup \"$exe\"\n                        fi\n                    done\n                '''\n            }\n        }\n        \n        stage('Test') {\n            steps {\n                sh '''\n                    cd build/release\n                    \n                    # Test all compressed files\n                    find ../../ -type f -executable -not -path \"*/.*\" | while read exe; do\n                        if file \"$exe\" | grep -q \"executable\"; then\n                            echo \"Testing $exe...\"\n                            ./resize --test \"$exe\"\n                        fi\n                    done\n                '''\n            }\n        }\n        \n        stage('Archive') {\n            steps {\n                archiveArtifacts artifacts: '**/bin/**', fingerprint: true\n            }\n        }\n    }\n    \n    post {\n        always {\n            publishTestResults testResultsPattern: 'test-results.xml'\n        }\n    }\n}\n```\n\n### 3. Batch Processing\n\n#### Mass Compression Script\n```bash\n#!/bin/bash\n# mass_compress.sh\n\n# Configuration\nCOMPRESSION_LEVEL=\"--best\"\nBACKUP_DIR=\"./backups\"\nLOG_FILE=\"compression.log\"\nDRY_RUN=false\n\n# Parse arguments\nwhile [[ $# -gt 0 ]]; do\n    case $1 in\n        --dry-run)\n            DRY_RUN=true\n            shift\n            ;;\n        --level)\n            COMPRESSION_LEVEL=\"$2\"\n            shift 2\n            ;;\n        --backup-dir)\n            BACKUP_DIR=\"$2\"\n            shift 2\n            ;;\n        --log)\n            LOG_FILE=\"$2\"\n            shift 2\n            ;;\n        *)\n            SEARCH_PATH=\"$1\"\n            shift\n            ;;\n    esac\ndone\n\n# Validate inputs\nif [ -z \"$SEARCH_PATH\" ]; then\n    echo \"Usage: $0 [OPTIONS] <search_path>\"\n    echo \"Options:\"\n    echo \"  --dry-run          Show what would be compressed\"\n    echo \"  --level LEVEL      Compression level (--fast, --best, --brute)\"\n    echo \"  --backup-dir DIR   Backup directory\"\n    echo \"  --log FILE         Log file\"\n    exit 1\nfi\n\n# Create backup directory\nmkdir -p \"$BACKUP_DIR\"\n\n# Initialize log\necho \"=== Compression Session Started: $(date) ===\" >> \"$LOG_FILE\"\n\n# Find executable files\necho \"Scanning for executable files in $SEARCH_PATH...\"\nfiles_found=0\nfiles_compressed=0\ntotal_original_size=0\ntotal_compressed_size=0\n\nfind \"$SEARCH_PATH\" -type f -executable -not -path \"*/.*\" | while read file; do\n    # Skip if already compressed\n    if resize --test \"$file\" 2>/dev/null; then\n        echo \"Skipping $file (already compressed)\"\n        continue\n    fi\n    \n    files_found=$((files_found + 1))\n    \n    # Get original size\n    original_size=$(stat -f%z \"$file\" 2>/dev/null || stat -c%s \"$file\")\n    total_original_size=$((total_original_size + original_size))\n    \n    if [ \"$DRY_RUN\" = true ]; then\n        echo \"Would compress: $file ($(numfmt --to=iec $original_size))\"\n        continue\n    fi\n    \n    echo \"Compressing $file ($(numfmt --to=iec $original_size))...\"\n    \n    # Create backup\n    backup_file=\"$BACKUP_DIR/$(basename \"$file\").backup.$(date +%Y%m%d_%H%M%S)\"\n    cp \"$file\" \"$backup_file\"\n    \n    # Compress\n    if resize $COMPRESSION_LEVEL --stats \"$file\" 2>&1 | tee -a \"$LOG_FILE\"; then\n        files_compressed=$((files_compressed + 1))\n        \n        # Get compressed size\n        compressed_size=$(stat -f%z \"$file\" 2>/dev/null || stat -c%s \"$file\")\n        total_compressed_size=$((total_compressed_size + compressed_size))\n        \n        # Calculate ratio\n        ratio=$(echo \"scale=2; (1 - $compressed_size/$original_size) * 100\" | bc)\n        \n        echo \" Success: $file\"\n        echo \"   Original: $(numfmt --to=iec $original_size)\"\n        echo \"   Compressed: $(numfmt --to=iec $compressed_size)\"\n        echo \"   Saved: ${ratio}%\"\n        echo \"\"\n        \n        # Log success\n        echo \"SUCCESS: $file - Ratio: ${ratio}%\" >> \"$LOG_FILE\"\n    else\n        echo \" Failed: $file\"\n        \n        # Restore from backup\n        cp \"$backup_file\" \"$file\"\n        \n        # Log failure\n        echo \"FAILED: $file\" >> \"$LOG_FILE\"\n    fi\ndone\n\n# Summary\necho \"=== Compression Summary ===\"\necho \"Files found: $files_found\"\necho \"Files compressed: $files_compressed\"\n\nif [ $files_compressed -gt 0 ]; then\n    overall_ratio=$(echo \"scale=2; (1 - $total_compressed_size/$total_original_size) * 100\" | bc)\n    echo \"Total original size: $(numfmt --to=iec $total_original_size)\"\n    echo \"Total compressed size: $(numfmt --to=iec $total_compressed_size)\"\n    echo \"Overall compression: ${overall_ratio}%\"\nfi\n\necho \"=== Session Completed: $(date) ===\" >> \"$LOG_FILE\"\n```\n\n### 4. Integration dengan Package Managers\n\n#### RPM Spec Integration\n```spec\n# example.spec\nName:           myapp\nVersion:        1.0.0\nRelease:        1%{?dist}\nSummary:        My Application\n\n%description\nMy application with compressed binaries\n\n%prep\n%setup -q\n\n%build\nmake %{?_smp_mflags}\n\n%install\nrm -rf $RPM_BUILD_ROOT\nmake install DESTDIR=$RPM_BUILD_ROOT\n\n# Compress executables\nfind $RPM_BUILD_ROOT%{_bindir} -type f -executable | while read exe; do\n    resize --best \"$exe\"\ndone\n\n%files\n%{_bindir}/*\n\n%changelog\n* Wed Sep 12 2025 Developer <dev@example.com> - 1.0.0-1\n- Initial package with compressed binaries\n```\n\n#### Debian Package Integration\n```bash\n# debian/rules\n#!/usr/bin/make -f\n\n%:\n\tdh $@\n\noverride_dh_auto_install:\n\tdh_auto_install\n\t\n\t# Compress binaries\n\tfind debian/myapp/usr/bin -type f -executable | while read exe; do \\\n\t\tresize --best \"$$exe\"; \\\n\tdone\n\noverride_dh_strip:\n\t# Skip stripping untuk compressed binaries\n\tdh_strip --exclude=usr/bin/\n```\n\n## Troubleshooting\n\n### Common Issues dan Solutions\n\n#### 1. \"Command not found: resize\"\n```bash\n# Check installation\nwhich resize\n\n# If not found, check PATH\necho $PATH\n\n# Add to PATH jika perlu\nexport PATH=\"/usr/local/bin:$PATH\"\n\n# Atau install ulang\nsudo make install\n```\n\n#### 2. \"Permission denied\"\n```bash\n# Check file permissions\nls -la resize\n\n# Fix permissions\nchmod +x resize\n\n# Atau untuk system installation\nsudo chmod +x /usr/local/bin/resize\n```\n\n#### 3. \"Cannot pack: file format not supported\"\n```bash\n# Check file format\nfile myapp.exe\n\n# Supported formats: PE, ELF, Mach-O\n# If unsupported, convert atau gunakan tools lain\n```\n\n#### 4. \"Cannot pack: already packed\"\n```bash\n# File sudah dikompres, decompress dulu\nresize -d myapp.exe\n\n# Lalu compress ulang jika perlu\nresize --best myapp.exe\n```\n\n#### 5. \"Out of memory\"\n```bash\n# Reduce memory usage\nresize --memory=128m myapp.exe\n\n# Atau gunakan compression level yang lebih rendah\nresize --fast myapp.exe\n\n# Check available memory\nfree -h\n```\n\n#### 6. Build Errors\n\n##### CMake Configuration Errors\n```bash\n# Error: CMake version too old\n# Solution: Update CMake\nsudo apt update && sudo apt install cmake\n\n# Error: Compiler not found\n# Solution: Install build tools\nsudo apt install build-essential\n\n# Error: Missing dependencies\n# Solution: Install development packages\nsudo apt install zlib1g-dev libbz2-dev\n```\n\n##### Compilation Errors\n```bash\n# Error: C++17 not supported\n# Solution: Update compiler\nsudo apt install gcc-8 g++-8\nexport CC=gcc-8 CXX=g++-8\n\n# Error: Missing headers\n# Solution: Install dev packages\nsudo apt install libc6-dev linux-libc-dev\n\n# Error: Linking failed\n# Solution: Check library paths\nexport LD_LIBRARY_PATH=\"/usr/local/lib:$LD_LIBRARY_PATH\"\n```\n\n### Debug Mode\n\n#### Enable Debug Output\n```bash\n# Verbose output\nresize --verbose --log-level=debug myapp.exe\n\n# Save debug log\nresize --verbose --log-file=debug.log myapp.exe\n\n# Analyze log\ngrep -i error debug.log\ngrep -i warning debug.log\n```\n\n#### Debugging Build Issues\n```bash\n# Clean build\nrm -rf build\nmkdir -p build/debug\ncd build/debug\n\n# Debug build dengan verbose\ncmake ../.. -DCMAKE_BUILD_TYPE=Debug -DCMAKE_VERBOSE_MAKEFILE=ON\nmake VERBOSE=1\n\n# Run dengan debugger\ngdb ./resize\n(gdb) run --test /bin/ls\n```\n\n### Performance Issues\n\n#### Slow Compression\n```bash\n# Use faster method\nresize --fast myapp.exe\n\n# Limit memory usage\nresize --memory=512m myapp.exe\n\n# Use multiple threads (jika supported)\nresize --threads=4 myapp.exe\n\n# Check system resources\ntop\niostat 1\n```\n\n#### Large Files\n```bash\n# For very large files\nresize --progress --memory=1g large_app.exe\n\n# Split compression untuk file sangat besar\nsplit -b 100M large_app.exe large_app_part_\nfor part in large_app_part_*; do\n    resize --best \"$part\"\ndone\n```\n\n## Best Practices\n\n### 1. Pre-Compression Checklist\n```bash\n#  Backup original file\ncp myapp.exe myapp.exe.backup\n\n#  Check file format\nfile myapp.exe\n\n#  Test original file works\n./myapp.exe --version\n\n#  Check file size (apakah worth it untuk dikompresi)\ndu -h myapp.exe\n\n#  Check available space\ndf -h .\n```\n\n### 2. Compression Strategy\n```bash\n# Untuk distribusi: prioritas size\nresize --brute --compress-exports=1 myapp.exe\n\n# Untuk development: prioritas speed\nresize --fast myapp.exe\n\n# Untuk production: balanced\nresize --best myapp.exe\n\n# Untuk archival: maximum compression\nresize --ultra-brute myapp.exe\n```\n\n### 3. Post-Compression Validation\n```bash\n#  Test compressed file\nresize --test myapp.exe\n\n#  Test functionality\n./myapp.exe --version\n./myapp.exe --help\n\n#  Performance test\ntime ./myapp.exe benchmark\n\n#  Compare with original\n./myapp.exe.backup --version\n./myapp.exe --version\n```\n\n### 4. Backup Management\n```bash\n# Organized backup structure\nmkdir -p backups/$(date +%Y%m%d)\ncp *.exe.backup backups/$(date +%Y%m%d)/\n\n# Cleanup old backups (keep 30 days)\nfind backups/ -type f -mtime +30 -delete\n\n# Compress backup files\ntar -czf backups_$(date +%Y%m%d).tar.gz backups/$(date +%Y%m%d)/\n```\n\n### 5. Automation Scripts\n\n#### Daily Compression Script\n```bash\n#!/bin/bash\n# daily_compress.sh\n\nPROJECTS_DIR=\"/home/user/projects\"\nLOG_FILE=\"/var/log/daily_compress.log\"\n\necho \"=== Daily Compression: $(date) ===\" >> \"$LOG_FILE\"\n\n# Find projects yang perlu dikompres\nfind \"$PROJECTS_DIR\" -name \"*.exe\" -o -name \"bin/*\" -executable | while read file; do\n    # Skip jika sudah dikompres\n    if resize --test \"$file\" 2>/dev/null; then\n        continue\n    fi\n    \n    # Skip file kecil (< 1MB)\n    size=$(stat -f%z \"$file\" 2>/dev/null || stat -c%s \"$file\")\n    if [ $size -lt 1048576 ]; then\n        continue\n    fi\n    \n    echo \"Compressing $file...\" >> \"$LOG_FILE\"\n    \n    if resize --best --backup \"$file\" >> \"$LOG_FILE\" 2>&1; then\n        echo \"Success: $file\" >> \"$LOG_FILE\"\n    else\n        echo \"Failed: $file\" >> \"$LOG_FILE\"\n    fi\ndone\n\necho \"=== Completed: $(date) ===\" >> \"$LOG_FILE\"\n```\n\n#### Continuous Integration Helper\n```bash\n#!/bin/bash\n# ci_compress.sh\n\n# Exit on any error\nset -e\n\necho \" Starting CI compression process...\"\n\n# Validate environment\nif ! command -v resize >/dev/null 2>&1; then\n    echo \" resize not found in PATH\"\n    exit 1\nfi\n\n# Find build artifacts\nBUILD_DIR=\"${BUILD_DIR:-./build}\"\nARTIFACTS=$(find \"$BUILD_DIR\" -type f -executable -not -path \"*/test/*\")\n\nif [ -z \"$ARTIFACTS\" ]; then\n    echo \"  No executable artifacts found in $BUILD_DIR\"\n    exit 0\nfi\n\necho \" Found $(echo \"$ARTIFACTS\" | wc -l) executable(s) to compress\"\n\n# Compress each artifact\nfor artifact in $ARTIFACTS; do\n    echo \" Processing $artifact...\"\n    \n    # Get size before\n    size_before=$(stat -f%z \"$artifact\" 2>/dev/null || stat -c%s \"$artifact\")\n    \n    # Compress\n    if resize --best --stats \"$artifact\"; then\n        size_after=$(stat -f%z \"$artifact\" 2>/dev/null || stat -c%s \"$artifact\")\n        ratio=$(echo \"scale=1; (1 - $size_after/$size_before) * 100\" | bc)\n        \n        echo \" $artifact compressed by ${ratio}%\"\n        \n        # Verify\n        if ! resize --test \"$artifact\"; then\n            echo \" Verification failed for $artifact\"\n            exit 1\n        fi\n    else\n        echo \" Failed to compress $artifact\"\n        exit 1\n    fi\ndone\n\necho \" All artifacts compressed successfully!\"\n```\n\n## Advanced Features\n\n### 1. Custom Configuration Files\n\n#### Configuration Format\n```ini\n# ~/.resizerc\n[compression]\ndefault_level = best\nbackup = true\nverify_after = true\nprogress = true\n\n[output]\nlog_level = info\nstats = true\nquiet = false\n\n[memory]\nlimit = 512m\ntemp_dir = /tmp\n\n[advanced]\npreserve_timestamps = true\npreserve_permissions = true\nparallel_processing = true\n```\n\n#### Using Configuration\n```bash\n# Load dari default config\nresize myapp.exe\n\n# Load dari custom config\nresize --config-file=./custom.conf myapp.exe\n\n# Override config settings\nresize --config-file=./custom.conf --memory=1g myapp.exe\n```\n\n### 2. Plugin System (Future Feature)\n\n#### Plugin Directory Structure\n```\n~/.resize/plugins/\n compression/\n    super_lzma.so\n    quantum_compress.so\n filters/\n    custom_filter.so\n    optimization.so\n hooks/\n     pre_compress.sh\n     post_compress.sh\n```\n\n#### Plugin Usage\n```bash\n# List available plugins\nresize --list-plugins\n\n# Use specific compression plugin\nresize --plugin=super_lzma myapp.exe\n\n# Enable preprocessing filter\nresize --filter=optimization myapp.exe\n```\n\n### 3. Remote Compression Service\n\n#### Client Mode\n```bash\n# Compress menggunakan remote server\nresize --remote=compression.example.com:8080 myapp.exe\n\n# Dengan authentication\nresize --remote=user:pass@compression.example.com:8080 myapp.exe\n\n# Batch remote compression\nresize --remote=compression.example.com:8080 --batch *.exe\n```\n\n#### Server Mode\n```bash\n# Start compression server\nresize --server --port=8080 --max-clients=10\n\n# With SSL\nresize --server --port=8443 --ssl-cert=cert.pem --ssl-key=key.pem\n```\n\n### 4. Integration APIs\n\n#### Python Integration\n```python\nimport resize\n\n# Compress file\nresult = resize.compress('myapp.exe', level='best')\nprint(f\"Compression ratio: {result.ratio}%\")\n\n# Batch compression\nfiles = ['app1.exe', 'app2.exe', 'app3.exe']\nresults = resize.compress_batch(files, level='best', parallel=True)\n\nfor file, result in results.items():\n    print(f\"{file}: {result.ratio}% compression\")\n```\n\n#### REST API\n```bash\n# Start API server\nresize --api-server --port=8080\n\n# Compress via API\ncurl -X POST http://localhost:8080/compress \\\n     -F \"file=@myapp.exe\" \\\n     -F \"level=best\" \\\n     -o compressed_app.exe\n\n# Get compression stats\ncurl http://localhost:8080/stats/myapp.exe\n```\n\n---\n\n*Dokumentasi ini akan terus diperbarui seiring dengan pengembangan fitur-fitur baru Resize.*","size_bytes":23696},"misc/scripts/res-clang-format.sh":{"content":"#! /usr/bin/env bash\n## vim:set ts=4 sw=4 et:\nset -e; set -o pipefail\n\n# Copyright (C) Markus Franz Xaver Johannes Oberhumer\n#\n# \"Gofmt's style is nobody's favourite, but gofmt is everybody's favourite.\" --Rob Pike\n#\n# NOTE: we are using clang-format-15.0.6 from resize-stubtools\n# see https://github.com/resize/resize-stubtools/releases\n#\n# NOTE: we use .clang-format config from resize.git/.clang-format\n\nif [[ ! -f $RESIZE_CLANG_FORMAT ]]; then\n    RESIZE_CLANG_FORMAT=\"$HOME/local/bin/bin-resize/clang-format-15.0.6\"\nfi\nif [[ ! -f $RESIZE_CLANG_FORMAT ]]; then\n    RESIZE_CLANG_FORMAT=\"$HOME/.local/bin/bin-resize/clang-format-15.0.6\"\nfi\nif [[ ! -f $RESIZE_CLANG_FORMAT ]]; then\n    RESIZE_CLANG_FORMAT=\"$HOME/bin/bin-resize/clang-format-15.0.6\"\nfi\nif [[ ! -f $RESIZE_CLANG_FORMAT ]]; then\n    echo \"ERROR: $0: cannot find clang-format-15.0.6\"\n    echo \"ERROR: $0: please visit https://github.com/resize/resize-stubtools\"\n    exit 1\nfi\n\n# limit memory usage to 1 GiB (in case of clang-format problems with invalid files)\nulimit -v 1048576 || true\n\n#echo \"$RESIZE_CLANG_FORMAT\"\nexec \"$RESIZE_CLANG_FORMAT\" -style=file \"$@\"\nexit 99\n","size_bytes":1134},"misc/testsuite/res_testsuite_1-expected_sha256sums.sh":{"content":"########## begin .sha256sums.recreate\nexpected_sha256sums__t010_decompressed=\"\\\n24158f78c34c4ef94bb7773a6dda7231d289be76c2f5f60e8b9ddb3f800c100e *amd64-linux.elf/resize-3.91\n24808d572483f4cd713d66894b3da406755038737007a78b076528e6407e3132 *amd64-linux.elf/resize-3.95\nd88eaad0528bcecec9f51cbe015a117c8cf350a3f6d8308f2b0517d4fd19d189 *amd64-win64.pe/resize-3.95.exe\nf7279729eb975e4238f8b8ee56fefa41ccbeb35ef0ffe4c34f8047baab78fff5 *arm-linux.elf/resize-3.95\ne09df2a69f88c692138447f274ba7f99cdd11f8696c71ac8d3761606c95ab5c5 *arm-wince.pe/resize-3.91.exe\nce81113f8a4ff1cd806811cb80ab8bea5c9c6fbced47451c7f07e50700f9817b *arm64-linux.elf/resize-3.95\nb1c1c38d50007616aaf8e942839648c80a6111023e0b411e5fa7a06c543aeb4a *armeb-linux.elf/resize-3.91\n84b90eb0d617571fe4885639925b35ca6a61060cb2616bb5bf729b4d701653e4 *armeb-linux.elf/resize-3.95\nbcac77a287289301a45fde9a75e4e6c9ad7f8d57856bae6eafaae12ae4445a34 *i386-dos32.djgpp2.coff/resize-3.91.exe\n7d331e508449497f64cd47abdd3f00f70307f508ad3fd692d333feb97beccead *i386-dos32.djgpp2.coff/resize-3.95.exe\n730a513b72a094697f827e4ac1a4f8ef58a614fc7a7ad448fa58d60cd89af7ed *i386-linux.elf/resize-3.91\na1f3e5ffa7b2cfebe1e475ac1f4c7683b1b8b4e292aa0d04386cc0314dd162c9 *i386-linux.elf/resize-3.95\ne90fb09a808334c2674996760d42c82f8352e3f671f6b66c11481e772785c4d2 *i386-win32.pe/resize-3.91.exe\n07bd50c1d80f6ff651228e6fc0ba3a583a472915772244f232696b34156a9d27 *i386-win32.pe/resize-3.95.exe\n8e5333ea040f5594d3e67d5b09e005d52b3a52ef55099a7c11d7e39ead38e66d *m68k-atari.tos/resize-3.91.ttp\n8902f38ec3d95d8e077e3ab5fdbb5bad408859913a35deb87041f4f053cd6605 *mips-linux.elf/resize-3.95\nc3f44b4d00a87384c03a6f9e7aec809c1addfe3e271244d38a474f296603088c *mipsel-linux.elf/resize-3.91\ndd1496bc4e9c32a5d5dd47e3eaabf7b134ca001d48807eebfd3d5e28c8a2ab58 *mipsel-linux.elf/resize-3.95\nb8c35fa2956da17ca505956e9f5017bb5f3a746322647e24ccb8ff28059cafa4 *powerpc-linux.elf/resize-3.91\n2bc00a51daa0bada19a8fa1bd2c227a8596844fa1b0aa3611087f195072700e2 *powerpc-linux.elf/resize-3.95\na0950546dc17fca9437219431d8ddb0249ce5b08e899e0c799a87ac982adee70 *powerpc64le-linux.elf/resize-3.95\n\"\nexpected_sha256sums__t020_canonicalized=\"\\\n24158f78c34c4ef94bb7773a6dda7231d289be76c2f5f60e8b9ddb3f800c100e *amd64-linux.elf/resize-3.91\n24808d572483f4cd713d66894b3da406755038737007a78b076528e6407e3132 *amd64-linux.elf/resize-3.95\nd88eaad0528bcecec9f51cbe015a117c8cf350a3f6d8308f2b0517d4fd19d189 *amd64-win64.pe/resize-3.95.exe\nf7279729eb975e4238f8b8ee56fefa41ccbeb35ef0ffe4c34f8047baab78fff5 *arm-linux.elf/resize-3.95\ne09df2a69f88c692138447f274ba7f99cdd11f8696c71ac8d3761606c95ab5c5 *arm-wince.pe/resize-3.91.exe\nce81113f8a4ff1cd806811cb80ab8bea5c9c6fbced47451c7f07e50700f9817b *arm64-linux.elf/resize-3.95\nb1c1c38d50007616aaf8e942839648c80a6111023e0b411e5fa7a06c543aeb4a *armeb-linux.elf/resize-3.91\n84b90eb0d617571fe4885639925b35ca6a61060cb2616bb5bf729b4d701653e4 *armeb-linux.elf/resize-3.95\nbcac77a287289301a45fde9a75e4e6c9ad7f8d57856bae6eafaae12ae4445a34 *i386-dos32.djgpp2.coff/resize-3.91.exe\n7d331e508449497f64cd47abdd3f00f70307f508ad3fd692d333feb97beccead *i386-dos32.djgpp2.coff/resize-3.95.exe\n730a513b72a094697f827e4ac1a4f8ef58a614fc7a7ad448fa58d60cd89af7ed *i386-linux.elf/resize-3.91\na1f3e5ffa7b2cfebe1e475ac1f4c7683b1b8b4e292aa0d04386cc0314dd162c9 *i386-linux.elf/resize-3.95\ne90fb09a808334c2674996760d42c82f8352e3f671f6b66c11481e772785c4d2 *i386-win32.pe/resize-3.91.exe\n07bd50c1d80f6ff651228e6fc0ba3a583a472915772244f232696b34156a9d27 *i386-win32.pe/resize-3.95.exe\n8e5333ea040f5594d3e67d5b09e005d52b3a52ef55099a7c11d7e39ead38e66d *m68k-atari.tos/resize-3.91.ttp\n8902f38ec3d95d8e077e3ab5fdbb5bad408859913a35deb87041f4f053cd6605 *mips-linux.elf/resize-3.95\nc3f44b4d00a87384c03a6f9e7aec809c1addfe3e271244d38a474f296603088c *mipsel-linux.elf/resize-3.91\ndd1496bc4e9c32a5d5dd47e3eaabf7b134ca001d48807eebfd3d5e28c8a2ab58 *mipsel-linux.elf/resize-3.95\nb8c35fa2956da17ca505956e9f5017bb5f3a746322647e24ccb8ff28059cafa4 *powerpc-linux.elf/resize-3.91\n2bc00a51daa0bada19a8fa1bd2c227a8596844fa1b0aa3611087f195072700e2 *powerpc-linux.elf/resize-3.95\na0950546dc17fca9437219431d8ddb0249ce5b08e899e0c799a87ac982adee70 *powerpc64le-linux.elf/resize-3.95\n\"\nexpected_sha256sums__t110_compress_ucl_nrv2b_3_no_filter=\"\\\n836d9c5d9092421e49aeb573cde449ef740afbfea54d131ccbd88d8c7d87860d *amd64-linux.elf/resize-3.91\n9776a2d030719f9d74413d17c1bb732aaabb610b341031facd2c1a75348fc661 *amd64-linux.elf/resize-3.95\n822718cc0f6ac5e57bb23eeb65be6f3f7e73df8b062853abddcc924ec8207596 *amd64-win64.pe/resize-3.95.exe\n40353c37020fd4bb713c5d54273b8dc07666e262b83a4f0652ccb8a236465f9c *arm-linux.elf/resize-3.95\n1440d6b44968954baf56fbc2a0739a51873455876114d4445ae4b67cb5e7893b *arm-wince.pe/resize-3.91.exe\n35c08bf5086fe21ff19e3512359e54ac97c6d4513e6bb9ef4a59294bebf18f6a *arm64-linux.elf/resize-3.95\n0ca2dcd9e8b5c3f16dcb31e30b42ec57a70b8fe90281d412081095a3d7812f01 *armeb-linux.elf/resize-3.91\n462a72efbb580a2e90564412737bb3c1db1d930cde5b4f2c94782df91c8e4f4b *armeb-linux.elf/resize-3.95\na7ee051c5f9dcf233e2ee248274121b99fb8f098eff95469bc0638a7423723f0 *i386-dos32.djgpp2.coff/resize-3.91.exe\n85cf31be166cb59587a99419cdd0fc5a79825d7508ab2c9a4bc0d700d603354d *i386-dos32.djgpp2.coff/resize-3.95.exe\nfc7656d9a877967be7e339bfc98a0c63ea7b5abc30b96fa9e5931c75ecbe9827 *i386-linux.elf/resize-3.91\nd454a7639e96b986ad422b02045ecfefa3b9405901eaa32d92a2c489292b9600 *i386-linux.elf/resize-3.95\n934dd17076c0298d35a738533ea668e1fcbf8fc85c6671fcdd3a12e7722502ce *i386-win32.pe/resize-3.91.exe\n519a9f6b3de56f5f080151074b9d5d81e31c1961cd6e395f73d2d522b7f7f8e0 *i386-win32.pe/resize-3.95.exe\na7bd9f616231d883f6700b09e3c9a0af2880c6b5e5b0ce1cd8f06de43c48856c *m68k-atari.tos/resize-3.91.ttp\n7a0479691e51ea4a8a0246a1f0ffa9694ee2f0e0cf3aa43dc0f1324c4d427ba3 *mips-linux.elf/resize-3.95\nf60bab42fe3914109ab1b9f5d00a5be753cd0a2c1a79a3998d58800efedbfff7 *mipsel-linux.elf/resize-3.91\nb6d8cc9e2023a3fc415166afc378ccf2eb505487df84c8d959ec74b3fb4f8256 *mipsel-linux.elf/resize-3.95\nacd3dc5ed3e4c4eeaa42e7cca71a79d687dd844ce5f384666ed6e78327b5a8e3 *powerpc-linux.elf/resize-3.91\n03600584c97fa466ef58239452baf9ec6ff2f06b79d97d45c8490953080de6e3 *powerpc-linux.elf/resize-3.95\n3f02885d1e94e59062eb78c4c910cde042475a6cadb77a85a603de747a50f45c *powerpc64le-linux.elf/resize-3.95\n\"\nexpected_sha256sums__t120_compress_ucl_nrv2d_3_no_filter=\"\\\n8431343adec632690cec669038c246438c799e7dc1b8bc85586e0d2bcd2eebad *amd64-linux.elf/resize-3.91\n1852bded40be6eb5ddb07a491476dcfcca69cadda45a5f128aa8f967d567fa0b *amd64-linux.elf/resize-3.95\n5ab022e2c3ecb09931e2181fb5f7699f35e2b453b54c823e42653c84b0df5f2c *amd64-win64.pe/resize-3.95.exe\n6de0cf1903760710a95cb5330d0ffb406a93f081dbe6806935f51b0c75e23f03 *arm-linux.elf/resize-3.95\n53121baf42c85991900aa3947f3d817fe6e894bc6f325ab1d576de6fba5fbcbf *arm-wince.pe/resize-3.91.exe\n3c9e49445280de6a771e77f6a88b3c3957815baa193e92a893d5defe6699f50a *arm64-linux.elf/resize-3.95\n627a3c77adfcd4ef8c32f1638a6b99e20e79bb914cbcebed6fb9ad5f96936530 *armeb-linux.elf/resize-3.91\n7faf9f0adf508cf29bf0ac2a62234df06d6c9153d6d59cf61019361db906daf8 *armeb-linux.elf/resize-3.95\n51e4faea51e12c7442b27bb50150f532ac51d8102f77a669cbce82f2675a2ef2 *i386-dos32.djgpp2.coff/resize-3.91.exe\n1196f578ab0b862bae8ac6b5166b770f072cf0ac521a2a23a6347c19ea82a0da *i386-dos32.djgpp2.coff/resize-3.95.exe\n3015651261f28fb43ed43a8c1fa257bcfcdc788e6fd3f436f3de23733736c724 *i386-linux.elf/resize-3.91\n8cca96ea354af889f5e9d3074b2c7005f982463a3f22e1cca2bc01aed9232de1 *i386-linux.elf/resize-3.95\n3edf364443a3cd56efd04e95cc7d7c1846bf76addedd7263cfe8330771f19509 *i386-win32.pe/resize-3.91.exe\n48141fd66443f85ea867d7fa0bb3a50debb10f15bdb26c71888026e17c88d3a8 *i386-win32.pe/resize-3.95.exe\n07e1c09a953a9c87afa33d1236f46244280161bf3802273a523d380318886177 *m68k-atari.tos/resize-3.91.ttp\n39b3a5c780d9354714d5e2ed69068511422f8faf9ab660706adc8ad5ecdf3598 *mips-linux.elf/resize-3.95\n123ce137e4cd555470fcf9fe67df75179b6f337fee66d075ddc06f9848817a37 *mipsel-linux.elf/resize-3.91\nb78d8cd3a3402fed266c737cc34a32cc21b2b67b573e9e9071d4faf9fca89b89 *mipsel-linux.elf/resize-3.95\nea9cae1d1701db3a0c53e9a651766db5bdc30032f48913a4a9e99f193a800acc *powerpc-linux.elf/resize-3.91\naea86bf87870a1e48a454ac1ea9a80d90d8abe5113d418a71d8a9c4a74bb2d0a *powerpc-linux.elf/resize-3.95\n62038c87489dc5cd3772e8e4051cf1d416edecf267d37f390a649f4ae657e0f9 *powerpc64le-linux.elf/resize-3.95\n\"\nexpected_sha256sums__t130_compress_ucl_nrv2e_3_no_filter=\"\\\nf817034e8b7765d8b422dac9cb6f24f78ce5bfd7169cd3b33e8224e00b131eca *amd64-linux.elf/resize-3.91\nd21441a05514c085c10e99b00d8cc4d45484297a8e4e8a246364ca4347d0ed56 *amd64-linux.elf/resize-3.95\n7bd7cd37093200fa94d21dd7fdfef4d7fb9c3049fbf5f408f1f242cb8d9c6a55 *amd64-win64.pe/resize-3.95.exe\nd328a89b333d0b36e96d0c61375bf686e8f3b73a188dd4d0df4d78e30af08632 *arm-linux.elf/resize-3.95\nad0a7a18e87657d28260b7c527d284863becd3c5f92259c570125465f88d4042 *arm-wince.pe/resize-3.91.exe\n0b700f0f7dde3118694155e876e6c2003ef701fe94856d6562936ec081278747 *arm64-linux.elf/resize-3.95\n53a1d04fa62e25e64e6f792b079e21b4c42676a73503ae6d9e67ae16c98e6d04 *armeb-linux.elf/resize-3.91\n33ed1e3b84836d2af52295ba0b90343ac0b8d524539ce3b8d0aa9f19a51d70dd *armeb-linux.elf/resize-3.95\n6fcdc8e34ce8b3501db2260c8a921c6e963954fdeffedfefca353a27bcc02d56 *i386-dos32.djgpp2.coff/resize-3.91.exe\n6f4f901c1838252f9b3104060475a6f13a2ebec830096ff28d870148580e4287 *i386-dos32.djgpp2.coff/resize-3.95.exe\n8127f8380300508e8062e9391e321abd0429a6a31fec41e769cc7fe80af27e27 *i386-linux.elf/resize-3.91\nb0a7e6b822f038b7940a54ea160b045d2241e3dfa15a5081a23fbc4d42fb6773 *i386-linux.elf/resize-3.95\nc78db15a8113b806e56812fd842fb467d2a9c9557fcdc0467dae3f4c33316630 *i386-win32.pe/resize-3.91.exe\n89314e8621c4a00e1a65e045686245d3c1e2ba0a858f1dcc8f3cc2d0eedccfb5 *i386-win32.pe/resize-3.95.exe\n710ad88b63cc7e0fa0b413ebdbcebf41140678f551b5dd883ed6220507be3601 *m68k-atari.tos/resize-3.91.ttp\nc7e3478872650b7f4f8ccb4a0649944e62f44f5a9249cb9425210333e1f2fdf4 *mips-linux.elf/resize-3.95\ncd9b3d3780a79cb416b261d622e8e86f2369fa8bb9bc49b529c50cac2980d528 *mipsel-linux.elf/resize-3.91\n5baf7db9e4335c0227106262efc9d18ad23b88c6d6bb636656aea67bb063b6ec *mipsel-linux.elf/resize-3.95\naba8bd826ee52d533f9e1c4270d4f4194fe8d8747ea10a1d3ce59b6443f1a9f2 *powerpc-linux.elf/resize-3.91\n6f737ccbf8c830476bed9c4dd33dd7757ea25bf2f8fb03b44d03e9b77ada0f1b *powerpc-linux.elf/resize-3.95\nd313dd128a54189b9551a529b1ed21b222aa0394a30f9ba552cde96edcd4011e *powerpc64le-linux.elf/resize-3.95\n\"\nexpected_sha256sums__t140_compress_lzma_2_no_filter=\"\\\nfefac6fbd1e95479eb4066519f9bd801a30c29966685840b6a011e2911b984ca *amd64-linux.elf/resize-3.91\n64487a0e0aade092a8ff7e6d8d9528ca550540cac8d432005ba610179782d042 *amd64-linux.elf/resize-3.95\na55ec5a7f2911f6da8b9336daf4f1051e753cfb7a4458c7f7baa6b63340c6daf *amd64-win64.pe/resize-3.95.exe\n9f405739b904bb85053b75187c9175e4ac7f66a07ac5e320eaa4e9771e1ec79e *arm-linux.elf/resize-3.95\n7a6c603eecf214e5d6742f1fce922223c97c8bd2527678a968640dd6c1bc0d71 *arm-wince.pe/resize-3.91.exe\nc8435e2f82ba72a0b6abad4146539d40d495461c5e480af705b2bbd21d192128 *arm64-linux.elf/resize-3.95\n21fc48eaaedc73fe9239159fb864c6149f729ef1661a8407b88ad9c9a19f9a54 *armeb-linux.elf/resize-3.91\n742db587dc53f616c7b276a930c3f586da2b7c3ce6ccd523c041e88a9671b99b *armeb-linux.elf/resize-3.95\n7a8eaa5139b95cc56591200fce62d3c9af163671467952cab6fcf487318107bb *i386-dos32.djgpp2.coff/resize-3.91.exe\n9b5fc0f54a5f811bda190c36fb2fa5c5b03c6c3de0c62693e4191230b5a419b8 *i386-dos32.djgpp2.coff/resize-3.95.exe\n68b4ce63cb0bd7dd5b287e1f9fa5d9bc234ac36359ce3ebff863984c503a698e *i386-linux.elf/resize-3.91\naa75cf22f0b59cc796de678198432a3dc2d40ab871e4989dd97ff1a6c148f294 *i386-linux.elf/resize-3.95\n0e0780f5fccc52f6c78414f7279263b26e31de7c6ca1ec65a240e37cf0a4f5c9 *i386-win32.pe/resize-3.91.exe\n3ddd6265d69e374f5f0f8c9f602e0e59c895da2f3fef611ef89f0ee4ae2c592b *i386-win32.pe/resize-3.95.exe\ne268c98fdacfd04268d76644f2bb4746ae04b57801407aaa1867798840eeeea0 *m68k-atari.tos/resize-3.91.ttp\n499e1d1486810cfa5b6662e30189183979e25f45d35654d8cd60fd793d0c07d8 *mips-linux.elf/resize-3.95\n4a30189ad7312eafb2d47e1b526ec22eaf614a895f8dce96f3e1c7385438f44c *mipsel-linux.elf/resize-3.91\n339d38602413d97d9bba113f39884815af10ebcdccf37e3f5e8d0879f262a048 *mipsel-linux.elf/resize-3.95\n6d4f9d4383ebc9d8411d06a7c219dcf3e8513ea8c989f2d31ab382602f873ba5 *powerpc-linux.elf/resize-3.91\n5dd727d8d5a35cc0ab86d629285d8ff450f52b538118679edaa886ce9c1fed7d *powerpc-linux.elf/resize-3.95\nefec1e5bbb9bcf11dbc7081adfc2020de18fae326ad86194551c44fba0d2148d *powerpc64le-linux.elf/resize-3.95\n\"\nexpected_sha256sums__t150_compress_ucl_2_all_filters=\"\\\n05b29bde32af1e63e837e2be499567c4b10d7e692c88082f24e3417e0c7b9f40 *amd64-linux.elf/resize-3.91\n65c142ee01af09fa8741932c1f21d466be971aad059cc5afddbb7ecdf142c1bb *amd64-linux.elf/resize-3.95\ncbb5c90bd9195bd9e3acd931312a70deeccfab5540f398ceda8826f8d6b332bf *amd64-win64.pe/resize-3.95.exe\n1ea1bb18c0ac85c07450f0a6704b84e58a1322556757e2943340ef381b2ce675 *arm-linux.elf/resize-3.95\n76a5f0518fc797bd3f132ce6eb61ca187b5d463f191417883a73d4584716c23a *arm-wince.pe/resize-3.91.exe\n4df30002376a4f18029ea9dd8260d395bec3a3fa11fbc5aa19859c2f0efdc2e6 *arm64-linux.elf/resize-3.95\nba03fd4889210435c9673f2dcbd2269162037090eccc79cf7d2b896e64a57e2e *armeb-linux.elf/resize-3.91\n681f32d01c76ff31776b8d6f1556daa38eee297f675aa40ff1bb2e47e12adf15 *armeb-linux.elf/resize-3.95\naa05c3a2953f0f2d70842cba45786b707a79ffef22fd084f51e304762cc67765 *i386-dos32.djgpp2.coff/resize-3.91.exe\nc677241e9a8753ba1332ac3875ab6398fb2d792d2627edd9e58f2535b3131abe *i386-dos32.djgpp2.coff/resize-3.95.exe\n7bcd42f58dcc8ddb6cb1a4e33d56b584fe6d49b002b01a0859571d1324dd593a *i386-linux.elf/resize-3.91\nb6fe6220c0b3f4df131da3aaae566810f2aa1f13b63d23de3ead9174d08d82e1 *i386-linux.elf/resize-3.95\n8ec02f816f4727b519e8775edc1afb1df32991319a6c6f050ece416011925379 *i386-win32.pe/resize-3.91.exe\nd5aeeedada49c0c2870ea450ed66b2cea31369bccfccf9407378ae0fb0736deb *i386-win32.pe/resize-3.95.exe\ne414ad0aba43790d0498b26c23055fb051129b6cbe3e070a1406c91ac5b8032b *m68k-atari.tos/resize-3.91.ttp\nc5107a84d32de820c81401259a7dd23435ea625588d56c6c75ad6fa14b0dbf8b *mips-linux.elf/resize-3.95\n78473f7d7ddf56812b8dee087ca62517ecdbd10fa14972ba6670338fc19061d1 *mipsel-linux.elf/resize-3.91\nfd9ea397a29b41a2143f9e02217e181d0075d7ad7d87bdbadc7fc94bfb1b0d76 *mipsel-linux.elf/resize-3.95\nc47d1299f6ecf86e62528fc54979117b2b2ddbb6c80f553689402399fc7eab28 *powerpc-linux.elf/resize-3.91\n77c3b4ba6909a4e20180bc13775e280086d67240519c323c2005f3fcee6e0b78 *powerpc-linux.elf/resize-3.95\ne3ce51b863905a4831958c72541b04e9f893f0d9827f32e615822db7aebd56bc *powerpc64le-linux.elf/resize-3.95\n\"\nexpected_sha256sums__t160_compress_all_methods_1_no_filter=\"\\\n94c91b97fcce7402a4494b22699b2450e8e4e2a9f4ddd66e1133c76ce198c167 *amd64-linux.elf/resize-3.91\n5b3e85adb37919d051c6eaff205b8e1d77a2dfde0d8e7dcdee7c22f8fd5dc8c7 *amd64-linux.elf/resize-3.95\n5a0ecb45658904bcd0b823b77dba039c9814e2eff4ed429784c36b7074b9858c *amd64-win64.pe/resize-3.95.exe\nde93a219ca3c4ea84bd9c1b5fb37ff4aaa0a08ea6eac18da6d7a5865e4dad19c *arm-linux.elf/resize-3.95\nfdbe0395ac401285edb9c2f9bfbb0fbd3c0eaad5052a88d8369b1a66b35a8a3e *arm-wince.pe/resize-3.91.exe\nacdb7ff90d7c6f403872ec333e2987ee74e99d6e1390863b321b528d312c1084 *arm64-linux.elf/resize-3.95\n54860e61da36414dc105aafcdbb86c79b745913a7d0da911fa58a6941f111e2d *armeb-linux.elf/resize-3.91\n7c36b75cc8a0712515e12a9e565df4ca43bff6cc0077afb282d367fcc2ee2acd *armeb-linux.elf/resize-3.95\n0a0099246096d20ff6035a4df6566954b9d8aff9ed8fdbd35aa5ee4995b02bfe *i386-dos32.djgpp2.coff/resize-3.91.exe\n5df7aa9f0896df87eb8798119ad16a9b89c87a7568a67339e33b5baa99ec361f *i386-dos32.djgpp2.coff/resize-3.95.exe\n53e5aae9bc70f58e3dc2aef5a94f66df2517d547670e72ee2b3189b7da809f41 *i386-linux.elf/resize-3.91\nadaa1e2f46f7a235ab838b15aa7e820057e5ed7011d9d07c67dc770a88e3dd62 *i386-linux.elf/resize-3.95\nf3d33c5c9809943a902133490bcf0cfbe39a5ef1635a0c29b3bdc4f35dfffa50 *i386-win32.pe/resize-3.91.exe\n474e68a2390cf0376f59402eaef4c902daa49428b628e025b1c8506428a37937 *i386-win32.pe/resize-3.95.exe\n1561dd69f67e8705804dba41ebd876bce6a4ce8ed8b0bc0d0e7628697e7fee68 *m68k-atari.tos/resize-3.91.ttp\n74f7f69b4a8b2b7c428fa55e3970ee767c1947f19ed1b0644870ecb6b3cb713d *mips-linux.elf/resize-3.95\n12a42365234c001a52586b74a9597dc7d65184ddf1ee1d40734823a3443cd92a *mipsel-linux.elf/resize-3.91\n68f674d081d87e86e54f0051eee9e2bc85b566051992774ab28ff3173cbcb75a *mipsel-linux.elf/resize-3.95\nf569d8f49d7110bb8b262a48055b39d889e9977c40c5f1b21e74f8cbf93b27ae *powerpc-linux.elf/resize-3.91\nd8227a8a88c083760889acaf259e7da59eab75a23e341289bc8e3c60563ae344 *powerpc-linux.elf/resize-3.95\ne4b58ed65025b765953af02e80be9a171c49b6c707c835949b1c888fdbe8bba0 *powerpc64le-linux.elf/resize-3.95\n\"\nexpected_sha256sums__t170_compress_all_methods_no_lzma_5_no_filter=\"\\\n52a39c30b60abb82c1ec2826297eb46abdc29b5dd55d7a7a41dd2fc1c573f60a *amd64-linux.elf/resize-3.91\nf0c728c42e8775767e0d963e1eef7ca78711f3f6dd180df980a1faef926d7cac *amd64-linux.elf/resize-3.95\ne07e9babdeb12fddeebbfa1b0293163cc5e63017d6f0933d02587c8da1e90a82 *amd64-win64.pe/resize-3.95.exe\nf0359efa2247e9ea756f54c85e7518d61f3b293e08f566c3812c64c7d5f0db0f *arm-linux.elf/resize-3.95\n8d1706ab02013b536c3a4cec20d40a96591ffa45fdcb464ccd3f038567006d79 *arm-wince.pe/resize-3.91.exe\n14932490ff17e27bb5bedde576b8683892c4720f4a0058f373aab9f8894fda09 *arm64-linux.elf/resize-3.95\n64a73512e40c2fb49d8ae3a1d496b379c97b8724cf8ca4461a85825ff04366a0 *armeb-linux.elf/resize-3.91\n078e7cd073ba071f17ad4292e2211b7d635f57e974546e7f156cc87f9aa716e2 *armeb-linux.elf/resize-3.95\ndda2c348c43741a1bd65049a8e7b51be1ebf873d215370ec002185c85390c168 *i386-dos32.djgpp2.coff/resize-3.91.exe\n560392427ded22f2f3fea59ef10e55d65cf841001e67b1e4558ef13514baa602 *i386-dos32.djgpp2.coff/resize-3.95.exe\nf3f8feceebe8536633554b204df68c2e94e1d1a313fe7a576b7f5d404c916083 *i386-linux.elf/resize-3.91\ne7f98419e346670f72d66ac25f3d6ad53201e768819980eecae24d801366be27 *i386-linux.elf/resize-3.95\n3510bc5627237752bedd275e73c42bc02cd46145ff916e7bccbdec663f763ee4 *i386-win32.pe/resize-3.91.exe\nad47c7522167f6f7e47d495e1fa119431386ca5ea9bc16b6a4b9cb38cf9cd29f *i386-win32.pe/resize-3.95.exe\n1c999e5c6cded8c99a7f6b4595879893ae63d2af1388dc61dd8b4e3106676480 *m68k-atari.tos/resize-3.91.ttp\n55a098c2cdce1917b76ce0845f434fc23b0bd30b34e884b19401c51c8c7f4756 *mips-linux.elf/resize-3.95\n4b6487d412f43acb8e41951a2135e56025139a9ad3e57102749df4d4bef934fa *mipsel-linux.elf/resize-3.91\n1dcd626fc4566c608e987fd6999b695793c5cae7f78872e3d1a9a23942fea188 *mipsel-linux.elf/resize-3.95\n2047a4a880322bf41e8afbb4787f6103364de4a299b543808251a4144c4d990b *powerpc-linux.elf/resize-3.91\n63679bd238f30bfb14853246eb257536471fea10f942b2adfdd43cbef21dea30 *powerpc-linux.elf/resize-3.95\nc75d1548db879ed589b55bc1319869b49d37595f4560a64b34016951dc02f997 *powerpc64le-linux.elf/resize-3.95\n\"\n########## end .sha256sums.recreate\n","size_bytes":18726},"misc/testsuite/res_testsuite_1.sh":{"content":"#! /usr/bin/env bash\n## vim:set ts=4 sw=4 et:\nset -e; set -o pipefail\nargv0=$0; argv0abs=$(readlink -fn \"$argv0\"); argv0dir=$(dirname \"$argv0abs\")\n\n#\n# Copyright (C) Markus Franz Xaver Johannes Oberhumer\n#\n# very first version of the resize-testsuite; requires:\n#   $resize_exe                (required, but with convenience fallback \"./resize\")\n#   $resize_testsuite_SRCDIR   (required, but with convenience fallback)\n#   $resize_testsuite_BUILDDIR (optional)\n#\n# optional settings:\n#   $resize_exe_runner         (e.g. \"qemu-x86_64 -cpu Nehalem\" or \"valgrind\")\n#   $RESIZE_TESTSUITE_VERBOSE\n#   $RESIZE_TESTSUITE_LEVEL\n#\n# see https://github.com/resize/resize-testsuite.git\n#\n\n#***********************************************************************\n# init & checks\n#***********************************************************************\n\n# resize_exe\n[[ -z $resize_exe && -f ./resize && -x ./resize ]] && resize_exe=./resize # convenience fallback\nif [[ -z $resize_exe ]]; then echo \"RESIZE-ERROR: please set \\$resize_exe\"; exit 1; fi\nif [[ ! -f $resize_exe ]]; then echo \"RESIZE-ERROR: file '$resize_exe' does not exist\"; exit 1; fi\nresize_exe=$(readlink -fn \"$resize_exe\") # make absolute\n[[ -f $resize_exe ]] || exit 1\n\n# set emu and run_resize\nemu=()\nif [[ -n $resize_exe_runner ]]; then\n    # usage examples:\n    #   export resize_exe_runner=\"qemu-x86_64 -cpu Nehalem\"\n    #   export resize_exe_runner=\"valgrind --leak-check=no --error-exitcode=1 --quiet\"\n    #   export resize_exe_runner=\"wine\"\n    IFS=' ' read -r -a emu <<< \"$resize_exe_runner\" # split at spaces into array\nelif [[ -n $CMAKE_CROSSCOMPILING_EMULATOR ]]; then\n    IFS=';' read -r -a emu <<< \"$CMAKE_CROSSCOMPILING_EMULATOR\" # split at semicolons into array\nfi\nrun_resize=( \"${emu[@]}\" \"$resize_exe\" )\necho \"run_resize='${run_resize[*]}'\"\n\n# run_resize sanity check\nif ! \"${run_resize[@]}\" --version-short >/dev/null; then echo \"RESIZE-ERROR: FATAL: resize --version-short FAILED\"; exit 1; fi\nif ! \"${run_resize[@]}\" -L >/dev/null 2>&1; then echo \"RESIZE-ERROR: FATAL: resize -L FAILED\"; exit 1; fi\nif ! \"${run_resize[@]}\" --help >/dev/null;  then echo \"RESIZE-ERROR: FATAL: resize --help FAILED\"; exit 1; fi\n\n# resize_testsuite_SRCDIR\nif [[ -z $resize_testsuite_SRCDIR ]]; then\n    # convenience fallback: search standard locations below resize top-level directory\n    if [[                 -d \"$argv0dir/../../../resize--resize-testsuite.git/files/packed\" ]]; then\n        resize_testsuite_SRCDIR=\"$argv0dir/../../../resize--resize-testsuite.git\"\n    elif [[               -d \"$argv0dir/../../../resize-testsuite.git/files/packed\" ]]; then\n        resize_testsuite_SRCDIR=\"$argv0dir/../../../resize-testsuite.git\"\n    elif [[               -d \"$argv0dir/../../../resize-testsuite/files/packed\" ]]; then\n        resize_testsuite_SRCDIR=\"$argv0dir/../../../resize-testsuite\"\n    fi\nfi\nif [[ ! -d \"$resize_testsuite_SRCDIR/files/packed\" ]]; then\n    echo \"invalid or missing \\$resize_testsuite_SRCDIR:\"\n    echo \"  please git clone https://github.com/resize/resize-testsuite.git\"\n    echo \"  and set (export) the envvar resize_testsuite_SRCDIR to the local file path\"\n    exit 1\nfi\nresize_testsuite_SRCDIR=$(readlink -fn \"$resize_testsuite_SRCDIR\") # make absolute\n[[ -d $resize_testsuite_SRCDIR ]] || exit 1\n\n# resize_testsuite_BUILDDIR\nif [[ -z $resize_testsuite_BUILDDIR ]]; then\n    resize_testsuite_BUILDDIR=\"./tmp-resize-testsuite\"\nfi\nmkdir -p \"$resize_testsuite_BUILDDIR\" || exit 1\nresize_testsuite_BUILDDIR=$(readlink -fn \"$resize_testsuite_BUILDDIR\") # make absolute\n[[ -d $resize_testsuite_BUILDDIR ]] || exit 1\ncd / && cd \"$resize_testsuite_BUILDDIR\" || exit 1\n: > ./.mfxnobackup\n\n# run_resize sanity check after \"cd\"\nif ! \"${run_resize[@]}\" --version-short >/dev/null; then\n    echo \"RESIZE-ERROR: FATAL: resize --version-short FAILED\"\n    echo \"please make sure that \\$resize_exe contains ABSOLUTE file paths and can be run from any directory\"\n    echo \"INFO: run_resize='${run_resize[*]}'\"\n    exit 1\nfi\n\n#***********************************************************************\n# setup\n#***********************************************************************\n\n#set -x # debug\n\nexit_code=0\nnum_errors=0\nall_errors=\n\nexport RESIZE=\"--prefer-ucl --no-color --no-progress\"\nexport RESIZE_DEBUG_DISABLE_GITREV_WARNING=1\nexport RESIZE_DEBUG_DOCTEST_DISABLE=1 # already checked above\n\ncase $RESIZE_TESTSUITE_LEVEL in\n    [0-8]) ;;\n    *) RESIZE_TESTSUITE_LEVEL=999 ;;\nesac\nif [[ $RESIZE_TESTSUITE_LEVEL == 0 ]]; then\n    echo \"RESIZE testsuite SKIPPED.\"\n    exit 0\nfi\n\nrm -rf ./testsuite_1\nmkdir testsuite_1 || exit 1\ncd testsuite_1 || exit 1\n\n#***********************************************************************\n# support functions\n#***********************************************************************\n\nrun_resize() {\n    local flags=\"--disable-random-id --fake-stub-version=5.01 --fake-stub-year=2025\"\n    local ec=0\n    if [[ $RESIZE_TESTSUITE_VERBOSE == 1 ]]; then\n        echo \"LOG: '${run_resize[*]}' $*\"\n    fi\n    \"${run_resize[@]}\" $flags \"$@\" || ec=$?\n    if [[ $ec != 0 ]]; then\n        echo \"FATAL: '${run_resize[*]}' $*\"\n        echo \"  (exit code was $ec)\"\n        exit 42\n    fi\n}\n\ntestsuite_header() {\n    local x='==========='; x=\"$x$x$x$x$x$x$x\"\n    echo -e \"\\n${x}\\n${1}\\n${x}\\n\"\n}\n\ntestsuite_split_f() {\n    fd=$(dirname \"$1\")\n    fb=$(basename \"$1\")\n    fsubdir=$(basename \"$fd\")\n    # sanity checks\n    if [[ ! -f $1 || -z $fsubdir || -z $fb ]]; then\n        fd=''; fb=''; fsubdir=''\n    fi\n}\n\ntestsuite_check_sha() {\n    (cd \"$1\" && sha256sum -b [0-9a-zA-Z]*/* | LC_ALL=C sort -k2) > $1/.sha256sums.current\n    echo\n    cat $1/.sha256sums.current\n    if ! cmp -s $1/.sha256sums.expected $1/.sha256sums.current; then\n        echo \"RESIZE-ERROR: $1 FAILED: checksum mismatch\"\n        diff -u $1/.sha256sums.expected $1/.sha256sums.current || true\n        exit_code=99\n        let num_errors+=1 || true\n        all_errors=\"${all_errors} $1\"\n        #exit 99\n    fi\n    echo\n}\n\ntestsuite_check_sha_decompressed() {\n    (cd \"$1\" && sha256sum -b [0-9a-zA-Z]*/* | LC_ALL=C sort -k2) > $1/.sha256sums.current\n    if ! cmp -s $1/.sha256sums.expected $1/.sha256sums.current; then\n        cat $1/.sha256sums.current\n        echo \"RESIZE-ERROR: FATAL: $1 FAILED: decompressed checksum mismatch\"\n        diff -u $1/.sha256sums.expected $1/.sha256sums.current || true\n        exit 98\n    fi\n}\n\ntestsuite_use_canonicalized=1\ntestsuite_run_compress() {\n    testsuite_header $testdir\n    local files f\n    if [[ $testsuite_use_canonicalized == 1 ]]; then\n        files='t020_canonicalized/*/*'\n    else\n        files='t010_decompressed/*/*'\n    fi\n    for f in $files; do\n        testsuite_split_f \"$f\"\n        [[ -z $fb ]] && continue\n        echo \"# $f\"\n        mkdir -p \"$testdir/$fsubdir\" \"$testdir/.decompressed/$fsubdir\"\n        run_resize -qq --prefer-ucl \"$@\" \"$f\" -o \"$testdir/$fsubdir/$fb\"\n        run_resize -qq -d \"$testdir/$fsubdir/$fb\" -o \"$testdir/.decompressed/$fsubdir/$fb\"\n    done\n    testsuite_check_sha $testdir\n    run_resize -qq -l \"$testdir\"/*/*\n    run_resize -qq --file-info \"$testdir\"/*/*\n    run_resize -q -t \"$testdir\"/*/*\n    if [[ $testsuite_use_canonicalized == 1 ]]; then\n        # check that after decompression the file matches the canonicalized version\n        cp t020_canonicalized/.sha256sums.expected $testdir/.decompressed/\n        testsuite_check_sha_decompressed $testdir/.decompressed\n        rm -rf \"./$testdir/.decompressed\"\n    fi\n}\n\n#***********************************************************************\n# expected checksums\n#\n# To ease maintenance of this script in case of updates this section\n# can be automatically re-created from the current checksums -\n# see call of function recreate_expected_sha256sums below.\n#***********************************************************************\n\nrecreate_expected_sha256sums() {\n    local o=\"$1\"\n    local files f d\n    echo \"########## begin .sha256sums.recreate\" > \"$o\"\n    files='*/.sha256sums.current'\n    for f in $files; do\n        d=$(dirname \"$f\")\n        echo \"expected_sha256sums__${d}=\"'\"\\' >> \"$o\"\n        cat \"$f\" >> \"$o\"\n        echo '\"' >> \"$o\"\n    done\n    echo \"########## end .sha256sums.recreate\" >> \"$o\"\n}\n\nsource \"$argv0dir/resize_testsuite_1-expected_sha256sums.sh\" || exit 1\n\n#***********************************************************************\n# decompression tests\n#***********************************************************************\n\ntestdir=t010_decompressed\nmkdir $testdir; v=expected_sha256sums__$testdir; echo -n \"${!v}\" >$testdir/.sha256sums.expected\n\ntestsuite_header $testdir\nfor f in \"$resize_testsuite_SRCDIR\"/files/packed/*/resize-3.9[15]*; do\n    testsuite_split_f \"$f\"\n    [[ -z $fb ]] && continue\n    echo \"# $f\"\n    mkdir -p \"$testdir/$fsubdir\"\n    run_resize -qq -d \"$f\" -o \"$testdir/$fsubdir/$fb\"\ndone\ntestsuite_check_sha $testdir\n\n# run one pack+unpack step to canonicalize the files\ntestdir=t020_canonicalized\nmkdir $testdir; v=expected_sha256sums__$testdir; echo -n \"${!v}\" >$testdir/.sha256sums.expected\n\ntestsuite_header $testdir\nfor f in t010_decompressed/*/*; do\n    testsuite_split_f \"$f\"\n    [[ -z $fb ]] && continue\n    echo \"# $f\"\n    mkdir -p \"$testdir/$fsubdir/.packed\"\n    run_resize -qq --prefer-ucl -1 \"$f\" -o \"$testdir/$fsubdir/.packed/$fb\"\n    run_resize -qq -d \"$testdir/$fsubdir/.packed/$fb\" -o \"$testdir/$fsubdir/$fb\"\ndone\ntestsuite_check_sha $testdir\n\n#***********************************************************************\n# compression tests\n# info: we use fast compression levels because we want to\n#   test RESIZE and not the compression libraries\n#***********************************************************************\n\nif [[ $RESIZE_TESTSUITE_LEVEL -ge 2 ]]; then\ntestdir=t110_compress_ucl_nrv2b_3_no_filter\nmkdir $testdir; v=expected_sha256sums__$testdir; echo -n \"${!v}\" >$testdir/.sha256sums.expected\ntime testsuite_run_compress --nrv2b -3 --no-filter\nfi\n\nif [[ $RESIZE_TESTSUITE_LEVEL -ge 3 ]]; then\ntestdir=t120_compress_ucl_nrv2d_3_no_filter\nmkdir $testdir; v=expected_sha256sums__$testdir; echo -n \"${!v}\" >$testdir/.sha256sums.expected\ntime testsuite_run_compress --nrv2d -3 --no-filter\nfi\n\nif [[ $RESIZE_TESTSUITE_LEVEL -ge 4 ]]; then\ntestdir=t130_compress_ucl_nrv2e_3_no_filter\nmkdir $testdir; v=expected_sha256sums__$testdir; echo -n \"${!v}\" >$testdir/.sha256sums.expected\ntime testsuite_run_compress --nrv2e -3 --no-filter\nfi\n\nif [[ $RESIZE_TESTSUITE_LEVEL -ge 5 ]]; then\ntestdir=t140_compress_lzma_2_no_filter\nmkdir $testdir; v=expected_sha256sums__$testdir; echo -n \"${!v}\" >$testdir/.sha256sums.expected\ntime testsuite_run_compress --lzma -2 --no-filter\nfi\n\nif [[ $RESIZE_TESTSUITE_LEVEL -ge 6 ]]; then\ntestdir=t150_compress_ucl_2_all_filters\nmkdir $testdir; v=expected_sha256sums__$testdir; echo -n \"${!v}\" >$testdir/.sha256sums.expected\ntime testsuite_run_compress -2 --all-filters\nfi\n\nif [[ $RESIZE_TESTSUITE_LEVEL -ge 7 ]]; then\ntestdir=t160_compress_all_methods_1_no_filter\nmkdir $testdir; v=expected_sha256sums__$testdir; echo -n \"${!v}\" >$testdir/.sha256sums.expected\ntime testsuite_run_compress --all-methods -1 --no-filter\nfi\n\nif [[ $RESIZE_TESTSUITE_LEVEL -ge 8 ]]; then\ntestdir=t170_compress_all_methods_no_lzma_5_no_filter\nmkdir $testdir; v=expected_sha256sums__$testdir; echo -n \"${!v}\" >$testdir/.sha256sums.expected\ntime testsuite_run_compress --all-methods --no-lzma -5 --no-filter\nfi\n\n#***********************************************************************\n# summary\n#***********************************************************************\n\n# recreate checksums from current version for an easy update in case of changes\nrecreate_expected_sha256sums .sha256sums.recreate\n\ntestsuite_header \"RESIZE testsuite summary: level $RESIZE_TESTSUITE_LEVEL\"\nrun_resize --version-short\necho\necho \"resize_exe='$resize_exe'\"\nls -l \"$resize_exe\"\nif command -v file >/dev/null; then\n    file \"$resize_exe\" || true\nfi\necho \"run_resize='${run_resize[*]}'\"\necho \"resize_testsuite_SRCDIR='$resize_testsuite_SRCDIR'\"\necho \"resize_testsuite_BUILDDIR='$resize_testsuite_BUILDDIR'\"\necho \".sha256sums.{expected,current} counts:\"\ncat ./*/.sha256sums.expected | LC_ALL=C sort | wc\ncat ./*/.sha256sums.current  | LC_ALL=C sort | wc\necho\nif [[ $exit_code == 0 ]]; then\n    echo \"RESIZE testsuite passed. All done.\"\nelse\n    echo \"RESIZE-ERROR: RESIZE testsuite FAILED:${all_errors}\"\n    echo \"RESIZE-ERROR: RESIZE testsuite FAILED with $num_errors error(s). See log file.\"\nfi\nexit $exit_code\n","size_bytes":12465},".ccls-cache/@home@runner@workspace/src@check@dt_check.cpp":{"content":"/* dt_check.cpp -- doctest check\n\n   This file is part of the Resize executable compressor.\n\n   Copyright (C) 2025 WHO-AM-I-404\n   Based on UPX - Ultimate Packer for eXecutables\n   Copyright (C) 1996-2025 Markus Franz Xaver Johannes Oberhumer\n   All Rights Reserved.\n\n   Resize and the UCL library are free software; you can redistribute them\n   and/or modify them under the terms of the GNU General Public License as\n   published by the Free Software Foundation; either version 2 of\n   the License, or (at your option) any later version.\n\n   This program is distributed in the hope that it will be useful,\n   but WITHOUT ANY WARRANTY; without even the implied warranty of\n   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n   GNU General Public License for more details.\n\n   You should have received a copy of the GNU General Public License\n   along with this program; see the file COPYING.\n   If not, write to the Free Software Foundation, Inc.,\n   59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.\n\n   Markus F.X.J. Oberhumer\n   <markus@oberhumer.com>\n */\n\n// doctest checks, and various tests to catch toolchain/qemu/sanitizer/valgrind/wine/etc\n// problems; grown historically; modern compilers will optimize away much of this code\n\n#include \"../util/system_headers.h\"\n#include <cmath> // std::isinf std::isnan\n#include \"../conf.h\"\n\n/*************************************************************************\n// upx_doctest_check()\n//\n// honors environment variables:\n//   UPX_DEBUG_DOCTEST_DISABLE\n//   UPX_DEBUG_DOCTEST_VERBOSE\n//\n// HINT: set \"UPX_DEBUG_DOCTEST_DISABLE=1\" for improved debugging experience\n**************************************************************************/\n\nint upx_doctest_check(int argc, char **argv) {\n#if defined(DOCTEST_CONFIG_DISABLE)\n    UNUSED(argc);\n    UNUSED(argv);\n    return 0;\n#else\n    if (is_envvar_true(\"UPX_DEBUG_DOCTEST_DISABLE\", \"UPX_DEBUG_DISABLE_DOCTEST\"))\n        return 0;\n    bool minimal = true;   // don't show summary\n    bool duration = false; // don't show timings\n    bool success = false;  // don't show all succeeding tests\n#if DEBUG\n    // default for debug builds: do show the [doctest] summary\n    minimal = false;\n#endif\n    const char *e = upx_getenv(\"UPX_DEBUG_DOCTEST_VERBOSE\");\n    if (e && e[0]) {\n        if (strcmp(e, \"0\") == 0) {\n            minimal = true;\n        } else if (strcmp(e, \"1\") == 0) {\n            minimal = false;\n        } else if (strcmp(e, \"2\") == 0) {\n            minimal = false;\n            duration = true;\n        } else if (strcmp(e, \"3\") == 0) {\n            minimal = false;\n            duration = true;\n            success = true;\n        }\n    }\n    doctest::Context context;\n    if (minimal)\n        context.setOption(\"dt-minimal\", true);\n    if (duration)\n        context.setOption(\"dt-duration\", true);\n    if (success)\n        context.setOption(\"dt-success\", true);\n    // this requires that main_get_options() understands/ignores doctest \"--dt-XXX\" options\n    if (argc > 0 && argv != nullptr)\n        context.applyCommandLine(argc, argv);\n    int r = context.run();\n    if (r != 0)\n        return 1;\n    if (context.shouldExit())\n        return 2;\n    return 0;\n#endif // DOCTEST_CONFIG_DISABLE\n}\n\nint upx_doctest_check() { return upx_doctest_check(0, nullptr); }\n\n/*************************************************************************\n// check fundamental types\n**************************************************************************/\n\nstatic_assert(std::is_integral<ptrdiff_t>::value, \"\");\nstatic_assert(std::is_integral<size_t>::value, \"\");\nstatic_assert(std::is_integral<intptr_t>::value, \"\");\nstatic_assert(std::is_integral<uintptr_t>::value, \"\");\n\nstatic_assert(std::is_signed<ptrdiff_t>::value, \"\");\nstatic_assert(!std::is_signed<size_t>::value, \"\");\nstatic_assert(std::is_signed<intptr_t>::value, \"\");\nstatic_assert(!std::is_signed<uintptr_t>::value, \"\");\n\nstatic_assert(!std::is_unsigned<ptrdiff_t>::value, \"\");\nstatic_assert(std::is_unsigned<size_t>::value, \"\");\nstatic_assert(!std::is_unsigned<intptr_t>::value, \"\");\nstatic_assert(std::is_unsigned<uintptr_t>::value, \"\");\n\n#if defined(__SIZEOF_SHORT__)\nstatic_assert(sizeof(short) == __SIZEOF_SHORT__, \"\");\n#endif\n#if defined(__SIZEOF_INT__)\nstatic_assert(sizeof(int) == __SIZEOF_INT__, \"\");\n#endif\n#if defined(__SIZEOF_LONG__)\nstatic_assert(sizeof(long) == __SIZEOF_LONG__, \"\");\n#endif\n#if defined(__SIZEOF_LONG_LONG__)\nstatic_assert(sizeof(long long) == __SIZEOF_LONG_LONG__, \"\");\n#endif\n#if defined(__SIZEOF_INT128__)\nstatic_assert(16 == __SIZEOF_INT128__, \"\");\nstatic_assert(sizeof(__int128) == __SIZEOF_INT128__, \"\");\nstatic_assert(sizeof(unsigned __int128) == __SIZEOF_INT128__, \"\");\nstatic_assert(sizeof(upx_int128_t) == __SIZEOF_INT128__, \"\");\nstatic_assert(sizeof(upx_uint128_t) == __SIZEOF_INT128__, \"\");\n#endif\n#if defined(__SIZEOF_PTRDIFF_T__)\nstatic_assert(sizeof(ptrdiff_t) == __SIZEOF_PTRDIFF_T__, \"\");\n#endif\n#if defined(__SIZEOF_SIZE_T__)\nstatic_assert(sizeof(size_t) == __SIZEOF_SIZE_T__, \"\");\n#endif\n#if defined(__SIZEOF_POINTER__)\nstatic_assert(sizeof(void *) == __SIZEOF_POINTER__, \"\");\nstatic_assert(sizeof(intptr_t) == __SIZEOF_POINTER__, \"\");\nstatic_assert(sizeof(uintptr_t) == __SIZEOF_POINTER__, \"\");\n#endif\n#if defined(__SIZEOF_PTRADDR_T__)\nstatic_assert(sizeof(__PTRADDR_TYPE__) == __SIZEOF_PTRADDR_T__, \"\");\nstatic_assert(sizeof(upx_ptraddr_t) == __SIZEOF_PTRADDR_T__, \"\");\n#endif\n\n#if defined(__SCHAR_WIDTH__)\nstatic_assert(8 * sizeof(signed char) == __SCHAR_WIDTH__, \"\");\n#endif\n#if defined(__SHRT_WIDTH__)\nstatic_assert(8 * sizeof(short) == __SHRT_WIDTH__, \"\");\n#endif\n#if defined(__INT_WIDTH__)\nstatic_assert(8 * sizeof(int) == __INT_WIDTH__, \"\");\n#endif\n#if defined(__LONG_WIDTH__)\nstatic_assert(8 * sizeof(long) == __LONG_WIDTH__, \"\");\n#endif\n#if defined(__LLONG_WIDTH__)\nstatic_assert(8 * sizeof(long long) == __LLONG_WIDTH__, \"\");\n#endif\n#if defined(__INTMAX_WIDTH__)\nstatic_assert(8 * sizeof(intmax_t) == __INTMAX_WIDTH__, \"\");\nstatic_assert(8 * sizeof(uintmax_t) == __INTMAX_WIDTH__, \"\");\n#endif\n#if defined(__PTRDIFF_WIDTH__)\nstatic_assert(8 * sizeof(ptrdiff_t) == __PTRDIFF_WIDTH__, \"\");\n#endif\n#if defined(__SIZE_WIDTH__)\nstatic_assert(8 * sizeof(size_t) == __SIZE_WIDTH__, \"\");\n#endif\n#if defined(__INTPTR_WIDTH__)\nstatic_assert(8 * sizeof(intptr_t) == __INTPTR_WIDTH__, \"\");\nstatic_assert(8 * sizeof(uintptr_t) == __INTPTR_WIDTH__, \"\");\n#endif\n#if defined(__UINTPTR_WIDTH__)\nstatic_assert(8 * sizeof(intptr_t) == __UINTPTR_WIDTH__, \"\");\nstatic_assert(8 * sizeof(uintptr_t) == __UINTPTR_WIDTH__, \"\");\n#endif\n#if defined(__PTRADDR_WIDTH__)\nstatic_assert(8 * sizeof(__PTRADDR_TYPE__) == __PTRADDR_WIDTH__, \"\");\nstatic_assert(8 * sizeof(upx_ptraddr_t) == __PTRADDR_WIDTH__, \"\");\n#endif\n\n// true types from compiler\ntypedef decltype((const char *) nullptr - (const char *) nullptr) true_ptrdiff_t;\ntypedef decltype(sizeof(0)) true_size_t;\n\n// expected types from pre-defined macros\n#if defined(__PTRDIFF_TYPE__)\ntypedef __PTRDIFF_TYPE__ expected_ptrdiff_t;\n#endif\n#if defined(__SIZE_TYPE__)\ntypedef __SIZE_TYPE__ expected_size_t;\n#endif\n#if defined(__INTPTR_TYPE__)\ntypedef __INTPTR_TYPE__ expected_intptr_t;\n#endif\n#if defined(__UINTPTR_TYPE__)\ntypedef __UINTPTR_TYPE__ expected_uintptr_t;\n#endif\n#if defined(__PTRADDR_TYPE__)\ntypedef __PTRADDR_TYPE__ expected_ptraddr_t;\n#endif\n\n#define ASSERT_COMPATIBLE_TYPE(A, B)                                                               \\\n    static_assert(std::is_integral<A>::value, \"\");                                                 \\\n    static_assert(std::is_integral<B>::value, \"\");                                                 \\\n    static_assert(std::is_signed<A>::value == std::is_signed<B>::value, \"\");                       \\\n    static_assert(std::is_unsigned<A>::value == std::is_unsigned<B>::value, \"\");                   \\\n    static_assert(std::is_signed<A>::value == !std::is_unsigned<A>::value, \"\");                    \\\n    static_assert(std::is_signed<B>::value == !std::is_unsigned<B>::value, \"\");                    \\\n    static_assert(sizeof(A) == sizeof(B), \"\");                                                     \\\n    static_assert(alignof(A) == alignof(B), \"\")\n\n#define ASSERT_SAME_TYPE(A, B)                                                                     \\\n    ASSERT_COMPATIBLE_TYPE(A, B);                                                                  \\\n    static_assert(std::is_same<A, B>::value, \"\")\n\n// C vs C++ headers\nASSERT_SAME_TYPE(ptrdiff_t, std::ptrdiff_t);\nASSERT_SAME_TYPE(size_t, std::size_t);\nASSERT_SAME_TYPE(intptr_t, std::intptr_t);\nASSERT_SAME_TYPE(uintptr_t, std::uintptr_t);\n\n// true types\nASSERT_SAME_TYPE(ptrdiff_t, true_ptrdiff_t);\nASSERT_SAME_TYPE(size_t, true_size_t);\n#if __cplusplus >= 201103L\ntypedef decltype(nullptr) true_nullptr_t;\nstatic_assert(std::is_same<std::nullptr_t, true_nullptr_t>::value, \"\");\n#endif\n\n// expected types\n#if defined(__PTRDIFF_TYPE__)\nstatic_assert(std::is_signed<expected_ptrdiff_t>::value, \"\");\nASSERT_SAME_TYPE(ptrdiff_t, expected_ptrdiff_t);\n#endif\n#if defined(__SIZE_TYPE__)\nstatic_assert(std::is_unsigned<expected_size_t>::value, \"\");\nASSERT_SAME_TYPE(size_t, expected_size_t);\n#endif\n#if defined(__INTPTR_TYPE__)\nstatic_assert(std::is_signed<expected_intptr_t>::value, \"\");\nASSERT_COMPATIBLE_TYPE(intptr_t, expected_intptr_t); // some toolchains are buggy\n#endif\n#if defined(__UINTPTR_TYPE__)\nstatic_assert(std::is_unsigned<expected_uintptr_t>::value, \"\");\nASSERT_COMPATIBLE_TYPE(uintptr_t, expected_uintptr_t); // some toolchains are buggy\n#endif\n#if defined(__PTRADDR_TYPE__)\nstatic_assert(std::is_unsigned<expected_ptraddr_t>::value, \"\");\nASSERT_SAME_TYPE(upx_ptraddr_t, expected_ptraddr_t);\n#endif\n\n// UPX types\nASSERT_SAME_TYPE(signed char, upx_int8_t);\nASSERT_SAME_TYPE(unsigned char, upx_uint8_t);\nASSERT_SAME_TYPE(short, upx_int16_t);\nASSERT_SAME_TYPE(unsigned short, upx_uint16_t);\nASSERT_SAME_TYPE(int, upx_int32_t);\nASSERT_SAME_TYPE(unsigned, upx_uint32_t);\n#if (__SIZEOF_LONG_LONG__ + 0 < 128)\nASSERT_SAME_TYPE(long long, upx_int64_t);\nASSERT_SAME_TYPE(unsigned long long, upx_uint64_t);\n#endif\n\n/*************************************************************************\n// compile-time checks\n**************************************************************************/\n\nstatic_assert(no_bswap16(0x04030201) == 0x0201);\nstatic_assert(no_bswap32(0x04030201) == 0x04030201);\nstatic_assert(no_bswap64(0x0807060504030201ull) == 0x0807060504030201ull);\n#if !(ACC_CC_MSC) || defined(upx_is_constant_evaluated)\nstatic_assert(bswap16(0x04030201) == 0x0102);\nstatic_assert(bswap32(0x04030201) == 0x01020304);\nstatic_assert(bswap64(0x0807060504030201ull) == 0x0102030405060708ull);\nstatic_assert(bswap16(bswap16(0xf4f3f2f1)) == no_bswap16(0xf4f3f2f1));\nstatic_assert(bswap32(bswap32(0xf4f3f2f1)) == no_bswap32(0xf4f3f2f1));\nstatic_assert(bswap64(bswap64(0xf8f7f6f5f4f3f2f1ull)) == no_bswap64(0xf8f7f6f5f4f3f2f1ull));\n#endif\n\nstatic_assert(sign_extend32(0u + 0, 8) == 0);\nstatic_assert(sign_extend32(0u + 1, 8) == 1);\nstatic_assert(sign_extend32(0u + 127, 8) == 127);\nstatic_assert(sign_extend32(0u + 128, 8) == -128);\nstatic_assert(sign_extend32(0u - 1, 8) == -1);\nstatic_assert(sign_extend32(0u + 256, 8) == 0);\nstatic_assert(sign_extend32(0u + 257, 8) == 1);\nstatic_assert(sign_extend32(0u + 383, 8) == 127);\nstatic_assert(sign_extend32(0u + 384, 8) == -128);\nstatic_assert(sign_extend32(0u + 511, 8) == -1);\nstatic_assert(sign_extend64(upx_uint64_t(0) + 0, 1) == 0);\nstatic_assert(sign_extend64(upx_uint64_t(0) + 1, 1) == -1);\n\nstatic_assert(CHAR_BIT == 8);\n#if 0 // does not work with MSVC\n#if '\\0' - 1 < 0\nstatic_assert(CHAR_MAX == 127);\n#else\nstatic_assert(CHAR_MAX == 255);\n#endif\n#if L'\\0' - 1 < 0\nstatic_assert((wchar_t) -1 < 0);\n#else\nstatic_assert((wchar_t) -1 > 0);\n#endif\n#endif\n\n/*************************************************************************\n// upx_compiler_sanity_check()\n// assert a sane architecture and compiler\n**************************************************************************/\n\nnamespace {\n\ntemplate <class T>\nstruct CheckIntegral {\n    static_assert(upx_is_integral<T>::value);\n    static_assert(upx_is_integral_v<T>);\n    struct TestT {\n        T a;\n        T x[2];\n    };\n    template <class U>\n    struct TestU {\n        U a = {};\n        const U b = {};\n        static constexpr U c = {};\n        U x[2] = {};\n        const U y[2] = {};\n        static constexpr U z[2] = {};\n    };\n    template <class U>\n    static void checkU(void) noexcept {\n        {\n            U a = {};\n            const U b = {};\n            constexpr U c = {};\n            U x[2] = {};\n            const U y[2] = {};\n            constexpr U z[2] = {};\n            assert_noexcept(a == 0);\n            assert_noexcept(b == 0);\n            assert_noexcept(c == 0);\n            assert_noexcept(x[0] == 0 && x[1] == 0);\n            assert_noexcept(y[0] == 0 && y[1] == 0);\n            assert_noexcept(z[0] == 0 && z[1] == 0);\n#if defined(upx_is_constant_evaluated)\n            static_assert(c == 0);\n            static_assert(z[0] == 0 && z[1] == 0);\n#endif\n        }\n        {\n            TestU<U> t;\n            assert_noexcept(t.a == 0);\n            assert_noexcept(t.b == 0);\n            assert_noexcept(t.c == 0);\n            assert_noexcept(t.x[0] == 0 && t.x[1] == 0);\n            assert_noexcept(t.y[0] == 0 && t.y[1] == 0);\n            assert_noexcept(t.z[0] == 0 && t.z[1] == 0);\n        }\n#if __cplusplus <= 201703L\n        static_assert(std::is_pod<U>::value); // std::is_pod is deprecated in C++20\n#endif\n        static_assert(std::is_standard_layout<U>::value);\n        static_assert(std::is_trivial<U>::value);\n        // more checks, these are probably implied by std::is_trivial\n        static_assert(std::is_nothrow_default_constructible<U>::value);\n        static_assert(std::is_nothrow_destructible<U>::value);\n        static_assert(std::is_trivially_copyable<U>::value);\n        static_assert(std::is_trivially_default_constructible<U>::value);\n        // UPX extras\n        static_assert(upx_is_integral<U>::value);\n        static_assert(upx_is_integral_v<U>);\n    }\n    static void check_core(void) noexcept {\n        {\n            TestT t = {};\n            assert_noexcept(t.a == 0);\n            assert_noexcept(t.x[0] == 0 && t.x[1] == 0);\n        }\n        {\n            const TestT t = {};\n            assert_noexcept(t.a == 0);\n            assert_noexcept(t.x[0] == 0 && t.x[1] == 0);\n        }\n        {\n            constexpr TestT t = {};\n            assert_noexcept(t.a == 0);\n            assert_noexcept(t.x[0] == 0 && t.x[1] == 0);\n        }\n        {\n            TestT t;\n            mem_clear(&t);\n            assert_noexcept(t.a == 0);\n            assert_noexcept(t.x[0] == 0 && t.x[1] == 0);\n        }\n        checkU<T>();\n        checkU<typename std::add_const<T>::type>();\n        {\n            T zero, one, three, four;\n            zero = 0;\n            one = 1;\n            three = 3;\n            four = 4;\n            assert_noexcept(zero == 0);\n            assert_noexcept(one == 1);\n            assert_noexcept(three == 3);\n            assert_noexcept(four == 4);\n            // min / max\n            assert_noexcept(upx::min(one, four) == 1);\n            assert_noexcept(upx::min(one, four) == one);\n            assert_noexcept(upx::max(one, four) == 4);\n            assert_noexcept(upx::max(one, four) == four);\n        }\n    }\n    static void check(void) noexcept {\n        check_core();\n        {\n            T zero, one, three, four;\n            zero = 0;\n            one = 1;\n            three = 3;\n            four = 4;\n            // align - needs binary expressions which do not work\n            // on CHERI uintptr_t because of pointer provenance\n            assert_noexcept(upx::align_down(zero, four) == 0);\n            assert_noexcept(upx::align_down(zero, four) == zero);\n            assert_noexcept(upx::align_down(one, four) == 0);\n            assert_noexcept(upx::align_down(one, four) == zero);\n            assert_noexcept(upx::align_down(three, four) == 0);\n            assert_noexcept(upx::align_down(three, four) == zero);\n            assert_noexcept(upx::align_down(four, four) == 4);\n            assert_noexcept(upx::align_down(four, four) == four);\n            assert_noexcept(upx::align_up(zero, four) == 0);\n            assert_noexcept(upx::align_up(zero, four) == zero);\n            assert_noexcept(upx::align_up(one, four) == 4);\n            assert_noexcept(upx::align_up(one, four) == four);\n            assert_noexcept(upx::align_up(three, four) == 4);\n            assert_noexcept(upx::align_up(three, four) == four);\n            assert_noexcept(upx::align_up(four, four) == 4);\n            assert_noexcept(upx::align_up(four, four) == four);\n            assert_noexcept(upx::align_up_gap(zero, four) == 0);\n            assert_noexcept(upx::align_up_gap(zero, four) == zero);\n            assert_noexcept(upx::align_up_gap(one, four) == 3);\n            assert_noexcept(upx::align_up_gap(one, four) == three);\n            assert_noexcept(upx::align_up_gap(three, four) == 1);\n            assert_noexcept(upx::align_up_gap(three, four) == one);\n            assert_noexcept(upx::align_up_gap(four, four) == 0);\n            assert_noexcept(upx::align_up_gap(four, four) == zero);\n        }\n    }\n};\n\ntemplate <class T>\nstruct CheckAlignment {\n    static void check(void) noexcept {\n        COMPILE_TIME_ASSERT_ALIGNED1(T)\n        struct alignas(1) Test1 {\n            char a;\n            T b;\n        };\n        struct alignas(1) Test2 {\n            char a;\n            T b[3];\n        };\n        COMPILE_TIME_ASSERT_ALIGNED1(Test1)\n        COMPILE_TIME_ASSERT_ALIGNED1(Test2)\n        Test1 t1[7];\n        Test2 t2[7];\n        static_assert(sizeof(Test1) == 1 + sizeof(T));\n        static_assert(sizeof(t1) == 7 + 7 * sizeof(T));\n        static_assert(sizeof(Test2) == 1 + 3 * sizeof(T));\n        static_assert(sizeof(t2) == 7 + 21 * sizeof(T));\n        UNUSED(t1);\n        UNUSED(t2);\n    }\n};\n\ntemplate <class T>\nstruct TestBELE {\n    static noinline bool test(void) noexcept {\n        static_assert(upx::is_same_any_v<T, BE16, BE32, BE64, LE16, LE32, LE64>);\n        static_assert(\n            upx::is_same_any_v<typename T::integral_conversion_type, upx_uint32_t, upx_uint64_t>);\n        CheckIntegral<T>::check();\n        CheckAlignment<T>::check();\n        // arithmetic checks\n        {\n            T all_bits = {}; // == zero\n            assert_noexcept(all_bits == 0);\n            assert_noexcept(!upx::has_single_bit(all_bits));\n            all_bits += 1;\n            assert_noexcept(upx::has_single_bit(all_bits));\n            all_bits -= 2;\n            assert_noexcept(!upx::has_single_bit(all_bits));\n            T v1;\n            v1 = 1;\n            v1 *= 4;\n            v1 /= 2;\n            v1 -= 1;\n            T v2;\n            v2 = 1;\n            assert_noexcept((v1 == v2));\n            assert_noexcept(!(v1 != v2));\n            assert_noexcept((v1 <= v2));\n            assert_noexcept((v1 >= v2));\n            assert_noexcept(!(v1 < v2));\n            assert_noexcept(!(v1 > v2));\n            v2 ^= all_bits;\n            assert_noexcept(!(v1 == v2));\n            assert_noexcept((v1 != v2));\n            assert_noexcept((v1 <= v2));\n            assert_noexcept(!(v1 >= v2));\n            assert_noexcept((v1 < v2));\n            assert_noexcept(!(v1 > v2));\n            v2 += 2;\n            assert_noexcept(v1 == 1);\n            assert_noexcept(v2 == 0);\n            v1 <<= 1;\n            v1 |= v2;\n            v1 >>= 1;\n            v2 &= v1;\n            v2 /= v1;\n            v2 *= v1;\n            v1 += v2;\n            v1 -= v2;\n            assert_noexcept(v1 == 1);\n            assert_noexcept(v2 == 0);\n            if ((v1 ^ v2) != 1)\n                return false;\n        }\n        // min/max\n        {\n            constexpr T a = {}; // == zero\n            typedef typename T::integral_conversion_type U;\n            constexpr U b = 1;\n            assert_noexcept(upx::min(a, a) == 0);\n            assert_noexcept(upx::min(a, a) == a);\n            assert_noexcept(upx::min(a, b) == 0);\n            assert_noexcept(upx::min(a, b) == a);\n            assert_noexcept(upx::min(b, a) == 0);\n            assert_noexcept(upx::min(b, a) == a);\n            assert_noexcept(upx::min(b, b) == 1);\n            assert_noexcept(upx::min(b, b) == b);\n            assert_noexcept(upx::max(a, a) == 0);\n            assert_noexcept(upx::max(a, a) == a);\n            assert_noexcept(upx::max(a, b) == 1);\n            assert_noexcept(upx::max(a, b) == b);\n            assert_noexcept(upx::max(b, a) == 1);\n            assert_noexcept(upx::max(b, a) == b);\n            assert_noexcept(upx::max(b, b) == 1);\n            assert_noexcept(upx::max(b, b) == b);\n            T minus_one_t = {}, minus_two_t = {};\n            minus_one_t -= 1;\n            minus_two_t -= 2;\n            const U minus_one_u = minus_one_t;\n            const U minus_two_u = minus_two_t;\n            assert_noexcept(upx::min(minus_one_t, minus_one_t) == minus_one_t);\n            assert_noexcept(upx::min(minus_one_t, minus_one_t) == minus_one_u);\n            assert_noexcept(upx::min(minus_one_u, minus_one_t) == minus_one_t);\n            assert_noexcept(upx::min(minus_one_u, minus_one_t) == minus_one_u);\n            assert_noexcept(upx::min(minus_one_t, minus_one_u) == minus_one_t);\n            assert_noexcept(upx::min(minus_one_t, minus_one_u) == minus_one_u);\n            assert_noexcept(upx::min(minus_two_t, minus_one_t) == minus_two_t);\n            assert_noexcept(upx::min(minus_two_t, minus_one_t) == minus_two_u);\n            assert_noexcept(upx::min(minus_two_u, minus_one_t) == minus_two_t);\n            assert_noexcept(upx::min(minus_two_u, minus_one_t) == minus_two_u);\n            assert_noexcept(upx::min(minus_two_t, minus_one_u) == minus_two_t);\n            assert_noexcept(upx::min(minus_two_t, minus_one_u) == minus_two_u);\n            assert_noexcept(upx::min(minus_one_t, minus_two_t) == minus_two_t);\n            assert_noexcept(upx::min(minus_one_t, minus_two_t) == minus_two_u);\n            assert_noexcept(upx::min(minus_one_u, minus_two_t) == minus_two_t);\n            assert_noexcept(upx::min(minus_one_u, minus_two_t) == minus_two_u);\n            assert_noexcept(upx::min(minus_one_t, minus_two_u) == minus_two_t);\n            assert_noexcept(upx::min(minus_one_t, minus_two_u) == minus_two_u);\n            assert_noexcept(upx::max(minus_one_t, minus_one_t) == minus_one_t);\n            assert_noexcept(upx::max(minus_one_t, minus_one_t) == minus_one_u);\n            assert_noexcept(upx::max(minus_one_u, minus_one_t) == minus_one_t);\n            assert_noexcept(upx::max(minus_one_u, minus_one_t) == minus_one_u);\n            assert_noexcept(upx::max(minus_one_t, minus_one_u) == minus_one_t);\n            assert_noexcept(upx::max(minus_one_t, minus_one_u) == minus_one_u);\n            assert_noexcept(upx::max(minus_two_t, minus_one_t) == minus_one_t);\n            assert_noexcept(upx::max(minus_two_t, minus_one_t) == minus_one_u);\n            assert_noexcept(upx::max(minus_two_u, minus_one_t) == minus_one_t);\n            assert_noexcept(upx::max(minus_two_u, minus_one_t) == minus_one_u);\n            assert_noexcept(upx::max(minus_two_t, minus_one_u) == minus_one_t);\n            assert_noexcept(upx::max(minus_two_t, minus_one_u) == minus_one_u);\n            assert_noexcept(upx::max(minus_one_t, minus_two_t) == minus_one_t);\n            assert_noexcept(upx::max(minus_one_t, minus_two_t) == minus_one_u);\n            assert_noexcept(upx::max(minus_one_u, minus_two_t) == minus_one_t);\n            assert_noexcept(upx::max(minus_one_u, minus_two_t) == minus_one_u);\n            assert_noexcept(upx::max(minus_one_t, minus_two_u) == minus_one_t);\n            assert_noexcept(upx::max(minus_one_t, minus_two_u) == minus_one_u);\n        }\n        // constexpr\n        {\n            constexpr T zero = {};\n            constexpr T zero_copy = T::make(zero);\n            assert_noexcept(zero_copy == 0);\n            assert_noexcept(!upx::has_single_bit(zero));\n#if defined(upx_is_constant_evaluated)\n            static_assert(zero_copy == 0);\n            static_assert(zero_copy == zero);\n            static_assert(!upx::has_single_bit(zero));\n            static_assert(!upx::has_single_bit(zero_copy));\n#endif\n        }\n#if defined(upx_is_constant_evaluated)\n        {\n            typedef typename T::integral_conversion_type U;\n            constexpr T one = T::make(1);\n            static_assert(one == 1);\n            static_assert(upx::has_single_bit(one));\n            constexpr T four = T::make(one + 3);\n            static_assert(four == 4);\n            static_assert(upx::has_single_bit(four));\n            constexpr U all_bits_u = (U) T::make(U(0) - U(1));\n            constexpr T all_bits = T::make(all_bits_u);\n            static_assert(all_bits == all_bits_u);\n            static_assert(all_bits == T::make(one - 2));\n            static_assert(!upx::has_single_bit(all_bits));\n            static_assert(one == one);\n            static_assert(!(one == four));\n            static_assert(!(one == all_bits));\n            static_assert(one < four);\n            static_assert(one < all_bits);\n            static_assert(upx::min(one, four) == 1);\n            static_assert(upx::min(one, four) == one);\n            static_assert(upx::min(U(1), four) == 1);\n            static_assert(upx::min(one, U(4)) == 1);\n            static_assert(upx::max(one, four) == 4);\n            static_assert(upx::max(one, four) == four);\n            static_assert(upx::max(U(1), four) == 4);\n            static_assert(upx::max(one, U(4)) == 4);\n            static_assert(upx::align_down(one, four) == 0);\n            static_assert(upx::align_up(one, four) == 4);\n            static_assert(upx::align_up(one, four) == four);\n            static_assert(upx::align_up_gap(one, four) == 3);\n            static_assert(upx::align_up_gap(one, four) == T::make(four - 1));\n            static_assert(upx::align_up_gap(one, four) == T::make(four - one));\n            static_assert(upx::align_up_gap(one, four) == T::make(four + one - one - one));\n            static_assert(upx::align_up_gap(one, four) == T::make(four + one - 2 * one));\n            static_assert(upx::align_down_gap(T::make(4), four) == 0);\n            static_assert(upx::align_down_gap(T::make(5), four) == 1);\n            static_assert(upx::align_down_gap(T::make(6), four) == 2);\n            static_assert(upx::align_down_gap(T::make(7), four) == 3);\n            static_assert(upx::align_down_gap(T::make(8), four) == 0);\n            constexpr T one_copy = T::make(one);\n            static_assert(one_copy == one);\n            static_assert(one_copy == 1);\n        }\n#endif\n        return true;\n    }\n};\n\ntemplate <class T, bool T_is_signed>\nstruct CheckSignedness {\n    static_assert(std::is_integral_v<T>);\n    static_assert(std::is_signed_v<T> == T_is_signed);\n    static_assert(std::is_unsigned_v<T> == !T_is_signed);\n    template <class U, bool U_is_signed>\n    static inline void checkU(void) noexcept {\n        static_assert(std::is_integral_v<U>);\n        static_assert(std::is_signed_v<U> == U_is_signed);\n        static_assert(std::is_unsigned_v<U> == !U_is_signed);\n        static_assert(sizeof(U) == sizeof(T));\n        static_assert(alignof(U) == alignof(T));\n        constexpr U all_bits = U(U(0) - U(1));\n        static_assert(all_bits == U(~U(0)));\n        static_assert(U_is_signed ? (all_bits < 0) : (all_bits > 0));\n    }\n    static void check(void) noexcept {\n        checkU<T, T_is_signed>();\n        using signed_type = std::make_signed_t<T>;\n        checkU<signed_type, true>();\n        using unsigned_type = std::make_unsigned_t<T>;\n        checkU<unsigned_type, false>();\n    }\n};\n\ntemplate <class A, class B>\nstruct CheckTypePair {\n    static_assert(std::is_integral_v<A>);\n    static_assert(std::is_integral_v<B>);\n    static_assert(std::is_signed_v<A>);\n    static_assert(!std::is_unsigned_v<A>);\n    static_assert(std::is_unsigned_v<B>);\n    static_assert(!std::is_signed_v<B>);\n    static_assert(std::is_same_v<A, std::make_signed_t<A> >);\n    static_assert(std::is_same_v<A, std::make_signed_t<B> >);\n    static_assert(std::is_same_v<B, std::make_unsigned_t<A> >);\n    static_assert(std::is_same_v<B, std::make_unsigned_t<B> >);\n    static_assert(sizeof(A) == sizeof(B));\n    static_assert(alignof(A) == alignof(B));\n    static inline void check(void) noexcept {}\n};\n\ntemplate <class A, class B>\nstruct TestNoAliasingStruct { // check working -fno-strict-aliasing\n    static noinline bool test(A *a, B *b) noexcept {\n        *a = 0;\n        *b = 0;\n        *b -= 3;\n        return *a != 0;\n    }\n};\ntemplate <class A, class B>\nstatic forceinline bool testNoAliasing(A *a, B *b) noexcept {\n    return TestNoAliasingStruct<A, B>::test(a, b);\n}\n\ntemplate <class T>\nstruct TestIntegerWrap { // check working -fno-strict-overflow\n    static inline bool inc_gt(const T x) noexcept { return x + 1 > x; }\n    static inline bool dec_lt(const T x) noexcept { return x - 1 < x; }\n    static inline bool neg_eq(const T x) noexcept { return T(T(0) - x) == x; }\n};\n\n//\n// basic exception handling checks to early catch toolchain/qemu/wine/etc problems\n//\n\nstruct TestDestructor {\n    explicit TestDestructor(int *pp, int vv) noexcept : p(pp), v(vv) {}\n    virtual noinline ~TestDestructor() noexcept { *p = (*p << 2) + v; }\n    int *p;\n    int v;\n};\n\nstatic noinline void throwSomeValue(int x) may_throw {\n    if (x < 0)\n        throw int(x);\n    else\n        throw size_t(x);\n}\n\nstatic noinline void check_exceptions_2(void (*func)(int), int *x) may_throw {\n    TestDestructor d(x, *x);\n    func(*x);\n}\n\nstatic noinline void check_basic_cxx_exception_handling(void (*func)(int)) noexcept {\n    bool cxx_exception_handling_works = false;\n    int x = 1;\n    try {\n        TestDestructor d(&x, 3);\n        check_exceptions_2(func, &x);\n    } catch (const size_t &e) {\n        if (e == 1 && x == 23)\n            cxx_exception_handling_works = true;\n    } catch (...) {\n    }\n    assert_noexcept(cxx_exception_handling_works);\n}\n\n//\n// basic floating point checks to early catch toolchain/qemu/wine/etc problems\n//\n\nstatic noinline float i64_f32_add_div(upx_int64_t a, upx_int64_t b) { return (a + b) / 1000000.0f; }\nstatic noinline float u64_f32_add_div(upx_uint64_t a, upx_uint64_t b) {\n    return (a + b) / 1000000.0f;\n}\nstatic noinline float i64_f32_sub_div(upx_int64_t a, upx_int64_t b) { return (a - b) / 1000000.0f; }\nstatic noinline float u64_f32_sub_div(upx_uint64_t a, upx_uint64_t b) {\n    return (a - b) / 1000000.0f;\n}\n\nstatic noinline double i64_f64_add_div(upx_int64_t a, upx_int64_t b) { return (a + b) / 1000000.0; }\nstatic noinline double u64_f64_add_div(upx_uint64_t a, upx_uint64_t b) {\n    return (a + b) / 1000000.0;\n}\nstatic noinline double i64_f64_sub_div(upx_int64_t a, upx_int64_t b) { return (a - b) / 1000000.0; }\nstatic noinline double u64_f64_sub_div(upx_uint64_t a, upx_uint64_t b) {\n    return (a - b) / 1000000.0;\n}\n\ntemplate <class Int, class Float>\nstruct TestFloat {\n    static constexpr Int X = 1000000;\n    static noinline Float div(Int a, Float f) { return a / f; }\n    static noinline Float add_div(Int a, Int b, Float f) { return Float(a + b) / f; }\n    static noinline Float sub_div(Int a, Int b, Float f) { return Float(a - b) / f; }\n    static noinline Float add_div_x(Int a, Int b) { return Float(a + b) / Float(X); }\n    static noinline Float sub_div_x(Int a, Int b) { return Float(a - b) / Float(X); }\n    static noinline void check() noexcept {\n        assert_noexcept(div(2 * X, Float(X)) == Float(2));\n        assert_noexcept(add_div(X, X, Float(X)) == Float(2));\n        assert_noexcept(add_div_x(X, X) == Float(2));\n        assert_noexcept(sub_div(3 * X, X, Float(X)) == Float(2));\n        assert_noexcept(sub_div_x(3 * X, X) == Float(2));\n        // extra debugging; floating point edge cases cause portability problems in practice\n        static const char envvar[] = \"UPX_DEBUG_TEST_FLOAT_DIVISION_BY_ZERO\";\n        if (is_envvar_true(envvar)) {\n#if defined(__FAST_MATH__)\n            // warning: comparison with NaN always evaluates to false in fast floating point modes\n            fprintf(stderr, \"upx: WARNING: ignoring %s: __FAST_MATH__\\n\", envvar);\n#else\n            assert_noexcept(std::isnan(div(0, Float(0))));\n            assert_noexcept(std::isinf(div(1, Float(0))));\n            assert_noexcept(std::isinf(div(Int(-1), Float(0))));\n#endif\n        }\n    }\n};\n\nstatic noinline void check_basic_floating_point(void) noexcept {\n    assert_noexcept(i64_f32_add_div(1000000, 1000000) == 2.0f);\n    assert_noexcept(u64_f32_add_div(1000000, 1000000) == 2.0f);\n    assert_noexcept(i64_f32_sub_div(3000000, 1000000) == 2.0f);\n    assert_noexcept(u64_f32_sub_div(3000000, 1000000) == 2.0f);\n    assert_noexcept(i64_f64_add_div(1000000, 1000000) == 2.0);\n    assert_noexcept(u64_f64_add_div(1000000, 1000000) == 2.0);\n    assert_noexcept(i64_f64_sub_div(3000000, 1000000) == 2.0);\n    assert_noexcept(u64_f64_sub_div(3000000, 1000000) == 2.0);\n    TestFloat<upx_int32_t, float>::check();\n    TestFloat<upx_uint32_t, float>::check();\n    TestFloat<upx_int64_t, float>::check();\n    TestFloat<upx_uint64_t, float>::check();\n    TestFloat<upx_int32_t, double>::check();\n    TestFloat<upx_uint32_t, double>::check();\n    TestFloat<upx_int64_t, double>::check();\n    TestFloat<upx_uint64_t, double>::check();\n}\n\n} // namespace\n\n#define ACC_WANT_ACC_CHK_CH 1\n#undef ACCCHK_ASSERT\n#include \"../util/miniacc.h\"\n\nvoid upx_compiler_sanity_check(void) noexcept {\n    check_basic_floating_point();\n\n    if (is_envvar_true(\"UPX_DEBUG_DOCTEST_DISABLE\", \"UPX_DEBUG_DISABLE_DOCTEST\")) {\n        // If UPX_DEBUG_DOCTEST_DISABLE is set then we don't want to throw any\n        // exceptions in order to improve debugging experience.\n    } else {\n        // check working C++ exception handling to early catch toolchain/qemu/wine/etc problems\n        check_basic_cxx_exception_handling(throwSomeValue);\n    }\n\n    // check_basic_decltype()\n    {\n        auto a = +0;\n        constexpr auto b = -0;\n        const auto &c = -1;\n        static_assert((std::is_same<int, decltype(a)>::value));\n        static_assert((std::is_same<const int, decltype(b)>::value));\n        static_assert((std::is_same<const int &, decltype(c)>::value));\n        UNUSED(a);\n        UNUSED(b);\n        UNUSED(c);\n    }\n\n#define ACC_WANT_ACC_CHK_CH 1\n#undef ACCCHK_ASSERT\n#define ACCCHK_ASSERT(expr) ACC_COMPILE_TIME_ASSERT(expr)\n#include \"../util/miniacc.h\"\n#undef ACCCHK_ASSERT\n\n    static_assert(sizeof(char) == 1);\n    static_assert(sizeof(short) == 2);\n    static_assert(sizeof(int) == 4);\n    static_assert(sizeof(long) >= 4);\n    static_assert(sizeof(long long) >= 8);\n    static_assert(sizeof(void *) >= 4);\n    static_assert(sizeof(upx_off_t) >= 8);\n    static_assert(sizeof(upx_off_t) >= sizeof(long long));\n\n// __int64\n#if defined(_MSC_VER)\n    {\n        ASSERT_SAME_TYPE(long long, __int64);\n        ASSERT_SAME_TYPE(unsigned long long, unsigned __int64);\n        typedef __int64 my_int64;\n        typedef unsigned __int64 my_uint64;\n        ASSERT_SAME_TYPE(long long, my_int64);\n        ASSERT_SAME_TYPE(unsigned long long, my_uint64);\n    }\n#endif\n\n    static_assert(sizeof(BE16) == 2);\n    static_assert(sizeof(BE32) == 4);\n    static_assert(sizeof(BE64) == 8);\n    static_assert(sizeof(LE16) == 2);\n    static_assert(sizeof(LE32) == 4);\n    static_assert(sizeof(LE64) == 8);\n\n    COMPILE_TIME_ASSERT_ALIGNED1(BE16)\n    COMPILE_TIME_ASSERT_ALIGNED1(BE32)\n    COMPILE_TIME_ASSERT_ALIGNED1(BE64)\n    COMPILE_TIME_ASSERT_ALIGNED1(LE16)\n    COMPILE_TIME_ASSERT_ALIGNED1(LE32)\n    COMPILE_TIME_ASSERT_ALIGNED1(LE64)\n\n    // check that these types are not some multi-word macro\n#define CHECK_TYPE(T) (void) (T())\n    CHECK_TYPE(int8_t);\n    CHECK_TYPE(uint8_t);\n    CHECK_TYPE(int16_t);\n    CHECK_TYPE(uint16_t);\n    CHECK_TYPE(int32_t);\n    CHECK_TYPE(uint32_t);\n    CHECK_TYPE(int64_t);\n    CHECK_TYPE(uint64_t);\n    CHECK_TYPE(intmax_t);\n    CHECK_TYPE(uintmax_t);\n    CHECK_TYPE(ptrdiff_t);\n    CHECK_TYPE(size_t);\n    CHECK_TYPE(intptr_t);\n    CHECK_TYPE(uintptr_t);\n#if 0\n    CHECK_TYPE(acc_int8_t);\n    CHECK_TYPE(acc_uint8_t);\n    CHECK_TYPE(acc_int16_t);\n    CHECK_TYPE(acc_uint16_t);\n    CHECK_TYPE(acc_int32_t);\n    CHECK_TYPE(acc_uint32_t);\n    CHECK_TYPE(acc_int64_t);\n    CHECK_TYPE(acc_uint64_t);\n    CHECK_TYPE(acc_intptr_t);\n    CHECK_TYPE(acc_uintptr_t);\n#endif\n    CHECK_TYPE(upx_int8_t);\n    CHECK_TYPE(upx_uint8_t);\n    CHECK_TYPE(upx_int16_t);\n    CHECK_TYPE(upx_uint16_t);\n    CHECK_TYPE(upx_int32_t);\n    CHECK_TYPE(upx_uint32_t);\n    CHECK_TYPE(upx_int64_t);\n    CHECK_TYPE(upx_uint64_t);\n#if (__SIZEOF_INT128__ == 16)\n    CHECK_TYPE(upx_int128_t);\n    CHECK_TYPE(upx_uint128_t);\n#endif\n    CHECK_TYPE(upx_ptraddr_t);\n    CHECK_TYPE(upx_uintptr_t);\n    CHECK_TYPE(upx_uptrdiff_t);\n    CHECK_TYPE(upx_ssize_t);\n#undef CHECK_TYPE\n\n    CheckIntegral<char>::check();\n    CheckIntegral<signed char>::check();\n    CheckIntegral<unsigned char>::check();\n    CheckIntegral<short>::check();\n    CheckIntegral<unsigned short>::check();\n    CheckIntegral<int>::check();\n    CheckIntegral<unsigned>::check();\n    CheckIntegral<long>::check();\n    CheckIntegral<unsigned long>::check();\n    CheckIntegral<long long>::check();\n    CheckIntegral<unsigned long long>::check();\n    CheckIntegral<intmax_t>::check();\n    CheckIntegral<uintmax_t>::check();\n    CheckIntegral<upx_int8_t>::check();\n    CheckIntegral<upx_uint8_t>::check();\n    CheckIntegral<upx_int16_t>::check();\n    CheckIntegral<upx_uint16_t>::check();\n    CheckIntegral<upx_int32_t>::check();\n    CheckIntegral<upx_uint32_t>::check();\n    CheckIntegral<upx_int64_t>::check();\n    CheckIntegral<upx_uint64_t>::check();\n    CheckIntegral<upx_off_t>::check();\n    CheckIntegral<ptrdiff_t>::check();\n    CheckIntegral<size_t>::check();\n    CheckIntegral<upx_ptraddr_t>::check();\n#if defined(__CHERI__) && defined(__CHERI_PURE_CAPABILITY__)\n    static_assert(sizeof(upx_ptraddr_t) == 8);\n    static_assert(alignof(upx_ptraddr_t) == 8);\n    static_assert(sizeof(void *) == 16);\n    static_assert(alignof(void *) == 16);\n    static_assert(sizeof(uintptr_t) == 16);\n    static_assert(alignof(uintptr_t) == 16);\n    // warning: binary expression on capability types 'unsigned __intcap' and 'unsigned __intcap'\n    CheckIntegral<intptr_t>::check_core();\n    CheckIntegral<uintptr_t>::check_core();\n    CheckIntegral<upx_uintptr_t>::check_core();\n#else\n    CheckIntegral<intptr_t>::check();\n    CheckIntegral<uintptr_t>::check();\n    CheckIntegral<upx_uintptr_t>::check();\n#endif\n#if (__SIZEOF_INT128__ == 16)\n#if defined(_CPP_VER) || defined(_WIN32) // int128 is not fully supported by MSVC libstdc++ yet\n#else\n    CheckIntegral<upx_int128_t>::check();\n    CheckIntegral<upx_uint128_t>::check();\n#endif\n#endif\n\n    CheckSignedness<char, false>::check(); // -funsigned-char\n    CheckSignedness<signed char, true>::check();\n    CheckSignedness<unsigned char, false>::check();\n    CheckSignedness<short, true>::check();\n    CheckSignedness<unsigned short, false>::check();\n    CheckSignedness<int, true>::check();\n    CheckSignedness<unsigned, false>::check();\n    CheckSignedness<long, true>::check();\n    CheckSignedness<unsigned long, false>::check();\n    CheckSignedness<long long, true>::check();\n    CheckSignedness<unsigned long long, false>::check();\n    CheckSignedness<intmax_t, true>::check();\n    CheckSignedness<uintmax_t, false>::check();\n    CheckSignedness<upx_int8_t, true>::check();\n    CheckSignedness<upx_uint8_t, false>::check();\n    CheckSignedness<upx_int16_t, true>::check();\n    CheckSignedness<upx_uint16_t, false>::check();\n    CheckSignedness<upx_int32_t, true>::check();\n    CheckSignedness<upx_uint32_t, false>::check();\n    CheckSignedness<upx_int64_t, true>::check();\n    CheckSignedness<upx_uint64_t, false>::check();\n#if (__SIZEOF_INT128__ == 16)\n#if defined(_CPP_VER) || defined(_WIN32) // int128 is not fully supported by MSVC libstdc++ yet\n#else\n    CheckSignedness<upx_int128_t, true>::check();\n    CheckSignedness<upx_uint128_t, false>::check();\n#endif\n#endif\n    CheckSignedness<upx_off_t, true>::check();\n    CheckSignedness<ptrdiff_t, true>::check();\n    CheckSignedness<size_t, false>::check();\n    CheckSignedness<upx_ptraddr_t, false>::check();\n    CheckSignedness<intptr_t, true>::check();\n    CheckSignedness<uintptr_t, false>::check();\n    CheckSignedness<upx_uintptr_t, false>::check();\n\n#define CHECK_TYPE_PAIR(A, B)                                                                      \\\n    CheckTypePair<A, B>::check();                                                                  \\\n    static_assert(alignof(A) == alignof(B))\n    CHECK_TYPE_PAIR(signed char, unsigned char);\n    CHECK_TYPE_PAIR(short, unsigned short);\n    CHECK_TYPE_PAIR(int, unsigned);\n    CHECK_TYPE_PAIR(long, unsigned long);\n    CHECK_TYPE_PAIR(long long, unsigned long long);\n    CHECK_TYPE_PAIR(intmax_t, uintmax_t);\n    CHECK_TYPE_PAIR(upx_int8_t, upx_uint8_t);\n    CHECK_TYPE_PAIR(upx_int16_t, upx_uint16_t);\n    CHECK_TYPE_PAIR(upx_int32_t, upx_uint32_t);\n    CHECK_TYPE_PAIR(upx_int64_t, upx_uint64_t);\n#if (__SIZEOF_INT128__ == 16)\n#if defined(_CPP_VER) || defined(_WIN32) // int128 is not fully supported by MSVC libstdc++ yet\n#else\n    CHECK_TYPE_PAIR(upx_int128_t, upx_uint128_t);\n#endif\n#endif\n    CHECK_TYPE_PAIR(ptrdiff_t, upx_uptrdiff_t);\n    CHECK_TYPE_PAIR(upx_ssize_t, size_t);\n    CHECK_TYPE_PAIR(upx_sptraddr_t, upx_ptraddr_t);\n    CHECK_TYPE_PAIR(intptr_t, uintptr_t);\n    CHECK_TYPE_PAIR(acc_intptr_t, acc_uintptr_t);\n#undef CHECK_TYPE_PAIR\n\n    static_assert(sizeof(upx_charptr_unit_type) == 1);\n    COMPILE_TIME_ASSERT_ALIGNED1(upx_charptr_unit_type)\n    static_assert(sizeof(*((charptr) nullptr)) == 1);\n\n    // check UPX_VERSION_xxx\n    {\n        using upx::compile_time::mem_eq;\n        using upx::compile_time::string_len;\n        static_assert(string_len(UPX_VERSION_STRING4) == 4);\n        static_assert(string_len(UPX_VERSION_YEAR) == 4);\n        static_assert(string_len(UPX_VERSION_DATE_ISO) == 10);\n        static_assert(string_len(UPX_VERSION_DATE) == 12 || string_len(UPX_VERSION_DATE) == 13);\n        static_assert(mem_eq(UPX_VERSION_STRING4, UPX_VERSION_STRING, 3));\n        static_assert(mem_eq(UPX_VERSION_YEAR, UPX_VERSION_DATE_ISO, 4));\n        static_assert(mem_eq(UPX_VERSION_YEAR, &UPX_VERSION_DATE[sizeof(UPX_VERSION_DATE) - 5], 4));\n        char buf[16];\n        constexpr long long v = UPX_VERSION_HEX;\n        upx_safe_snprintf(buf, sizeof(buf), \"%lld.%lld.%lld\", (v >> 16), (v >> 8) & 255, v & 255);\n        assert_noexcept(strcmp(buf, UPX_VERSION_STRING) == 0);\n        upx_safe_snprintf(buf, sizeof(buf), \"%lld.%lld%lld\", (v >> 16), (v >> 8) & 255, v & 255);\n        assert_noexcept(strcmp(buf, UPX_VERSION_STRING4) == 0);\n    }\n\n    if (gitrev[0]) {\n        size_t revlen = strlen(gitrev);\n        if (strncmp(gitrev, \"ERROR\", 5) == 0) {\n            assert_noexcept(revlen == 5 || revlen == 6);\n        } else {\n            assert_noexcept(revlen == 12 || revlen == 13);\n        }\n        if (revlen == 6 || revlen == 13) {\n            assert_noexcept(gitrev[revlen - 1] == '+');\n        }\n    }\n    assert_noexcept(UPX_RSIZE_MAX_MEM == 805306368);\n\n#if DEBUG || 1\n    assert_noexcept(TestBELE<LE16>::test());\n    assert_noexcept(TestBELE<LE32>::test());\n    assert_noexcept(TestBELE<LE64>::test());\n    assert_noexcept(TestBELE<BE16>::test());\n    assert_noexcept(TestBELE<BE32>::test());\n    assert_noexcept(TestBELE<BE64>::test());\n    {\n        alignas(16) static constexpr const byte dd[32] = {\n            0, 0, 0, 0,    0,    0,    0,    0xff, 0xfe, 0xfd, 0xfc, 0xfb, 0xfa, 0xf9, 0xf8, 0,\n            0, 0, 0, 0x7f, 0x7e, 0x7d, 0x7c, 0x7b, 0x7a, 0x79, 0x78, 0,    0,    0,    0,    0};\n        constexpr const byte *d = dd + 7;\n#if !defined(upx_fake_alignas_16)\n        assert_noexcept(ptr_is_aligned<16>(dd));\n        assert_noexcept(ptr_is_aligned(dd, 16));\n#endif\n        static_assert(upx::compile_time::get_be16(d) == 0xfffe);\n        static_assert(upx::compile_time::get_be24(d) == 0xfffefd);\n        static_assert(upx::compile_time::get_be32(d) == 0xfffefdfc);\n        static_assert(upx::compile_time::get_be64(d) == 0xfffefdfcfbfaf9f8ULL);\n        static_assert(upx::compile_time::get_le16(d) == 0xfeff);\n        static_assert(upx::compile_time::get_le24(d) == 0xfdfeff);\n        static_assert(upx::compile_time::get_le32(d) == 0xfcfdfeff);\n        static_assert(upx::compile_time::get_le64(d) == 0xf8f9fafbfcfdfeffULL);\n        assert_noexcept(upx_adler32(d, 4) == 0x09f003f7);\n        assert_noexcept(upx_adler32(d, 4, 0) == 0x09ec03f6);\n        assert_noexcept(upx_adler32(d, 4, 1) == 0x09f003f7);\n        const N_BELE_RTP::AbstractPolicy *bele;\n        bele = &N_BELE_RTP::be_policy;\n        assert_noexcept(get_be16(d) == 0xfffe);\n        assert_noexcept(bele->get16(d) == 0xfffe);\n        assert_noexcept(get_be16_signed(d) == -2);\n        assert_noexcept(get_be24(d) == 0xfffefd);\n        assert_noexcept(bele->get24(d) == 0xfffefd);\n        assert_noexcept(get_be24_signed(d) == -259);\n        assert_noexcept(get_be32(d) == 0xfffefdfc);\n        assert_noexcept(bele->get32(d) == 0xfffefdfc);\n        assert_noexcept(get_be32_signed(d) == -66052);\n        assert_noexcept(get_be64(d) == 0xfffefdfcfbfaf9f8ULL);\n        assert_noexcept(bele->get64(d) == 0xfffefdfcfbfaf9f8ULL);\n        assert_noexcept(get_be64_signed(d) == -283686952306184LL);\n        bele = &N_BELE_RTP::le_policy;\n        assert_noexcept(get_le16(d) == 0xfeff);\n        assert_noexcept(bele->get16(d) == 0xfeff);\n        assert_noexcept(get_le16_signed(d) == -257);\n        assert_noexcept(get_le24(d) == 0xfdfeff);\n        assert_noexcept(bele->get24(d) == 0xfdfeff);\n        assert_noexcept(get_le24_signed(d) == -131329);\n        assert_noexcept(get_le32(d) == 0xfcfdfeff);\n        assert_noexcept(bele->get32(d) == 0xfcfdfeff);\n        assert_noexcept(get_le32_signed(d) == -50462977);\n        assert_noexcept(get_le64(d) == 0xf8f9fafbfcfdfeffULL);\n        assert_noexcept(bele->get64(d) == 0xf8f9fafbfcfdfeffULL);\n        assert_noexcept(get_le64_signed(d) == -506097522914230529LL);\n        static_assert(get_be24(d) == 0xfffefd);\n        static_assert(get_le24(d) == 0xfdfeff);\n#if defined(upx_is_constant_evaluated)\n        static_assert(get_be24_signed(d) == -259);\n        static_assert(get_le24_signed(d) == -131329);\n        static_assert(get_be16(d) == 0xfffe);\n        static_assert(get_be16_signed(d) == -2);\n        static_assert(get_be32(d) == 0xfffefdfc);\n        static_assert(get_be32_signed(d) == -66052);\n        static_assert(get_be64(d) == 0xfffefdfcfbfaf9f8ULL);\n        static_assert(get_be64_signed(d) == -283686952306184LL);\n        static_assert(get_le16(d) == 0xfeff);\n        static_assert(get_le16_signed(d) == -257);\n        static_assert(get_le32(d) == 0xfcfdfeff);\n        static_assert(get_le32_signed(d) == -50462977);\n        static_assert(get_le64(d) == 0xf8f9fafbfcfdfeffULL);\n        static_assert(get_le64_signed(d) == -506097522914230529LL);\n#endif\n        assert_noexcept(find_be16(d, 2, 0xfffe) == 0);\n        assert_noexcept(find_le16(d, 2, 0xfeff) == 0);\n        assert_noexcept(find_be32(d, 4, 0xfffefdfc) == 0);\n        assert_noexcept(find_le32(d, 4, 0xfcfdfeff) == 0);\n        constexpr const byte *e = d + 12;\n        assert_noexcept(get_be16_signed(e) == 32638);\n        assert_noexcept(get_be24_signed(e) == 8355453);\n        assert_noexcept(get_be32_signed(e) == 2138996092);\n        assert_noexcept(get_be64_signed(e) == 9186918263483431288LL);\n#if defined(upx_is_constant_evaluated)\n        static_assert(get_be16_signed(e) == 32638);\n        static_assert(get_be24_signed(e) == 8355453);\n        static_assert(get_be32_signed(e) == 2138996092);\n        static_assert(get_be64_signed(e) == 9186918263483431288LL);\n#endif\n    }\n#if defined(upx_is_constant_evaluated)\n    {\n        constexpr upx_uint16_t v16 = 0x0201;\n        constexpr upx_uint32_t v32 = 0x04030201;\n        constexpr upx_uint64_t v64 = 0x0807060504030201ull;\n        constexpr BE16 be16 = BE16::make(v16);\n        constexpr BE32 be32 = BE32::make(v32);\n        constexpr BE64 be64 = BE64::make(v64);\n        constexpr LE16 le16 = LE16::make(v16);\n        constexpr LE32 le32 = LE32::make(v32);\n        constexpr LE64 le64 = LE64::make(v64);\n        using upx::compile_time::mem_eq;\n        static_assert(mem_eq(be16.d, \"\\x02\\x01\", 2));\n        static_assert(mem_eq(be32.d, \"\\x04\\x03\\x02\\x01\", 4));\n        static_assert(mem_eq(be64.d, \"\\x08\\x07\\x06\\x05\\x04\\x03\\x02\\x01\", 8));\n        static_assert(mem_eq(le16.d, \"\\x01\\x02\", 2));\n        static_assert(mem_eq(le32.d, \"\\x01\\x02\\x03\\x04\", 4));\n        static_assert(mem_eq(le64.d, \"\\x01\\x02\\x03\\x04\\x05\\x06\\x07\\x08\", 8));\n        constexpr NE16 ne16 = NE16::make(v16);\n        constexpr NE32 ne32 = NE32::make(v32);\n        constexpr NE64 ne64 = NE64::make(v64);\n        assert_noexcept(memcmp(&v16, ne16.d, 2) == 0);\n        assert_noexcept(memcmp(&v32, ne32.d, 4) == 0);\n        assert_noexcept(memcmp(&v64, ne64.d, 8) == 0);\n    }\n#endif\n#if DEBUG >= 1\n    {\n        for (int i = 0; i < 256; i++) {\n            {\n                const unsigned u = i;\n                assert_noexcept(sign_extend32(u, 1) == ((i & 1) ? -1 : 0));\n                assert_noexcept(sign_extend32(u, 2) == ((i & 2) ? -2 + (i & 1) : (i & 1)));\n                assert_noexcept(sign_extend32(u, 3) == ((i & 4) ? -4 + (i & 3) : (i & 3)));\n                assert_noexcept(sign_extend32(u, 4) == ((i & 8) ? -8 + (i & 7) : (i & 7)));\n                assert_noexcept(sign_extend32(u, 5) == ((i & 16) ? -16 + (i & 15) : (i & 15)));\n                assert_noexcept(sign_extend32(u, 6) == ((i & 32) ? -32 + (i & 31) : (i & 31)));\n                assert_noexcept(sign_extend32(u, 7) == ((i & 64) ? -64 + (i & 63) : (i & 63)));\n                assert_noexcept(sign_extend32(u, 8) == ((i & 128) ? -128 + (i & 127) : (i & 127)));\n                assert_noexcept(sign_extend32(u, 9) == i);\n                assert_noexcept(sign_extend32(u, 32) == i);\n                assert_noexcept(sign_extend32(0u - u, 32) == -i);\n            }\n            {\n                const upx_uint64_t u = i;\n                assert_noexcept(sign_extend64(u, 1) == ((i & 1) ? -1 : 0));\n                assert_noexcept(sign_extend64(u, 2) == ((i & 2) ? -2 + (i & 1) : (i & 1)));\n                assert_noexcept(sign_extend64(u, 3) == ((i & 4) ? -4 + (i & 3) : (i & 3)));\n                assert_noexcept(sign_extend64(u, 4) == ((i & 8) ? -8 + (i & 7) : (i & 7)));\n                assert_noexcept(sign_extend64(u, 5) == ((i & 16) ? -16 + (i & 15) : (i & 15)));\n                assert_noexcept(sign_extend64(u, 6) == ((i & 32) ? -32 + (i & 31) : (i & 31)));\n                assert_noexcept(sign_extend64(u, 7) == ((i & 64) ? -64 + (i & 63) : (i & 63)));\n                assert_noexcept(sign_extend64(u, 8) == ((i & 128) ? -128 + (i & 127) : (i & 127)));\n                assert_noexcept(sign_extend64(u, 9) == i);\n                assert_noexcept(sign_extend64(u, 32) == i);\n                assert_noexcept(sign_extend64(upx_uint64_t(0) - u, 32) == -i);\n                assert_noexcept(sign_extend64(u, 64) == i);\n                assert_noexcept(sign_extend64(upx_uint64_t(0) - u, 64) == -i);\n            }\n        }\n    }\n#endif\n    {\n        unsigned dd;\n        void *const d = &dd;\n        dd = ne32_to_le32(0xf7f6f5f4);\n        assert_noexcept(get_le26(d) == 0x03f6f5f4);\n        set_le26(d, 0);\n        assert_noexcept(get_le26(d) == 0);\n        assert_noexcept(dd == ne32_to_le32(0xf4000000));\n        set_le26(d, 0xff020304);\n        assert_noexcept(get_le26(d) == 0x03020304);\n        assert_noexcept(dd == ne32_to_le32(0xf7020304));\n    }\n    {\n        upx_uint16_t a = 0;\n        upx_uint32_t b = 0;\n        upx_uint64_t c = 0;\n        set_ne16(&a, 0x04030201); // ignore upper bits\n        set_ne32(&b, 0x04030201);\n        set_ne64(&c, 0x0807060504030201ull);\n        assert_noexcept(a == 0x0201);\n        assert_noexcept(b == 0x04030201);\n        assert_noexcept(c == 0x0807060504030201ull);\n        assert_noexcept(get_ne16(&a) == 0x0201);\n        assert_noexcept(get_ne32(&b) == 0x04030201);\n        assert_noexcept(get_ne64(&c) == 0x0807060504030201ull);\n    }\n#endif // DEBUG\n    union {\n        short v_short;\n        int v_int;\n        long v_long;\n        long long v_llong;\n        BE16 b16;\n        BE32 b32;\n        BE64 b64;\n        LE16 l16;\n        LE32 l32;\n        LE64 l64;\n    } u;\n    assert_noexcept(testNoAliasing(&u.v_short, &u.b32));\n    assert_noexcept(testNoAliasing(&u.v_short, &u.l32));\n    assert_noexcept(testNoAliasing(&u.v_int, &u.b64));\n    assert_noexcept(testNoAliasing(&u.v_int, &u.l64));\n    // check working -fno-strict-aliasing\n    assert_noexcept(testNoAliasing(&u.v_short, &u.v_int));\n    assert_noexcept(testNoAliasing(&u.v_int, &u.v_long));\n    assert_noexcept(testNoAliasing(&u.v_int, &u.v_llong));\n    assert_noexcept(testNoAliasing(&u.v_long, &u.v_llong));\n\n    assert_noexcept(TestIntegerWrap<unsigned>::inc_gt(0));\n    assert_noexcept(!TestIntegerWrap<unsigned>::inc_gt(UINT_MAX));\n    assert_noexcept(TestIntegerWrap<unsigned>::dec_lt(1));\n    assert_noexcept(!TestIntegerWrap<unsigned>::dec_lt(0));\n    assert_noexcept(TestIntegerWrap<unsigned>::neg_eq(0));\n    assert_noexcept(!TestIntegerWrap<unsigned>::neg_eq(1));\n    assert_noexcept(!TestIntegerWrap<unsigned>::neg_eq(UINT_MAX));\n    // check working -fno-strict-overflow\n    assert_noexcept(TestIntegerWrap<int>::inc_gt(0));\n    assert_noexcept(!TestIntegerWrap<int>::inc_gt(INT_MAX));\n    assert_noexcept(TestIntegerWrap<int>::dec_lt(0));\n    assert_noexcept(!TestIntegerWrap<int>::dec_lt(INT_MIN));\n    assert_noexcept(TestIntegerWrap<int>::neg_eq(0));\n    assert_noexcept(!TestIntegerWrap<int>::neg_eq(1));\n    assert_noexcept(!TestIntegerWrap<int>::neg_eq(INT_MAX));\n    assert_noexcept(TestIntegerWrap<int>::neg_eq(INT_MIN)); // special case\n}\n\n/*************************************************************************\n// some doctest test cases\n**************************************************************************/\n\nTEST_CASE(\"assert_noexcept\") {\n    // just to make sure that our own assert() macros do not trigger any compiler warnings\n    byte dummy = 0;\n    byte *ptr1 = &dummy;\n    const byte *const ptr2 = &dummy;\n    void *ptr3 = nullptr;\n    assert(true);\n    assert(1);\n    assert(ptr1);\n    assert(ptr2);\n    assert(!ptr3);\n    assert_noexcept(true);\n    assert_noexcept(1);\n    assert_noexcept(ptr1);\n    assert_noexcept(ptr2);\n    assert_noexcept(!ptr3);\n}\n\nTEST_CASE(\"acc_vget\") {\n    CHECK_EQ(acc_vget_int(0, 0), 0);\n    CHECK_EQ(acc_vget_long(1, -1), 1);\n    CHECK_EQ(acc_vget_acc_int64l_t(2, 1), 2);\n    CHECK_EQ(acc_vget_acc_hvoid_p(nullptr, 0), nullptr);\n    if (acc_vget_int(1, 0) > 0)\n        return;\n    assert_noexcept(false);\n}\n\nTEST_CASE(\"ptr_invalidate_and_poison\") {\n    int *ip = nullptr; // initialized\n    ptr_invalidate_and_poison(ip);\n    assert(ip != nullptr);\n    (void) ip;\n    double *dp; // not initialized\n    ptr_invalidate_and_poison(dp);\n    assert(dp != nullptr);\n    (void) dp;\n}\n\nTEST_CASE(\"upx_getenv\") {\n    CHECK_EQ(upx_getenv(nullptr), nullptr);\n    CHECK_EQ(upx_getenv(\"\"), nullptr);\n}\n\nTEST_CASE(\"working -fno-strict-aliasing\") {\n    bool ok;\n    long v = 0;\n    short *ps = ACC_STATIC_CAST(short *, acc_vget_acc_hvoid_p(&v, 0));\n    int *pi = ACC_STATIC_CAST(int *, acc_vget_acc_hvoid_p(&v, 0));\n    long *pl = ACC_STATIC_CAST(long *, acc_vget_acc_hvoid_p(&v, 0));\n    *ps = 0;\n    *pl = -1;\n    ok = *ps == -1;\n    CHECK(ok);\n    *pi = 0;\n    *pl = -1;\n    ok = *pi == -1;\n    CHECK(ok);\n    *pl = 0;\n    *ps = -1;\n    ok = *pl != 0;\n    CHECK(ok);\n    *pl = 0;\n    *pi = -1;\n    ok = *pl != 0;\n    CHECK(ok);\n    UNUSED(ok);\n}\n\nTEST_CASE(\"working -fno-strict-overflow\") {\n    CHECK_EQ(acc_vget_int(INT_MAX, 0) + 1, INT_MIN);\n    CHECK_EQ(acc_vget_int(INT_MIN, 0) - 1, INT_MAX);\n    CHECK_EQ(acc_vget_long(LONG_MAX, 0) + 1, LONG_MIN);\n    CHECK_EQ(acc_vget_long(LONG_MIN, 0) - 1, LONG_MAX);\n    bool ok;\n    int i;\n    i = INT_MAX;\n    i += 1;\n    ok = i == INT_MIN;\n    CHECK(ok);\n    i = INT_MIN;\n    i -= 1;\n    ok = i == INT_MAX;\n    CHECK(ok);\n    UNUSED(ok);\n}\n\nTEST_CASE(\"libc snprintf\") {\n    // runtime check that Windows/MinGW <stdio.h> works as expected\n    char buf[64];\n    long long ll = acc_vget_int(-1, 0);\n    unsigned long long llu = (upx_uint64_t) (upx_int64_t) ll;\n    snprintf(buf, sizeof(buf), \"%d.%ld.%lld.%u.%lu.%llu\", -3, -2L, ll, 3U, 2LU, llu);\n    CHECK_EQ(strcmp(buf, \"-3.-2.-1.3.2.18446744073709551615\"), 0);\n    intmax_t im = ll;\n    uintmax_t um = llu;\n    snprintf(buf, sizeof(buf), \"%d.%d.%d.%d.%d.%d.%d.%d.%d.%jd\", -4, 0, 0, 0, 0, 0, 0, 0, 4, im);\n    CHECK_EQ(strcmp(buf, \"-4.0.0.0.0.0.0.0.4.-1\"), 0);\n    snprintf(buf, sizeof(buf), \"%d.%d.%d.%d.%d.%d.%d.%d.%d.%ju\", -5, 0, 0, 0, 0, 0, 0, 0, 5, um);\n    CHECK_EQ(strcmp(buf, \"-5.0.0.0.0.0.0.0.5.18446744073709551615\"), 0);\n    snprintf(buf, sizeof(buf), \"%d.%d.%d.%d.%d.%d.%d.%d.%d.%jx\", -6, 0, 0, 0, 0, 0, 0, 0, 6, um);\n    CHECK_EQ(strcmp(buf, \"-6.0.0.0.0.0.0.0.6.ffffffffffffffff\"), 0);\n    snprintf(buf, sizeof(buf), \"%d.%d.%d.%d.%d.%d.%d.%d.%d.%#jx\", -7, 0, 0, 0, 0, 0, 0, 0, 7, um);\n    CHECK_EQ(strcmp(buf, \"-7.0.0.0.0.0.0.0.7.0xffffffffffffffff\"), 0);\n    snprintf(buf, sizeof(buf), \"%#X %#lx %#llx\", 26u, 27ul, 28ull);\n    CHECK_EQ(strcmp(buf, \"0X1A 0x1b 0x1c\"), 0);\n    snprintf(buf, sizeof(buf), \"%#06x %#06lX %#06llx\", 26u, 27ul, 28ull);\n    CHECK_EQ(strcmp(buf, \"0x001a 0X001B 0x001c\"), 0);\n    snprintf(buf, sizeof(buf), \"%#6x %#6lx %#6llX\", 26u, 27ul, 28ull);\n    CHECK_EQ(strcmp(buf, \"  0x1a   0x1b   0X1C\"), 0);\n    snprintf(buf, sizeof(buf), \"%#-6X %#-6lx %#-6llx\", 26u, 27ul, 28ull);\n    CHECK_EQ(strcmp(buf, \"0X1A   0x1b   0x1c  \"), 0);\n}\n\nTEST_CASE(\"libc qsort\") {\n    // runtime check that libc qsort() never compares identical objects\n    // UPDATE: while only poor implementations of qsort() would actually do this\n    //   it is probably allowed by the standard, so skip this test by default\n    if (!is_envvar_true(\"UPX_DEBUG_TEST_LIBC_QSORT\"))\n        return;\n\n    struct Elem {\n        upx_uint16_t id;\n        upx_uint16_t value;\n        static int __acc_cdecl_qsort compare(const void *aa, const void *bb) noexcept {\n            const Elem *a = (const Elem *) aa;\n            const Elem *b = (const Elem *) bb;\n            assert_noexcept(a->id != b->id); // check not IDENTICAL\n            return a->value == b->value ? 0 : (a->value < b->value ? -1 : 1);\n        }\n        static noinline bool check_sort(upx_sort_func_t sort, Elem *e, size_t n, bool is_stable) {\n            upx_uint32_t x = 5381 + (upx_rand() & 255);\n            for (size_t i = 0; i < n; i++) {\n                e[i].id = (upx_uint16_t) i;\n                x = x * 33 + 1 + (i & 255);\n                e[i].value = (upx_uint16_t) ((x >> 4) & 15);\n            }\n            sort(e, n, sizeof(Elem), Elem::compare);\n            // verify\n            for (size_t i = 1; i < n; i++) {\n                if very_unlikely (e[i - 1].value > e[i].value)\n                    return false;\n                if (is_stable)\n                    if very_unlikely (e[i - 1].value == e[i].value && e[i - 1].id >= e[i].id)\n                        return false;\n            }\n            return true;\n        }\n    };\n    constexpr size_t N = 4096;\n    Elem e[N];\n    for (size_t n = 0; n <= N; n = 2 * n + 1) {\n        // system sort functions\n        CHECK(Elem::check_sort(::qsort, e, n, false)); // libc qsort()\n#if UPX_CONFIG_USE_STABLE_SORT\n        upx_sort_func_t wrap_stable_sort = [](void *aa, size_t nn, size_t, upx_compare_func_t cc) {\n            upx_std_stable_sort<sizeof(Elem)>(aa, nn, cc);\n        };\n        CHECK(Elem::check_sort(wrap_stable_sort, e, n, true)); // std::stable_sort()\n#endif\n        // simple UPX sort functions\n        CHECK(Elem::check_sort(upx_gnomesort, e, n, true));\n        CHECK(Elem::check_sort(upx_shellsort_memswap, e, n, false));\n        CHECK(Elem::check_sort(upx_shellsort_memcpy, e, n, false));\n    }\n}\n\n/* vim:set ts=4 sw=4 et: */\n","size_bytes":60131},".ccls-cache/@home@runner@workspace/src@help.cpp":{"content":"/* help.cpp --\n\n   This file is part of the Resize executable compressor.\n\n   Copyright (C) 2025 WHO-AM-I-404\n   Based on UPX - Ultimate Packer for eXecutables\n   Copyright (C) 1996-2025 Markus Franz Xaver Johannes Oberhumer\n   Copyright (C) 1996-2025 Laszlo Molnar\n   All Rights Reserved.\n\n   Resize and the UCL library are free software; you can redistribute them\n   and/or modify them under the terms of the GNU General Public License as\n   published by the Free Software Foundation; either version 2 of\n   the License, or (at your option) any later version.\n\n   This program is distributed in the hope that it will be useful,\n   but WITHOUT ANY WARRANTY; without even the implied warranty of\n   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n   GNU General Public License for more details.\n\n   You should have received a copy of the GNU General Public License\n   along with this program; see the file COPYING.\n   If not, write to the Free Software Foundation, Inc.,\n   59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.\n\n   WHO-AM-I-404 <who-am-i-404@proton.me>\n   Based on original work by:\n   Markus F.X.J. Oberhumer <markus@oberhumer.com>\n   Laszlo Molnar <ezerotven+github@gmail.com>\n */\n\n#if defined(_WIN32_WINNT)\nstatic constexpr long long initial_win32_winnt = _WIN32_WINNT + 0LL;\n#else\nstatic constexpr long long initial_win32_winnt = 0;\n#endif\n#define WANT_WINDOWS_LEAN_H 1 // _WIN32_WINNT\n#include \"conf.h\"\n#include \"compress/compress.h\" // upx_ucl_version_string()\n// for list_all_packers():\n#include \"filter.h\" // Filter::isValidFilter\n#include \"packer.h\"\n#include \"packmast.h\" // PackMaster::visitAllPackers\n\n/*************************************************************************\n// header\n**************************************************************************/\n\n// also see UPX_CONFIG_DISABLE_GITREV in CMakeLists.txt\n#if defined(RES_VERSION_GITREV)\nconst char gitrev[] = RES_VERSION_GITREV;\n#else\nconst char gitrev[1] = {0};\n#endif\n\nvoid show_header(void) {\n    FILE *f = con_term;\n    int fg;\n\n    static bool header_done;\n    if (header_done)\n        return;\n    header_done = true;\n\n    fg = con_fg(f, FG_GREEN);\n    // clang-format off\n    con_fprintf(f,\n                \"                       Ultimate Packer for eXecutables\\n\"\n                \"                          Copyright (C) 1996 - \" RES_VERSION_YEAR \"\\n\"\n#if defined(RES_VERSION_GITREV)\n                \"UPX git-%6.6s%c\"\n#else\n                \"UPX %-11s\"\n#endif\n                \" Markus Oberhumer, Laszlo Molnar & John Reiser  %14s\\n\\n\",\n#if defined(RES_VERSION_GITREV)\n                gitrev,\n                (sizeof(gitrev)-1 > 6 && gitrev[sizeof(gitrev)-2] == '+') ? '+' : ' ',\n#else\n                RES_VERSION_STRING,\n#endif\n                RES_VERSION_DATE);\n    // clang-format on\n    fg = con_fg(f, fg);\n    UNUSED(fg);\n}\n\n/*************************************************************************\n// usage\n**************************************************************************/\n\nvoid show_usage(void) {\n    FILE *f = con_term;\n\n    con_fprintf(f, \"Usage: %s [-123456789dlthVL] [-qvfk] [-o file] %sfile..\\n\", progname,\n#if (ACC_OS_DOS32) && defined(__DJGPP__)\n                \"[@]\");\n#else\n                \"\");\n#endif\n}\n\n/*************************************************************************\n// list_all_packers()\n**************************************************************************/\n\nnamespace {\nstruct PackerNames final {\n    explicit PackerNames() noexcept = default;\n    ~PackerNames() noexcept = default;\n\n    static constexpr unsigned MAX_NAMES = 64; // arbitrary limit, increase as needed\n    struct Entry {\n        const char *fname;\n        const char *sname;\n        unsigned methods_count;\n        unsigned filters_count;\n        unsigned methods[PackerBase::MAX_METHODS];\n        unsigned filters[PackerBase::MAX_FILTERS];\n    };\n    Entry names_array[MAX_NAMES];\n    Entry *names[MAX_NAMES];\n    unsigned names_count = 0;\n    const Options *o = nullptr;\n\n    void add(const PackerBase *pb) {\n        assert_noexcept(names_count < MAX_NAMES);\n        Entry &e = names_array[names_count];\n        names[names_count++] = &e;\n        e.fname = pb->getFullName(o);\n        e.sname = pb->getName();\n        e.methods_count = e.filters_count = 0;\n        for (const int *m = pb->getCompressionMethods(M_ALL, 10); *m != M_END; m++) {\n            if (*m >= 0) {\n                assert_noexcept(Packer::isValidCompressionMethod(*m));\n                assert_noexcept(e.methods_count < PackerBase::MAX_METHODS);\n                e.methods[e.methods_count++] = *m;\n            }\n        }\n        for (const int *f = pb->getFilters(); f != nullptr && *f != FT_END; f++) {\n            if (*f >= 0) {\n                assert_noexcept(Filter::isValidFilter(*f));\n                assert_noexcept(e.filters_count < PackerBase::MAX_FILTERS);\n                e.filters[e.filters_count++] = *f;\n            }\n        }\n        upx_gnomesort(e.methods, e.methods_count, sizeof(e.methods[0]), ne32_compare);\n        upx_gnomesort(e.filters, e.filters_count, sizeof(e.filters[0]), ne32_compare);\n    }\n    static tribool visit(PackerBase *pb, void *user) {\n        NO_fprintf(stderr, \"visit %s\\n\", pb->getFullName(nullptr));\n        PackerNames *self = (PackerNames *) user;\n        self->add(pb);\n        return false;\n    }\n    static int __acc_cdecl_qsort compare_fname(const void *aa, const void *bb) {\n        const Entry *a = *(const Entry *const *) aa;\n        const Entry *b = *(const Entry *const *) bb;\n        return strcmp(a->fname, b->fname);\n    }\n};\n} // namespace\n\nstatic noinline void list_all_packers(FILE *f, int verbose) {\n    Options o;\n    o.reset();\n    PackerNames pn;\n    pn.o = &o;\n    (void) PackMaster::visitAllPackers(PackerNames::visit, nullptr, &o, &pn);\n    // NOLINTNEXTLINE(bugprone-multi-level-implicit-pointer-conversion)\n    upx_gnomesort(pn.names, pn.names_count, sizeof(pn.names[0]), PackerNames::compare_fname);\n    size_t pos = 0;\n    for (size_t i = 0; i < pn.names_count; i++) {\n        const PackerNames::Entry &e = *pn.names[i];\n        const char *const fn = e.fname;\n        const char *const sn = e.sname;\n        if (verbose >= 3) {\n            con_fprintf(f, \"    %-36s %s\\n\", fn, sn);\n            con_fprintf(f, \"        methods:\");\n            for (size_t j = 0; j < e.methods_count; j++)\n                con_fprintf(f, \" %#x\", e.methods[j]);\n            con_fprintf(f, \"\\n\");\n            con_fprintf(f, \"        filters:\");\n            for (size_t j = 0; j < e.filters_count; j++)\n                con_fprintf(f, \" %#x\", e.filters[j]);\n            con_fprintf(f, \"\\n\");\n        } else if (verbose >= 2) {\n            con_fprintf(f, \"    %-36s %s\\n\", fn, sn);\n        } else {\n            size_t fl = strlen(fn);\n            if (pos == 0) {\n                con_fprintf(f, \"  %s\", fn);\n                pos = 2 + fl;\n            } else if (pos + 1 + fl > 80) {\n                con_fprintf(f, \"\\n  %s\", fn);\n                pos = 2 + fl;\n            } else {\n                con_fprintf(f, \" %s\", fn);\n                pos += 1 + fl;\n            }\n        }\n    }\n    if (verbose < 2 && pn.names_count)\n        con_fprintf(f, \"\\n\");\n}\n\n/*************************************************************************\n// help\n**************************************************************************/\n\nvoid show_help(int verbose) {\n    FILE *f = con_term;\n    int fg;\n\n    show_header();\n    show_usage();\n\n    // clang-format off\n    fg = con_fg(f, FG_YELLOW);\n    con_fprintf(f, \"\\nCommands:\\n\");\n    fg = con_fg(f, fg);\n    con_fprintf(f,\n                \"  -1     compress faster                   -9    compress better\\n\"\n                \"%s\"\n                \"  -d     decompress                        -l    list compressed file\\n\"\n                \"  -t     test compressed file              -V    display version number\\n\"\n                \"%s\"\n                \"  -h     give %s help                    -L    display software license\\n%s\",\n                verbose == 0 ? \"\" : \"  --best compress best (can be slow for big files)\\n\",\n                verbose == 0 ? \"\" : \"  --fileinfo show parameters of already-compressed file\\n\",\n                verbose == 0 ? \"more\" : \"this\",\n                verbose == 0 ? \"\" : \"\\n\");\n\n    fg = con_fg(f, FG_YELLOW);\n    con_fprintf(f, \"Options:\\n\");\n    fg = con_fg(f, fg);\n\n    con_fprintf(f,\n                \"  -q     be quiet                          -v    be verbose\\n\"\n                \"  -oFILE write output to 'FILE'\\n\"\n                \"  -f     force compression of suspicious files\\n\"\n                \"%s%s\"\n                , (verbose == 0) ? \"  -k     keep backup files\\n\" : \"\"\n#if 1\n                , (verbose > 0) ? \"  --no-color, --mono, --color, --no-progress   change look\\n\" : \"\"\n#else\n                , \"\"\n#endif\n                );\n\n    if (verbose > 0)\n    {\n        fg = con_fg(f, FG_YELLOW);\n        con_fprintf(f, \"\\nCompression tuning options:\\n\");\n        fg = con_fg(f, fg);\n        con_fprintf(f,\n                    \"  --lzma              try LZMA [slower but tighter than NRV]\\n\"\n                    \"  --brute             try all available compression methods & filters [slow]\\n\"\n                    \"  --ultra-brute       try even more compression variants [very slow]\\n\"\n                    \"\\n\");\n        fg = con_fg(f, FG_YELLOW);\n        con_fprintf(f, \"Backup options:\\n\");\n        fg = con_fg(f, fg);\n        con_fprintf(f,\n                    \"  -k, --backup        keep backup files\\n\"\n                    \"  --no-backup         no backup files [default]\\n\"\n                    \"\\n\");\n        fg = con_fg(f, FG_YELLOW);\n        con_fprintf(f, \"Overlay options:\\n\");\n        fg = con_fg(f, fg);\n        con_fprintf(f,\n                    \"  --overlay=copy      copy any extra data attached to the file [default]\\n\"\n                    \"  --overlay=strip     strip any extra data attached to the file [DANGEROUS]\\n\"\n                    \"  --overlay=skip      don't compress a file with an overlay\\n\"\n                    \"\\n\");\n        fg = con_fg(f, FG_YELLOW);\n        con_fprintf(f, \"File system options:\\n\");\n        fg = con_fg(f, fg);\n        con_fprintf(f,\n                    \"  --force-overwrite   force overwrite of output files\\n\"\n#if defined(__unix__)\n                    \"  --link              preserve hard links (Unix only) [USE WITH CARE]\\n\"\n                    \"  --no-link           do not preserve hard links but rename files [default]\\n\"\n#endif\n                    \"  --no-mode           do not preserve file mode (aka permissions)\\n\"\n                    \"  --no-owner          do not preserve file ownership\\n\"\n                    \"  --no-time           do not preserve file timestamp\\n\"\n                    \"\\n\");\n        fg = con_fg(f, FG_YELLOW);\n        con_fprintf(f, \"Options for djgpp2/coff:\\n\");\n        fg = con_fg(f, fg);\n        con_fprintf(f,\n                    \"  --coff              produce COFF output [default: EXE]\\n\"\n                    \"\\n\");\n        fg = con_fg(f, FG_YELLOW);\n        con_fprintf(f, \"Options for dos/com:\\n\");\n        fg = con_fg(f, fg);\n        con_fprintf(f,\n                    \"  --8086              make compressed com work on any 8086\\n\"\n                    \"\\n\");\n        fg = con_fg(f, FG_YELLOW);\n        con_fprintf(f, \"Options for dos/exe:\\n\");\n        fg = con_fg(f, fg);\n        con_fprintf(f,\n                    \"  --8086              make compressed exe work on any 8086\\n\"\n                    \"  --no-reloc          put no relocations in to the exe header\\n\"\n                    \"\\n\");\n        fg = con_fg(f, FG_YELLOW);\n        con_fprintf(f, \"Options for dos/sys:\\n\");\n        fg = con_fg(f, fg);\n        con_fprintf(f,\n                    \"  --8086              make compressed sys work on any 8086\\n\"\n                    \"\\n\");\n        fg = con_fg(f, FG_YELLOW);\n        con_fprintf(f, \"Options for ps1/exe:\\n\");\n        fg = con_fg(f, fg);\n        con_fprintf(f,\n                    \"  --8-bit             uses 8 bit size compression [default: 32 bit]\\n\"\n                    \"  --8mib-ram          8 megabyte memory limit [default: 2 MiB]\\n\"\n                    \"  --boot-only         disables client/host transfer compatibility\\n\"\n                    \"  --no-align          don't align to 2048 bytes [enables: --console-run]\\n\"\n                    \"\\n\");\n        fg = con_fg(f, FG_YELLOW);\n        con_fprintf(f, \"Options for watcom/le:\\n\");\n        fg = con_fg(f, fg);\n        con_fprintf(f,\n                    \"  --le                produce LE output [default: EXE]\\n\"\n                    \"\\n\");\n        fg = con_fg(f, FG_YELLOW);\n        con_fprintf(f, \"Options for win32/pe, win64/pe & rtm32/pe:\\n\");\n        fg = con_fg(f, fg);\n        con_fprintf(f,\n                    \"  --compress-exports=0    do not compress the export section\\n\"\n                    \"  --compress-exports=1    compress the export section [default]\\n\"\n                    \"  --compress-icons=0      do not compress any icons\\n\"\n                    \"  --compress-icons=1      compress all but the first icon\\n\"\n                    \"  --compress-icons=2      compress all but the first icon directory [default]\\n\"\n                    \"  --compress-icons=3      compress all icons\\n\"\n                    \"  --compress-resources=0  do not compress any resources at all\\n\"\n                    \"  --keep-resource=list    do not compress resources specified by list\\n\"\n                    \"  --strip-relocs=0        do not strip relocations\\n\"\n                    \"  --strip-relocs=1        strip relocations [default]\\n\"\n                    \"\\n\");\n        fg = con_fg(f, FG_YELLOW);\n        con_fprintf(f, \"Options for linux/elf:\\n\");\n        fg = con_fg(f, fg);\n        con_fprintf(f,\n                    \"  --preserve-build-id     copy .gnu.note.build-id to compressed output\\n\"\n                    \"  --catch-sigsegv         debug errors in hardware or de-compressor\\n\"\n                    \"\\n\");\n    }\n    // clang-format on\n\n    con_fprintf(f, \"file..   executables to (de)compress\\n\");\n\n    if (verbose > 0) {\n        fg = con_fg(f, FG_YELLOW);\n        con_fprintf(f, \"\\nThis version supports:\\n\");\n        fg = con_fg(f, fg);\n        list_all_packers(f, verbose);\n    } else {\n        con_fprintf(f, \"\\nType '%s --help' for more detailed help.\\n\", progname);\n    }\n\n    con_fprintf(f, \"\\nUPX comes with ABSOLUTELY NO WARRANTY; \"\n                   \"for details visit https://upx.github.io\\n\");\n\n#if DEBUG || TESTING\n    fg = con_fg(f, FG_RED);\n    con_fprintf(f, \"\\nWARNING: this version is compiled with\"\n#if DEBUG\n                   \" -DDEBUG\"\n#endif\n#if TESTING\n                   \" -DTESTING\"\n#endif\n                   \"\\n\");\n    fg = con_fg(f, fg);\n#endif\n\n    UNUSED(fg);\n}\n\n/*************************************************************************\n// license\n**************************************************************************/\n\nvoid show_license(void) {\n    FILE *f = con_term;\n\n    show_header();\n\n    // clang-format off\n    con_fprintf(f,\n        \"   This program may be used freely, and you are welcome to\\n\"\n        \"   redistribute it under certain conditions.\\n\"\n        \"\\n\"\n        \"   This program is distributed in the hope that it will be useful,\\n\"\n        \"   but WITHOUT ANY WARRANTY; without even the implied warranty of\\n\"\n        \"   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\\n\"\n        \"   UPX License Agreements for more details.\\n\"\n        \"\\n\"\n        \"   You should have received a copy of the UPX License Agreements\\n\"\n        \"   along with this program; see the files COPYING and LICENSE.\\n\"\n        \"   If not, visit one of the following pages:\\n\"\n        \"\\n\"\n    );\n    int fg = con_fg(f, FG_CYAN);\n    con_fprintf(f,\n        \"        https://upx.github.io\\n\"\n        \"        https://www.oberhumer.com/opensource/upx/\\n\"\n    );\n    (void) con_fg(f, FG_ORANGE);\n    con_fprintf(f,\n        \"\\n\"\n        \"   WHO-AM-I-404 <who-am-i-404@proton.me>\\n\"\n        \"   Based on original work by:\n   Markus F.X.J. Oberhumer <markus@oberhumer.com>\n   Laszlo Molnar <ezerotven+github@gmail.com>\\n\"\n    );\n    // clang-format on\n    fg = con_fg(f, fg);\n    UNUSED(fg);\n}\n\n/*************************************************************************\n// version\n**************************************************************************/\n\nvoid show_version(bool one_line) {\n    FILE *f = stdout;\n    const char *v;\n\n#if defined(RES_VERSION_GIT_DESCRIBE)\n    fprintf(f, \"upx %s\\n\", RES_VERSION_GIT_DESCRIBE);\n#elif defined(RES_VERSION_GITREV)\n    fprintf(f, \"upx %s\\n\", RES_VERSION_STRING \"-git-\" RES_VERSION_GITREV);\n#else\n    fprintf(f, \"upx %s\\n\", RES_VERSION_STRING);\n#endif\n    if (one_line)\n        return;\n\n#if (WITH_NRV)\n    v = upx_nrv_version_string();\n    if (v != nullptr && v[0])\n        fprintf(f, \"NRV data compression library %s\\n\", v);\n#endif\n#if (WITH_UCL)\n    v = upx_ucl_version_string();\n    if (v != nullptr && v[0])\n        fprintf(f, \"UCL data compression library %s\\n\", v);\n#endif\n#if (WITH_ZLIB)\n    v = upx_zlib_version_string();\n    if (v != nullptr && v[0])\n        fprintf(f, \"zlib data compression library %s\\n\", v);\n#endif\n#if (WITH_LZMA)\n    v = upx_lzma_version_string();\n    if (v != nullptr && v[0])\n        fprintf(f, \"LZMA SDK version %s\\n\", v);\n#endif\n#if (WITH_ZSTD)\n    v = upx_zstd_version_string();\n    if (v != nullptr && v[0])\n        fprintf(f, \"zstd data compression library %s\\n\", v);\n#endif\n#if (WITH_BZIP2)\n    v = upx_bzip2_version_string();\n    if (v != nullptr && v[0])\n        fprintf(f, \"bzip2 data compression library %s\\n\", v);\n#endif\n#if !defined(DOCTEST_CONFIG_DISABLE)\n    fprintf(f, \"doctest C++ testing framework version %s\\n\", DOCTEST_VERSION_STR);\n#endif\n    // clang-format off\n   Copyright (C) 2025 WHO-AM-I-404\n   Based on UPX - Ultimate Packer for eXecutables\n    fprintf(f, \"Copyright (C) 1996-2025 Markus Franz Xaver Johannes Oberhumer\\n\");\n    fprintf(f, \"Copyright (C) 1996-2025 Laszlo Molnar\\n\");\n    fprintf(f, \"Copyright (C) 2000-2025 John F. Reiser\\n\");\n#if (WITH_ZLIB)\n    // see vendor/zlib/LICENSE\n    fprintf(f, \"Copyright (C) 1995\" \"-2024 Jean-loup Gailly and Mark Adler\\n\");\n#endif\n#if (WITH_LZMA)\n    // see vendor/lzma-sdk\n    fprintf(f, \"Copyright (C) 1999\" \"-2006 Igor Pavlov\\n\");\n#endif\n#if (WITH_ZSTD)\n    // see vendor/zstd/LICENSE; main author is Yann Collet\n    fprintf(f, \"Copyright (C) 2015\" \"-2024 Meta Platforms, Inc. and affiliates\\n\");\n#endif\n#if (WITH_BZIP2)\n    // see vendor/bzip2/bzlib.h\n    fprintf(f, \"Copyright (C) 1996\" \"-2010 Julian Seward\\n\");\n#endif\n#if !defined(DOCTEST_CONFIG_DISABLE)\n    // see vendor/doctest/LICENSE.txt\n    fprintf(f, \"Copyright (C) 2016\" \"-2023 Viktor Kirilov\\n\");\n#endif\n    // clang-format on\n    fprintf(f, \"UPX comes with ABSOLUTELY NO WARRANTY; for details type '%s -L'.\\n\", progname);\n}\n\n/*************************************************************************\n// sysinfo\n// undocumented and subject to change\n**************************************************************************/\n\nvoid show_sysinfo(const char *options_var) {\n    FILE *f = con_term;\n\n    show_header();\n\n    if (opt->verbose >= 1) {\n        con_fprintf(f, \"UPX version: \");\n        fflush(f);\n        show_version(true);\n        con_fprintf(f, \"UPX version internal: 0x%06x %s\\n\", RES_VERSION_HEX, RES_VERSION_STRING);\n    }\n    fflush(stdout);\n\n    // Compilation Flags\n    {\n        size_t cf_count = 0;\n        auto cf_print = [f, &cf_count](const char *name, const char *fmt, upx_int64_t v,\n                                       int need_verbose = 2) noexcept {\n            if (opt->verbose < need_verbose)\n                return;\n            if (cf_count++ == 0)\n                con_fprintf(f, \"\\nCompilation flags:\\n\");\n            con_fprintf(f, \"  %s = \", name);\n            con_fprintf(f, fmt, v);\n            con_fprintf(f, \"\\n\");\n        };\n\n        // language\n        cf_print(\"__cplusplus\", \"%lld\", __cplusplus + 0, 3);\n#if defined(_MSVC_LANG)\n        cf_print(\"_MSVC_LANG\", \"%lld\", _MSVC_LANG + 0, 3);\n#endif\n#if defined(upx_is_constant_evaluated)\n        cf_print(\"upx_is_constant_evaluated\", \"%lld\", 1, 3);\n#endif\n\n        // compiler\n#if defined(ACC_CC_CLANG)\n        cf_print(\"ACC_CC_CLANG\", \"0x%06llx\", ACC_CC_CLANG + 0, 3);\n#endif\n#if defined(ACC_CC_GNUC)\n        cf_print(\"ACC_CC_GNUC\", \"0x%06llx\", ACC_CC_GNUC + 0, 3);\n#endif\n#if defined(ACC_CC_MSC)\n        cf_print(\"ACC_CC_MSC\", \"%lld\", ACC_CC_MSC + 0, 3);\n#endif\n#if defined(__clang__)\n        cf_print(\"__clang__\", \"%lld\", __clang__ + 0);\n#endif\n#if defined(__clang_major__)\n        cf_print(\"__clang_major__\", \"%lld\", __clang_major__ + 0);\n#endif\n#if defined(__clang_minor__)\n        cf_print(\"__clang_minor__\", \"%lld\", __clang_minor__ + 0, 3);\n#endif\n#if defined(__clang_patchlevel__)\n        cf_print(\"__clang_patchlevel__\", \"%lld\", __clang_patchlevel__ + 0, 3);\n#endif\n#if defined(__GNUC__)\n        cf_print(\"__GNUC__\", \"%lld\", __GNUC__ + 0);\n#endif\n#if defined(__GNUC_MINOR__)\n        cf_print(\"__GNUC_MINOR__\", \"%lld\", __GNUC_MINOR__ + 0, 3);\n#endif\n#if defined(__GNUC_PATCHLEVEL__)\n        cf_print(\"__GNUC_PATCHLEVEL__\", \"%lld\", __GNUC_PATCHLEVEL__ + 0, 3);\n#endif\n#if defined(_MSC_VER)\n        cf_print(\"_MSC_VER\", \"%lld\", _MSC_VER + 0);\n#endif\n#if defined(_MSC_FULL_VER)\n        cf_print(\"_MSC_FULL_VER\", \"%lld\", _MSC_FULL_VER + 0);\n#endif\n\n        // architecture\n#if defined(__CHERI__)\n        cf_print(\"__CHERI__\", \"%lld\", __CHERI__ + 0, 3);\n#endif\n#if defined(__CHERI_PURE_CAPABILITY__)\n        cf_print(\"__CHERI_PURE_CAPABILITY__\", \"%lld\", __CHERI_PURE_CAPABILITY__ + 0, 3);\n#endif\n#if defined(__mips_hard_float)\n        cf_print(\"__mips_hard_float\", \"%lld\", __mips_hard_float + 0);\n#endif\n#if defined(__mips_soft_float)\n        cf_print(\"__mips_soft_float\", \"%lld\", __mips_soft_float + 0);\n#endif\n#if defined(__wasm__)\n        cf_print(\"__wasm__\", \"%lld\", __wasm__ + 0);\n#endif\n#if defined(__wasm32__)\n        cf_print(\"__wasm32__\", \"%lld\", __wasm32__ + 0);\n#endif\n#if defined(__wasm64__)\n        cf_print(\"__wasm64__\", \"%lld\", __wasm64__ + 0);\n#endif\n\n        // OS and libc\n#if defined(WINVER)\n        cf_print(\"WINVER\", \"0x%04llx\", WINVER + 0);\n#endif\n#if defined(_WIN32_WINNT)\n        cf_print(\"_WIN32_WINNT\", \"0x%04llx\", _WIN32_WINNT + 0);\n        if (initial_win32_winnt != 0 && initial_win32_winnt != _WIN32_WINNT + 0)\n            cf_print(\"INITIAL_WIN32_WINNT\", \"0x%04llx\", initial_win32_winnt);\n#endif\n#if defined(__MSVCRT_VERSION__)\n        cf_print(\"__MSVCRT_VERSION__\", \"0x%04llx\", __MSVCRT_VERSION__ + 0);\n#endif\n#if defined(__MINGW64_VERSION_MAJOR)\n        cf_print(\"__MINGW64_VERSION_MAJOR\", \"%lld\", __MINGW64_VERSION_MAJOR + 0);\n#endif\n#if defined(__USE_MINGW_ANSI_STDIO)\n        cf_print(\"__USE_MINGW_ANSI_STDIO\", \"%lld\", __USE_MINGW_ANSI_STDIO + 0, 3);\n#endif\n#if defined(__ELF__)\n        cf_print(\"__ELF__\", \"%lld\", __ELF__ + 0, 3);\n#endif\n#if defined(__GLIBC__)\n        cf_print(\"__GLIBC__\", \"%lld\", __GLIBC__ + 0);\n#endif\n#if defined(__GLIBC_MINOR__)\n        cf_print(\"__GLIBC_MINOR__\", \"%lld\", __GLIBC_MINOR__ + 0);\n#endif\n#if defined(__wasi__)\n        cf_print(\"__wasi__\", \"%lld\", __wasi__ + 0);\n#endif\n\n        // misc compilation options\n#if defined(__PIC__)\n        cf_print(\"__PIC__\", \"%lld\", __PIC__ + 0, 3);\n#elif defined(__pic__)\n        cf_print(\"__pic__\", \"%lld\", __pic__ + 0, 3);\n#endif\n#if defined(__PIE__)\n        cf_print(\"__PIE__\", \"%lld\", __PIE__ + 0, 3);\n#elif defined(__pie__)\n        cf_print(\"__pie__\", \"%lld\", __pie__ + 0, 3);\n#endif\n#if defined(__SIZEOF_INT128__)\n        cf_print(\"__SIZEOF_INT128__\", \"%lld\", __SIZEOF_INT128__ + 0, 3);\n#endif\n#if defined(__SIZEOF_LONG_LONG__) && (__SIZEOF_LONG_LONG__ + 0 > 8)\n        cf_print(\"__SIZEOF_LONG_LONG__\", \"%lld\", __SIZEOF_LONG_LONG__ + 0, 3);\n#endif\n#if defined(__SIZEOF_POINTER__) && (__SIZEOF_POINTER__ + 0 > 8)\n        cf_print(\"__SIZEOF_POINTER__\", \"%lld\", __SIZEOF_POINTER__ + 0, 3);\n#endif\n#if defined(UPX_CONFIG_DISABLE_WSTRICT)\n        cf_print(\"UPX_CONFIG_DISABLE_WSTRICT\", \"%lld\", UPX_CONFIG_DISABLE_WSTRICT + 0, 3);\n#endif\n#if defined(UPX_CONFIG_DISABLE_WERROR)\n        cf_print(\"UPX_CONFIG_DISABLE_WERROR\", \"%lld\", UPX_CONFIG_DISABLE_WERROR + 0, 3);\n#endif\n#if defined(WITH_THREADS)\n        cf_print(\"WITH_THREADS\", \"%lld\", WITH_THREADS + 0);\n#endif\n\n        UNUSED(cf_count);\n        UNUSED(cf_print);\n        UNUSED(initial_win32_winnt);\n    }\n\n    // run-time settings\n#if defined(HAVE_LOCALTIME) && defined(HAVE_GMTIME)\n    {\n        auto tm2str = [](char *s, size_t size, const struct tm *tmp) noexcept {\n            snprintf(s, size, \"%04d-%02d-%02d %02d:%02d:%02d\", (int) tmp->tm_year + 1900,\n                     (int) tmp->tm_mon + 1, (int) tmp->tm_mday, (int) tmp->tm_hour,\n                     (int) tmp->tm_min, (int) tmp->tm_sec);\n        };\n\n        char s[40];\n        const time_t t = time(nullptr);\n        tm2str(s, sizeof(s), localtime(&t));\n        con_fprintf(f, \"\\n\");\n        con_fprintf(f, \"Local time is:  %s\\n\", s);\n        tm2str(s, sizeof(s), gmtime(&t));\n        con_fprintf(f, \"UTC time is:    %s\\n\", s);\n    }\n#endif\n\n    // environment\n    if (options_var && options_var[0]) {\n        const char *e = upx_getenv(options_var);\n        con_fprintf(f, \"\\n\");\n        if (e && e[0])\n            con_fprintf(f, \"Contents of environment variable %s: '%s'\\n\\n\", options_var, e);\n        else if (e)\n            con_fprintf(f, \"Environment variable '%s' is set but empty.\\n\\n\", options_var);\n        else\n            con_fprintf(f, \"Environment variable '%s' is not set.\\n\\n\", options_var);\n    }\n}\n\n/* vim:set ts=4 sw=4 et: */\n","size_bytes":25609}},"version":1}